<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵KK个人博客第三站</title>
  
  <subtitle>纠结体本体,同步记录日常笔记，Write the code, Change the world！</subtitle>
  <link href="https://zkkget.github.io/atom.xml" rel="self"/>
  
  <link href="https://zkkget.github.io/"/>
  <updated>2022-09-20T06:47:14.605Z</updated>
  <id>https://zkkget.github.io/</id>
  
  <author>
    <name>赵KK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nacos源码解析</title>
    <link href="https://zkkget.github.io/posts/20220916a1.html"/>
    <id>https://zkkget.github.io/posts/20220916a1.html</id>
    <published>2022-09-16T02:24:22.000Z</published>
    <updated>2022-09-20T06:47:14.605Z</updated>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://nacos.io/zh-cn/docs/architecture.html">https://nacos.io/zh-cn/docs/architecture.html</a></p><p>官网架构<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/nacos%E6%9E%B6%E6%9E%84.jpg" alt="架构"></p><p>总流程<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/nacos.webp" alt="流程"></p><p>1.为何要看源码<br>提升技术功底：学习源码里的优秀设计思想，比如一些疑难问题的解决思路，还有一些优秀的设计模式，整体提升自己的技术功底<br>深度掌握技术框架：源码看多了，对于一个新技术或框架的掌握速度会有大幅提升，看下框架demo大致就能知道底层的实现，技术框架更新再快也不怕<br>快速定位线上问题：遇到线上问题，特别是框架源码里的问题(比如bug)，能够快速定位，这就是相比其他没看过源码的人的优势<br>对面试大有裨益：面试一线互联网公司对于框架技术一般都会问到源码级别的实现<br>知其然知其所以然：对技术有追求的人必做之事，使用了一个好的框架，很想知道底层是如何实现的<br>拥抱开源社区：参与到开源项目的研发，结识更多大牛，积累更多优质人脉</p><p>一、入口分析<br>服务注册与发现@EnableDiscoveryClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">//@Import注解用来帮助我们把一些需要定义为Bean的类导入到IOC容器里面</span></span><br><span class="line"><span class="meta">@Import(EnableDiscoveryClientImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDiscoveryClient &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If true, the ServiceRegistry will automatically register the local server.默认为true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">autoRegister</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用autoRegister()方法时默认返回true,在本接口中还引入了ImportSelector类即@Import(EnableDiscoveryClientImportSelector.class),其中selectImports调用如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">public String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">String[] imports <span class="operator">=</span> super.selectImports(metadata);</span><br><span class="line"></span><br><span class="line">AnnotationAttributes attributes <span class="operator">=</span> AnnotationAttributes.fromMap(</span><br><span class="line">metadata.getAnnotationAttributes(getAnnotationClass().getName(), <span class="literal">true</span>));</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>获取本类的autoRegister属性</span><br><span class="line"><span class="type">boolean</span> autoRegister <span class="operator">=</span> attributes.getBoolean(&quot;autoRegister&quot;);</span><br><span class="line"></span><br><span class="line">if (autoRegister) &#123;</span><br><span class="line">List<span class="operator">&lt;</span>String<span class="operator">&gt;</span> importsList <span class="operator">=</span> <span class="keyword">new</span> ArrayList<span class="operator">&lt;&gt;</span>(Arrays.asList(imports));</span><br><span class="line">importsList.add(&quot;org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationConfiguration&quot;);</span><br><span class="line">imports <span class="operator">=</span> importsList.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Environment env <span class="operator">=</span> getEnvironment();</span><br><span class="line">if(ConfigurableEnvironment.class.isInstance(env)) &#123;</span><br><span class="line">ConfigurableEnvironment configEnv <span class="operator">=</span> (ConfigurableEnvironment)env;</span><br><span class="line">LinkedHashMap<span class="operator">&lt;</span>String, Object<span class="operator">&gt;</span> map <span class="operator">=</span> <span class="keyword">new</span> LinkedHashMap<span class="operator">&lt;&gt;</span>();</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>注入yml文件属性</span><br><span class="line">map.put(&quot;spring.cloud.service-registry.auto-registration.enabled&quot;, <span class="literal">false</span>);</span><br><span class="line">MapPropertySource propertySource <span class="operator">=</span> <span class="keyword">new</span> MapPropertySource(</span><br><span class="line">&quot;springCloudDiscoveryClient&quot;, map);</span><br><span class="line">configEnv.getPropertySources().addLast(propertySource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> imports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、META-INF/spring.factories</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.NacosDiscoveryAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.endpoint.NacosDiscoveryEndpointAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.registry.NacosServiceRegistryAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.NacosDiscoveryClientConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.reactive.NacosReactiveDiscoveryClientConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.configclient.NacosConfigServerAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.loadbalancer.LoadBalancerNacosAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.NacosServiceAutoConfiguration</span><br><span class="line">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.configclient.NacosDiscoveryClientConfigServiceBootstrapConfiguration</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.logging.NacosLoggingListener</span><br></pre></td></tr></table></figure><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/nacosdiscovery.jpg" alt="流程"><br>NacosDiscoveryAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnDiscoveryEnabled</span></span><br><span class="line"><span class="meta">@ConditionalOnNacosDiscoveryEnabled</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosDiscoveryAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NacosDiscoveryProperties <span class="title">nacosProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NacosDiscoveryProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NacosServiceDiscovery <span class="title">nacosServiceDiscovery</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">NacosDiscoveryProperties discoveryProperties,</span></span></span><br><span class="line"><span class="params"><span class="function">NacosServiceManager nacosServiceManager)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NacosServiceDiscovery(discoveryProperties, nacosServiceManager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、服务自动注册<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/SpringCloudCommons.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/serviceregistry.jpg" alt="流程"><br>Spring Cloud 有 Euerka、ZK、Nacos 等多种注册中心的实现，想要达到实现统一必须有一套规范，而Spring Cloud Commons 就是定义了这一规范。<br>Spring Cloud Commons里面的org.springframework.cloud.client.serviceregistry包下面有 AutoServiceRegistration、Registration、ServiceRegistry这三个接口，这是服务注册的核心接口<br>其中Registration继承了ServiceInstance,在ServiceInstance中规范了一个服务实例属性<br>1、AutoServiceRegistration用于服务自动注册。自动注册的意思就是，服务启动后自动把服务信息注册到注册中心。它的存在就是要规范实现必须要有自动注册.</p><p>2、Registration存储服务信息，用于规范将什么信息注册到注册中心,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Registration</span> <span class="keyword">extends</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The unique instance ID as registered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//注册的唯一ID</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> String <span class="title">getInstanceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The service ID as registered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getServiceId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The hostname of the registered service instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getHost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The port of the registered service instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Whether the port of the registered service instance uses HTTPS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">是否使用<span class="function">HTTPS</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The service URI address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">URI <span class="title">getUri</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The key / value pair metadata associated with the service instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Map&lt;String, String&gt; <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The scheme of the service instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">注册服务的约束</span><br><span class="line"><span class="function"><span class="keyword">default</span> String <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、ServiceRegistry用来注册或者注销服务,下线服务以及心跳检测等都可在此循迹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span>&lt;<span class="title">R</span> <span class="keyword">extends</span> <span class="title">Registration</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers the registration. A registration typically has information about an</span></span><br><span class="line"><span class="comment"> * instance, such as its hostname and port.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registration registration meta data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(R registration)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Deregisters the registration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registration registration meta data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(R registration)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Closes the ServiceRegistry. This is a lifecycle method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the status of the registration. The status values are determined by the</span></span><br><span class="line"><span class="comment"> * individual implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registration The registration to update.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> status The status to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.cloud.client.serviceregistry.endpoint.ServiceRegistryEndpoint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(R registration, String status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the status of a particular registration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registration The registration to query.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; The type of the status.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The status of the registration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.cloud.client.serviceregistry.endpoint.ServiceRegistryEndpoint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getStatus</span><span class="params">(R registration)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、Nacos实现</p><h2 id="NacosRegistration"><a href="#NacosRegistration" class="headerlink" title="NacosRegistration"></a>NacosRegistration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosRegistration</span> <span class="keyword">implements</span> <span class="title">Registration</span>, <span class="title">ServiceInstance</span> </span></span><br></pre></td></tr></table></figure><h2 id="NacosServiceRegistry"><a href="#NacosServiceRegistry" class="headerlink" title="NacosServiceRegistry"></a>NacosServiceRegistry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceRegistry</span> <span class="keyword">implements</span> <span class="title">ServiceRegistry</span>&lt;<span class="title">Registration</span>&gt; </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure><p>将配置文件封装为Instance实例,调用namingService.registerInstance(serviceId, instance)方法将服务注册到注册中心,在2.1.1当中则是通过NacosServiceManager来管理NameService的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Properties nacosProperties = nacosDiscoveryProperties.getNacosProperties();</span><br><span class="line">nacosServiceManager.getNamingMaintainService(nacosProperties).updateInstance(</span><br><span class="line">serviceId, nacosDiscoveryProperties.getGroup(), instance);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;update nacos instance status fail&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NacosAutoServiceRegistration"><a href="#NacosAutoServiceRegistration" class="headerlink" title="NacosAutoServiceRegistration"></a>NacosAutoServiceRegistration</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class NacosAutoServiceRegistration extends AbstractAutoServiceRegistration&lt;Registration&gt; </span><br><span class="line">  -&gt; public abstract class AbstractAutoServiceRegistration&lt;R extends Registration&gt;implements AutoServiceRegistration, ApplicationContextAware, ApplicationListener&lt;WebServerInitializedEvent&gt; &#123;</span><br></pre></td></tr></table></figure><p>通过间接实现ApplicationListener在服务启动时调用onApplicationEvent将服务注册到服务中心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; ApplicationListener&lt;PayloadApplicationEvent&lt;T&gt;&gt; forPayload(Consumer&lt;T&gt; consumer) &#123;</span><br><span class="line">        <span class="keyword">return</span> (event) -&gt; &#123;</span><br><span class="line">            consumer.accept(event.getPayload());</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(WebServerInitializedEvent event)</span> </span>&#123;</span><br><span class="line">bind(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(WebServerInitializedEvent event)</span> </span>&#123;</span><br><span class="line">ApplicationContext context = event.getApplicationContext();</span><br><span class="line"><span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableWebServerApplicationContext) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;management&quot;</span>.equals(((ConfigurableWebServerApplicationContext) context).getServerNamespace())) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.port.compareAndSet(<span class="number">0</span>, event.getWebServer().getPort());</span><br><span class="line"><span class="keyword">this</span>.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Discovery Lifecycle disabled. Not starting&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only initialize if nonSecurePort is greater than 0 and it isn&#x27;t already running</span></span><br><span class="line"><span class="comment">// because of containerPortInitializer below</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.running.get()) &#123;</span><br><span class="line"><span class="keyword">this</span>.context.publishEvent(<span class="keyword">new</span> InstancePreRegisteredEvent(<span class="keyword">this</span>, getRegistration()));</span><br><span class="line">register();</span><br><span class="line"><span class="keyword">if</span> (shouldRegisterManagement()) &#123;</span><br><span class="line">registerManagement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.context.publishEvent(<span class="keyword">new</span> InstanceRegisteredEvent&lt;&gt;(<span class="keyword">this</span>, getConfiguration()));</span><br><span class="line"><span class="keyword">this</span>.running.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>publishiEvent则是在AbstractApplicationContext中调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">侦听器在消息源之后初始化，以便能够以在监听器实现中访问它。因此，消息源实现不能发布事件。</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端如何向服务端注册"><a href="#客户端如何向服务端注册" class="headerlink" title="客户端如何向服务端注册"></a>客户端如何向服务端注册</h2><p>com.alibaba.cloud.nacos.registry.NacosServiceRegistry#register</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Registration registration)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;No service to register for nacos client...&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NamingService namingService = namingService();</span><br><span class="line">String serviceId = registration.getServiceId();</span><br><span class="line">String group = nacosDiscoveryProperties.getGroup();</span><br><span class="line"></span><br><span class="line">Instance instance = getNacosInstanceFromRegistration(registration);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">namingService.registerInstance(serviceId, group, instance);</span><br><span class="line">log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, group, serviceId,</span><br><span class="line">instance.getIp(), instance.getPort());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (nacosDiscoveryProperties.isFailFast()) &#123;</span><br><span class="line">log.error(<span class="string">&quot;nacos registry, &#123;&#125; register failed...&#123;&#125;,&quot;</span>, serviceId,</span><br><span class="line">registration.toString(), e);</span><br><span class="line">rethrowRuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">log.warn(<span class="string">&quot;Failfast is false. &#123;&#125; register failed...&#123;&#125;,&quot;</span>, serviceId,</span><br><span class="line">registration.toString(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">        String groupedServiceName = NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            BeatInfo beatInfo = beatReactor.buildBeatInfo(groupedServiceName, instance);</span><br><span class="line">            beatReactor.addBeatInfo(groupedServiceName, beatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        serverProxy.registerService(groupedServiceName, groupName, instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;[REGISTER-SERVICE] &#123;&#125; registering service &#123;&#125; with instance: &#123;&#125;&quot;</span>, namespaceId, serviceName,</span><br><span class="line">                instance);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">16</span>);</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, serviceName);</span><br><span class="line">        params.put(CommonParams.GROUP_NAME, groupName);</span><br><span class="line">        params.put(CommonParams.CLUSTER_NAME, instance.getClusterName());</span><br><span class="line">        params.put(<span class="string">&quot;ip&quot;</span>, instance.getIp());</span><br><span class="line">        params.put(<span class="string">&quot;port&quot;</span>, String.valueOf(instance.getPort()));</span><br><span class="line">        params.put(<span class="string">&quot;weight&quot;</span>, String.valueOf(instance.getWeight()));</span><br><span class="line">        params.put(<span class="string">&quot;enable&quot;</span>, String.valueOf(instance.isEnabled()));</span><br><span class="line">        params.put(<span class="string">&quot;healthy&quot;</span>, String.valueOf(instance.isHealthy()));</span><br><span class="line">        params.put(<span class="string">&quot;ephemeral&quot;</span>, String.valueOf(instance.isEphemeral()));</span><br><span class="line">        params.put(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.toJson(instance.getMetadata()));</span><br><span class="line">        </span><br><span class="line">        reqApi(UtilAndComs.nacosUrlInstance, params, HttpMethod.POST);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">reqApi</span><span class="params">(String api, Map&lt;String, String&gt; params, Map&lt;String, String&gt; body, List&lt;String&gt; servers,</span></span></span><br><span class="line"><span class="params"><span class="function">            String method)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, getNamespaceId());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(servers) &amp;&amp; StringUtils.isBlank(nacosDomain)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.INVALID_PARAM, <span class="string">&quot;no server available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NacosException exception = <span class="keyword">new</span> NacosException();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(nacosDomain)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxRetry; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> callServer(api, params, body, nacosDomain, method);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, nacosDomain, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">int</span> index = random.nextInt(servers.size());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; servers.size(); i++) &#123;</span><br><span class="line">                String server = servers.get(index);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> callServer(api, params, body, server, method);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, server, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                index = (index + <span class="number">1</span>) % servers.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.error(<span class="string">&quot;request: &#123;&#125; failed, servers: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>, api, servers, exception.getErrCode(),</span><br><span class="line">                exception.getErrMsg());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(exception.getErrCode(),</span><br><span class="line">                <span class="string">&quot;failed to req API:&quot;</span> + api + <span class="string">&quot; after all servers(&quot;</span> + servers + <span class="string">&quot;) tried: &quot;</span> + exception.getMessage());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HttpRestResult&lt;String&gt; restResult = nacosRestTemplate</span><br><span class="line">                    .exchangeForm(url, header, Query.newInstance().initParams(params), body, method, String.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@CanDistro</span><span class="comment">//注释以确定是否应重定向方法。</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="comment">//com.alibaba.nacos.auth.annotation.Secured权限控制</span></span><br><span class="line">    <span class="meta">@Secured(action = ActionTypes.WRITE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> String namespaceId = WebUtils</span><br><span class="line">                .optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">        <span class="keyword">final</span> String serviceName = WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">        NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Instance instance = HttpRequestInstanceBuilder.newBuilder()</span><br><span class="line">                .setDefaultInstanceEphemeral(switchDomain.isDefaultInstanceEphemeral()).setRequest(request).build();</span><br><span class="line">        </span><br><span class="line">        getInstanceOperator().registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">        NotifyCenter.publishEvent(<span class="keyword">new</span> RegisterInstanceTraceEvent(System.currentTimeMillis(), <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="keyword">false</span>, namespaceId, NamingUtils.getGroupName(serviceName), NamingUtils.getServiceName(serviceName),</span><br><span class="line">                instance.getIp(), instance.getPort()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> ephemeral = instance.isEphemeral();</span><br><span class="line">        String clientId = IpPortBasedClient.getClientId(instance.toInetAddr(), ephemeral);</span><br><span class="line">        createIpPortClientIfAbsent(clientId);</span><br><span class="line">        Service service = getService(namespaceId, serviceName, ephemeral);</span><br><span class="line">        clientOperationService.registerInstance(service, instance, clientId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在NacosServiceRegistry实例化的时候实例化nacosServiceManager,然后调用nacosServiceManager的getNamingService方法,构造实例化参数后<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/NacosServiceRegistry.jpg" alt="流程"></p><p>把服务放入serviceMap服务注册表中</p><p>初始化服务，创建一个健康检查的任务（主线–健康检查代码）</p><p>向一个队列中添加一个监听器（RecordListener类型）当监听到某些事件时会执行里面的onChange方法，Nacos大量运用了观察者设计模式，比如实例的注册、剔除等会被抽象成一个个的任务放到一个阻塞队列中，当监听到有任务时进来时，监听器会处理这些任务，执行onChange方法</p><p>com.alibaba.nacos.naming.consistency.RecordListener#onChange</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(String key, Service service)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Loggers.SRV_LOG.warn(<span class="string">&quot;received empty push from raft, key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(service.getNamespaceId())) &#123;</span><br><span class="line">                service.setNamespaceId(Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Loggers.RAFT.info(<span class="string">&quot;[RAFT-NOTIFIER] datum is changed, key: &#123;&#125;, value: &#123;&#125;&quot;</span>, key, service);</span><br><span class="line">            </span><br><span class="line">            Service oldDom = getService(service.getNamespaceId(), service.getName());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (oldDom != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldDom.update(service);</span><br><span class="line">                <span class="comment">// re-listen to handle the situation when the underlying listener is removed:</span></span><br><span class="line">                consistencyService</span><br><span class="line">                        .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">true</span>),</span><br><span class="line">                                oldDom);</span><br><span class="line">                consistencyService</span><br><span class="line">                        .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">false</span>),</span><br><span class="line">                                oldDom);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                putServiceAndInit(service);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Loggers.SRV_LOG.error(<span class="string">&quot;[NACOS-SERVICE] error while processing service update&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="addInstance"><a href="#addInstance" class="headerlink" title="addInstance"></a>addInstance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="keyword">boolean</span> ephemeral, Instance... ips)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">       </span><br><span class="line">       String key = KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line">       </span><br><span class="line">       Service service = getService(namespaceId, serviceName);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">           List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line">           </span><br><span class="line">           Instances instances = <span class="keyword">new</span> Instances();</span><br><span class="line">           instances.setInstanceList(instanceList);</span><br><span class="line">           </span><br><span class="line">           consistencyService.put(key, instances);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="consistencyService"><a href="#consistencyService" class="headerlink" title="consistencyService"></a>consistencyService</h2><h3 id="AP"><a href="#AP" class="headerlink" title="AP"></a>AP</h3><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/ConsistencyService.jpg" alt="流程"><br>clientOperationService.registerInstance(service, instance, clientId)中调用了ServiceManager<br>###CP<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/PersistentConsistencyServiceDelegateImpl.png" alt="流程"></p><p>Service:主要关心实例的变动</p><p>ServiceManager:主要关心服务的变动</p><p>SwitchManager:主要关心AP模型、CP模型的切换</p><h1 id="Nacos-2-0源码分析-健康检查机制"><a href="#Nacos-2-0源码分析-健康检查机制" class="headerlink" title="Nacos 2.0源码分析-健康检查机制"></a>Nacos 2.0源码分析-健康检查机制</h1><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.jpg" alt="流程"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      BeatInfo beatInfo;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">BeatTask</span><span class="params">(BeatInfo beatInfo)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.beatInfo = beatInfo;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (beatInfo.isStopped()) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">long</span> nextTime = beatInfo.getPeriod();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//发送心跳续约</span></span><br><span class="line">          <span class="comment">//lightBeatEnabled默认值为false</span></span><br><span class="line">              JsonNode result = serverProxy.sendBeat(beatInfo, BeatReactor.<span class="keyword">this</span>.lightBeatEnabled);</span><br><span class="line">              <span class="keyword">long</span> interval = result.get(CLIENT_BEAT_INTERVAL_FIELD).asLong();</span><br><span class="line">              <span class="keyword">boolean</span> lightBeatEnabled = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">if</span> (result.has(CommonParams.LIGHT_BEAT_ENABLED)) &#123;</span><br><span class="line">                  lightBeatEnabled = result.get(CommonParams.LIGHT_BEAT_ENABLED).asBoolean();</span><br><span class="line">              &#125;</span><br><span class="line">              BeatReactor.<span class="keyword">this</span>.lightBeatEnabled = lightBeatEnabled;</span><br><span class="line">              <span class="keyword">if</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  nextTime = interval;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">int</span> code = NamingResponseCode.OK;</span><br><span class="line">              <span class="keyword">if</span> (result.has(CommonParams.CODE)) &#123;</span><br><span class="line">                  code = result.get(CommonParams.CODE).asInt();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (code == NamingResponseCode.RESOURCE_NOT_FOUND) &#123;</span><br><span class="line">                  Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">                  instance.setPort(beatInfo.getPort());</span><br><span class="line">                  instance.setIp(beatInfo.getIp());</span><br><span class="line">                  instance.setWeight(beatInfo.getWeight());</span><br><span class="line">                  instance.setMetadata(beatInfo.getMetadata());</span><br><span class="line">                  instance.setClusterName(beatInfo.getCluster());</span><br><span class="line">                  instance.setServiceName(beatInfo.getServiceName());</span><br><span class="line">                  instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">                  instance.setEphemeral(<span class="keyword">true</span>);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      serverProxy.registerService(beatInfo.getServiceName(),</span><br><span class="line">                              NamingUtils.getGroupName(beatInfo.getServiceName()), instance);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (NacosException ex) &#123;</span><br><span class="line">              NAMING_LOGGER.error(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                      JacksonUtils.toJson(beatInfo), ex.getErrCode(), ex.getErrMsg());</span><br><span class="line">  </span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception unknownEx) &#123;</span><br><span class="line">              NAMING_LOGGER.error(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, unknown exception msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                      JacksonUtils.toJson(beatInfo), unknownEx.getMessage(), unknownEx);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              executorService.schedule(<span class="keyword">new</span> BeatTask(beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JsonNode <span class="title">sendBeat</span><span class="params">(BeatInfo beatInfo, <span class="keyword">boolean</span> lightBeatEnabled)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">          NAMING_LOGGER.debug(<span class="string">&quot;[BEAT] &#123;&#125; sending beat to server: &#123;&#125;&quot;</span>, namespaceId, beatInfo.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">      Map&lt;String, String&gt; bodyMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (!lightBeatEnabled) &#123;</span><br><span class="line">          bodyMap.put(<span class="string">&quot;beat&quot;</span>, JacksonUtils.toJson(beatInfo));</span><br><span class="line">      &#125;</span><br><span class="line">      params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">      params.put(CommonParams.SERVICE_NAME, beatInfo.getServiceName());</span><br><span class="line">      params.put(CommonParams.CLUSTER_NAME, beatInfo.getCluster());</span><br><span class="line">      params.put(IP_PARAM, beatInfo.getIp());</span><br><span class="line">      params.put(PORT_PARAM, String.valueOf(beatInfo.getPort()));</span><br><span class="line">      String result = reqApi(UtilAndComs.nacosUrlBase + <span class="string">&quot;/instance/beat&quot;</span>, params, bodyMap, HttpMethod.PUT);</span><br><span class="line">      <span class="keyword">return</span> JacksonUtils.toObj(result);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="服务端处理心跳续约"><a href="#服务端处理心跳续约" class="headerlink" title="服务端处理心跳续约"></a>服务端处理心跳续约</h2><p>com.alibaba.nacos.naming.controllers.InstanceController#beat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ObjectNode <span class="title">beat</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       </span><br><span class="line">       ObjectNode result = JacksonUtils.createEmptyJsonNode();</span><br><span class="line">       result.put(SwitchEntry.CLIENT_BEAT_INTERVAL, switchDomain.getClientBeatInterval());</span><br><span class="line">       </span><br><span class="line">       String beat = WebUtils.optional(request, <span class="string">&quot;beat&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">       RsInfo clientBeat = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isNotBlank(beat)) &#123;</span><br><span class="line">           clientBeat = JacksonUtils.toObj(beat, RsInfo.class);</span><br><span class="line">       &#125;</span><br><span class="line">       String clusterName = WebUtils</span><br><span class="line">               .optional(request, CommonParams.CLUSTER_NAME, UtilsAndCommons.DEFAULT_CLUSTER_NAME);</span><br><span class="line">       String ip = WebUtils.optional(request, <span class="string">&quot;ip&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">       <span class="keyword">int</span> port = Integer.parseInt(WebUtils.optional(request, <span class="string">&quot;port&quot;</span>, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">       <span class="keyword">if</span> (clientBeat != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isNotBlank(clientBeat.getCluster())) &#123;</span><br><span class="line">               clusterName = clientBeat.getCluster();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// fix #2533</span></span><br><span class="line">               clientBeat.setCluster(clusterName);</span><br><span class="line">           &#125;</span><br><span class="line">           ip = clientBeat.getIp();</span><br><span class="line">           port = clientBeat.getPort();</span><br><span class="line">       &#125;</span><br><span class="line">       String namespaceId = WebUtils.optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">       String serviceName = WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">       <span class="comment">//校验服务名格式</span></span><br><span class="line">       NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">       Loggers.SRV_LOG.debug(<span class="string">&quot;[CLIENT-BEAT] full arguments: beat: &#123;&#125;, serviceName: &#123;&#125;, namespaceId: &#123;&#125;&quot;</span>, clientBeat,</span><br><span class="line">               serviceName, namespaceId);</span><br><span class="line">       BeatInfoInstanceBuilder builder = BeatInfoInstanceBuilder.newBuilder();</span><br><span class="line">       builder.setRequest(request);</span><br><span class="line">       <span class="comment">//获取实例信息</span></span><br><span class="line">       <span class="keyword">int</span> resultCode = getInstanceOperator()</span><br><span class="line">               .handleBeat(namespaceId, serviceName, ip, port, clusterName, clientBeat, builder);</span><br><span class="line">       result.put(CommonParams.CODE, resultCode);</span><br><span class="line">       result.put(SwitchEntry.CLIENT_BEAT_INTERVAL,</span><br><span class="line">               getInstanceOperator().getHeartBeatInterval(namespaceId, serviceName, ip, port, clusterName));</span><br><span class="line">       result.put(SwitchEntry.LIGHT_BEAT_ENABLED, switchDomain.isLightBeatEnabled());</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在2.1.1当中getInstanceOperator().handleBeat(namespaceId, serviceName, ip, port, clusterName, clientBeat, builder);封装了对Service的处理包含开启续约,更新客户端心跳时间<br>分为客户端和服务端<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/handleBeat.png" alt="流程"><br>对于服务端我们看下service#handleBeat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">handleBeat</span><span class="params">(String namespaceId, String serviceName, String ip, <span class="keyword">int</span> port, String cluster,</span></span></span><br><span class="line"><span class="params"><span class="function">            RsInfo clientBeat, BeatInfoInstanceBuilder builder)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        com.alibaba.nacos.naming.core.Instance instance = serviceManager</span><br><span class="line">                .getInstance(namespaceId, serviceName, cluster, ip, port);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clientBeat == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> NamingResponseCode.RESOURCE_NOT_FOUND;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Loggers.SRV_LOG.warn(<span class="string">&quot;[CLIENT-BEAT] The instance has been removed for health mechanism, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;perform data compensation operations, beat: &#123;&#125;, serviceName: &#123;&#125;&quot;</span>, clientBeat, serviceName);</span><br><span class="line">            instance = parseInstance(builder.setBeatInfo(clientBeat).setServiceName(serviceName).build());</span><br><span class="line">            serviceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取服务实例</span></span><br><span class="line">        Service service = serviceManager.getService(namespaceId, serviceName);</span><br><span class="line">        <span class="comment">//检查服务是否为空</span></span><br><span class="line">        serviceManager.checkServiceIsNull(service, namespaceId, serviceName);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (clientBeat == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clientBeat = <span class="keyword">new</span> RsInfo();</span><br><span class="line">            clientBeat.setIp(ip);</span><br><span class="line">            clientBeat.setPort(port);</span><br><span class="line">            clientBeat.setCluster(cluster);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//服务续约</span></span><br><span class="line">        service.processClientBeat(clientBeat);</span><br><span class="line">        <span class="keyword">return</span> NamingResponseCode.OK;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedule client beat check task without a delay.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task health check task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> scheduled future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledFuture&lt;?&gt; scheduleNow(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">return</span> GlobalExecutor.scheduleNamingHealth(task, <span class="number">0</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    将心跳时间设置为当前时间</span><br></pre></td></tr></table></figure><h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>com.alibaba.nacos.naming.core.ServiceManager#putServiceAndInit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putServiceAndInit</span><span class="params">(Service service)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        putService(service);</span><br><span class="line">        service = getService(service.getNamespaceId(), service.getName());</span><br><span class="line">        service.init();</span><br><span class="line">        consistencyService</span><br><span class="line">                .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">true</span>), service);</span><br><span class="line">        consistencyService</span><br><span class="line">                .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">false</span>), service);</span><br><span class="line">        Loggers.SRV_LOG.info(<span class="string">&quot;[NEW-SERVICE] &#123;&#125;&quot;</span>, service.toJson());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Init service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HealthCheckReactor.scheduleCheck(clientBeatCheckTask);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Cluster&gt; entry : clusterMap.entrySet()) &#123;</span><br><span class="line">            entry.getValue().setService(<span class="keyword">this</span>);</span><br><span class="line">            entry.getValue().init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="健康检查任务"><a href="#健康检查任务" class="headerlink" title="健康检查任务"></a>健康检查任务</h3><p>ClientBeatCheckTask<br>if (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getInstanceHeartBeatTimeOut())<br>getInstanceHeartBeatTimeOut<br>15秒</p><p>public static final long DEFAULT_HEART_BEAT_TIMEOUT = TimeUnit.SECONDS.toMillis(15);</p><p>public static final long DEFAULT_IP_DELETE_TIMEOUT = TimeUnit.SECONDS.toMillis(30);</p><p>public static final long DEFAULT_HEART_BEAT_INTERVAL = TimeUnit.SECONDS.toMillis(5);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// If upgrade to 2.0.X stop health check with v1</span></span><br><span class="line">            <span class="keyword">if</span> (ApplicationUtils.getBean(UpgradeJudgement.class).isUseGrpcFeatures()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!getDistroMapper().responsible(service.getName())) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!getSwitchDomain().isHealthCheckEnabled()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            List&lt;Instance&gt; instances = service.allIPs(<span class="keyword">true</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// first set health status of instances:</span></span><br><span class="line">            <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getInstanceHeartBeatTimeOut()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!instance.isMarked()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (instance.isHealthy()) &#123;</span><br><span class="line">                            instance.setHealthy(<span class="keyword">false</span>);</span><br><span class="line">                            Loggers.EVT_LOG</span><br><span class="line">                                    .info(<span class="string">&quot;&#123;POS&#125; &#123;IP-DISABLED&#125; valid: &#123;&#125;:&#123;&#125;@&#123;&#125;@&#123;&#125;, region: &#123;&#125;, msg: client timeout after &#123;&#125;, last beat: &#123;&#125;&quot;</span>,</span><br><span class="line">                                            instance.getIp(), instance.getPort(), instance.getClusterName(),</span><br><span class="line">                                            service.getName(), UtilsAndCommons.LOCALHOST_SITE,</span><br><span class="line">                                            instance.getInstanceHeartBeatTimeOut(), instance.getLastBeat());</span><br><span class="line">                            getPushService().serviceChanged(service);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!getGlobalConfig().isExpireInstance()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// then remove obsolete instances:</span></span><br><span class="line">            <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (instance.isMarked()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当超过30秒无响应则删除</span></span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getIpDeleteTimeout()) &#123;</span><br><span class="line">                    <span class="comment">// delete instance</span></span><br><span class="line">                    Loggers.SRV_LOG.info(<span class="string">&quot;[AUTO-DELETE-IP] service: &#123;&#125;, ip: &#123;&#125;&quot;</span>, service.getName(),</span><br><span class="line">                            JacksonUtils.toJson(instance));</span><br><span class="line">                    deleteIp(instance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.SRV_LOG.warn(<span class="string">&quot;Exception while processing client beat time out.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：Zookeeper中在进行服务注册的时候，发起一个长连接，比如用Nio或者Netty，会一直占用管道，而Nacos只是发起一个http请求，发起请求后就结束了，Nacos在1.4.x版本中是典型的短链接（当然2.0后改用gRpc长连接），而Zk采用长连接方式建立通道，如果在客户端服务器非常非常多，会比较耗性能的，Nacos相比会轻量不少哦，Zk为了保证服务变动的一致性，监听回调机制就会立刻通知到客户端，响应是很及时的，所以Zk保证了Cp，Nacos有两块保证了心跳，一块是客户端的定时拉取，一块是udp反向推送，即便udp丢失了，也有定时任务兜底。</p><h2 id="TcpHealthCheckProcessor"><a href="#TcpHealthCheckProcessor" class="headerlink" title="TcpHealthCheckProcessor"></a>TcpHealthCheckProcessor</h2><p>com.alibaba.nacos.naming.healthcheck.v2.processor.TcpHealthCheckProcessor </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官网：&lt;a href=&quot;https://nacos.io/zh-cn/docs/architecture.html&quot;&gt;https://nacos.io/zh-cn/docs/architecture.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网架构&lt;br&gt;&lt;img src=&quot;htt</summary>
      
    
    
    
    <category term="SpringCloud Nacos" scheme="https://zkkget.github.io/categories/SpringCloud-Nacos/"/>
    
    
    <category term="SpringCloud Nacos" scheme="https://zkkget.github.io/tags/SpringCloud-Nacos/"/>
    
  </entry>
  
  <entry>
    <title>Mysql保留关键字</title>
    <link href="https://zkkget.github.io/posts/20220830a1.html"/>
    <id>https://zkkget.github.io/posts/20220830a1.html</id>
    <published>2022-08-30T06:53:46.000Z</published>
    <updated>2022-08-30T06:54:11.240Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL关键字（保留字）列表<br>在使用MySQL的时候，一般尽量避免用关键字作为表名，如使用关键字做表名，需要按标准写法给SQL语句加<a href="%E6%88%96%E6%98%AF%E2%80%9C"></a>区分字段名和表名。</p><p>下面列出MySQL所有关键字，希望给使用MySQL的朋友提供一些参考帮助。</p><p>ADD    ALL    ALTER<br>ANALYZE    AND    AS<br>ASC    ASENSITIVE    BEFORE<br>BETWEEN    BIGINT    BINARY<br>BLOB    BOTH    BY<br>CALL    CASCADE    CASE<br>CHANGE    CHAR    CHARACTER<br>CHECK    COLLATE    COLUMN<br>CONDITION    CONNECTION    CONSTRAINT<br>CONTINUE    CONVERT    CREATE<br>CROSS    CURRENT_DATE    CURRENT_TIME<br>CURRENT_TIMESTAMP    CURRENT_USER    CURSOR<br>DATABASE    DATABASES    DAY_HOUR<br>DAY_MICROSECOND    DAY_MINUTE    DAY_SECOND<br>DEC    DECIMAL    DECLARE<br>DEFAULT    DELAYED    DELETE<br>DESC    DESCRIBE    DETERMINISTIC<br>DISTINCT    DISTINCTROW    DIV<br>DOUBLE    DROP    DUAL<br>EACH    ELSE    ELSEIF<br>ENCLOSED    ESCAPED    EXISTS<br>EXIT    EXPLAIN    FALSE<br>FETCH    FLOAT    FLOAT4<br>FLOAT8    FOR    FORCE<br>FOREIGN    FROM    FULLTEXT<br>GOTO    GRANT    GROUP<br>HAVING    HIGH_PRIORITY    HOUR_MICROSECOND<br>HOUR_MINUTE    HOUR_SECOND    IF<br>IGNORE    IN    INDEX<br>INFILE    INNER    INOUT<br>INSENSITIVE    INSERT    INT<br>INT1    INT2    INT3<br>INT4    INT8    INTEGER<br>INTERVAL    INTO    IS<br>ITERATE    JOIN    KEY<br>KEYS    KILL    LABEL<br>LEADING    LEAVE    LEFT<br>LIKE    LIMIT    LINEAR<br>LINES    LOAD    LOCALTIME<br>LOCALTIMESTAMP    LOCK    LONG<br>LONGBLOB    LONGTEXT    LOOP<br>LOW_PRIORITY    MATCH    MEDIUMBLOB<br>MEDIUMINT    MEDIUMTEXT    MIDDLEINT<br>MINUTE_MICROSECOND    MINUTE_SECOND    MOD<br>MODIFIES    NATURAL    NOT<br>NO_WRITE_TO_BINLOG    NULL    NUMERIC<br>ON    OPTIMIZE    OPTION<br>OPTIONALLY    OR    ORDER<br>OUT    OUTER    OUTFILE<br>PRECISION    PRIMARY    PROCEDURE<br>PURGE    RAID0    RANGE<br>READ    READS    REAL<br>REFERENCES    REGEXP    RELEASE<br>RENAME    REPEAT    REPLACE<br>REQUIRE    RESTRICT    RETURN<br>REVOKE    RIGHT    RLIKE<br>SCHEMA    SCHEMAS    SECOND_MICROSECOND<br>SELECT    SENSITIVE    SEPARATOR<br>SET    SHOW    SMALLINT<br>SPATIAL    SPECIFIC    SQL<br>SQLEXCEPTION    SQLSTATE    SQLWARNING<br>SQL_BIG_RESULT    SQL_CALC_FOUND_ROWS    SQL_SMALL_RESULT<br>SSL    STARTING    STRAIGHT_JOIN<br>TABLE    TERMINATED    THEN<br>TINYBLOB    TINYINT    TINYTEXT<br>TO    TRAILING    TRIGGER<br>TRUE    UNDO    UNION<br>UNIQUE    UNLOCK    UNSIGNED<br>UPDATE    USAGE    USE<br>USING    UTC_DATE    UTC_TIME<br>UTC_TIMESTAMP    VALUES    VARBINARY<br>VARCHAR    VARCHARACTER    VARYING<br>WHEN    WHERE    WHILE<br>WITH    WRITE    X509<br>XOR    YEAR_MONTH    ZEROFILL</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL关键字（保留字）列表&lt;br&gt;在使用MySQL的时候，一般尽量避免用关键字作为表名，如使用关键字做表名，需要按标准写法给SQL语句加&lt;a href=&quot;%E6%88%96%E6%98%AF%E2%80%9C&quot;&gt;&lt;/a&gt;区分字段名和表名。&lt;/p&gt;
&lt;p&gt;下面列出MySQ</summary>
      
    
    
    
    
    <category term="Mysql" scheme="https://zkkget.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>1000万数据对比ContainsAll实测</title>
    <link href="https://zkkget.github.io/posts/20220812cl89v5wv60001t4uj8zs1bfwv.html"/>
    <id>https://zkkget.github.io/posts/20220812cl89v5wv60001t4uj8zs1bfwv.html</id>
    <published>2022-08-12T08:24:06.000Z</published>
    <updated>2022-08-12T08:25:08.475Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutReminder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            list.add(getRandomString(random.nextInt(<span class="number">100</span>)));</span><br><span class="line">            list2.add(getRandomString(random.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        list.containsAll(list2);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(stopWatch.getTotalTimeSeconds());</span><br><span class="line">        StopWatch stopWatch2 = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch2.start();</span><br><span class="line">        CollectionUtils.containsAll(list, list2);</span><br><span class="line">        stopWatch2.stop();</span><br><span class="line">        System.out.println(stopWatch2.getTotalTimeSeconds());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">0.571</span></span><br><span class="line"><span class="number">17.27</span></span><br><span class="line"></span><br><span class="line">源码 java.util.List#<span class="function">containsAll</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = es.length;</span><br><span class="line">        <span class="keyword">for</span> (Object e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexOfRange(e, es, <span class="number">0</span>, len) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOfRange</span><span class="params">(Object o, Object[] es, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt; to; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt; to; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">源码org.apache.commons.collections4.CollectionUtils#containsAll</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;code&gt;true&lt;/code&gt; iff all elements of &#123;<span class="doctag">@code</span> coll2&#125; are also contained</span></span><br><span class="line"><span class="comment">     * in &#123;<span class="doctag">@code</span> coll1&#125;. The cardinality of values in &#123;<span class="doctag">@code</span> coll2&#125; is not taken into account,</span></span><br><span class="line"><span class="comment">     * which is the same behavior as &#123;<span class="doctag">@link</span> Collection#containsAll(Collection)&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * In other words, this method returns &lt;code&gt;true&lt;/code&gt; iff the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #intersection&#125; of &lt;i&gt;coll1&lt;/i&gt; and &lt;i&gt;coll2&lt;/i&gt; has the same cardinality as</span></span><br><span class="line"><span class="comment">     * the set of unique values from &#123;<span class="doctag">@code</span> coll2&#125;. In case &#123;<span class="doctag">@code</span> coll2&#125; is empty, &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * will be returned.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method is intended as a replacement for &#123;<span class="doctag">@link</span> Collection#containsAll(Collection)&#125;</span></span><br><span class="line"><span class="comment">     * with a guaranteed runtime complexity of &#123;<span class="doctag">@code</span> O(n + m)&#125;. Depending on the type of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Collection&#125; provided, this method will be much faster than calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Collection#containsAll(Collection)&#125; instead, though this will come at the</span></span><br><span class="line"><span class="comment">     * cost of an additional space complexity O(n).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coll1  the first collection, must not be null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coll2  the second collection, must not be null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;code&gt;true&lt;/code&gt; iff the intersection of the collections has the same cardinality</span></span><br><span class="line"><span class="comment">     *   as the set of unique elements from the second collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(<span class="keyword">final</span> Collection&lt;?&gt; coll1, <span class="keyword">final</span> Collection&lt;?&gt; coll2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coll2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Iterator&lt;?&gt; it = coll1.iterator();</span><br><span class="line">            <span class="keyword">final</span> Set&lt;Object&gt; elementsAlreadySeen = <span class="keyword">new</span> HashSet&lt;Object&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> Object nextElement : coll2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (elementsAlreadySeen.contains(nextElement)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> foundCurrentElement = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Object p = it.next();</span><br><span class="line">                    elementsAlreadySeen.add(p);</span><br><span class="line">                    <span class="keyword">if</span> (nextElement == <span class="keyword">null</span> ? p == <span class="keyword">null</span> : nextElement.equals(p)) &#123;</span><br><span class="line">                        foundCurrentElement = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (foundCurrentElement) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
    <category term="ContainsAll" scheme="https://zkkget.github.io/tags/ContainsAll/"/>
    
  </entry>
  
  <entry>
    <title>面向面试编程</title>
    <link href="https://zkkget.github.io/posts/20220802cl89v5wwl001pt4uj6xy6fwa0.html"/>
    <id>https://zkkget.github.io/posts/20220802cl89v5wwl001pt4uj6xy6fwa0.html</id>
    <published>2022-08-02T03:35:12.000Z</published>
    <updated>2022-09-06T03:34:36.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Service-和-Component-注解的差别？"><a href="#Service-和-Component-注解的差别？" class="headerlink" title="@Service 和@Component 注解的差别？"></a>@Service 和@Component 注解的差别？</h2><p>@Component spring基础的注解,被spring管理的组件或bean,用于将对象实例化到Spring容器中<br>而@Service源码中是包含@Component注解的,也就是说service实现component的功能,但service用于服务层,处理业务逻辑</p><h2 id="各种-Restful-请求格式以及各种-http-请求返回码。"><a href="#各种-Restful-请求格式以及各种-http-请求返回码。" class="headerlink" title="各种 Restful 请求格式以及各种 http 请求返回码。"></a>各种 Restful 请求格式以及各种 http 请求返回码。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">API,英文全称Application Programming Interface,翻译为“应用程序编程接口”。就是将一些功能（逻辑）封装成组件,目的是提供一个应用程序接口给其它程序与开发人员访问,而这些访问人员不需要访问源码以及理解内部工作原理就可以直接使用</span><br><span class="line">RESTFUL是一种网络应用程序的设计风格和开发方式,基于HTTP,可以使用 XML 格式定义或 JSON 格式定义。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取,所以,使用JSON格式的REST风格的API具有简单、易读、易用的特点。</span><br><span class="line">而http返回状态码常见200.400.500等</span><br></pre></td></tr></table></figure><h2 id="Transactional-事务里的事务隔离级别和事务传播机制概念。"><a href="#Transactional-事务里的事务隔离级别和事务传播机制概念。" class="headerlink" title="@Transactional 事务里的事务隔离级别和事务传播机制概念。"></a>@Transactional 事务里的事务隔离级别和事务传播机制概念。</h2><p>定义一个事务受其他并发事务影响程度。事务并发引发的问题。</p><p>脏读：一个事务读取到另一个事务修改但还未提交的数据<br>不可重复读：一个事务读取数据之后,该数据被其他事务修改,此时第一个事务读取到的事务就是错误的（强调修改）<br>幻读：一个事务读取了某些数据,没提交再读取时数据多了或者少了,类似幻觉（强调增删）<br>丢失修改：两个事务都读取了数据,其中一个事务修改之后,另一个事务也做了修改,前者的修改丢失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以放在 类上 或者 方法上。 </span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 区别于 transactionManager属性</span></span><br><span class="line"><span class="comment"> * 查看 transactionManager</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选定特定的 事务管理器 SpringBoot中默认不用配置 可以是beanName或者特定的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置传播级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置事务隔离级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务只读 默认是可以修改的 如果设置为true只能执行查询相关</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定错误回滚 当未抛出该类型的错误或者其子类的错误时 不会回滚 默认是任何错误（异常）都会回滚</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 略 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果配置这个 如果抛出此异常将不会回滚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 略 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Isolation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认的隔离级别</span></span><br><span class="line"><span class="comment"> * 所有其他级别对应于JDBC隔离级别</span></span><br><span class="line"><span class="comment"> * 具体隔离级别 查看 java.sql.Connection</span></span><br><span class="line"><span class="comment"> * Mysql 默认 RR(REPEATABLE_READ)</span></span><br><span class="line"><span class="comment"> * Oracle 默认 RC(READ_COMMITTED)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未提交读 什么问题都不解决</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_READ_UNCOMMITTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交读 解决脏读</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_READ_COMMITTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重复读 解决脏读和不可重复读 不解决幻读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 串行读 解决所有的事务隔离问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Isolation(<span class="keyword">int</span> value) &#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>传播行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Support a current transaction, create a new one if none exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is the default setting of a transaction annotation.</span></span><br><span class="line"><span class="comment"> * 外围有事务则加入形成同一个事务,外围无事务则新开启,内部事务之间相互独立</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Support a current transaction, execute non-transactionally if none exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: For transaction managers with transaction synchronization,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> SUPPORTS&#125; is slightly different from no transaction at all,</span></span><br><span class="line"><span class="comment"> * as it defines a transaction scope that synchronization will apply for.</span></span><br><span class="line"><span class="comment"> * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc)</span></span><br><span class="line"><span class="comment"> * will be shared for the entire specified scope. Note that this depends on</span></span><br><span class="line"><span class="comment"> * the actual synchronization configuration of the transaction manager.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization</span></span><br><span class="line"><span class="comment"> * 若外围没有事务则非事务执行,有事务则同 REQUIRED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Support a current transaction, throw an exception if none exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * 使用外围事务,若外围无事务则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new transaction, and suspend the current transaction if one exists.</span></span><br><span class="line"><span class="comment"> * Analogous to the EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span></span><br><span class="line"><span class="comment"> * on all transaction managers. This in particular applies to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span></span><br><span class="line"><span class="comment"> * which requires the &#123;<span class="doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span></span><br><span class="line"><span class="comment"> * made available to it (which is server-specific in standard Java EE).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span></span><br><span class="line"><span class="comment"> * 外围有无事务都开启新事务,相互独立,且与外围事务相互独立开 如果当前有事务,就把当前的事务挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute non-transactionally, suspend the current transaction if one exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span></span><br><span class="line"><span class="comment"> * on all transaction managers. This in particular applies to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span></span><br><span class="line"><span class="comment"> * which requires the &#123;<span class="doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span></span><br><span class="line"><span class="comment"> * made available to it (which is server-specific in standard Java EE).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span></span><br><span class="line"><span class="comment"> * 非事务执行,若外围存在事务则挂起该事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute non-transactionally, throw an exception if a transaction exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * 非事务执行,当外围有事务则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute within a nested transaction if a current transaction exists,</span></span><br><span class="line"><span class="comment"> * behave like &#123;<span class="doctag">@code</span> REQUIRED&#125; otherwise. There is no analogous feature in EJB.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific</span></span><br><span class="line"><span class="comment"> * transaction managers. Out of the box, this only applies to the JDBC</span></span><br><span class="line"><span class="comment"> * DataSourceTransactionManager. Some JTA providers might support nested</span></span><br><span class="line"><span class="comment"> * transactions as well.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.jdbc.datasource.DataSourceTransactionManager</span></span><br><span class="line"><span class="comment"> * 外围无事务,则同 REQUIRED 内部开启新事务相互独立。外围有事务,则内部事务是其子事务,主事务回滚则子事务全部回滚,子事务回滚不影响其他子事务和主事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Propagation(<span class="keyword">int</span> value) &#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Spring-依赖注入概念和-Autowired-的用法。"><a href="#Spring-依赖注入概念和-Autowired-的用法。" class="headerlink" title="Spring 依赖注入概念和@Autowired 的用法。"></a>Spring 依赖注入概念和@Autowired 的用法。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">概念：实例不再由程序员实例化,而是通过spring容器帮我们<span class="keyword">new</span>指定实例并且将实例注入到需要该对象的类。</span><br><span class="line">依赖注入能够让相互协作的软件组件保持松散耦合</span><br><span class="line"><span class="meta">@Autowired</span> 注释,它可以对类成员变量、方法及构造函数进行标注,完成自动装配的工作。 通过 <span class="meta">@Autowired</span>的使用来消除 set ,get方法。也可作用与集合上</span><br><span class="line">这里授权服务配置类是继承了AuthorizationServerConfigurerAdapter,而AuthorizationServerConfigurerAdapter又实现了AuthorizationServerConfigurer接口！</span><br><span class="line">源码AuthorizationServerConfigurer</span><br><span class="line"><span class="meta">@Autowired</span>对List自动注入</span><br><span class="line"><span class="comment">//@Autowired注解用在接口的集合上面,所有实现该接口的实现类都会在该集合中</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;IAsynTask&gt; tasks = Collections.emptyList();</span><br></pre></td></tr></table></figure><h2 id="Spring-Bean-的生命周期。"><a href="#Spring-Bean-的生命周期。" class="headerlink" title="Spring Bean 的生命周期。"></a>Spring Bean 的生命周期。</h2><p>Bean 的生命周期概括起来就是 4 个阶段：</p><p>实例化（Instantiation）<br>属性赋值（Populate）<br>初始化（Initialization）<br>销毁（Destruction）<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/374544735d0dd4104601ef98749c7f89.jpg" alt="流程"><br>##Spring Boot 启动流程以及底层源码、<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/05-305138350.jpg" alt="流程"><br>索引的数据结构（比如 B+树）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">B+Tree</span><br><span class="line">B+Tree相对于B-Tree有几点不同：</span><br><span class="line">非叶子节点只存储键值信息。</span><br><span class="line">所有叶子节点之间都有一个链指针。</span><br><span class="line">数据记录都存放在叶子节点中。</span><br><span class="line">查询速度快,但是占用空间</span><br><span class="line">索引结构：B-Tree B+Tree B：balance</span><br><span class="line">B-Tree：平衡二叉树</span><br><span class="line">特点：</span><br><span class="line"><span class="number">1.</span>具有数据节点</span><br><span class="line"><span class="number">2.</span>指向下层指针</span><br><span class="line"><span class="number">3.</span>指向数据指针</span><br><span class="line">缺页查询,产生IO</span><br><span class="line">B+Tree：</span><br><span class="line">特点:</span><br><span class="line"><span class="number">1.</span>具有数据节点</span><br><span class="line"><span class="number">2.</span>指向下层指针</span><br><span class="line">命中数据<span class="number">3</span>层查找后查询数据指针</span><br><span class="line">加载更快,产生更少IO</span><br><span class="line">效率：BTree更高,但从IO角度,Mysql选择B+Tree</span><br><span class="line"></span><br><span class="line">Hash 索引的特点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hash 索引只能够用于使用 = 或者 &lt;=&gt; 运算符的相等比较(但是速度更快)。Hash 索引不能够用于诸如 &lt; 等用于查找一个范围值的比较运算符。依赖于这种单值查找的系统被称为 “键-值存储”；对于这种系统,尽可能地使用 hash 索引。</span><br><span class="line">优化器不能够使用 hash 索引来加速 ORDER BY 操作。这种类型的索引不能够用于按照顺序查找下一个条目。</span><br><span class="line">MySql 无法使用 hash 索引估计两个值之间有多少行(这种情况由范围优化器来决定使用哪个索引)。如果你将一张 MyISAM 或 InnoDB 表转换成一个 hash 索引的内存表时,一些查询可能会受此影响。</span><br><span class="line">查找某行记录必须进行全键匹配。而 B-tree 索引,任何该键的左前缀都可用以查找记录</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建索引的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_xxx <span class="keyword">USING</span> BTREE <span class="keyword">ON</span> tablename (字段,字段,字段);</span><br></pre></td></tr></table></figure><p>索引的种类尤其是复合索引以及对应的回表和最左匹配原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">普通索引：最基本的索引,没有任何约束限制。</span><br><span class="line">唯一索引：和普通索引类似,但是具有唯一性约束,可以有 <span class="keyword">null</span></span><br><span class="line">主键索引：特殊的唯一索引,不允许有 <span class="keyword">null</span>,一张表最多一个主键索引</span><br><span class="line">组合索引：多列值组成一个索引,用于组合搜索,效率大于索引合并</span><br><span class="line">全文索引：对文本的内容进行分词、搜索</span><br><span class="line">覆盖索引：查询列要被所建的索引覆盖,不必读取数据行</span><br><span class="line"><span class="number">1</span>、复合索引绑定的第一个列,没有出现在查询条件中;</span><br><span class="line">举例说明：为emp表插入索引idx_age_deptid_name(age,deptid,name),但是在查询条件中未使用age,导致复合索引全部失效。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、复合索引绑定的多个列是有顺序的,某一个列没有出现在查询条件中,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里没有deptid列,会导致复合索引中的deptid及其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>查询条件中出现某个列是范围查询的,存储引擎不能使用复合索引中该列其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里deptid列使用到了范围查询,会导致复合索引中的deptid其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>查询条件中某列使用否定条件的（!= &lt;&gt; IS NOT NULL）,存储引擎不能使用索引中该列其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里deptid列使用到了否定条件,会导致复合索引中的deptid其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>查询条件中某列使用LIKE条件后的字段是以%开头的（如：’%ABC’）,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里name列使用到了like ‘%a’,会导致复合索引中的name及其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>查询条件中某列使用函数的,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里name列使用到了like ‘%a’,会导致复合索引中的name及其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>查询条件中某列使用类型转换的（包括显示的和隐示的）,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">如：字符串类型的列NAME=<span class="number">3</span>,就是隐示的类型转换,将INT型转换为字符串类型。如果写为NAME=’<span class="number">3</span>’,就不是类型转换。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件name=<span class="number">3</span>,会导致复合索引中的name及其后的索引失效。条件写成name=‘<span class="number">3</span>’,索引就不会失效。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>如果索引的列在 select 所需获得的列中（因为在 mysql 中索引是根据索引列的值进行排序的,所以索引节点中存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表,如果 select 所需获得列中有大量的非索引列,索引就需要到表中找到相应的列的信息,这就叫回表。<br>使用聚集索引（主键或第一个唯一索引）就不会回表,普通索引就会回表</p><h2 id="索引下推优化"><a href="#索引下推优化" class="headerlink" title="索引下推优化,"></a>索引下推优化,</h2><p>可以在索引遍历过程中,对索引中包含的字段先做判断,过滤掉不符合条件的记录,减少回表字数。<br>最左匹配原则<br>带头大哥不能死,中间兄弟不能断</p><h2 id="Spring-AOP-底层原理"><a href="#Spring-AOP-底层原理" class="headerlink" title="Spring AOP 底层原理"></a>Spring AOP 底层原理</h2><p>aop 底层是采用动态代理机制实现的：接口+实现类</p><h2 id="如果要代理的对象-实现了某个接口-那么-Spring-AOP-会使用-JDK-Proxy-去创建代"><a href="#如果要代理的对象-实现了某个接口-那么-Spring-AOP-会使用-JDK-Proxy-去创建代" class="headerlink" title="如果要代理的对象,实现了某个接口,那么 Spring AOP 会使用 JDK Proxy,去创建代"></a>如果要代理的对象,实现了某个接口,那么 Spring AOP 会使用 JDK Proxy,去创建代</h2><p>理对象。</p><h2 id="没有实现接口的对象-就无法使用-JDK-Proxy-去进行代理了-这时候-Spring-AOP-会使用"><a href="#没有实现接口的对象-就无法使用-JDK-Proxy-去进行代理了-这时候-Spring-AOP-会使用" class="headerlink" title="没有实现接口的对象,就无法使用 JDK Proxy 去进行代理了,这时候 Spring AOP 会使用"></a>没有实现接口的对象,就无法使用 JDK Proxy 去进行代理了,这时候 Spring AOP 会使用</h2><p>Cglib 生成一个被代理对象的子类来作为代理。<br>就是由代理创建出一个和 impl 实现类平级的一个对象,但是这个对象不是一个真正的对象,<br>只是一个代理对象,但它可以实现和 impl 相同的功能,这个就是 aop 的横向机制原理,这<br>样就不需要修改源代码。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>HashMap在java1.7之前底层数据结构是数组+链表,1.8之后是数组+链表+红黑树,<br>在1.7以前的put方法采用的是头插法,当hash碰撞次数到达8,且桶内元素到达64个的时候形成链表,但是在极端情况下会造成链表过长,效率变低,并且在rehash的时候,头插法会造成回环链首尾相连,形成死锁,在java1.8以后采用红黑树,除了添加效率都高,是线程不安全的,不安全示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class HashMapTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMapThread thread0 = new HashMapThread();</span><br><span class="line">        HashMapThread thread1 = new HashMapThread();</span><br><span class="line">        HashMapThread thread2 = new HashMapThread();</span><br><span class="line">        HashMapThread thread3 = new HashMapThread();</span><br><span class="line">        HashMapThread thread4 = new HashMapThread();</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HashMapThread extends Thread &#123;</span><br><span class="line">    private static AtomicInteger ai = new AtomicInteger();</span><br><span class="line">    private static Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (ai.get() &lt; 1000000) &#123;</span><br><span class="line">            map.put(ai.get(), ai.get());</span><br><span class="line">            ai.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8 之前</p><h2 id="JDK1-8-之前-HashMap-底层是-数组和链表-结合在一起使用也就是-链表散列。-HashMap-通过-key-的-hashCode-经过扰动函数处理过后得到-hash-值-然后通过-n"><a href="#JDK1-8-之前-HashMap-底层是-数组和链表-结合在一起使用也就是-链表散列。-HashMap-通过-key-的-hashCode-经过扰动函数处理过后得到-hash-值-然后通过-n" class="headerlink" title="JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。 ## HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值,然后通过 (n -"></a>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。 ## HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值,然后通过 (n -</h2><ol><li>&amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度）,如果当前位置存在<br>元素的话,就判断该元素与要存入的元素的 hash 值以及 key 是否相同,如果相同的话,<br>直接覆盖,不相同就通过拉链法解决冲突。<h2 id="所谓扰动函数指的就是-HashMap-的-hash-方法。使用-hash-方法也就是扰动函数是为了"><a href="#所谓扰动函数指的就是-HashMap-的-hash-方法。使用-hash-方法也就是扰动函数是为了" class="headerlink" title="所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了"></a>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了</h2>防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。<br>JDK1.8 之后<br>当链表长度大于阈值（默认为 8）时,会首先调用 treeifyBin()方法。这个方法会根据<br>HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下,才会<br>执行转换红黑树操作,以减少搜索时间。否则,就是只是执行 resize() 方法对数组扩容。</li></ol><p>1.通常代替HashMap的安全由HashTable代替,但是多线程下他的put.get方法都是synchronized,效率太低,<br>2.Collections.synchronizedMap(),底层仍是synchronized<br>3.java9实现Collections.of()<br>ConcurrentHashMap 与 ConcurrentSkipListMap<br>ConcurrentHashMap 加锁<br>ConcurrentSkipListMap 不需要加锁,浪费空间,<br>4.ConcurrentHashMap<br>ConcurrentHashMap如何保证线程安全,在1.7以前由划分segment分段锁机制,共计16个并发级别,隔离级别太大,有很多空间就浪费了,太小就段内的元素过多<br>1.8以后是cas算法C语言写得,无锁算法,put添加的时候,链表+红黑树<br>put方法（无锁添加）<br>3、HashMap 的扩容机制是怎样的？<br>一般情况下,当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的 2 倍。<br>HashMap 的容量是有上限的,必须小于 1&lt;&lt;30,即 1073741824。如果容量超出了这个<br>数,则不再增长,且阈值会被设置为 Integer.MAX_VALUE。<br>JDK7 中的扩容机制</p><h2 id="空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是空数"><a href="#空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是空数" class="headerlink" title="空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是空数"></a>空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是空数</h2><p>组。</p><h2 id="有参构造函数：根据参数确定容量、负载因子、阈值等。"><a href="#有参构造函数：根据参数确定容量、负载因子、阈值等。" class="headerlink" title="有参构造函数：根据参数确定容量、负载因子、阈值等。"></a>有参构造函数：根据参数确定容量、负载因子、阈值等。</h2><h2 id="第一次-put-时会初始化数组-其容量变为不小于指定容量的-2-的幂数-然后根据负载因子"><a href="#第一次-put-时会初始化数组-其容量变为不小于指定容量的-2-的幂数-然后根据负载因子" class="headerlink" title="第一次 put 时会初始化数组,其容量变为不小于指定容量的 2 的幂数,然后根据负载因子"></a>第一次 put 时会初始化数组,其容量变为不小于指定容量的 2 的幂数,然后根据负载因子</h2><p>确定阈值。</p><h2 id="如果不是第一次扩容-则-新容量-旧容量-x-2-新阈值-新容量-x-负载因子-。"><a href="#如果不是第一次扩容-则-新容量-旧容量-x-2-新阈值-新容量-x-负载因子-。" class="headerlink" title="如果不是第一次扩容,则 新容量=旧容量 x 2 ,新阈值=新容量 x 负载因子 。"></a>如果不是第一次扩容,则 新容量=旧容量 x 2 ,新阈值=新容量 x 负载因子 。</h2><p>JDK8 的扩容机制</p><h2 id="空参数的构造函数：实例化的-HashMap-默认内部数组是-null-即没有实例化。第一次调"><a href="#空参数的构造函数：实例化的-HashMap-默认内部数组是-null-即没有实例化。第一次调" class="headerlink" title="空参数的构造函数：实例化的 HashMap 默认内部数组是 null,即没有实例化。第一次调"></a>空参数的构造函数：实例化的 HashMap 默认内部数组是 null,即没有实例化。第一次调</h2><p>用 put 方法时,则会开始第一次初始化扩容,长度为 16。 ## 有参构造函数：用于指定容量。会根据指定的正整数找到不小于指定容量的 2 的幂数,将<br>这个数设置赋值给阈值（threshold）。第一次调用 put 方法时,会将阈值赋值给容量,<br>然后让 阈值 = 容量 x 负载因子。 ## 如果不是第一次扩容,则容量变为原来的 2 倍,阈值也变为原来的 2 倍。（容量和阈值都<br>变为原来的 2 倍时,负载因子还是不变）。<br>此外还有几个细节需要注意：</p><h2 id="首次-put-时-先会触发扩容（算是初始化）-然后存入数据-然后判断是否需要扩容；"><a href="#首次-put-时-先会触发扩容（算是初始化）-然后存入数据-然后判断是否需要扩容；" class="headerlink" title="首次 put 时,先会触发扩容（算是初始化）,然后存入数据,然后判断是否需要扩容；"></a>首次 put 时,先会触发扩容（算是初始化）,然后存入数据,然后判断是否需要扩容；</h2><h2 id="不是首次-put-则不再初始化-直接存入数据-然后判断是否需要扩容；"><a href="#不是首次-put-则不再初始化-直接存入数据-然后判断是否需要扩容；" class="headerlink" title="不是首次 put,则不再初始化,直接存入数据,然后判断是否需要扩容；"></a>不是首次 put,则不再初始化,直接存入数据,然后判断是否需要扩容；</h2><p>4、ConcurrentHashMap 的存储结构是怎样的？</p><h2 id="Java7-中-ConcurrnetHashMap-使用的分段锁-也就是每一个-Segment-上同时只有一个"><a href="#Java7-中-ConcurrnetHashMap-使用的分段锁-也就是每一个-Segment-上同时只有一个" class="headerlink" title="Java7 中 ConcurrnetHashMap 使用的分段锁,也就是每一个 Segment 上同时只有一个"></a>Java7 中 ConcurrnetHashMap 使用的分段锁,也就是每一个 Segment 上同时只有一个</h2><p>线程可以操作,每一个 Segment 都是一个类似 HashMap 数组的结构,它可以扩容,它<br>的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变,默认 Segment 的<br>个数是 16 个。</p><h2 id="Java8-中的-ConcurrnetHashMap-使用的-Synchronized-锁加-CAS-的机制。结构也由"><a href="#Java8-中的-ConcurrnetHashMap-使用的-Synchronized-锁加-CAS-的机制。结构也由" class="headerlink" title="Java8 中的 ConcurrnetHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由"></a>Java8 中的 ConcurrnetHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由</h2><p>Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红<br>黑树,Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红<br>黑树,在冲突小于一定数量时又退回链表。<br>5、线程池大小如何设置？</p><h2 id="CPU-密集型任务-N-1-：-这种任务消耗的主要是-CPU-资源-可以将线程数设置为-N-（CPU-核心数）-1-比-CPU-核心数多出来的一个线程是为了防止线程偶发的缺页中断"><a href="#CPU-密集型任务-N-1-：-这种任务消耗的主要是-CPU-资源-可以将线程数设置为-N-（CPU-核心数）-1-比-CPU-核心数多出来的一个线程是为了防止线程偶发的缺页中断" class="headerlink" title="CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源,可以将线程数设置为 N （CPU 核心数）+1,比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断,"></a>CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源,可以将线程数设置为 N （CPU 核心数）+1,比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断,</h2><p>或者其它原因导致的任务暂停而带来的影响。一旦任务暂停,CPU 就会处于空闲状态,而<br>在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><h2 id="I-O-密集型任务-2N-：-这种任务应用起来-系统会用大部分的时间来处理-I-O-交互-而"><a href="#I-O-密集型任务-2N-：-这种任务应用起来-系统会用大部分的时间来处理-I-O-交互-而" class="headerlink" title="I/O 密集型任务(2N)： 这种任务应用起来,系统会用大部分的时间来处理 I/O 交互,而"></a>I/O 密集型任务(2N)： 这种任务应用起来,系统会用大部分的时间来处理 I/O 交互,而</h2><p>线程在处理 I/O 的时间段内不会占用 CPU 来处理,这时就可以将 CPU 交出给其它线程<br>使用。因此在 I/O 密集型任务的应用中,我们可以多配置一些线程,具体的计算方法是<br>2N。<br>如何判断是 CPU 密集任务还是 IO 密集任务？<br>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单<br>凡涉及到网络读取,文件读取这类都是 IO 密集型,这类任务的特点是 CPU 计算耗费时间相<br>比于等待 IO 操作完成的时间来说很少,大部分时间都花在了等待 IO 操作完成上。<br>6、IO 密集=Ncpu*2 是怎么计算出来？</p><h2 id="I-O-密集型任务任务应用起来-系统会用大部分的时间来处理-I-O-交互-而线程在处理"><a href="#I-O-密集型任务任务应用起来-系统会用大部分的时间来处理-I-O-交互-而线程在处理" class="headerlink" title="I/O 密集型任务任务应用起来,系统会用大部分的时间来处理 I/O 交互,而线程在处理"></a>I/O 密集型任务任务应用起来,系统会用大部分的时间来处理 I/O 交互,而线程在处理</h2><p>I/O 的时间段内不会占用 CPU 来处理,这时就可以将 CPU 交出给其它线程使用。因此在<br>I/O 密集型任务的应用中,我们可以多配置一些线程。例如：数据库交互,文件上传下<br>载,网络传输等。IO 密集型,即该任务需要大量的 IO,即大量的阻塞,故需要多配置线<br>程数。</p><h2 id="7、G1-收集器有哪些特点？"><a href="#7、G1-收集器有哪些特点？" class="headerlink" title="7、G1 收集器有哪些特点？"></a>7、G1 收集器有哪些特点？</h2><p>G1 的全称是 Garbage-First,意为垃圾优先,哪一块的垃圾最多就优先清理它。<br>G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布,变成可预期且可配置的。<br>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：<br>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势,使用多个 CPU（CPU 或者<br>CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程<br>执行的 GC 动作,G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</p><h2 id="分代收集：虽然-G1-可以不需要其他收集器配合就能独立管理整个-GC-堆-但是还是保留"><a href="#分代收集：虽然-G1-可以不需要其他收集器配合就能独立管理整个-GC-堆-但是还是保留" class="headerlink" title="分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆,但是还是保留"></a>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆,但是还是保留</h2><p>了分代的概念。<br>空间整合：与 CMS 的“标记-清理”算法不同,G1 从整体来看是基于“标记-整理”算法<br>实现的收集器；从局部上来看是基于“标记-复制”算法实现的。<br>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势,降低停顿时间是 G1 和 CMS 共<br>同的关注点,但 G1 除了追求低停顿外,还能建立可预测的停顿时间模型,能让使用者明<br>确指定在一个长度为 M 毫秒的时间片段内。<br>G1 收集器在后台维护了一个优先列表,每次根据允许的收集时间,优先选择回收价值最大的<br>Region（这也就是它的名字 Garbage-First 的由来）</p><h2 id="8、你有哪些手段来排查-OOM-的问题？"><a href="#8、你有哪些手段来排查-OOM-的问题？" class="headerlink" title="8、你有哪些手段来排查 OOM 的问题？"></a>8、你有哪些手段来排查 OOM 的问题？</h2><p>增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -<br>XX:HeapDumpPath=/tmp/heapdump.hprof,当 OOM 发生时自动 dump 堆内存信<br>息到指定目录。<br>同时 jstat 查看监控 JVM 的内存和 GC 情况,先观察问题大概出在什么区域。<br>使用 MAT 工具载入到 dump 文件,分析大对象的占用情况,比如 HashMap 做缓存未<br>清理,时间长了就会内存溢出,可以把改为弱引用。</p><h2 id="9、请你谈谈-MySQL-事务隔离级别-MySQL-的默认隔离级别是什么？"><a href="#9、请你谈谈-MySQL-事务隔离级别-MySQL-的默认隔离级别是什么？" class="headerlink" title="9、请你谈谈 MySQL 事务隔离级别,MySQL 的默认隔离级别是什么？"></a>9、请你谈谈 MySQL 事务隔离级别,MySQL 的默认隔离级别是什么？</h2><p>为了达到事务的四大特性,数据库定义了 4 种不同的事务隔离级别：<br> READ-UNCOMMITTED（读取未提交）：最低的隔离级别,允许脏读,也就是可能读取<br>到其他会话中未提交事务修改的数据,可能会导致脏读、幻读或不可重复读。<br> READ-COMMITTED（读取已提交）： 只能读取到已经提交的数据。Oracle 等多数数据<br>库默认都是该级别 （不重复读）,可以阻止脏读,但是幻读或不可重复读仍有可能发生。<br>REPEATABLE-READ（可重复读）：对同一字段的多次读取结果都是一致的,除非数据是<br>被本身事务自己所修改,可以阻止脏读和不可重复读,但幻读仍有可能发生。<br>SERIALIZABLE（可串行化）：最高的隔离级别,完全服从 ACID 的隔离级别。所有的事<br>务依次逐个执行,这样事务之间就完全不可能产生干扰,也就是说,该级别可以防止脏<br>读、不可重复读以及幻读。<br> MySQL 默认采用的 REPEATABLE_READ 隔离级别。</p><h2 id="可重复读解决了哪些问题？"><a href="#可重复读解决了哪些问题？" class="headerlink" title="可重复读解决了哪些问题？"></a>可重复读解决了哪些问题？</h2><p> 可重复读的核心就是一致性读(consistent read);保证多次读取同一个数据时,其值都和事<br>务开始时候的内容是一致,禁止读取到别的事务未提交的数据,会造成幻读。<br> 而事务更新数据的时候,只能用当前读。如果当前的记录的行锁被其他事务占用的话,就<br>需要进入锁等待。<br>32<br> 查询只承认在事务启动前就已经提交完成的数据。<br> 可重复读解决的是重复读的问题,可重复读在快照读的情况下是不会有幻读,但当前读的<br>时候会有幻读。</p><h2 id="11、对-SQL-慢查询会考虑哪些优化-？"><a href="#11、对-SQL-慢查询会考虑哪些优化-？" class="headerlink" title="11、对 SQL 慢查询会考虑哪些优化 ？"></a>11、对 SQL 慢查询会考虑哪些优化 ？</h2><p> 分析语句,是否加载了不必要的字段/数据。<br> 分析 SQL 执行计划（explain extended）,思考可能的优化点,是否命中索引等。<br> 查看 SQL 涉及的表结构和索引信息。<br> 如果 SQL 很复杂,优化 SQL 结构。<br> 按照可能的优化点执行表结构变更、增加索引、SQL 改写等操作。<br> 查看优化后的执行时间和执行计划。<br> 如果表数据量太大,考虑分表。<br> 利用缓存,减少查询次数</p><h2 id="12、谈一谈缓存穿透、缓存击穿和缓存雪崩-以及解决办法？"><a href="#12、谈一谈缓存穿透、缓存击穿和缓存雪崩-以及解决办法？" class="headerlink" title="12、谈一谈缓存穿透、缓存击穿和缓存雪崩,以及解决办法？"></a>12、谈一谈缓存穿透、缓存击穿和缓存雪崩,以及解决办法？</h2><p>缓存穿透<br> 问题：大量并发查询不存在的 KEY,在缓存和数据库中都不存在,同时给缓存和数据库带<br>来压力。<br> 原因：一般而言,缓存穿透有 2 种可能性：业务数据被误删,导致缓存和数据库中都没有<br>数据。恶意进行 ddos 攻击。<br> 分析：为什么会多次透传呢？不存在 一直为空,需要注意让缓存能够区分 KEY 不存在和<br>查询到一个空值。<br> 解决办法：缓存空值的 KEY,这样第一次不存在也会被加载会记录,下次拿到有这个<br>KEY。Bloom 过滤或 RoaingBitmap 判断 KEY 是否存在,如果布隆过滤器中没有查到这<br>个数据,就不去数据库中查。在处理请求前增加恶意请求检查,如果检测到是恶意攻击,<br>则拒绝进行服务。完全以缓存为准,使用延迟异步加载的策略（异步线程负责维护缓存的<br>数据,定期或根据条件触发更新）,这样就不会触发更新。<br>缓存击穿<br> 问题：某个 KEY 失效的时候,正好有大量并发请求访问这个 KEY。  分析：跟穿透其实很像,属于比较偶然的。<br> 解决办法：KEY 的更新操作添加全局互斥锁。完全以缓存为准,使用延迟异步加载的策略<br>（异步线程负责维护缓存的数据,定期或根据条件触发更新）,这样就不会触发更新。<br>缓存雪崩<br> 问题：当某一时刻发生大规模的缓存失效的情况,导致大量的请求无法获取数据,从而将<br>流量压力传导到数据库上,导致数据库压力过大甚至宕机。<br> 原因：一般而言,缓存雪崩有 2 种可能性：大量的数据同一个时间失效：比如业务关系强<br>相关的数据要求同时失效 Redis 宕机<br> 分析：一般来说,由于更新策略、或者数据热点、缓存服务宕机等原因,可能会导致缓存<br>数据同一个时间点大规模不可用,或者都更新。所以,需要我们的更新策略要在时间上合<br>适,数据要均匀分享,缓存服务器要多台高可用。<br> 解决办法：更新策略在时间上做到比较平均。如果数据需要同一时间失效,可以给这批数<br>据加上一些随机值,使得这批数据不要在同一个时间过期,降低数据库的压力。使用的热<br>数据尽量分散到不同的机器上。多台机器做主从复制或者多副本,实现高可用。做好主从<br>的部署,当主节点挂掉后,能快速的使用从结点顶上。实现熔断限流机制,对系统进行负<br>载能力控制。对于非核心功能的业务,拒绝其请求,只允许核心功能业务访问数据库获取<br>数据。服务降价：提供默认返回值,或简单的提示信息。</p><h2 id="13、LRU-是什么？如何实现？"><a href="#13、LRU-是什么？如何实现？" class="headerlink" title="13、LRU 是什么？如何实现？"></a>13、LRU 是什么？如何实现？</h2><p>最近最少使用策略 LRU（Least Recently Used）是一种缓存淘汰算法,是一种缓存淘汰机<br>制。<br> 使用双向链表实现的队列,队列的最大容量为缓存的大小。在使用过程中,把最近使用的<br>页面移动到队列头,最近没有使用的页面将被放在队列尾的位置<br> 使用一个哈希表,把页号作为键,把缓存在队列中的节点的地址作为值,只需要把这个页<br>对应的节点移动到队列的前面,如果需要的页面在内存中,此时需要把这个页面加载到内<br>存中,简单的说,就是将一个新节点添加到队列前面,并在哈希表中跟新相应的节点地<br>址,如果队列是满的,那么就从队尾移除一个节点,并将新节点添加到队列的前面。</p><h2 id="14、什么是堆内存？参数如何设置？"><a href="#14、什么是堆内存？参数如何设置？" class="headerlink" title="14、什么是堆内存？参数如何设置？"></a>14、什么是堆内存？参数如何设置？</h2><p>堆内存是指由程序代码自由分配的内存,与栈内存作区分。<br>在 Java 中,堆内存主要用于分配对象的存储空间,只要拿到对象引用,所有线程都可<br>以访问堆内存。<br> -Xmx, 指定最大堆内存。 如 -Xmx4g. 这只是限制了 Heap 部分的最大值为 4g。这个内<br>存不包括栈内存,也不包括堆外使用的内存。<br> -Xms, 指定堆内存空间的初始大小。 如 -Xms4g。 而且指定的内存大小,并不是操作系<br>统实际分配的初始值,而是 GC 先规划好,用到才分配。 专用服务器上需要保持 –Xms<br>和 –Xmx 一致,否则应用刚启动可能就有好几个 FullGC。当两者配置不一致时,堆内存<br>扩容可能会导致性能抖动。<br>34<br> -Xmn, 等价于 -XX:NewSize,使用 G1 垃圾收集器 不应该 设置该选项,在其他的某些业<br>务场景下可以设置。官方建议设置为 -Xmx 的 1/2 ~ 1/4.<br> -XX：MaxPermSize=size, 这是 JDK1.7 之前使用的。Java8 默认允许的 Meta 空间无限<br>大,此参数无效。<br> -XX：MaxMetaspaceSize=size, Java8 默认不限制 Meta 空间, 一般不允许设置该选<br>项。<br> -XX：MaxDirectMemorySize=size,系统可以使用的最大堆外内存,这个参数跟 -<br>Dsun.nio.MaxDirectMemorySize 效果相同。<br> -Xss, 设置每个线程栈的字节数。 例如 -Xss1m 指定线程栈为 1MB,与-<br>XX:ThreadStackSize=1m 等价</p><h2 id="15、栈和队列-举个使用场景例子？"><a href="#15、栈和队列-举个使用场景例子？" class="headerlink" title="15、栈和队列,举个使用场景例子？"></a>15、栈和队列,举个使用场景例子？</h2><p> 栈（后进先出）可以用于字符匹配,数据反转等场景<br> 队列（先进先出）可以用于任务队列,共享打印机等场景</p><h2 id="16、MySQL-为什么-InnoDB-是默认引擎？"><a href="#16、MySQL-为什么-InnoDB-是默认引擎？" class="headerlink" title="16、MySQL 为什么 InnoDB 是默认引擎？"></a>16、MySQL 为什么 InnoDB 是默认引擎？</h2><p>MyISAM与InnoDB 的区别（9个不同点）<br>区别：</p><ol><li><p>InnoDB支持事务,MyISAM不支持,对于InnoDB每一条SQL语言都默认封装成事务,自动提交,这样会影响速度,所以最好把多条SQL语言放在begin和commit之间,组成一个事务； </p></li><li><p>InnoDB支持外键,而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； </p></li><li><p>InnoDB是聚集索引,使用B+Tree作为索引结构,数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构）,必须要有主键,通过主键索引效率很高。但是辅助索引需要两次查询,先查询到主键,然后再通过主键查询到数据。因此,主键不应该过大,因为主键太大,其他索引也都会很大。</p><pre><code>MyISAM是非聚集索引,也是使用B+Tree作为索引结构,索引和数据文件是分离的,索引保存的是数据文件的指针。主键索引和辅助索引是独立的。也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件,辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</code></pre></li><li><p>InnoDB不保存表的具体行数,执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数,执行上述语句时只需要读出该变量即可,速度很快（注意不能加有任何WHERE条件）；</p></li></ol><p>那么为什么InnoDB没有了这个变量呢？</p><pre><code>因为InnoDB的事务特性,在同一时刻表中的行数对于不同的事务而言是不一样的,因此count统计会计算对于当前事务而言可以统计到的行数,而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在,InnoDB还会尝试去遍历其他聚簇索引。如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中,count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样,如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS</code></pre><ol start="5"><li><p>Innodb不支持全文索引,而MyISAM支持全文索引,在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了</p></li><li><p>MyISAM表格可以被压缩后进行查询操作</p></li><li><p>InnoDB支持表、行(默认)级锁,而MyISAM支持表级锁</p><pre><code>InnoDB的行锁是实现在索引上的,而不是锁在物理行记录上。潜台词是,如果访问没有命中索引,也无法使用行锁,将要退化为表锁。</code></pre></li></ol><p>例如：</p><pre><code>t_user(uid, uname, age, sex) innodb;uid PK无其他索引update t_user set age=10 where uid=1;             命中索引,行锁。update t_user set age=10 where uid != 1;           未命中索引,表锁。update t_user set age=10 where name=&#39;chackca&#39;;    无索引,表锁。</code></pre><p>8、InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键）,而Myisam可以没有</p><p>9、Innodb存储文件有frm、ibd,而Myisam是frm、MYD、MYI</p><pre><code>    Innodb：frm是表定义文件,ibd是数据文件    Myisam：frm是表定义文件,myd是数据文件,myi是索引文件</code></pre><p>如何选择：<br>    1. 是否要支持事务,如果要请选择innodb,如果不需要可以考虑MyISAM；</p><pre><code>2. 如果表中绝大多数都只是读查询,可以考虑MyISAM,如果既有读也有写,请使用InnoDB。3. 系统奔溃后,MyISAM恢复起来更困难,能否接受；4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM),说明其优势是有目共睹的,如果你不知道用什么,那就用InnoDB,至少不会差。</code></pre><p>InnoDB为什么推荐使用自增ID作为主键？</p><pre><code>答：自增ID可以保证每次插入时B+索引是从右边扩展的,可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键,会使得数据随机插入,效率比较差。</code></pre><p>innodb引擎的4大特性</p><pre><code>   插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)</code></pre><h2 id="19、MVCC-是什么？它的底层原理是什么？"><a href="#19、MVCC-是什么？它的底层原理是什么？" class="headerlink" title="19、MVCC 是什么？它的底层原理是什么？"></a>19、MVCC 是什么？它的底层原理是什么？</h2><p>MVCC,多版本并发控制,它是通过读取历史版本的数据,来降低并发事务冲突,从而提高并<br>发性能的一种机制。<br> 事务版本号<br> 表的隐藏列<br> undo log<br> read view</p><h2 id="20、undo-log-具体怎么回滚事务-？"><a href="#20、undo-log-具体怎么回滚事务-？" class="headerlink" title="20、undo log 具体怎么回滚事务 ？"></a>20、undo log 具体怎么回滚事务 ？</h2><p>举个例子：<br> 对于 insert 类型的 sql,会在 undo log 中记录下方才你 insert 进来的数据的 ID,当你想<br>roll back 时,根据 ID 完成精准的删除。<br> 对于 delete 类型的 sql,会在 undo log 中记录方才你删除的数据,当你回滚时会将删除<br>前的数据 insert 进去。<br> 对于 update 类型的 sql,会在 undo log 中记录下修改前的数据,回滚时只需要反向<br>update 即可。<br> 对于 select 类型的 sql,别费心了,select 不需要回滚。</p><h2 id="22、索引失效的情况有哪些？"><a href="#22、索引失效的情况有哪些？" class="headerlink" title="22、索引失效的情况有哪些？"></a>22、索引失效的情况有哪些？</h2><p> like 以%开头索引无效,当 like 以&amp;结尾,索引有效。<br> or 语句前后没有同事使用索引,当且仅当 or 语句查询条件的前后列均为索引时,索引生<br>效。<br> 组合索引,使用的不是第一列索引时候,索引失效,即最左匹配规则。<br> 数据类型出现隐式转换,如 varchar 不加单引号的时候可能会自动转换为 int 类型,这个<br>时候索引失效。<br> 在索引列上使用 IS NULL 或者 IS NOT NULL 时候,索引失效,因为索引是不索引空值<br>得。<br> 在索引字段上使用,NOT、 &lt;&gt;、！= 、时候是不会使用索引的,对于这样的处理只会进<br>行全表扫描。<br> 对索引字段进行计算操作,函数操作时不会使用索引。<br> 当全表扫描速度比索引速度快的时候不会使用索引。<br>索引失效场景一：带头大哥不能死,中间兄弟不能断</p><p>索引失效场景二：在索引列上做操作</p><p>索引失效场景三：范围条件右边全失效</p><p>索引低效场景四：select * 会降低索引的效率</p><p>索引失效场景五：使用!=或&lt;&gt;会导致索引失效</p><p>索引失效场景六、isnull和is not null字段无法使用索引</p><p>索引失效场景七、%like%查询时的索引失效问题</p><p>索引失效场景八、字符串不加单引号索引失效</p><p>索引失效场景九、少用or,用or连接索引会失效</p><h2 id="Spring-Bean-容器的生命周期是什么样的？"><a href="#Spring-Bean-容器的生命周期是什么样的？" class="headerlink" title="Spring Bean 容器的生命周期是什么样的？"></a>Spring Bean 容器的生命周期是什么样的？</h2><p> Bean 容器找到配置文件中 Spring Bean 的定义。<br> Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。<br> 如果涉及到一些属性值 利用 set()方法设置一些属性值。<br> 如果 Bean 实现了 BeanNameAware 接口,调用 setBeanName()方法,传入 Bean 的名<br>字。<br> 如果 Bean 实现了 BeanClassLoaderAware 接口,调用 setBeanClassLoader()方法,传<br>入 ClassLoader 对象的实例。<br> 如果 Bean 实现了 BeanFactoryAware 接口,调用 setBeanFactory()方法,传入<br>BeanFactory 对象的实例。<br> 与上面的类似,如果实现了其他 <code>*</code>.Aware 接口,就调用相应的方法。<br> 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象,执行<br>postProcessBeforeInitialization() 方法<br>39<br> 如果 Bean 实现了 InitializingBean 接口,执行 afterPropertiesSet()方法。<br> 如果 Bean 在配置文件中的定义包含 init-method 属性,执行指定的方法。<br> 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象,执行<br>postProcessAfterInitialization() 方法<br> 当要销毁 Bean 的时候,如果 Bean 实现了 DisposableBean 接口,执行 destroy() 方<br>法。<br> 当要销毁 Bean 的时候,如果 Bean 在配置文件中的定义包含 destroy-method 属性,执<br>行指定的方法。</p><h2 id="Redis-数据结构-压缩列表和跳跃表的区别"><a href="#Redis-数据结构-压缩列表和跳跃表的区别" class="headerlink" title="Redis 数据结构 压缩列表和跳跃表的区别"></a>Redis 数据结构 压缩列表和跳跃表的区别</h2><p>压缩列表（ziplist）本质上就是一个字节数组,是 Redis 为了节约内存而设计的一种线性<br>数据结构,可以包含多个元素,每个元素可以是一个字节数组或一个整数。<br> 跳跃表（skiplist）是一种有序数据结构,它通过在每个节点中维持多个指向其他节点的指<br>针,从而达到快速访问节点的目的。跳跃表支持平均 O（logN）、最坏 O（N）复杂度的<br>节点查找,还可以通过顺序性操作来批量处理节点</p><h2 id="1-redis的hash怎么实现的？-实现原理-rehash过程"><a href="#1-redis的hash怎么实现的？-实现原理-rehash过程" class="headerlink" title="1.redis的hash怎么实现的？(实现原理)rehash过程"></a>1.redis的hash怎么实现的？(实现原理)rehash过程</h2><p>redis初始创建hash表,有序集合,链表时, 存储结构采用一种ziplist的存储结构, 这种结构内存排列更紧密, 能提高访存性能.<br>hash_max_ziplist_entries和hash_max_ziplist_value值作为阀值,hash_max_ziplist_entries表示一旦ziplist中元素数量超过该值,则需要转换为dict结构；hash_max_ziplist_value表示一旦ziplist中数据长度大于该值,则需要转换为dict结构。<br>哈希等价于Java语言的HashMap或者是Python语言的字典（Dict）<br>redis hash 的内部结构.第一维是数组,第二维是链表.组成一个 hashtable.<br>在 Java 中 HashMap 扩容是个很耗时的操作,需要去申请新的数组,为了追求高性能,Redis 采用了渐进式 rehash 策略.这也是 hash 中最重要的部分.<br>在扩容的时候 rehash 策略会保留新旧两个 hashtable 结构,查询时也会同时查询两个 hashtable.Redis会将旧 hashtable 中的内容一点一点的迁移到新的 hashtable 中,当迁移完成时,就会用新的 hashtable 取代之前的.当 hashtable 移除了最后一个元素之后,这个数据结构将会被删除.<br><a href="https://juejin.im/post/5cfe6383e51d45599e019d8f">https://juejin.im/post/5cfe6383e51d45599e019d8f</a><br>与java的hashmap的rehash区别<br>个人理解：hashmap的rehash是一次性拷贝的,不同的是,Redis的字典只能是字符串,另外他们rehash的方式不一样,因为Java的HashMap的字典很大时,rehash是个耗时的操作,需要一次全部rehash。Redis为了追求高性能,不能堵塞服务,所以采用了渐进式rehash策略。<br>rehash的详细步骤<br><a href="https://www.cnblogs.com/meituantech/p/9376472.html">https://www.cnblogs.com/meituantech/p/9376472.html</a><br>与ConcurrentHashMap扩容的策略比较？<br>ConcurrentHashMap采用的扩容策略为： “多线程协同式rehash“。<br>1.扩容所花费的时间对比： 一个单线程渐进扩容,一个多线程协同扩容。在平均的情况下,是ConcurrentHashMap 快。这也意味着,扩容时所需要 花费的空间能够更快的进行释放。<br>2.读操作,两者性能相差不多。<br>3.写操作,Redis的字典返回更快些,因为它不像ConcurrentHashMap那样去帮着扩容(当要写的桶位已经搬到了newTable时),等扩容完才能进行操作。<br>4.删除操作,与写一样。<br><a href="http://xytschool.com/resource/236.html">http://xytschool.com/resource/236.html</a></p><h2 id="redis如何保证高可用"><a href="#redis如何保证高可用" class="headerlink" title="redis如何保证高可用"></a>redis如何保证高可用</h2><p>保证redis高可用机制需要redis主从复制、redis持久化机制、哨兵机制、keepalived等的支持。<br>主从复制的作用：数据备份、读写分离、分布式集群、实现高可用、宕机容错机制等。</p><h2 id="redis主从复制原理"><a href="#redis主从复制原理" class="headerlink" title="redis主从复制原理"></a>redis主从复制原理</h2><p>首先主从复制需要分为两个角色：master(主) 和 slave(从) ,注意：redis里面只支持一个主,不像Mysql、Nginx主从复制可以多主多从。</p><p>(1)redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave）,主数据库可以进行读写操作,当发生写操作的时候自动将数据同步到从数据库,而从数据库一般是只读的,并接收主数据库同步过来的数据,一个主数据库可以有多个从数据库,而一个从数据库只能有一个主数据库。</p><p>(2)通过redis的复制功能可以很好的实现数据库的读写分离,提高服务器的负载能力。主数据库主要进行写操作,而从数据库负责读操作。</p><p><a href="https://blog.csdn.net/itcats_cn/article/details/82428716">https://blog.csdn.net/itcats_cn/article/details/82428716</a></p><h1 id="说说redis的持久化机制-为啥不能用redis做专门的持久化数据库存储？"><a href="#说说redis的持久化机制-为啥不能用redis做专门的持久化数据库存储？" class="headerlink" title="说说redis的持久化机制,为啥不能用redis做专门的持久化数据库存储？"></a>说说redis的持久化机制,为啥不能用redis做专门的持久化数据库存储？</h1><p>个人理解：强一致性的数据是不适合放在缓存中的。另外MySQL对事务的支持也是redis本身不能达到的,需要单独实现<br>一般不是说redis or  MySQL,而是redis+MySQL<br><a href="https://blog.csdn.net/u011784767/article/details/76824822">https://blog.csdn.net/u011784767/article/details/76824822</a><br>为什么Redis进行RDB持久化数据时,新起一个进程而不是在原进程中起一个线程来持久化数据<br>(1)Redis RDB持久化机制会阻塞主进程,这样主进程就无法响应客户端请求。<br>(2)我们知道Redis对客户端响应请求的工作模型是单进程和单线程的,如果在主进程内启动一个线程,这样会造成对数据的竞争条件,为了避免使用锁降低性能。基于以上两点这就是为什么Redis通过启动一个进程来执行RDB了<br>—单线程的redis为什么这么快<br>(1)纯内存操作<br>(2)单线程操作,避免了频繁的上下文切换<br>(3)采用了非阻塞I/O多路复用机制</p><p>1</p><h2 id="Redis的数据类型以及使用场景"><a href="#Redis的数据类型以及使用场景" class="headerlink" title="Redis的数据类型以及使用场景"></a>Redis的数据类型以及使用场景</h2><p>(1)String<br>这个其实没啥好说的,最常规的set/get操作,value可以是String也可以是数字。<br>一般做一些复杂的计数功能的缓存。</p><p>(2)hash<br>这里value存放的是结构化的对象,比较方便的就是操作其中的某个字段。博主在做单点登录的时候,<br>就是用这种数据结构存储用户信息,以cookieId作为key,设置30分钟为缓存过期时间,能很好的模拟出类似session的效果。</p><p>(3)list<br>使用List的数据结构,可以做简单的消息队列的功能。另外还有一个就是,可以利用lrange命令,<br>做基于redis的分页功能,性能极佳,用户体验好。</p><p>(4)set<br>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？<br>因为我们的系统一般都是集群部署,使用JVM自带的Set,比较麻烦,难道为了一个做一个全局去重,再启一个公共服务,太麻烦了。</p><p>另外,就是利用交集、并集、差集等操作,可以计算共同喜好,全部的喜好,自己独有的喜好等功能。</p><p>(5)sorted set<br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用,取TOP N操作。sorted set可以用来做延时任务。最后一个应用就是可以做范围查找</p><h1 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h1><p>redis采用的是定期删除+惰性删除+内存淘汰策略。<br>[2020年6月29日17:25:36在平时的项目中测试,不定期会产生无用token的key数据,平时可以进行模糊删除]</p><p>缓存穿透,即黑客故意去请求缓存中不存在的数据,导致所有的请求都怼到数据库上,从而数据库连接异常。</p><p>解决方案:<br>(一)利用互斥锁,缓存失效的时候,先去获得锁,得到锁了,再去请求数据库。没得到锁,则休眠一段时间重试<br>(二)采用异步更新策略,无论key是否取到值,都直接返回。value值中维护一个缓存失效时间,缓存如果过期,<br>异步起一个线程去读数据库,更新缓存。需要做缓存预热(项目启动前,先加载缓存)操作。<br>(三)提供一个能迅速判断请求是否有效的拦截机制,比如,利用布隆过滤器,内部维护一系列合法有效的key。<br>迅速判断出,请求所携带的Key是否合法有效。如果不合法,则直接返回。</p><p>缓存雪崩,即缓存同一时间大面积的失效,这个时候又来了一波请求,结果请求都怼到数据库上,从而导致数据库连接异常。</p><p>解决方案:<br>(一)给缓存的失效时间,加上一个随机值,避免集体失效。<br>(二)使用互斥锁,但是该方案吞吐量明显下降了。<br>(三)双缓存。我们有两个缓存,缓存A和缓存B。缓存A的失效时间为20分钟,缓存B不设失效时间。<br>自己做缓存预热操作。然后细分以下几个小点<br>1 从缓存A读数据库,有则直接返回<br>2 A没有数据,直接从B读数据,直接返回,并且异步启动一个更新线程。<br>3 更新线程同时更新缓存A和缓存B。</p><h2 id="如何解决redis的并发竞争key问题"><a href="#如何解决redis的并发竞争key问题" class="headerlink" title="如何解决redis的并发竞争key问题"></a>如何解决redis的并发竞争key问题</h2><p>分析:这个问题大致就是,同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。<br>需要说明一下,博主提前百度了一下,发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。<br>因为我们的生产环境,基本都是redis集群环境,做了数据分片操作。你一个事务中有涉及到多个key操作的时候,<br>这多个key不一定都存储在同一个redis-server上。因此,redis的事务机制,十分鸡肋。</p><p>回答:如下所示<br>(1)如果对这个key操作,不要求顺序<br>这种情况下,准备一个分布式锁,大家去抢锁,抢到锁就做set操作即可,比较简单。<br>(2)如果对这个key操作,要求顺序<br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候,<br>需要保存一个时间戳。假设时间戳如下<br>系统A key 1 {valueA  3:00}<br>系统B key 1 {valueB  3:05}<br>系统C key 1 {valueC  3:10}<br>那么,假设这会系统B先抢到锁,将key1设置为{valueB 3:05}。接下来系统A抢到锁,发现自己的valueA的时间戳早于缓存中的时间戳,那就不做set操作了。以此类推。<br>redis分页<br>HSCAN testHash “0” count 10</p><p>注：测试field数量在22条时（没有测试Redis中Hash使分页生效时的field数量的下限）,分页未生效。<br>#mysql 执行一个 sql 的过程<br>执行完毕之后有一个缓存的过程<br><a href="https://www.cnblogs.com/luoying/p/12073812.html">https://www.cnblogs.com/luoying/p/12073812.html</a></p><h2 id="MySQL分页limit速度太慢的优化方法"><a href="#MySQL分页limit速度太慢的优化方法" class="headerlink" title="MySQL分页limit速度太慢的优化方法"></a>MySQL分页limit速度太慢的优化方法</h2><p>1.子查询优化法<br>先找出第一条数据,然后大于等于这条数据的id就是要获取的数据<br>缺点：数据必须是连续的,可以说不能有where条件,where条件会筛选数据,导致数据失去连续性<br>2.limit限制优化法<br>把limit偏移量限制低于某个数<br>3.where条件先过滤后分页</p><h2 id="wait-notify-为什么要搭配使用？"><a href="#wait-notify-为什么要搭配使用？" class="headerlink" title="wait notify 为什么要搭配使用？"></a>wait notify 为什么要搭配使用？</h2><p>单独调用会报异常<br>只有在调用线程拥有某个对象的独占锁时,才能够调用该对象的wait(),notify()和notifyAll()方法。因为程序验证通常是在对象的同步方法或同步代码块中调用它们的。如果尝试在未获取对象锁时调用这三个方法,<br>“java.lang.IllegalMonitorStateException:current thread not owner”。<br>底层把对象作为一个监视器</p><h2 id="栈会溢出吗？什么时候溢出？方法区会溢出吗？"><a href="#栈会溢出吗？什么时候溢出？方法区会溢出吗？" class="headerlink" title="栈会溢出吗？什么时候溢出？方法区会溢出吗？"></a>栈会溢出吗？什么时候溢出？方法区会溢出吗？</h2><p>栈是线程私有的,它的生命周期与线程相同,每个方法在执行的时候都会创建一个栈帧,用来<br>存储局部变量表,操作数栈,动态链接,方法出口等信息。局部变量表又包含基本数据类型,<br>对象引用类型。如果线程请求的栈深度大于虚拟机所允许的最大深度,将抛出<br>StackOverflowError 异常,方法递归调用产生这种结果。如果 Java 虚拟机栈可以动态扩展,<br>并且扩展的动作已经尝试过,但是无法申请到足够的内存去完成扩展,或者在新建立线程的时<br>候没有足够的内存去创建对应的虚拟机栈,那么 Java 虚拟机将抛出一个 OutOfMemory 异<br>常。(线程启动过多)。<br>方法区会发生溢出。<br>HotSpot jdk1.7 之前字符串常量池是方法区的一部分,方法区叫做“永久代”,在 1.7 之前<br>无限的创建对象就会造成内存溢出,提示信息：PermGen space 而是用 jdk1.7 之后,开始逐<br>步去永久代,就不会产生内存溢出。<br>方法区用于存放 Class 的相关信息,如类名、访问修饰符、常量池、字段描述、方法描述等,<br>如果动态生成大量的 Class 文件,也会产生内存溢出。常见的场景还有：大量 JSP 或动态产生<br>JSP 文件的应用（JSP 第一次运行时需要编译为 java 类）、基于 OSGi 的应用（即使是同一个<br>类文件,被不同的类加载器加载也会视为不同的类）</p><h2 id="redis排行榜代码"><a href="#redis排行榜代码" class="headerlink" title="redis排行榜代码"></a>redis排行榜代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">countPoint</span><span class="params">(Long pointId,String ponitList, Long userId)</span> </span>&#123;</span><br><span class="line">        String key = RedisConstants.get(pointId.toString());</span><br><span class="line">        String userIdStr = userId.toString();</span><br><span class="line">        <span class="keyword">boolean</span> flag = redisService.isMember(key, userIdStr);</span><br><span class="line">        DetailVo vo = DetailVo.builder()</span><br><span class="line">                .pointId(pointId)</span><br><span class="line">                .likeCreateTime(<span class="keyword">new</span> Date())</span><br><span class="line">                .likeUserId(userId)</span><br><span class="line">                .likedUserId(likedUserId)</span><br><span class="line">                .build();</span><br><span class="line">        Map resultMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            redisService.srem(key, userIdStr);</span><br><span class="line">            vo.setType(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//减分</span></span><br><span class="line">            redisService.incrScoreZset(ponitList,likedUserId.toString(),-<span class="number">1</span>);</span><br><span class="line">            resultMap.put(<span class="string">&quot;no&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisService.sadd(key, userIdStr);</span><br><span class="line">            <span class="comment">//加分</span></span><br><span class="line">            redisService.incrScoreZset(ponitList,likedUserId.toString(),<span class="number">1</span>);</span><br><span class="line">            vo.setType(<span class="number">1</span>);</span><br><span class="line">            resultMap.put(<span class="string">&quot;yes&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        mQProducer.sendUpdateUp(vo);</span><br><span class="line">        resultMap.put(<span class="string">&quot;Number&quot;</span>, redisService.scard(key));</span><br><span class="line">        <span class="keyword">return</span> resultMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="请问-这个-Dao-接口的工作原理是什么？Dao-接口里的方法-参数不同时-方法能重载吗？"><a href="#请问-这个-Dao-接口的工作原理是什么？Dao-接口里的方法-参数不同时-方法能重载吗？" class="headerlink" title="请问,这个 Dao 接口的工作原理是什么？Dao 接口里的方法,参数不同时,方法能重载吗？"></a>请问,这个 Dao 接口的工作原理是什么？Dao 接口里的方法,参数不同时,方法能重载吗？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Dao 接口即 Mapper 接口。接口的全限名,就是映射文件中的 namespace 的值；</span><br><span class="line">接口的方法名,就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的</span><br><span class="line">参数,就是传递给 sql 的参数。</span><br><span class="line">Mapper 接口是没有实现类的,当调用接口方法时,接口全限名+方法名拼接字符</span><br><span class="line">串作为 key 值,可唯一定位一个 MapperStatement。在 Mybatis 中,每一个</span><br><span class="line">&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签,都会被解析为一个</span><br><span class="line">MapperStatement 对象。</span><br><span class="line">举例：com.mybatis3.mappers.StudentDao.findStudentById,可以唯</span><br><span class="line">一找到 namespace 为 com.mybatis3.mappers.StudentDao 下面 id 为</span><br><span class="line">findStudentById 的 MapperStatement。</span><br><span class="line">Mapper 接口里的方法,是不能重载的,因为是使用 全限名+方法名 的保存和寻</span><br><span class="line">找策略。Mapper 接口的工作原理是 JDK 动态代理,Mybatis 运行时会使用 JDK</span><br><span class="line">动态代理为 Mapper 接口生成代理对象 proxy,代理对象会拦截接口方法,转而</span><br><span class="line">执行 MapperStatement 所代表的 sql,然后将 sql 执行结果返回。</span><br></pre></td></tr></table></figure><h2 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis 使用 RowBounds 对象进行分页,它是针对 ResultSet 结果集执行的内<br>存分页,而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分<br>页功能,也可以使用分页插件来完成物理分页。<br>分页插件的基本原理是使用 Mybatis 提供的插件接口,实现自定义插件,在插件<br>的拦截方法内拦截待执行的 sql,然后重写 sql,根据 dialect 方言,添加对应的物<br>理分页语句和物理分页参数。</p><h2 id="Mybatis-的一级、二级缓存"><a href="#Mybatis-的一级、二级缓存" class="headerlink" title="Mybatis 的一级、二级缓存"></a>Mybatis 的一级、二级缓存</h2><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存,其存储作用域为<br>Session,当 Session flush 或 close 之后,该 Session 中的所有 Cache 就<br>将清空,默认打开一级缓存。<br>2）二级缓存与一级缓存其机制相同,默认也是采用 PerpetualCache,HashMap<br>存储,不同在于其存储作用域为 Mapper(Namespace),并且可自定义存储源,<br>如 Ehcache。默认不打开二级缓存,要开启二级缓存,使用二级缓存属性类需要<br>实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置<br><cache/> ；<br>3）对于缓存数据更新机制,当某一个作用域(一级缓存 Session/二级缓存<br>Namespaces)的进行了 C/U/D 操作后,默认该作用域下所有 select 中的缓存将<br>被 clear。</p><h1 id="Redis面试专题"><a href="#Redis面试专题" class="headerlink" title="Redis面试专题"></a>Redis面试专题</h1><h2 id="redis-和-memcached-什么区别？为什么高并发下有时单线程的-redis-比多线程的"><a href="#redis-和-memcached-什么区别？为什么高并发下有时单线程的-redis-比多线程的" class="headerlink" title="redis 和 memcached 什么区别？为什么高并发下有时单线程的 redis 比多线程的"></a>redis 和 memcached 什么区别？为什么高并发下有时单线程的 redis 比多线程的</h2><p>memcached 效率要高？<br>区别：<br>1.mc 可缓存图片和视频。rd 支持除 k/v 更多的数据结构;<br>2.rd 可以使用虚拟内存,rd 可持久化和 aof 灾难恢复,rd 通过主从支持数据备份;<br>3.rd 可以做消息队列。<br>原因：mc 多线程模型引入了缓存一致性和锁,加锁带来了性能损耗。</p><h2 id="假如-Redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来？"><a href="#假如-Redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来？" class="headerlink" title="假如 Redis 里面有 1 亿个 key,其中有 10w 个 key 是以某个固定的已知的前缀开头的,如果将它们全部找出来？"></a>假如 Redis 里面有 1 亿个 key,其中有 10w 个 key 是以某个固定的已知的前缀开头的,如果将它们全部找出来？</h2><p>使用 keys 指令可以扫出指定模式的 key 列表。<br>对方接着追问：如果这个 redis 正在给线上的业务提供服务,那使用 keys 指令会有什么问<br>题？<br>这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一<br>段时间,线上服务会停顿,直到指令执行完毕,服务才能恢复。这个时候可以使用 scan 指<br>令,scan 指令可以无阻塞的提取出指定模式的 key 列表,但是会有一定的重复概率,在客<br>户端做一次去重就可以了,但是整体所花费的时间会比直接用 keys 指令长。</p><h2 id="Synchronized-锁升级过程"><a href="#Synchronized-锁升级过程" class="headerlink" title="Synchronized 锁升级过程"></a>Synchronized 锁升级过程</h2><p>首先,synchronized 是什么？我们需要明确的给个定义——同步锁,没错,它就是把锁。</p><p>可以用来干嘛？锁,当然当然是用于线程间的同步,以及保护临界区内的资源。我们知道,锁是个非常笼统的概念,像生活中有指纹锁、密码锁等等多个种类,那 synchronized 代表的锁具体是把什么锁呢？</p><p>答案是—— Java 内置锁。在 Java 中,每个对象中都隐藏着一把锁,而 synchronized 关键字就是激活这把隐式锁的把手（开关）。</p><p>先来简单了解一下 synchronized,我们知道其共有 3 种使用方式：</p><p>关于扫描时markword,可以去了解下对象在JVM中的结构,这里简单说明,每个对象都会有一个对象头markword,这块区域可以存放hashcode和锁信息以及GC信息</p><p>Synchronized 的使用</p><p>修饰静态方法：锁住当前 class,作用于该 class 的所有实例<br>修饰非静态方法：只会锁住当前 class 的实例<br>修饰代码块：该方法接受一个对象作为参数,锁住的即该对象<br>使用方法就不在这里赘述,可自行搜索其详细的用法,这不是本篇文章所关心的内容。</p><p>知道了 synchronized 的概念,回头来看标题,它说的锁升级到底是个啥？对于不太熟悉锁升级的人来说,可能会想：</p><p>所谓锁,不就是啪一下锁上就完事了吗？升级是个什么玩意？这跟打扑克牌也没关系啊。</p><p>对于熟悉的人来说,可能会想：</p><p>不就是「无锁 ==&gt; 偏向锁 ==&gt; 轻量级锁 ==&gt; 重量级锁 」吗？</p><p>你可能在很多地方看到过上面描述的锁升级过程,也能直接背下来。但你真的知道无锁、偏向锁、轻量级锁、重量级锁到底代表着什么吗？这些锁存储在哪里？以及什么情况下会使得锁向下一个 level 升级？</p><p>想知道答案,我们似乎必须先搞清楚 Java 内置锁,其内部结构是啥样的？内置锁又存放在哪里？</p><p>答案在开篇提到过——在 Java 对象中。</p><p>那么现在的问题就从「内置锁结构是啥」变成了「Java 对象长啥样」。</p><p> 对象结构<br>从宏观上看,Java 对象的结构很简单,分为三部分：</p><p>Java 对象结构</p><p>从微观上看,各个部分都还可以深入展开,详见下图：</p><p>Java 详细对象结构</p><p>接下来分别深入讨论一下这三部分。</p><p>对象头<br>从脑图中可以看出,其由 Mark Word、Class Pointer、数组长度三个字段组成。简单来说：</p><p>Mark Word：主要用于存储自身运行时数据<br>Class Pointer：是指针,指向方法区中该 class 的对象,JVM 通过此字段来判断当前对象是哪个类的实例<br>数组长度：当且仅当对象是数组时才会有该字段<br>Class Pointer 和数组长度没什么好说的,接下来重点聊聊 Mark Word。</p><p>Mark Word 所代表的「运行时数据」主要用来表示当前 Java 对象的线程锁状态以及 GC 的标志。而线程锁状态分别就是无锁、偏向锁、轻量级锁、重量级锁。</p><p>所以前文提到的这 4 个状态,其实就是 Java 内置锁的不同状态。</p><p>在 JDK 1.6 之前,内置锁都是重量级锁,效率低下。效率低下表现在</p><p>而在 JDK 1.6 之后为了提高 synchronized 的效率,才引入了偏向锁、轻量级锁。</p><p>随着锁竞争逐渐激烈,其状态会按照「无锁 ==&gt; 偏向锁 ==&gt; 轻量级锁 ==&gt; 重量级锁 」这个方向逐渐升级,并且不可逆,只能进行锁升级,而无法进行锁降级。</p><p>接下来我们思考一个问题,既然 Mark Word 可以表示 4 种不同的锁状态,其内部到底是怎么区分的呢？（由于目前主流的 JVM 都是 64 位,所以我们只讨论 64 位的 Mark Word）接下来我们通过图片直观的感受一下。</p><p>（1）无锁</p><p>无锁</p><p>这个可以理解为单线程很快乐的运行,没有其他的线程来和其竞争。</p><p>（2）偏向锁</p><p>偏向锁</p><p>首先,什么叫偏向锁？举个例子,一段同步的代码,一直只被线程 A 访问,既然没有其他的线程来竞争,每次都要获取锁岂不是浪费资源？所以这种情况下线程 A 就会自动进入偏向锁的状态。</p><p>后续线程 A 再次访问同步代码时,不需要做任何的 check,直接执行（对该线程的「偏爱」）,这样降低了获取锁的代价,提升了效率。</p><p>看到这里,你会发现无锁、偏向锁的 lock 标志位是一样的,即都是 01,这是因为无锁、偏向锁是靠字段 biased_lock 来区分的,0 代表没有使用偏向锁,1 代表启用了偏向锁。为什么要这么搞？你可以理解为无锁、偏向锁在本质上都可以理解为无锁（参考上面提到的线程 A 的状态）,所以 lock 的标志位都是 01 是没毛病的。</p><p>PS：这里的线程 ID 是持有当前对象偏向锁的线程</p><p>（3）轻量级锁</p><p>轻量级锁</p><p>但是,一旦有第二个线程参与竞争,就会立即膨胀为轻量级锁。企图抢占的线程一开始会使用自旋：</p><p>的方式去尝试获取锁。如果循环几次,其他的线程释放了锁,就不需要进行用户态到内核态的切换。虽然如此,但自旋需要占用很多 CPU 的资源（自行理解汽车空档疯狂踩油门）。如果另一个线程 一直不释放锁,难道它就在这一直空转下去吗？</p><p>当然不可能,JDK 1.7 之前是普通自旋,会设定一个最大的自旋次数,默认是 10 次,超过这个阈值就停止自旋。JDK 1.7 之后,引入了适应性自旋。简单来说就是：这次自旋获取到锁了,自旋的次数就会增加；这次自旋没拿到锁,自旋的次数就会减少。</p><p>（4）重量级锁</p><p>重量级锁</p><p>上面提到,试图抢占的线程自旋达到阈值,就会停止自旋,那么此时锁就会膨胀成重量级锁。当其膨胀成重量级锁后,其他竞争的线程进来就不会自旋了,而是直接阻塞等待,并且 Mark Word 中的内容会变成一个监视器（monitor）对象,用来统一管理排队的线程。</p><p>这个 monitor 对象,每个对象都会关联一个。monitor 对象本质上是一个同步机制,保证了同时只有一个线程能够进入临界区,在 HotSpot 的虚拟机中,是由 C++ 类 ObjectMonitor 实现的。</p><p>那么 monitor 对象具体是如何来管理线程的？接下来我们看几个 ObjectMonitor 类关键的属性：</p><p>ContentionQueue：是个队列,所有竞争锁的线程都会先进入这个队列中,可以理解为线程的统一入口,进入的线程会阻塞。<br>EntryList：ContentionQueue 中有资格的线程会被移动到这里,相当于进行一轮初筛,进入的线程会阻塞。<br>Owner：拥有当前 monitor 对象的线程,即 —— 持有锁的那个线程。<br>OnDeck：与 Owner 线程进行竞争的线程,同一时刻只会有一个 OnDeck 线程在竞争。<br>WaitSet：当 Owner 线程调用 wait()  方法被阻塞之后,会被放到这里。当其被唤醒之后,会重新进入 EntryList 当中,这个集合的线程都会阻塞。<br>Count：用于实现可重入锁,synchronized 是可重入的。<br>对象体<br>对象体包含了当前对象的字段和值,在业务中u l是较为核心的部分。</p><p>对齐字节<br>就是单纯用于填充的字节,没有其他的业务含义。其目的是为了保证对象所占用的内存大小为 8 的倍数,因为HotSpot VM 的内存管理要求对象的起始地址必须是 8 的倍数。</p><p> 锁升级<br>了解完  4 种锁状态之后,我们就可以整体的来看一下锁升级的过程了。<br>锁的详细升级过程<br>1.一开始对象是无锁状态的</p><p>2.一个线程尝试执行Synchronize代码块时,成功获得对象的锁,通过CAS操作往该对象markword中插入当前线程id, 同时修改偏向锁的标志位 。此时是偏向锁（偏向这个线程的锁,锁计数+1）,同一个线程可以重复进入该锁,锁计数+1,执行完毕会锁计数-1,直到锁计数复0,释放锁。</p><p>正是因为有记录线程id,所以Synchronized实现了可重入锁的逻辑（简单说就是一个锁的拥有者可以重复的获取自己的锁,而不会产生阻塞问题）<br>关于扫描时markword,可以去了解下对象在JVM中的结构,这里简单说明,每个对象都会有一个对象头markword,这块区域可以存放hashcode和锁信息以及GC信息</p><p>线程 A 进入 synchronized 开始抢锁,JVM 会判断当前是否是偏向锁的状态,如果是就会根据 Mark Word 中存储的线程 ID 来判断,当前线程 A 是否就是持有偏向锁的线程。如果是,则忽略 check,线程 A 直接执行临界区内的代码。</p><p>但如果 Mark Word 里的线程不是线程 A,就会通过自旋尝试获取锁,如果获取到了,就将 Mark Word 中的线程 ID 改为自己的；如果竞争失败,就会立马撤销偏向锁,膨胀为轻量级锁。</p><p>后续的竞争线程都会通过自旋来尝试获取锁,如果自旋成功那么锁的状态仍然是轻量级锁。然而如果竞争失败,锁会膨胀为重量级锁,后续等待的竞争的线程都会被阻塞。</p><p>无锁状态、偏向锁、轻量级锁、重量级锁 ,这是锁膨胀的过程,不可逆,但只有偏向锁可以变回无锁态。<br>转载博文：<br><a href="https://cloud.tencent.com/developer/article/2074879#:~:text=%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3%20Synchronized%20%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%201%20%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E9%94%81%E4%BD%8F%E5%BD%93%E5%89%8D%20class%EF%BC%8C%E4%BD%9C%E7%94%A8%E4%BA%8E%E8%AF%A5%20class,%E7%9A%84%E6%89%80%E6%9C%89%E5%AE%9E%E4%BE%8B%202%20%E4%BF%AE%E9%A5%B0%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E5%8F%AA%E4%BC%9A%E9%94%81%E4%BD%8F%E5%BD%93%E5%89%8D%20class%20%E7%9A%84%E5%AE%9E%E4%BE%8B%203%20%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%9A%E8%AF%A5%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E9%94%81%E4%BD%8F%E7%9A%84%E5%8D%B3%E8%AF%A5%E5%AF%B9%E8%B1%A1">https://cloud.tencent.com/developer/article/2074879#:~:text=%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3%20Synchronized%20%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%201%20%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E9%94%81%E4%BD%8F%E5%BD%93%E5%89%8D%20class%EF%BC%8C%E4%BD%9C%E7%94%A8%E4%BA%8E%E8%AF%A5%20class,%E7%9A%84%E6%89%80%E6%9C%89%E5%AE%9E%E4%BE%8B%202%20%E4%BF%AE%E9%A5%B0%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E5%8F%AA%E4%BC%9A%E9%94%81%E4%BD%8F%E5%BD%93%E5%89%8D%20class%20%E7%9A%84%E5%AE%9E%E4%BE%8B%203%20%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%9A%E8%AF%A5%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E9%94%81%E4%BD%8F%E7%9A%84%E5%8D%B3%E8%AF%A5%E5%AF%B9%E8%B1%A1</a><br>锁优化篇：<br>JDK1.6引入了大量的优化,如：自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁。锁主要存在四中状态,依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态,他们会随着竞争的激烈而逐渐升级。但是有一点,不可以进行锁降级</p><p>一、自旋锁：<br>线程频繁的阻塞和唤醒对CPU来说是一件负担很重的工作,会给系统带来很大的压力。同时很多锁状态只会持续很短一段时间,为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。  所谓自旋锁,就是让该线程等待一段时间,不会被立即挂起,看持有锁的线程是否会很快释放锁,如果释放了,就可以抢到锁。那怎么等待呢？其实就是执行一段无意义的循环,大家是不是瞬间觉得好low,原来就是执行一段for循环,别急着下结论,我们继续来分析</p><p>执行一段无意义的循环。如果持有锁的线程很快就释放了锁,那么自旋的效率就非常好。但是如果自旋很久都没抢到锁,那自旋就是浪费资源,说的难听点就是占着茅坑不拉屎。所以说,自旋等待的时间或者次数必须要有一个限度,如果超过了定义的时间仍然没有获取到锁,则把它挂起。</p><p>自旋锁在JDK 1.4.2中引入,默认关闭,但是可以使用-XX:+UseSpinning开启,在JDK1.6中默认开启。同时自旋的默认次数为10次,可以通过参数-XX:PreBlockSpin来调整；但是无论你怎么调整这些参数,都无法满足不可预知的情况。于是JDK1.6引入自适应的自旋锁,让虚拟机会变得越来越聪明。</p><p>二、适应自旋锁<br>JDK 1.6引入了更加聪明的自旋锁,叫做自适应自旋锁。他的自旋次数是会变的,我用大白话来讲一下,就是线程如果上次自旋成功了,那么这次自旋的次数会更加多,因为虚拟机认为既然上次成功了,那么这次自旋也很有可能会再次成功。反之,如果某个锁很少有自旋成功,那么以后的自旋的次数会减少甚至省略掉自旋过程,以免浪费处理器资源。大家现在觉得没这么low了吧</p><p>三、锁消除<br>锁消除用大白话来讲,就是在一段程序里你用了锁,但是jvm检测到这段程序里不存在共享数据竞争问题,也就是变量没有逃逸出方法外,这个时候jvm就会把这个锁消除掉</p><p>我们程序员写代码的时候自然是知道哪里需要上锁,哪里不需要,但是有时候我们虽然没有显示使用锁,但是我们不小心使了一些线程安全的API时,如StringBuffer、Vector、HashTable等,这个时候会隐形的加锁。比如下段代码</p><p>复制<br>public void sbTest(){<br>        StringBuffer sb= new StringBuffer();<br>        for(int i = 0 ; i &lt; 10 ; i++){<br>            sb.append(i);<br>        }<br>        System.out.println(sb.toString());<br>    }<br>复制<br>复制<br>上面这段代码,JVM可以明显检测到变量sb没有逃逸出方法sbTest()之外,所以JVM可以大胆地将sbTest内部的加锁操作消除。</p><p> 四、锁粗化<br>众所周知在使用锁的时候,要让锁的作用范围尽量的小,这样是为了在锁内执行代码尽可能少,缩短持有锁的时间,其他等待锁的线程能尽快拿到锁。在大多数的情况下这样做是正确的。但是连续加锁解锁操作,可能会导致不必要的性能损耗,比如下面这个for循环：</p><p>锁粗化前：<br>for (…) {<br>  synchronized (obj) {<br>    // 一些操作<br>  }<br>}<br>锁粗化后：<br>synchronized (this) {<br> for (…) {<br>   // 一些操作<br> }<br>}<br>复制<br>复制<br>大家应该能看出锁粗化大概是什么意思了。就是将多个连续的加锁、解锁操作连接在一起,扩展成一个范围更大的锁。即加锁解锁操作会移到for循环之外。</p><p>五、偏向锁<br>当我们创建一个对象时,该对象的部分Markword关键数据如下。</p><p>bit fields</p><p>是否偏向锁</p><p>锁标志位</p><p>hash</p><p>0</p><p>01</p><p>从图中可以看出,偏向锁的标志位是“01”,状态是“0”,表示该对象还没有被加上偏向锁。（“1”是表示被加上偏向锁）。该对象被创建出来的那一刻,就有了偏向锁的标志位,这也说明了所有对象都是可偏向的,但所有对象的状态都为“0”,也同时说明所有被创建的对象的偏向锁并没有生效。</p><p>不过,当线程执行到临界区（critical section）时,此时会利用CAS(Compare and Swap)操作,将线程ID插入到Markword中,同时修改偏向锁的标志位。</p><p>所谓临界区,就是只允许一个线程进去执行操作的区域,即同步代码块。CAS是一个原子性操作</p><p>此时的Mark word的结构信息如下：</p><p>bit fields</p><p>是否偏向锁</p><p>锁标志位</p><p>threadId</p><p>epoch</p><p>1</p><p>01</p><p>此时偏向锁的状态为“1”,说明对象的偏向锁生效了,同时也可以看到,哪个线程获得了该对象的锁。</p><p>偏向锁是jdk1.6引入的一项锁优化,其中的“偏”是偏心的偏。它的意思就是说,这个锁会偏向于第一个获得它的线程,在接下来的执行过程中,假如该锁没有被其他线程所获取,没有其他线程来竞争该锁,那么持有偏向锁的线程将永远不需要进行同步操作。也就是说:在此线程之后的执行过程中,如果再次进入或者退出同一段同步块代码,并不再需要去进行加锁或者解锁操作,而是会做以下的步骤：</p><p>Load-and-test,也就是简单判断一下当前线程id是否与Markword当中的线程id是否一致.<br>如果一致,则说明此线程已经成功获得了锁,继续执行下面的代码.<br>如果不一致,则要检查一下对象是否还是可偏向,即“是否偏向锁”标志位的值。<br>如果还未偏向,则利用CAS操作来竞争锁,也即是第一次获取锁时的操作。<br>释放锁 偏向锁的释放采用了一种只有竞争才会释放锁的机制,线程是不会主动去释放偏向锁,需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><p>暂停拥有偏向锁的线程,判断锁对象石是否还处于被锁定状态；<br>撤销偏向锁,恢复到无锁状态或者轻量级锁的状态；<br>安全点会导致stw（stop the word）,导致性能下降,这种情况下应当禁用； </p><p>查看停顿–安全点停顿日志</p><p>要查看安全点停顿,可以打开安全点日志,通过设置JVM参数 -</p><p>XX:+PrintGCApplicationStoppedTime 会打出系统停止的时间,</p><p>添加-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 这两个参数会打印出详细信息,可以查看到使用偏向锁导致的停顿,时间非常短暂,但是争用严重的情况下,停顿次数也会非常多；</p><p>注意：安全点日志不能一直打开： </p><ol><li>安全点日志默认输出到stdout,一是stdout日志的整洁性,二是stdout所重定向的文件如果不在/dev/shm,可能被锁。 </li><li>对于一些很短的停顿,比如取消偏向锁,打印的消耗比停顿本身还大。 </li><li>安全点日志是在安全点内打印的,本身加大了安全点的停顿时间。</li></ol><p>所以安全日志应该只在问题排查时打开。<br>如果在生产系统上要打开,再再增加下面四个参数：<br>-XX:+UnlockDiagnosticVMOptions -XX: -DisplayVMOutput -XX:+LogVMOutput -XX:LogFile=/dev/shm/vm.log<br>打开Diagnostic（只是开放了更多的flag可选,不会主动激活某个flag）,关掉输出VM日志到stdout,输出到独立文件,/dev/shm目录（内存文件系统）。</p><p>此日志分三部分：<br>第一部分是时间戳,VM Operation的类型 </p><p>第二部分是线程概况,被中括号括起来 </p><p>total: 安全点里的总线程数<br>initially_running: 安全点时开始时正在运行状态的线程数<br>wait_to_block: 在VM Operation开始前需要等待其暂停的线程数</p><p>第三部分是到达安全点时的各个阶段以及执行操作所花的时间,其中最重要的是vmop</p><p>spin: 等待线程响应safepoint号召的时间；<br>block: 暂停所有线程所用的时间；<br>sync: 等于 spin+block,这是从开始到进入安全点所耗的时间,可用于判断进入安全点耗时；<br>cleanup: 清理所用时间；<br>vmop: 真正执行VM Operation的时间。<br>可见,那些很多但又很短的安全点,全都是RevokeBias, 高并发的应用会禁用掉偏向锁。</p><p>jvm开启/关闭偏向锁</p><p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0<br>关闭偏向锁：-XX:-UseBiasedLocking</p><p>六、轻量级锁<br>自旋锁的目标是降低线程切换的成本。如果锁竞争激烈,我们不得不依赖于重量级锁,让竞争失败的线程阻塞；如果完全没有实际的锁竞争,那么申请重量级锁都是浪费的。轻量级锁的目标是,减少无实际竞争情况下,使用重量级锁产生的性能消耗,包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。</p><p>顾名思义,轻量级锁是相对于重量级锁而言的。使用轻量级锁时,不需要申请互斥量,仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record（Lock Record：JVM检测到当前对象是无锁状态,则会在当前线程的栈帧中创建一个名为LOCKRECOD表空间用于copy Mark word 中的数据）,如果更新成功,则轻量级锁获取成功,记录锁状态为轻量级锁；否则,说明已经有线程获得了轻量级锁,目前发生了锁竞争（不适合继续使用轻量级锁）,接下来膨胀为重量级锁。</p><p>当然,由于轻量级锁天然瞄准不存在锁竞争的场景,如果存在锁竞争但不激烈,仍然可以用自旋锁优化,自旋失败后再膨胀为重量级锁。</p><p>缺点：同自旋锁相似：如果锁竞争激烈,那么轻量级将很快膨胀为重量级锁,那么维持轻量级锁的过程就成了浪费。</p><p>七、重量级锁<br>        轻量级锁膨胀之后,就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的,而monitor又依赖操作系统的MutexLock(互斥锁)来实现的,所以重量级锁也被成为互斥锁。<br>当轻量级所经过锁撤销等步骤升级为重量级锁之后,它的Markword部分数据大体如下</p><p>bit fields</p><p>锁标志位</p><p>指向Mutex的指针</p><p>10</p><p>为什么说重量级锁开销大呢</p><p>主要是,当系统检查到锁是重量级锁之后,会把等待想要获得锁的线程进行阻塞,被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时,都需要操作系统来帮忙,这就需要从用户态转换到内核态,而转换状态是需要消耗很多时间的,有可能比用户执行代码的时间还要长。<br>这就是说为什么重量级线程开销很大的。</p><p>互斥锁(重量级锁)也称为阻塞同步、悲观锁</p><p>八、总结<br>        偏向所锁,轻量级锁都是乐观锁,重量级锁是悲观锁。</p><pre><code>    一个对象刚开始实例化的时候,没有任何线程来访问它的时候。它是可偏向的,意味着,它现在认为只可能有一个线程来访问它,所以当第一个</code></pre><p>线程来访问它的时候,它会偏向这个线程,此时,对象持有偏向锁。偏向第一个线程,这个线程在修改对象头成为偏向锁的时候使用CAS操作,并将<br>对象头中的ThreadID改成自己的ID,之后再次访问这个对象时,只需要对比ID,不需要再使用CAS在进行操作。</p><pre><code>    一旦有第二个线程访问这个对象,因为偏向锁不会主动释放,所以第二个线程可以看到对象时偏向状态,这时表明在这个对象上已经存在竞争了,检查原来持有该对象锁的线程是否依然存活,如果挂了,则可以将对象变为无锁状态,然后重新偏向新的线程,如果原来的线程依然存活,则马上执行那个线程的操作栈,检查该对象的使用情况,如果仍然需要持有偏向锁,则偏向锁升级为轻量级锁,（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了,则可以将对象回复成无锁状态,然后重新偏向。    轻量级锁认为竞争存在,但是竞争的程度很轻,一般两个线程对于同一个锁的操作都会错开,或者说稍微等待一下（自旋）,另一个线程就会释放锁。但是当自旋超过一定的次数,或者一个线程在持有锁,一个在自旋,又有第三个来访时,轻量级锁膨胀为重量级锁,重量级锁使除了拥有锁的线程以外的线程都阻塞,防止CPU空转。</code></pre><p>转载博文：<a href="https://cloud.tencent.com/developer/article/1698812?from=article.detail.2019347">https://cloud.tencent.com/developer/article/1698812?from=article.detail.2019347</a></p><h2 id="Mysql-json数据查询"><a href="#Mysql-json数据查询" class="headerlink" title="Mysql json数据查询"></a>Mysql json数据查询</h2><p>1、使用 字段-&gt;’$.json属性’ 进行查询条件</p><p>2、使用 json_extract 函数查询,json_extract(字段, “$.json属性”)</p><p>3、根据json数组查询,用 JSON_CONTAINS(字段, JSON_OBJECT(‘json属性’, “内容”))</p><p>举例：</p><p>SELECT * from<br>test<br>– WHERE attributes -&gt; ‘$.orderInviteCode.inviterUserId’ = 310000000780<br>– WHERE json_extract(attributes, “$.orderInviteCode.inviterUserId”) = 310000000780</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>Thread类有7个基本构造函数,当指定线程执行顺序时,可调用start方法,然后调用join方法,其中join的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       join(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ↓</span><br><span class="line">↓</span><br><span class="line">↓</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">               wait(<span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">               <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">               <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               wait(delay);</span><br><span class="line">               now = System.currentTimeMillis() - base;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>java无法销毁一个线程,但是当调用isAlive方法时,返回false则已销毁<br>为什么放弃了stop方法？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">this</span> method is inherently unsafe.  Stopping a thread with</span><br><span class="line">     *       Thread.stop causes it to unlock all of the monitors that it</span><br><span class="line">     *       <span class="function">has <span class="title">locked</span> <span class="params">(as a natural consequence of the unchecked</span></span></span><br><span class="line"><span class="params"><span class="function">     *       &#123;<span class="meta">@code</span> ThreadDeath&#125; exception propagating up the stack)</span>.  If</span></span><br><span class="line"><span class="function">     *       any of the objects previously <span class="keyword">protected</span> by these monitors were in</span></span><br><span class="line"><span class="function">     *       an inconsistent state, the damaged objects become visible to</span></span><br><span class="line"><span class="function">     *       other threads, potentially resulting in arbitrary behavior.  Many</span></span><br><span class="line"><span class="function">     *       uses of </span>&#123;<span class="meta">@code</span> stop&#125; should be replaced by code that simply</span><br><span class="line">     *       modifies some variable to indicate that the target thread should</span><br><span class="line">     *       stop running.  The target thread should check <span class="keyword">this</span> variable</span><br><span class="line">     *       regularly, and <span class="keyword">return</span> from its run method in an orderly fashion</span><br><span class="line">     *       <span class="keyword">if</span> the variable indicates that it is to stop running.  If the</span><br><span class="line">     *       <span class="function">target thread waits <span class="keyword">for</span> <span class="keyword">long</span> <span class="title">periods</span> <span class="params">(on a condition variable,</span></span></span><br><span class="line"><span class="params"><span class="function">     *       <span class="keyword">for</span> example)</span>, the </span>&#123;<span class="meta">@code</span> interrupt&#125; method should be used to</span><br><span class="line">     *       interrupt the wait.</span><br><span class="line">     *       For more information, see</span><br><span class="line">     *       &lt;a href=<span class="string">&quot;&#123;@docRoot&#125;/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;</span>&gt;Why</span><br><span class="line">     *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.</span><br><span class="line">防止死锁ddd</span><br><span class="line">所以已经在<span class="number">1.2</span>就过期了</span><br></pre></td></tr></table></figure><p>说明Thread interrupt（）  isinterrupted（）interrupted 的区别和含义<br>Thread.interrupt()   设置状态<br>isInterrupted()    判断 返回Boolean<br>interrupted 即判断又清除</p><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先是一个<span class="keyword">native</span>方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>向调度程序提示当前线程愿意让步,使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择,也就是说,当前也就是刚刚的那个线程还是有可能会被再次执行到的,并不是说一定会执行其他线程而该线程在下一次中不会执行到了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Service-和-Component-注解的差别？&quot;&gt;&lt;a href=&quot;#Service-和-Component-注解的差别？&quot; class=&quot;headerlink&quot; title=&quot;@Service 和@Component 注解的差别？&quot;&gt;&lt;/a&gt;@Servic</summary>
      
    
    
    
    
    <category term="面试" scheme="https://zkkget.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture</title>
    <link href="https://zkkget.github.io/posts/20220728cl89v5wvc0003t4uj69rx76nq.html"/>
    <id>https://zkkget.github.io/posts/20220728cl89v5wvc0003t4uj69rx76nq.html</id>
    <published>2022-07-28T02:44:05.000Z</published>
    <updated>2022-09-05T02:55:53.648Z</updated>
    
    <content type="html"><![CDATA[<p>想学习CompletableFuture，因此查询资料发现<br>CompletableFuture是JDK8中的新特性，主要用于对JDK5中加入的Future的补充。<br>CompletableFuture实现了CompletionStage和Future接口。<br>需要先了解Future接口<br>什么是Future？<br>简单来说future就是一个Future对象，当执行return await。。。的时候，实际上返回的是一个延迟计算的Future对象，这个Future对象是Dart内置的，有自己的队列策略，它将要操作的事件放入EventQueue中，在队列中的事件按照先进先出的原则去逐一处理事件，当事件处理完成后，将结果返回给Future对象。</p><p>在这个过程中涉及到了异步和等待：</p><p>异步：就是不用阻塞当前线程，来等待该线程任务处理完成再去执行其他任务。<br>等待：await，声明运算为延迟执行<br>async和await<br>首先看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getData() async&#123;</span><br><span class="line">   return await http.get(Uri.encodeFull(url), headers: &#123;&quot;Accept&quot;: &quot;application/json&quot;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">//然后调用函数来获取结果</span><br><span class="line">String data = getData();</span><br></pre></td></tr></table></figure><p>这段代码在运行的时候会报错。<br>因为data是String类型，而函数getData()是一个异步操作函数，其返回值是一个await延迟执行的结果。<br>在Dart中，有await标记的运算，结果都是一个Future对象，Future不是String类型，所以就报错了。<br>如何获取异步函数的结果呢？Dart规定有async标记的函数，只能由await来调用，那么我们可以在函数前加一个await关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String data;</span><br><span class="line">setData() async &#123;</span><br><span class="line">  data = <span class="function">await <span class="title">getData</span><span class="params">()</span></span>;    <span class="comment">//getData()延迟执行后赋值给data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async和await的使用其实就只有两点：</p><p>await关键字必须在async函数内部使用<br>调用async函数必须使用await关键字</p><p>Dart(释义：镖)异步<br>Dart是单线程模型，是一种Event-Looper以及Event-Queue的模型，所有的事件都是通过EventLooper的依次执行。</p><p>Event-Looper与Netty的NioEventLoopGroup异曲同工，都是线程模型</p><p>作者：zhaoolee<br>链接：<a href="https://www.jianshu.com/p/aefd0e50b802">https://www.jianshu.com/p/aefd0e50b802</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>单线程模型<br>所谓单线程，就是一旦一个函数开始执行，就必须将这个函数执行完，才能去执行其他函数</p><p>作者：MakerChin<br>链接：<a href="https://www.jianshu.com/p/890df7ea8f87">https://www.jianshu.com/p/890df7ea8f87</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>Future接口的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//取消任务。参数:是否立即中断任务执行，或者等等任务结束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//任务是否已经取消，若已取消，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//任务是否已经完成。包括任务正常完成、抛出异常或被取消，都返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*等待任务执行结束，获得V类型的结果。InterruptedException: 线程被中断异常， ExecutionException: 任务执行异常，如果任务被取消，还会抛出CancellationException*/</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计算超时，将抛出TimeoutException*/</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用不带参数的get方法的调用被阻塞，直到计算完成。如果在计算完成之前，调用带参get()方法超时时，会抛出TimeoutException异常。若运行该计算的线程被中断，两种get()方法都会抛出InterruptedException。如果计算已经完成，那么get方法立即返回。<br>若计算还在进行，isDone方法返回false；如果完成了，则返回true。<br>调用cancel()时，若计算还没有开始，它被取消且不再开始。若计算处于运行之中，那么如果mayInterrupt参数为true，它就被中断。<br>相比future.get()，其实更推荐使用get (long timeout, TimeUnit unit) 方法，因为设置了超时时间可以防止程序无限制的等待future的返回结果。<br>FutureTask源码解析<br>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="comment">//状态为NEW</span></span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实际上Callable = Runnable + result，继续看上面的第二个构造方法，看看Executors.callable(runnable, result)的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//new了一个RunnableAdapter,返回Callable,说明RunnableAdapter实现了Callable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>状态值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//初始化状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//正在执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//正常完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//出现异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//正被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//已被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>FutureTask的run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*compareAndSwapObject(this, runnerOffset,]null, Thread.currentThread()))</span></span><br><span class="line"><span class="comment">         其中第一个参数为需要改变的对象，第二个为偏移量，第三个参数为期待的值，第四个为更新后的值。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//call()方法是由FutureTask调用的,说明call()不是异步执行的</span></span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//设置异常</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// NEW -&gt; COMPLETING</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            <span class="comment">//返回结果,也包括异常</span></span><br><span class="line">            outcome = v;</span><br><span class="line">            <span class="comment">//COMPLETING -&gt; NORMAL</span></span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">            <span class="comment">//唤醒等待的线程</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//是否是未完成状态,是则等待</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            <span class="comment">//等待过程</span></span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/itcats_cn/article/details/81322122">https://blog.csdn.net/itcats_cn/article/details/81322122</a></p><p>CompletableFuture类的官方API文档解释：</p><p>CompletableFuture是一个在完成时可以触发相关方法和操作的Future，并且它可以视作为CompletableStage。<br>除了直接操作状态和结果的这些方法和相关方法外（CompletableFuture API提供的方法），CompletableFuture还实现了以下的CompletionStage的相关策略：<br>① 非异步方法的完成，可以由当前CompletableFuture的线程提供，也可以由其他调用完方法的线程提供。<br>② 所有没有显示使用Executor的异步方法，会使用ForkJoinPool.commonPool()（那些并行度小于2的任务会创建一个新线程来运行）。为了简化监视、调试和跟踪异步方法，所有异步任务都被标记为CompletableFuture.AsynchronouseCompletionTask。<br>③ 所有CompletionStage方法都是独立于其他公共方法实现的，因此一个方法的行为不受子类中其他方法的覆盖影响。<br>CompletableFuture还实现了Future的以下策略<br>① 不像FutureTask，因CompletableFuture无法直接控制计算任务的完成，所以CompletableFuture的取消会被视为异常完成。调用cancel()方法会和调用completeExceptionally（）方法一样，具有同样的效果。isCompletedEceptionally()方法可以判断CompletableFuture是否是异常完成。<br>② 在调用get()和get(long, TimeUnit)方法时以异常的形式完成，则会抛出ExecutionException,大多数情况下都会使用join()和getNow(T)，它们会抛出CompletionException。<br>小结：</p><p>Concurrent包中的Future在获取结果时会发生阻塞，而CompletableFuture则不会，它可以通过触发异步方法来获取结果。<br>在CompletableFuture中，如果没有显示指定的Executor的参数，则会调用默认的ForkJoinPool.commonPool()。<br>调用CompletableFuture的cancel()方法和调用completeExceptionally()方法的效果一样。<br>在JDK5中，使用Future来获取结果时都非常的不方便，只能通过get()方法阻塞线程或者通过轮询isDone()的方式来获取任务结果，这种阻塞或轮询的方式会无畏的消耗CPU资源，而且还不能及时的获取任务结果，因此JDK8中提供了CompletableFuture来实现异步的获取任务结果。</p><p>使用下CompletableFuture的API<br>CompletableFuture类提供了非常多的方法供我们使用，包括了runAsync()、supplyAsync()、thenAccept()等方法。<br>runAsync()，异步运行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAsyncExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, executorService);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cf.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CompletedFuture...isDown&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">CompletedFuture…isDown</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里调用的runAsync()方法没有使用ForkJoinPool的线程，而是使用了Executors.newSingleThreadExecutor()中的线程。runAsync()其实效果跟单开一个线程一样。<br>supplyAsync()</p><p>supply有供应的意思，supplyAsync就可以理解为异步供应，查看supplyAsync()方法入参可以知道，其有两个入参：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier supplier,</span><br><span class="line">Executor executor</span><br></pre></td></tr></table></figure><p>这里先简单介绍下Supplier接口，Supplier接口是JDK8引入的新特性，它也是用于创建对象的，只不过调用Supplier的get()方法时，才会去通过构造方法去创建对象，并且每次创建出的对象都不一样。Supplier常用语法为：Supplier<MySupplier> sup= MySupplier::new;<br>再展示代码例子之前，再讲一个thenAccept()方法，可以发现thenAccept()方法的入参如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comsumer&lt;? super T&gt;</span><br><span class="line">Comsumer接口同样是java8新引入的特性，它有两个重要接口方法：</span><br><span class="line"></span><br><span class="line">accept()</span><br><span class="line">andThen()</span><br><span class="line">thenAccept()可以理解为接收CompletableFuture的结果然后再进行处理。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面看下supplyAsync()和thenAccept()的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void thenApply() throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(2);</span><br><span class="line">        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123; //实现了Supplier的get()方法</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;supplyAsync &quot; + Thread.currentThread().getName());</span><br><span class="line">            return &quot;hello &quot;;</span><br><span class="line">        &#125;,executorService).thenAccept(s -&gt; &#123; //实现了Comsumper的accept()方法</span><br><span class="line">            try &#123;</span><br><span class="line">                thenApply_test(s + &quot;world&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (cf.isDone()) &#123;</span><br><span class="line">                System.out.println(&quot;CompletedFuture...isDown&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">supplyAsync pool-1-thread-1</span><br><span class="line">thenApply_test hello world</span><br><span class="line">thenApply_test pool-1-thread-1</span><br></pre></td></tr></table></figure><p>从代码逻辑可以看出，thenApply_test等到了pool-1-thread-1线程完成任务后，才进行的调用，并且拿到了supplye()方法返回的结果，而main则异步执行了，这就避免了Future获取结果时需要阻塞或轮询的弊端。<br>exceptionally<br>当任务在执行过程中报错了咋办？exceptionally()方法很好的解决了这个问题，当报错时会去调用exceptionally()方法，它的入参为：Function&lt;Throwable, ? extends T&gt; fn，fn为执行任务报错时的回调方法，下面看看代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void exceptionally() &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if (1 == 1) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;测试exceptionally...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;s1&quot;;</span><br><span class="line">        &#125;, executorService).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            return &quot;helloworld &quot; + e.getMessage();</span><br><span class="line">        &#125;);</span><br><span class="line">        cf.thenAcceptAsync(s -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;thenAcceptAsync: &quot; + s);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;main: &quot; + Thread.currentThread().getName());</span><br><span class="line">        while (true) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main: main</span><br><span class="line">java.lang.RuntimeException: 测试exceptionally…</span><br><span class="line">CompletableFuture is Down…helloworld java.lang.RuntimeException: 测试exceptionally…</span><br><span class="line">thenAcceptAsync: helloworld java.lang.RuntimeException: 测试exceptionally…</span><br></pre></td></tr></table></figure><p>从代码以及运行结果来看，当任务执行过程中报错时会执行exceptionally()中的代码，thenAcceptAsync()会获取抛出的异常并输出到控制台，不管CompletableFuture()执行过程中报错、正常完成、还是取消，都会被标示为已完成，所以最后CompletableFuture.isDown()为true。</p><p>在Java8中，新增的ForkJoinPool.commonPool()方法，这个方法可以获得一个公共的ForkJoin线程池，这个公共线程池中的所有线程都是Daemon线程，意味着如果主线程退出，这些线程无论是否执行完毕，都会退出系统。</p><p>2.3 源码分析<br>CompletableFuture类实现了Future接口和CompletionStage接口，Future大家都经常遇到，但是这个CompletionStage接口就有点陌生了，这里的CompletionStage实际上是一个任务执行的一个“阶段”，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; &#123;</span><br><span class="line">volatile Object result;       // CompletableFuture的结果值或者是一个异常的报装对象AltResult</span><br><span class="line">    volatile Completion stack;    // 依赖操作栈的栈顶</span><br><span class="line">    ...</span><br><span class="line">    // CompletableFuture的方法</span><br><span class="line">    ... </span><br><span class="line">// Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">    private static final long RESULT;</span><br><span class="line">    private static final long STACK;</span><br><span class="line">    private static final long NEXT;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            final sun.misc.Unsafe u;</span><br><span class="line">            UNSAFE = u = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = CompletableFuture.class;</span><br><span class="line">            RESULT = u.objectFieldOffset(k.getDeclaredField(&quot;result&quot;)); //计算result属性的位偏移量</span><br><span class="line">            STACK = u.objectFieldOffset(k.getDeclaredField(&quot;stack&quot;)); //计算stack属性的位偏移量</span><br><span class="line">            NEXT = u.objectFieldOffset </span><br><span class="line">                (Completion.class.getDeclaredField(&quot;next&quot;));  //计算next属性的位偏移量</span><br><span class="line">        &#125; catch (Exception x) &#123;</span><br><span class="line">            throw new Error(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CompletableFuture中有一个静态代码块，在CompletableFuture类初始化之前就进行调用，代码块里的内容就是通过Unsafe类去获取CompletableFuture的result、stack和next属性的“偏移量”，这个偏移量主要用于Unsafe的CAS操作时进行位移量的比较。<br>runAsync(Runnable, Executor) &amp; runAsync(Runnable)<br>runAsync()做的事情就是异步的执行任务，返回的是CompletableFuture对象，不过CompletableFuture对象不包含结果。runAsync()方法有两个重载方法，这两个重载方法的区别是Executor可以指定为自己想要使用的线程池，而runAsync(Runnable)则使用的是ForkJoinPool.commonPool()。</p><p>下面先来看看runAsync(Runnable)的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) &#123;</span><br><span class="line">       return asyncRunStage(asyncPool, runnable);</span><br><span class="line">   &#125;</span><br><span class="line">这里的asyncPool是一个静态的成员变量：</span><br></pre></td></tr></table></figure><p>private static final boolean useCommonPool =<br>        (ForkJoinPool.getCommonPoolParallelism() &gt; 1); // 并行级别<br>private static final Executor asyncPool = useCommonPool ?<br>    ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();<br>回到asyncRunStage()源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static CompletableFuture&lt;Void&gt; asyncRunStage(Executor e, Runnable f) &#123;</span><br><span class="line">       if (f == null) throw new NullPointerException();</span><br><span class="line">       CompletableFuture&lt;Void&gt; d = new CompletableFuture&lt;Void&gt;();</span><br><span class="line">       e.execute(new AsyncRun(d, f));</span><br><span class="line">       return d;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看到asyncRunStage()源码，可以知道任务是由Executor来执行的，那么可想而知Async类一定是实现了Callable接口或者继承了Runnable类，查看Async类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static final class AsyncRun extends ForkJoinTask&lt;Void&gt;</span><br><span class="line">            implements Runnable, AsynchronousCompletionTask &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; dep; Runnable fn;</span><br><span class="line">        AsyncRun(CompletableFuture&lt;Void&gt; dep, Runnable fn) &#123;</span><br><span class="line">            this.dep = dep; this.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final Void getRawResult() &#123; return null; &#125;</span><br><span class="line">        public final void setRawResult(Void v) &#123;&#125;</span><br><span class="line">        public final boolean exec() &#123; run(); return true; &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            CompletableFuture&lt;Void&gt; d; Runnable f;</span><br><span class="line">            if ((d = dep) != null &amp;&amp; (f = fn) != null) &#123;</span><br><span class="line">                dep = null; fn = null;//释放掉内存</span><br><span class="line">                if (d.result == null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        f.run();</span><br><span class="line">                        d.completeNull();</span><br><span class="line">                    &#125; catch (Throwable ex) &#123;</span><br><span class="line">                        d.completeThrowable(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d.postComplete(); // 任务结束后，会执行所有依赖此任务的其他任务，这些任务以一个无锁并发栈的形式存在</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在AsyncRun类中，实现了Runnable接口的run()方法，在run()方法内部，会调用传进来的Runnable对象的run()方法，这里就需要用户自己去实现了，上文中的实例代码就是通过Lambda表达式来实现了Runnable接口。调用了f.run()之后，然后就是completeNull()方法了，该方法底层通过调用UNSAFE类的compareAndSwapObject()方法，来以CAS的方式将CompletableFuture的结果赋为null。postComplete()就是任务结束后，会执行所有依赖此任务的其他任务，这些任务以一个无锁并发栈的形式存在。<br>postComplete()的源码还是有点复杂的，先不急着分析。先看看Completion这个抽象类的数据结构组成：</p><p>Completion<br>下面先看看Completion的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如果触发，则执行完成操作，返回可能需要传播的依赖项（如果存在）。</span><br><span class="line">@param mode SYNC, ASYNC, or NESTED</span><br><span class="line">abstract static class Completion extends ForkJoinTask&lt;Void&gt;</span><br><span class="line">        implements Runnable, AsynchronousCompletionTask &#123;</span><br><span class="line">        volatile Completion next;      </span><br><span class="line">        abstract CompletableFuture&lt;?&gt; tryFire(int mode);</span><br><span class="line">        abstract boolean isLive();</span><br><span class="line"></span><br><span class="line">        public final void run()                &#123; tryFire(ASYNC); &#125;</span><br><span class="line">        public final boolean exec()            &#123; tryFire(ASYNC); return true; &#125;</span><br><span class="line">        public final Void getRawResult()       &#123; return null; &#125;</span><br><span class="line">        public final void setRawResult(Void v) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Completion是一个抽象类，分别实现了Runnable、AsynchronousCompletionTask接口，继承了ForkJoinPoolTask类，而ForJoinPoolTask抽象类又实现了Future接口，因此Completion实际上就是一个Future。可以看到Completion的抽象方法和成员方法的实现逻辑都短短一行或者没有，可以猜到这些方法的实现都是在其子类中。其实现类包括了UniCompletion、BiCompletion、UniAccept、BiAccept等，如下图：<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Completion.jpg" alt="流程"></p><p>而Completion类中还有一个非常重要的成员属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile Completion next;</span><br></pre></td></tr></table></figure><p>有印象的读者应该能记得，CompletableFuture中有一个属性——stack，就是Completion类的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile Completion stack;</span><br></pre></td></tr></table></figure><p>由这个属性可以看出，CompletableFuture其实就是一个链表的一个数据结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">abstract static class UniCompletion&lt;T,V&gt; extends Completion &#123;</span><br><span class="line">        Executor executor;                 // executor to use (null if none)</span><br><span class="line">        CompletableFuture&lt;V&gt; dep;          // 代表的依赖的CompletableFuture</span><br><span class="line">        CompletableFuture&lt;T&gt; src;          // 代表的是源CompletableFuture</span><br><span class="line"></span><br><span class="line">        UniCompletion(Executor executor, CompletableFuture&lt;V&gt; dep,</span><br><span class="line">                      CompletableFuture&lt;T&gt; src) &#123;</span><br><span class="line">            this.executor = executor; this.dep = dep; this.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * 确保当前Completion可以被调用；并且使用ForkJoinPool标记为来确保只有一个线程可以调用，</span><br><span class="line">         * 如果是异步的，则在任务启动之后通过tryFire来进行调用。tryFire方法时在UniAccept类中。</span><br><span class="line">         */</span><br><span class="line">        final boolean claim() &#123;</span><br><span class="line">            Executor e = executor;</span><br><span class="line">            if (compareAndSetForkJoinTaskTag((short)0, (short)1)) &#123;</span><br><span class="line">                if (e == null)</span><br><span class="line">                    return true;</span><br><span class="line">                executor = null; // disable</span><br><span class="line">                e.execute(this);</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean isLive() &#123; return dep != null; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>claim方法要在执行action前调用，若claim方法返回false，则不能调用action，原则上要保证action只执行一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static final class UniAccept&lt;T&gt; extends UniCompletion&lt;T,Void&gt; &#123;</span><br><span class="line">        Consumer&lt;? super T&gt; fn;</span><br><span class="line">        UniAccept(Executor executor, CompletableFuture&lt;Void&gt; dep,</span><br><span class="line">                  CompletableFuture&lt;T&gt; src, Consumer&lt;? super T&gt; fn) &#123;</span><br><span class="line">            super(executor, dep, src); this.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 尝试去调用当前任务。uniAccept()方法为核心逻辑。</span><br><span class="line">         */</span><br><span class="line">        final CompletableFuture&lt;Void&gt; tryFire(int mode) &#123;</span><br><span class="line">            CompletableFuture&lt;Void&gt; d; CompletableFuture&lt;T&gt; a;</span><br><span class="line">            if ((d = dep) == null ||</span><br><span class="line">                !d.uniAccept(a = src, fn, mode &gt; 0 ? null : this))</span><br><span class="line">                return null;</span><br><span class="line">            dep = null; src = null; fn = null;</span><br><span class="line">            return d.postFire(a, mode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">final &lt;S&gt; boolean uniAccept(CompletableFuture&lt;S&gt; a,</span><br><span class="line">                                Consumer&lt;? super S&gt; f, UniAccept&lt;S&gt; c) &#123;</span><br><span class="line">        Object r; Throwable x;</span><br><span class="line">        if (a == null || (r = a.result) == null || f == null) //判断源任务是否已经完成了，a表示的就是源任务，a.result就代表的是原任务的结果。</span><br><span class="line">            return false;</span><br><span class="line">        tryComplete: if (result == null) &#123;</span><br><span class="line">            if (r instanceof AltResult) &#123;</span><br><span class="line">                if ((x = ((AltResult)r).ex) != null) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    break tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = null;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (c != null &amp;&amp; !c.claim())</span><br><span class="line">                    return false;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;) S s = (S) r;</span><br><span class="line">                f.accept(s);  //去调用Comsumer</span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于Completion的执行，还有几个关键的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int SYNC   =  0;//同步</span><br><span class="line">static final int ASYNC  =  1;//异步</span><br><span class="line">static final int NESTED = -1;//嵌套</span><br></pre></td></tr></table></figure><p>Completion在CompletableFuture中是如何工作的呢？现在先不着急了解其原理，下面再去看下一个重要的接口——CompletionStage。</p><p>CompletionStage<br>下面介绍下CompletionStage接口。看字面意思可以理解为“完成动作的一个阶段”，查看官方注释文档：CompletionStage是一个可能执行异步计算的“阶段”，这个阶段会在另一个CompletionStage完成时调用去执行动作或者计算，一个CompletionStage会以正常完成或者中断的形式“完成”，并且它的“完成”会触发其他依赖的CompletionStage。CompletionStage 接口的方法一般都返回新的CompletionStage，因此构成了链式的调用。<br>【下文中Stage代表CompletionStage】</p><p>那么在Java中什么是CompletionStage呢？<br>官方定义中，一个Function，Comsumer或者Runnable都会被描述为一个CompletionStage，相关方法比如有apply，accept，run等，这些方法的区别在于它们有些是需要传入参，有些则会产生“结果”。</p><p>Funtion方法会产生结果<br>Comsumer会消耗结果<br>Runable既不产生结果也不消耗结果<br>下面看看一个Stage的调用例子：</p><p>stage.thenApply(x -&gt; square(x)).thenAccept(x -&gt; System.out.println(x)).thenRun(() -&gt; System.out.println())<br>1<br>这里x -&gt; square(x)就是一个Function类型的Stage，它返回了x。x -&gt; System.out.println(x)就是一个Comsumer类型的Stage，用于接收上一个Stage的结果x。() -&gt;System.out.println()就是一个Runnable类型的Stage，既不消耗结果也不产生结果。</p><p>一个、两个或者任意一个CompletionStage的完成都会触发依赖的CompletionStage的执行，CompletionStage的依赖动作可以由带有then的前缀方法来实现。如果一个Stage被两个Stage的完成给触发，则这个Stage可以通过相应的Combine方法来结合它们的结果，相应的Combine方法包括：thenCombine、thenCombineAsync。但如果一个Stage是被两个Stage中的其中一个触发，则无法去combine它们的结果，因为这个Stage无法确保这个结果是那个与之依赖的Stage返回的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testCombine() throws Exception &#123;</span><br><span class="line">       String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           return &quot;hello&quot;;</span><br><span class="line">       &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           return &quot; world&quot;;</span><br><span class="line">       &#125;), (s1, s2) -&gt; s1 + &quot; &quot; + s2).join();</span><br><span class="line"></span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>虽然Stage之间的依赖关系可以控制触发计算，但是并不能保证任何的顺序。</p><p>另外，可以用一下三种的任何一种方式来安排一个新Stage的计算：default execution、default asynchronous execution（方法后缀都带有async）或者custom（自定义一个executor）。默认和异步模式的执行属性由CompletionStage实现而不是此接口指定。</p><p>小结：CompletionStage确保了CompletableFuture能够进行链式调用。</p><p>下面开始介绍CompletableFuture的几个核心方法：</p><p>postComplete</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final void postComplete() &#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; f = this; Completion h;    //this表示当前的CompletableFuture</span><br><span class="line">        while ((h = f.stack) != null ||                                  //判断stack栈是否为空</span><br><span class="line">               (f != this &amp;&amp; (h = (f = this).stack) != null)) &#123;    </span><br><span class="line">            CompletableFuture&lt;?&gt; d; Completion t;      </span><br><span class="line">            if (f.casStack(h, t = h.next)) &#123;                          //通过CAS出栈，</span><br><span class="line">                if (t != null) &#123;</span><br><span class="line">                    if (f != this) &#123;</span><br><span class="line">                        pushStack(h);             //如果f不是this，将刚出栈的h入this的栈顶</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    h.next = null;    // detach   帮助GC</span><br><span class="line">                &#125;</span><br><span class="line">                f = (d = h.tryFire(NESTED)) == null ? this : d;        //调用tryFire</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postComplete()方法可以理解为当任务完成之后，调用的一个“后完成”方法，主要用于触发其他依赖任务。</p><p>uniAccept</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">final &lt;S&gt; boolean uniAccept(CompletableFuture&lt;S&gt; a,</span><br><span class="line">                                Consumer&lt;? super S&gt; f, UniAccept&lt;S&gt; c) &#123;</span><br><span class="line">        Object r; Throwable x;</span><br><span class="line">        if (a == null || (r = a.result) == null || f == null)    //判断当前CompletableFuture是否已完成，如果没完成则返回false；如果完成了则执行下面的逻辑。</span><br><span class="line">            return false;</span><br><span class="line">        tryComplete: if (result == null) &#123;</span><br><span class="line">            if (r instanceof AltResult) &#123;   //判断任务结果是否是AltResult类型</span><br><span class="line">                if ((x = ((AltResult)r).ex) != null) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    break tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = null;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (c != null &amp;&amp; !c.claim()) //判断当前任务是否可以执行</span><br><span class="line">                    return false;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;) S s = (S) r;   //获取任务结果</span><br><span class="line">                f.accept(s);    //执行Comsumer</span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里有一个很巧妙的地方，就是uniAccept的入参中，CompletableFuture a表示的是源任务，UniAccept c中报装有依赖的任务，这点需要清除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pushStack</span><br><span class="line"></span><br><span class="line">final void pushStack(Completion c) &#123;</span><br><span class="line">        do &#123;&#125; while (!tryPushStack(c));      //使用CAS自旋方式压入栈，避免了加锁竞争</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">final boolean tryPushStack(Completion c) &#123;</span><br><span class="line">        Completion h = stack;         </span><br><span class="line">        lazySetNext(c, h);   //将当前stack设置为c的next</span><br><span class="line">        return UNSAFE.compareAndSwapObject(this, STACK, h, c); //尝试把当前栈（h）更新为新值（c）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static void lazySetNext(Completion c, Completion next) &#123;</span><br><span class="line">        UNSAFE.putOrderedObject(c, NEXT, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>光分析源码也没法深入理解其代码原理，下面结合一段示例代码来对代码原理进行分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void thenApply() throws Exception &#123;</span><br><span class="line">       ExecutorService executorService = Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">       CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">                //休眠200秒</span><br><span class="line">               Thread.sleep(200000);</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(&quot;supplyAsync &quot; + Thread.currentThread().getName());</span><br><span class="line">           return &quot;hello &quot;;</span><br><span class="line">       &#125;,executorService).thenAccept(s -&gt; &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               thenApply_test(s + &quot;world&quot;);</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       System.out.println(Thread.currentThread().getName());</span><br><span class="line">       while (true) &#123;</span><br><span class="line">           if (cf.isDone()) &#123;</span><br><span class="line">               System.out.println(&quot;CompletedFuture...isDown&quot;);</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/** 运行结果：</span><br><span class="line">    main</span><br><span class="line">    supplyAsync pool-1-thread-1</span><br><span class="line">    thenApply_test hello world</span><br><span class="line">    thenApply_test pool-1-thread-1</span><br><span class="line">    CompletedFuture...isDown</span><br><span class="line">    */</span><br></pre></td></tr></table></figure><p>这段示例代码所做的事情就是supplyAsync(Supplier supplier)休眠200秒之后，返回一个字符串，thenAccept(Consumer&lt;? super T&gt; action)等到任务完成之后接收这个字符串，并且调用thenApply_test()方法，随后输出 hello world。<br>代码中让线程休眠200秒是为了方便观察CompletableFuture的传递过程。</p><p>下面就描述下程序的整个运作流程。<br>① 主线程调用CompletableFuture的supplyAsync()方法，传入Supplier和Executor。在supplyAsync()中又继续调用CompletableFuture的asyncSupplyStage(Executor, Supplier)方法。</p><p>来到asyncSupplyStage()方法中，调用指定的线程池，并执行execute(new AsyncSupply(d,f))，这里d就是我们的“源任务”，接下来thenApply()要依赖着这个源任务进行后续逻辑操作，f就是Supplier的函数式编程。</p><p>AsyncSupply实现了Runnable的run()方法，核心逻辑就在run()方法里。在run()方法里，先判断d.result == null，判断该任务是否已经完成，防止并发情况下其他线程完成此任务了。f.get()就是调用的Supplier的函数式编程，这里会休眠200秒，所以executor线程池开启的线程会在这里阻塞200秒。</p><p>② 虽然executor线程池线程阻塞了，但是main线程任然会继续执行接下来的代码。</p><p>main线程会在asyncSupplyStage()方法中返回d，就是我们的“依赖任务”，而这个任务此时还处在阻塞中。接下来main线程会继续执行CompletableFuture的thenAccept(Comsumer&lt;? super T&gt; action)方法，然后调用CompletableFuture的uniAcceptStage()方法。<br>在这里插入图片描述<br>在uniAcceptStage()方法中，会将“依赖任务”、“源任务”、线程池以及Comsumer报装程一个UniAccept对象，然后调用push()压入stack的栈顶中。随后调用UniAccept的tryFire()方法。<br>在这里插入图片描述<br>其中的CompletableFuture的uniAccept()方法会判断任务是否完成，判断依据是a.result 是否为空，这里的a就是之前传入的“源任务”，等到“源任务”阻塞200秒过后，就会完成任务，并将字符串存入到 result中。<br>在这里插入图片描述<br>判断到“源任务”完成之后，就会调用接下来的逻辑。s拿到的值就是“源”任务返回的字符串，并且传入到了Comsumer.accept()方法中。然而“源任务”还在阻塞中，main线程会跳出uniAccept()，继续执行接下来的逻辑。接下来就是输出当前线程的名字，然后调用while(true)，结束条件为CompletableFuture.isDone()，当任务完成时则结束while(true)循环。</p><p>③ 回到“源任务”，虽然main线程已经结束了整个生命周期，但是executor线程池的线程任然阻塞着的，休眠了200秒之后，继续执行任务。<br>在这里插入图片描述<br>然后来到了postComplete()方法。这个方法在前面已经介绍到了，它是CompletableFuture的核心方法之一，做了许多事情。最重要的一件事情就是触发其他依赖任务，接下来调用的方法依次为：UniAccept.tryFire(mode) ——&gt; CompletableFuture.uniAccept(…) ——&gt; Comsumer.accept(s) ——&gt; 输出“hello world”，并输出当前调用线程的线程名。因这个调用链已经在②中介绍过了，所以就不再详细介绍其运作逻辑。<br>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">      runAsync();</span><br><span class="line">      supplyAsync();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //无返回值</span><br><span class="line">    public static void runAsync() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;run end ...&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        future.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //有返回值</span><br><span class="line">    public static void supplyAsync() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Long&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;run end ...&quot;);</span><br><span class="line">            return System.currentTimeMillis();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        long time = future.get();</span><br><span class="line">        System.out.println(&quot;time = &quot;+time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run end ...</span><br><span class="line">run end ...</span><br><span class="line">time = 1596010020281</span><br></pre></td></tr></table></figure><p>小结： 通过这个小示例，终于理解到了“源任务”和“依赖任务”之间的调用关系，以及CompletableFuture的基本运作原理。然而CompletableFuture还有其他的方法需要去深入分析，由于篇幅所限就不再赘述，感兴趣的读者可以以debug的模式去一点一点分析CompletableFuture其他方法的底层原理。这里不得不说Java并发包作者Doug Lea大神真的太厉害了，阅读他的源码之后，可以发现他写的代码不能以技术来形容，而应该使用“艺术”来形容。</p><p>总结<br>CompletableFuture底层由于借助了魔法类Unsafe的相关CAS方法，除了get或join结果之外，其他方法都实现了无锁操作。<br>CompletableFuture实现了CompletionStage接口，因而具备了链式调用的能力，CompletionStage提供了either、apply、run以及then等相关方法，使得CompletableFuture可以使用各种应用场景。<br>CompletableFuture中有“源任务”和“依赖任务”，“源任务”的完成能够触发“依赖任务”的执行，这里的完成可以是返回正常结果或者是异常。<br>CompletableFuture默认使用ForkJoinPool，也可以使用指定线程池来执行任务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;想学习CompletableFuture，因此查询资料发现&lt;br&gt;CompletableFuture是JDK8中的新特性，主要用于对JDK5中加入的Future的补充。&lt;br&gt;CompletableFuture实现了CompletionStage和Future接口。&lt;br&gt;</summary>
      
    
    
    
    
    <category term="CompletableFuture" scheme="https://zkkget.github.io/tags/CompletableFuture/"/>
    
  </entry>
  
  <entry>
    <title>优雅永不过时</title>
    <link href="https://zkkget.github.io/posts/20220726cl89v5wwb001ct4uj6wzcaew9.html"/>
    <id>https://zkkget.github.io/posts/20220726cl89v5wwb001ct4uj6wzcaew9.html</id>
    <published>2022-07-26T02:26:41.000Z</published>
    <updated>2022-07-26T02:30:41.087Z</updated>
    
    <content type="html"><![CDATA[<p>无论是日常编码，还是业务涉及，能够优雅的表达思想，提高代码简洁度，阅读性都是一种能力，总结一下优雅的做法</p><p>优雅的关闭流<br>java7 try with resource，针对实现了AutoCloseable接口的类，都可优雅的关闭流，从而舍弃finally关闭</p><p>try catch finally</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = null;</span><br><span class="line">try &#123;</span><br><span class="line">....</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (in != null) &#123;</span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e2) &#123;</span><br><span class="line">e2.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">try winth resource</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try (final BufferedReader in = new BufferedReader(new InputStreamReader((new URL(url + &quot;?&quot; + param)).openConnection().getInputStream()));PrintWriter out =new PrintWriter(response.getWriter()))&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;catch&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netty 优雅的关闭流程<br>1<br>shutdownGracefully()<br>Lambda表达式<br>list求交集</p><p>1<br>List<Long> collect = list1.stream().filter(list2::contains).collect(Collectors.toList());<br>设计模式代替if else,策略模式，模板模式<br>代码整洁度，例如多注入service，按着高矮胖瘦排列，视觉舒适，controller求求你别写业务代码了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public  List getRandomList(List&lt;?&gt; paramList,int count)&#123;</span><br><span class="line">        if(count==0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Random random=new Random();</span><br><span class="line">        List&lt;Integer&gt; tempList=new ArrayList&lt;&gt;();//临时存放产生的list索引，去除重复的索引</span><br><span class="line">        List newList=new ArrayList();//生成新的list集合</span><br><span class="line">        int temp=0;</span><br><span class="line">        if(count&lt;=1)&#123;//如果数据小于1，取一条数据</span><br><span class="line">            temp = random.nextInt(paramList.size());</span><br><span class="line">            newList.add(paramList.get(temp));</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for(int i=0;i&lt;Math.ceil(count);i++)&#123;</span><br><span class="line">                temp=random.nextInt(paramList.size());//初始化一个随机数，将产生的随机数作为被抽list的索引</span><br><span class="line">                if(!tempList.contains(temp))&#123;//判断随机抽取的随机数</span><br><span class="line">                    tempList.add(temp);</span><br><span class="line">                    newList.add(paramList.get(temp));</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>优雅判空<br>个人喜欢Assert判空，至于java8的Optional并没体会到优雅之处，日常StringUtils，Collections，isNoBlank等，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public String testOptional(Test test) &#123;</span><br><span class="line">        return Optional.ofNullable(test).flatMap(Test::getTest3)</span><br><span class="line">                .flatMap(Test3::getTest2)</span><br><span class="line">                .map(Test2::getInfo)</span><br><span class="line">                .orElse(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">看起来挺优雅，但日常没体会到</span><br><span class="line">还有日常常用的instanceof</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">else if (f instanceof TreeBin) &#123;</span><br><span class="line">        validated = true;</span><br><span class="line">        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">        if ((r = t.root) != null &amp;&amp;</span><br><span class="line">            (p = r.findTreeNode(hash, key, null)) != null) &#123;</span><br><span class="line">            V pv = p.val;</span><br><span class="line">            if (cv == null || cv == pv ||</span><br><span class="line">                (pv != null &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                oldVal = pv;</span><br><span class="line">                if (value != null)</span><br><span class="line">                    p.val = value;</span><br><span class="line">                else if (t.removeTreeNode(p))</span><br><span class="line">                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;无论是日常编码，还是业务涉及，能够优雅的表达思想，提高代码简洁度，阅读性都是一种能力，总结一下优雅的做法&lt;/p&gt;
&lt;p&gt;优雅的关闭流&lt;br&gt;java7 try with resource，针对实现了AutoCloseable接口的类，都可优雅的关闭流，从而舍弃finally</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode算法题</title>
    <link href="https://zkkget.github.io/posts/20220726cl89v5wvh0006t4ujfzkx3v6v.html"/>
    <id>https://zkkget.github.io/posts/20220726cl89v5wvh0006t4ujfzkx3v6v.html</id>
    <published>2022-07-26T02:22:55.000Z</published>
    <updated>2022-07-26T02:26:11.279Z</updated>
    
    <content type="html"><![CDATA[<p>一：力扣第14题 编写一个函数来查找字符串数组中的最长公共前缀<br>官方解法：<br>##方法一：横向扫描</p><p>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if (strs == null || strs.length == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = strs[0];</span><br><span class="line">        int count = strs.length;</span><br><span class="line">        for (int i = 1; i &lt; count; i++) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            if (prefix.length() == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String longestCommonPrefix(String str1, String str2) &#123;</span><br><span class="line">        int length = Math.min(str1.length(), str2.length());</span><br><span class="line">        int index = 0;</span><br><span class="line">        while (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return str1.substring(0, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复杂度分析</span><br><span class="line">时间复杂度：O(mn)O(mn)，其中 mm 是字符串数组中的字符串的平均长度，nn 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</span><br><span class="line">空间复杂度：O(1)O(1)。使用的额外空间复杂度为常数。</span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>#leetcode 用户灵魂画手<br>思路<br>标签：链表<br>当字符串数组长度为 0 时则公共前缀为空，直接返回<br>令最长公共前缀 ans 的值为第一个字符串，进行初始化<br>遍历后面的字符串，依次将其与 ans 进行比较，两两找出公共前缀，最终结果即为最长公共前缀<br>如果查找过程中出现了 ans 为空的情况，则公共前缀不存在直接返回<br>时间复杂度：O(s)O(s)，s 为所有字符串的长度之和<br>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs.length == 0) </span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        String ans = strs[0];</span><br><span class="line">        for(int i =1;i&lt;strs.length;i++) &#123;</span><br><span class="line">            int j=0;</span><br><span class="line">            for(;j&lt;ans.length() &amp;&amp; j &lt; strs[i].length();j++) &#123;</span><br><span class="line">                if(ans.charAt(j) != strs[i].charAt(j))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.substring(0, j);</span><br><span class="line">            if(ans.equals(&quot;&quot;))</span><br><span class="line">                return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">作者：guanpengchn</span><br><span class="line">链接：https://leetcode-cn.com/problems/longest-common-prefix/solution/hua-jie-suan-fa-14-zui-chang-gong-gong-qian-zhui-b/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>#最易理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        String s=&quot;&quot;;</span><br><span class="line">        int judge=1;</span><br><span class="line">        if(strs.length==0)&#123;//数组为空直接返回&quot;&quot;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;strs[0].length();i++)&#123;</span><br><span class="line">            char a=strs[0].charAt(i);//直接选择第一个数组元素，依次取这个字符串的字符</span><br><span class="line">            </span><br><span class="line">            for(int j=0;j&lt;strs.length;j++)&#123;</span><br><span class="line">                </span><br><span class="line">                if(i&gt;=strs[j].length())&#123;//因为每个字符串长度不同，防止溢出</span><br><span class="line">                    judge=0;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if(a!=strs[j].charAt(i))&#123;</span><br><span class="line">                    judge=0;//只要存在不同，直接退出</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                else&#123;</span><br><span class="line">                    if(j==strs.length-1)&#123;</span><br><span class="line">                        s=s+a;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            if(judge==0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">本文链接：https://blog.csdn.net/shancx/article/details/82746264</span><br></pre></td></tr></table></figure><p>二：未排序正整数数组中累加和为给定值的最长子数组长度<br>给定一个数组arr，该数组无序，每个数正数，给定一个K，求arr的所有子数组中所有元素相加和为k的最长子数组的长度。</p><p>例如：arr=[1,2,1,1,1],k=3</p><p>结果是3，[1,1,1]的长度。</p><p>思路：</p><p>首先用两个位置来标记子数组左右两头，记为left与right，开始的时候都在数组的最左边即left=right=0，过程如下：</p><p>1，开始变量left=0，right=0，代表子数组arr[left,right];</p><p>2，变量sum始终表示子数组arr[left,right]的和，开始的时候sum= arr[0],即是arr[0,0]的和；</p><p>3，变量len一直记录累加和为k的所有子数组中最大子数组的长度，开始的时候len=0;</p><p>4，根据sum与k的比较结果决定是left移动还right移动。若干sum==K，说明arr[left,right]累加和为k,如果长度大于len，更新len</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package Array;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by wuxiaosi on 2017/9/24.</span><br><span class="line"> */</span><br><span class="line">public class getMaxLength &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int k=3;</span><br><span class="line">        int[] arr=&#123;1,2,1,1,1&#125;;</span><br><span class="line">        System.out.println(getMaxLengthK(arr,k));</span><br><span class="line">    &#125;</span><br><span class="line">    public static int getMaxLengthK(int[] arr,int k)&#123;</span><br><span class="line">        if(arr==null||arr.length==0||k&lt;=0)&#123;</span><br><span class="line">            return  0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=0;</span><br><span class="line">        int sum=arr[0];</span><br><span class="line">        int len=0;</span><br><span class="line">        while(right&lt;arr.length)&#123;</span><br><span class="line">            if(sum==k)&#123;</span><br><span class="line">                len = Math.max(len,right-left+1);</span><br><span class="line">                sum=sum-arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            else if(sum&lt;k)&#123;</span><br><span class="line">                right++;//向右移动</span><br><span class="line">                if(right==arr.length)&#123;//right到数组边界长度，就break</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                sum=sum+arr[right];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sum=sum-arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「wuxiaosi808」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/wuxiaosi808/article/details/78079574</span><br></pre></td></tr></table></figure><p>三 有两个整数数组A1，A2，设计函数求其两个数组的最大值和第二大的值<br>思路一：</p><p>1.获取最值需要进行比较，每一次比较都会有一个较大的值，因为该值的不确定性，通过一个变量进行临时存储。</p><p>2.让数组中的每一个元素都和这个变量中的值进行比较，如果大于变量中的值，就用该变量记录较大值。</p><p>3.当所有的元素都比较完成，那么该变量中的存储就是数组中的最大值了。</p><p>步骤：</p><p>1.定义变量，初始化为数组中的任意一个元素。</p><p>2.通过循环语句对数组进行遍历。</p><p>3.在变量过程中定义判断条件，如果遍历到的元素比变量中的元素大，就赋值给该变量。</p><p>注意：</p><p>通过定义一个功能来完成，以便提高代码的复用性。该功能结果为数组中的最大元素，未知内容为数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) </span><br><span class="line">&#123;</span><br><span class="line">int[] arr1 = &#123;9,5,6,3,1,2,8,7&#125;;</span><br><span class="line">int max1 = getMax(arr1);</span><br><span class="line">System.out.println(&quot;max1=&quot;+max1);</span><br><span class="line">double[] arr2 = &#123;9.0,5.0,6.0,3.0,1.0,2.0,8.0,7.0&#125;;</span><br><span class="line">double max2 = getMax(arr2);</span><br><span class="line">System.out.println(&quot;max2=&quot;+max2);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">//获取int类型数组最大值</span><br><span class="line">public static int getMax(int[] arr)</span><br><span class="line">&#123;</span><br><span class="line">int max = arr[0];</span><br><span class="line">for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(arr[i]&gt;max)</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br><span class="line">//获取double类型数组最大值，功能相似，以重载的形式存在</span><br><span class="line">public static double getMax(double[] arr)</span><br><span class="line">&#123;</span><br><span class="line">double max = arr[0];</span><br><span class="line">for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(arr[i]&gt;max)</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><p>1.定义变量，初始化为数组角标0。</p><p>2.通过循环语句对数组进行遍历。</p><p>3.在变量过程中定义判断条件，如果遍历到的元素比角标所在的元素中的数值大，就将较大值的角标赋值给变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) </span><br><span class="line">&#123;</span><br><span class="line">int[] arr1 = &#123;9,5,6,3,1,2,8,7&#125;;</span><br><span class="line">int max1 = getMax(arr1);</span><br><span class="line">System.out.println(&quot;max1=&quot;+max1);</span><br><span class="line">double[] arr2 = &#123;9.0,5.0,6.0,3.0,1.0,2.0,8.0,7.0&#125;;</span><br><span class="line">double max2 = getMax(arr2);</span><br><span class="line">System.out.println(&quot;max2=&quot;+max2);</span><br><span class="line">&#125;</span><br><span class="line">//获取int类型数组最大值</span><br><span class="line">public static int getMax(int[] arr)</span><br><span class="line">&#123;</span><br><span class="line">int max = 0;</span><br><span class="line">for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(arr[i]&gt;arr[max])</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line">return arr[max];</span><br><span class="line">&#125;</span><br><span class="line">//获取double类型数组最大值，功能相似，以重载的形式存在</span><br><span class="line">public static double getMax(double[] arr)</span><br><span class="line">&#123;</span><br><span class="line">double max = 0;</span><br><span class="line">for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(arr[i]&gt;arr[max])</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line">return arr[max];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「Destiny_lt」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/ytu_lt/article/details/70160598</span><br></pre></td></tr></table></figure><h1 id="四-翻转单词顺序列（I-am-a-student-gt-student-a-am-I）"><a href="#四-翻转单词顺序列（I-am-a-student-gt-student-a-am-I）" class="headerlink" title="四 翻转单词顺序列（I am a student.-&gt;student. a am I）"></a>四 翻转单词顺序列（I am a student.-&gt;student. a am I）</h1><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”<br>方法一：双指针<br>算法解析：<br>倒序遍历字符串 ss ，记录单词左右索引边界 ii , jj ；<br>每确定一个单词的边界，则将其添加至单词列表 resres ；<br>最终，将单词列表拼接为字符串，并返回即可。<br>复杂度分析：<br>时间复杂度 O(N)O(N) ： 其中 NN 为字符串 ss 的长度，线性遍历字符串。<br>空间复杂度 O(N)O(N) ： 新建的 list(Python) 或 StringBuilder(Java) 中的字符串总长度 \leq N≤N ，占用 O(N)O(N) 大小的额外空间。<br>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        s = s.trim(); // 删除首尾空格</span><br><span class="line">        int j = s.length() - 1, i = j;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        while(i &gt;= 0) &#123;</span><br><span class="line">            while(i &gt;= 0 &amp;&amp; s.charAt(i) != &#x27; &#x27;) i--; // 搜索首个空格</span><br><span class="line">            res.append(s.substring(i + 1, j + 1) + &quot; &quot;); // 添加单词</span><br><span class="line">            while(i &gt;= 0 &amp;&amp; s.charAt(i) == &#x27; &#x27;) i--; // 跳过单词间空格</span><br><span class="line">            j = i; // j 指向下个单词的尾字符</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString().trim(); // 转化为字符串并返回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：分割 + 倒序<br>利用 “字符串分割”、“列表倒序” 的内置函数 （面试时不建议使用） ，可简便地实现本题的字符串翻转要求<br>复杂度分析：<br>时间复杂度 O(N)O(N) ： 总体为线性时间复杂度，各函数时间复杂度和参考资料链接如下。<br>split() 方法： 为 O(N)O(N) ；<br>trim() 和 strip() 方法： 最差情况下（当字符串全为空格时），为 O(N)O(N) ；<br>join() 方法： 为 O(N)O(N) ；<br>reverse() 方法： 为 O(N)O(N) ；<br>空间复杂度 O(N)O(N) ： 单词列表 strsstrs 占用线性大小的额外空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        String[] strs = s.trim().split(&quot; &quot;); // 删除首尾空格，分割字符串</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        for(int i = strs.length - 1; i &gt;= 0; i--) &#123; // 倒序遍历单词列表</span><br><span class="line">            if(strs[i].equals(&quot;&quot;)) continue; // 遇到空单词则跳过</span><br><span class="line">            res.append(strs[i] + &quot; &quot;); // 将单词拼接至 StringBuilder</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString().trim(); // 转化为字符串，删除尾部空格，并返回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/mian-shi-ti-58-i-fan-zhuan-dan-ci-shun-xu-shuang-z/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String ReverseSentence(String str)</span><br><span class="line">    &#123;</span><br><span class="line">        //先单个单词反转,再整体反转。I am a student.》》I ma a .tneduts 》》student. a am I</span><br><span class="line">        if(str.length()==0)</span><br><span class="line">            return str;</span><br><span class="line"></span><br><span class="line">        char[]chs=str.toCharArray();</span><br><span class="line"></span><br><span class="line">        //对单个字符数组元素进行反转</span><br><span class="line">        int i=0,j=0;//定义两个指针进行遍历</span><br><span class="line">        while(j&lt;=str.length())&#123;</span><br><span class="line"></span><br><span class="line">            //以空格作为区分，对每个单词进行反转</span><br><span class="line">            if(j==str.length()||chs[j]==&#x27; &#x27;)&#123;//j==str.length()不要忘记</span><br><span class="line">                reverse(chs,i,j-1);</span><br><span class="line">                i=j+1;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果chs[j]!=&#x27; &#x27;那么继续遍历直到找到空格</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //整体字符串反转</span><br><span class="line">        reverse(chs,0,str.length()-1);</span><br><span class="line"></span><br><span class="line">        return new String(chs);//学习</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private void reverse(char[]ch,int i,int j)&#123;</span><br><span class="line">        while(i&lt;j)&#123;</span><br><span class="line">            //反转交换,代码是一样的</span><br><span class="line">            char temp=ch[i];</span><br><span class="line">            ch[i]=ch[j];</span><br><span class="line">            ch[j]=temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">本文链接：https://blog.csdn.net/hefenglian/article/details/79932709</span><br></pre></td></tr></table></figure><h1 id="最牛逼的解法：JavaScript"><a href="#最牛逼的解法：JavaScript" class="headerlink" title="最牛逼的解法：JavaScript"></a>最牛逼的解法：JavaScript</h1><p>解法：先用trim()把字符串两端空格去掉，split(‘ ‘)把字符串切割成以空格为界限的单词块，filter()过滤掉数组中的纯空格，reverse()进行数组反转，join(‘ ‘)把数组变成中间只带一个空格的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    var reverseWords = function (s) &#123;</span><br><span class="line">        var str = s.trim().split(&#x27; &#x27;).filter(item =&gt; item!=&#x27;&#x27;).reverse().join(&#x27; &#x27;)</span><br><span class="line">        console.log(str)</span><br><span class="line">    &#125;;</span><br><span class="line">作者：CHH_</span><br><span class="line">链接：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/yi-xing-dai-ma-jie-jue-suo-you-by-chen-1wz/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>暴力求解法(百度百科)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">暴力求解法, 又名直接带入法（Directly Calculating）它是已知最古老的算法之一，与&quot;直观目测法&quot;，&quot;心灵感应法&quot;并称世界三大不可思议数学计算法则， 其可追溯至3200年前，古老的埃及人便开始使用象形文字进行复杂的数学演算。它首次的文本出现是欧几里德的《几何原本》（第V卷，命题i和ii）中，而在中国则可以追溯至宋朝末年出现的沈括《梦溪笔谈》</span><br><span class="line">暴力求解法的由来</span><br><span class="line"></span><br><span class="line">在汉高祖时期有一个有趣的小故事是这样的:</span><br></pre></td></tr></table></figure><p>“高祖年间,大将军韩信征讨突厥得胜,七月七日凯旋而归，其时举国腾。信进宫，高祖曰:’淮阴侯乃真人也，战无不功克，朕三年尝闻智勇，招为爱卿，果其然，甚好甚慰。’信曰:’大王聪明仁惠，敬贤礼士，江表英豪贤归附，臣听闻蜀地龙光射牛斗之墟，人杰多地灵，又适王举兵招马，无怪骏才星驰。’高祖对曰:’今汝方成大业，且问卿求?’信:’乃望众亲赐匹布，以二渐累。’回:’善，明日使文库之卿，方得人数。’隔日使返，帝问:”需布甚许?”曰:”臣不才，方得淮阴侯亲友八十五者，食客则七百七十六人之众，臣斗胆以树枝编排数之方得须七三万千三百二十馀一匹”帝惊道:”甚许!乃至库之空不能所期，淮阴岂谋他意?”遂隔日将信斩之，不知了了。”<br>暴力求解法的演算<br>1.例题:在地面上的同一1地点分别以速率V1、V2先后竖直像上抛出两个可视为质点的小球。第二个小球抛出后经过T时间与第一个小球相遇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">设第一小球抛出后t0时间与第二小球相遇 (此时第二小球已运动T,T&lt;t0)</span><br><span class="line">因为 h1 = h2</span><br><span class="line">v1t0 - <span class="number">1</span>/2g(t0)^<span class="number">2</span> = v2T -<span class="number">1</span>/2gT^<span class="number">2</span></span><br><span class="line">所以 T = (v2+√(v2^<span class="number">2</span>-2g(v1t0 - <span class="number">1</span>/2g(t0)^<span class="number">2</span>))) / g</span><br><span class="line">又 T &lt; v2/g</span><br><span class="line">根据复杂计算</span><br><span class="line">可得 T = (v2-√v2^<span class="number">2</span>-v1^<span class="number">2</span>) / g</span><br><span class="line">所以 Tmax = (v2-√v2^<span class="number">2</span>-v1^<span class="number">2</span>) / g</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一：力扣第14题 编写一个函数来查找字符串数组中的最长公共前缀&lt;br&gt;官方解法：&lt;br&gt;##方法一：横向扫描&lt;/p&gt;
&lt;p&gt;如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    
    <category term="Leetcode算法题" scheme="https://zkkget.github.io/tags/Leetcode%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁一面整理</title>
    <link href="https://zkkget.github.io/posts/20220726cl89v5wwe001jt4uj546e90kr.html"/>
    <id>https://zkkget.github.io/posts/20220726cl89v5wwe001jt4uj546e90kr.html</id>
    <published>2022-07-26T02:21:30.000Z</published>
    <updated>2022-07-26T02:22:19.303Z</updated>
    
    <content type="html"><![CDATA[<p>java的同步容器，并发容器？<br>同步：即每次只有一个线程访问容器状态。<br>并发：即每次可有多个线程访问容器状态。<br>同步容器：Vector，HashTable<br>并发容器：ConCurrentHashMap，CopeyOnwrite<br>–当并发读远多于修改的场景下需要使用List和Set时，可以考虑使用CopyOnWriteArrayList和CopyOnWriteArraySet；<br>–当需要并发使用&lt;Key, Value&gt;键值对存取数据时，可以使用ConcurrentHashMap；<br>–当要保证并发&lt;Key, Value&gt;键值对有序时可以使用ConcurrentSkipListMap。</p><p>ArrayList和LinkedList的插入和访问的复杂度<br>即数组与链表的访问插入复杂度<br>1&gt;.数组在访问时可通过下标直接查询，复杂度O(1),链表复杂度O(n)<br>2&gt;.数组插入时数组下标需要移动O(n)，链表直接操作指针O(1)<br>反射原理—&gt;</p><blockquote><p>反射可动态加载外部配置对象，通过class.forName加载类信息，而forName方法就是通过反射类调用的类信息，<br>jvm加载获取到里面的classLoader，通过native方法获取类信息，最终调用invoke0()方法，反射是线程安全的，<br>因为loadClass方法是synchronized修饰的，找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；<br>注解原理—&gt;</p></blockquote><blockquote><p>注解等同于加了标记,注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池<br>注解参数成员必须是public的，没有成员方法也行，但是就没得意义了<br>新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？<br>新生代分为Eden区，幸存from区，幸存to区，大小比例8:1:1<br>新生代使用复制算法，高效，省去了标记整理的过程，新生代需要清理的对象数量巨大，复制算法浪费空间，但效率高，<br>–&gt;引申<br>MinorGC的过程(复制-&gt;清空-&gt;互换)<br>1:Eden,SurvivorFrom复制到SurvivorTo，年龄+1</p></blockquote><p>首先，当Eden区满的时候会触发第一次GC,把还活着的对象拷贝到SurvivorFrom区，当Eden区再次出发GC的时候会扫描Eden区和form区，对这个区域进行垃圾回收，经过这次回收还活着的，复制到To区，对象年龄+1</p><p>2:清空Eden区、SurvivorFrom</p><p>然后清空Eden区和SurvivorFrom区的对象，谁空谁是to。</p><p>3:SurvivorTo和SurvivorFrom互换</p><p>互换之后SurvivorTo成为下一次GC的From区，当对象年龄达到15，最终如果存活，存入老年代。<br>—&gt;jvm分区</p><p>jvm分区<br>jvm分区<br>堆栈方法区<br>堆管存储，类实例和数组对象存储<br>栈管运行，存储基础数据类型和引用，栈帧<br>1.8之前是方法区，1.8之后改为元空间，存储静态变量 + 常量 + 类信息(构造方法/接口定义) + 运行时常量池存在方法区中<br>—&gt;垃圾回收算法<br>复制算法，标记清除，标记压缩，引用计数算法，可达性分析算法<br>复制算法</p><p>把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。</p><p>引用计数法：循环引用不可回收，不推荐</p><p>GCRoot：可达性分析算法</p><p>从根集对象向下搜索，如果一个对象没有任何链相连时，则说明对象不可用。</p><p>哪些可以作为GC root的对象<br>1.虚拟机栈中的引用对象<br>2.方法区中的类静态属性引用的对象<br>3.方法区中常量引用的对象<br>4.本地方法栈中引用的对象<br>如何确定垃圾？<br>已经不再被内存使用到的空间<br>JVM虚拟机 YGC和FGC发生的具体场景</p><p>YGC和FGC是什么<br>YGC ：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。 （复制算法 —&gt; 一般适用对象存活率低的场景）</p><p>FGC ：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。 （标记整理或者标记清除算法 —&gt; 一般适用于对象存活率高的场景）</p><p>2、什么时候执行YGC和FGC</p><p>1、eden空间不足,执行 young gc</p><p>2、old空间不足，perm空间不足，调用方法System.gc() ，ygc时的悲观策略,<br>dump live的内存信息时(jmap –dump:live)，都会执行full gc</p><p>3.JVM老年代和新生代的比例<br>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。<br>这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。<br>新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<br>默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )</p><p>频繁 fullgc 的排查<br>full gc产生场景如上叙述一下<br>其次猜测一下大概产生原因<br>尤其是大对象，80%以上的情况就是他。 那么大对象从哪里来的：<br>【1】数据库（包括 Mysql和 Mongodb等 NOSql数据库），结果集太大；<br>【2】第三方接口传输的大对象；<br>【3】消息队列，消息太大；</p><p>排查步骤—-&gt;<br>    (1):打印GCdetail<br>    -XX:+PrintGCDtails<br>    (2):生成dump文件  注意:dump操作的时候是会发生stop the word事件的，也就是说此时所有的用户线程都会暂停运行<br>    开启XX:+HeapDumpBeforeFullGC<br>    使用jvisualvm查看<br>&lt;关于top k 问题已经在实际解决Linux 阿里云服务器问题应用&gt;<br>—&gt;JMM<br>java memory model<br>—&gt;垃圾收集器<br>并行 串行 并发标记 CMS G1 ZGC<br>G1不产生内存碎片 可精准控制停顿</p><p>–&gt;CMS垃圾回收过程<br>1.总体介绍：<br>CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于老年代的回收采用CMS。CMS采用的基础算法是：标记—清除。</p><p>CMS<br>CMS<br>2.CMS过程：<br>初始标记(STW initial mark)<br>并发标记(Concurrent marking)<br>并发预清理(Concurrent precleaning)<br>重新标记(STW remark)<br>并发清理(Concurrent sweeping)<br>并发重置(Concurrent reset)<br>5.如何处理接口的重复请求？不得不说他不好好问，目的是问如何保证接口的幂等性?<br>分布式系统中，服务部署在不同的服务器上，但是数据要保证打到一个redis上<br>对于每个请求必须有一个唯一的标识。举个例子：订单支付请求，肯定得包含订单 id，一个订单 id 最多支付一次。<br>每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在数据库中记录个状态，比如支付之前记录一条这个订单的支付流水。<br>每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId 已经存在了，唯一键约束生效，报错插入不进去的。然后系统就不用再扣款了。<br>在网络延迟传输中，会造成消息队列重试，在重试过程中，消息会存在重复</p><p>解决方案：</p><p>1.如果是数据库的插入操作，给消息做一个主键，避免出现脏数据。<br>2.使用第三方做消费记录，例如Redis，全局id为K，消息为V，写入到Redis，消费之前先去查Redis是否存在<br>–&gt;引申分布式系统中如何生成高效的分布式唯一ID 雪花算法<br>可用分布式锁,redis 递增,机器的唯一码 拿出几位存为机器id,这样一来每次查询操作相对更快</p><p>G1回收器有个非常好的特性就是会不断的帮助JVM调整策略， 会根据实际的GC情况调整年轻代和老年代的比例大小，默认情况下，年轻代最多可以占用60%的堆内存。这其实就是GC的灵活性。</p><p>G1的另一个显著特点他能够让用户设置应用的暂停时间，通过参数：-XX:MaxGCPauseMillis来指定，为什么G1能做到这一点呢？也许你已经注意到了，G1回收的第4步，它是“选择一些内存块”，而不是整代内存来回收，这是G1跟其它GC非常不同的一点，其它GC每次回收都会回收整个Generation的内存(Eden, Old), 而回收内存所需的时间就取决于内存的大小，以及实际垃圾的多少，所以垃圾回收时间是不可控的；而G1每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如</p><p>Http与Https的区别？<br>博客:<a href="https://blog.csdn.net/guolin_blog/article/details/104546558">https://blog.csdn.net/guolin_blog/article/details/104546558</a><br>总结：首先回答对称加密以及非对称加密的区别。<br>对称加密比较简单，就是客户端和服务器共用同一个密钥，该密钥可以用于加密一段内容，同时也可以用于解密这段内容。对称加密的优点是加解密效率高，但是在安全性方面可能存在一些问题，因为密钥存放在客户端有被窃取的风险。对称加密的代表算法有：AES、DES等。</p><p>而非对称加密则要复杂一点，它将密钥分成了两种：公钥和私钥。公钥通常存放在客户端，私钥通常存放在服务器。使用公钥加密的数据只有用私钥才能解密，反过来使用私钥加密的数据也只有用公钥才能解密。非对称加密的优点是安全性更高，因为客户端发送给服务器的加密信息只有用服务器的私钥才能解密，因此不用担心被别人破解，但缺点是加解密的效率相比于对称加密要差很多。非对称加密的代表算法有：RSA、ElGamal等。<br>关键词：CA机构<br>个人理解：https使用的是对称加密与非对称加密相结合的方式。首先双端通信使用非对称加密，客户端加密传输时先请求第三方CA机构，CA加密处理完返回给服务器端，证书中加入了网站的域名，</p><p>redis掀桌连问</p><p>redis<br>redis<br>1.redis的hash怎么实现的？(实现原理)rehash过程<br>redis初始创建hash表,有序集合，链表时, 存储结构采用一种ziplist的存储结构, 这种结构内存排列更紧密, 能提高访存性能.<br>hash_max_ziplist_entries和hash_max_ziplist_value值作为阀值，hash_max_ziplist_entries表示一旦ziplist中元素数量超过该值，则需要转换为dict结构；hash_max_ziplist_value表示一旦ziplist中数据长度大于该值，则需要转换为dict结构。<br>哈希等价于Java语言的HashMap或者是Python语言的字典（Dict）<br>redis hash 的内部结构.第一维是数组,第二维是链表.组成一个 hashtable.<br>在 Java 中 HashMap 扩容是个很耗时的操作,需要去申请新的数组,为了追求高性能,Redis 采用了渐进式 rehash 策略.这也是 hash 中最重要的部分.<br>在扩容的时候 rehash 策略会保留新旧两个 hashtable 结构,查询时也会同时查询两个 hashtable.Redis会将旧 hashtable 中的内容一点一点的迁移到新的 hashtable 中,当迁移完成时,就会用新的 hashtable 取代之前的.当 hashtable 移除了最后一个元素之后,这个数据结构将会被删除.<br><a href="https://juejin.im/post/5cfe6383e51d45599e019d8f">https://juejin.im/post/5cfe6383e51d45599e019d8f</a><br>与java的hashmap的rehash区别<br>个人理解：hashmap的rehash是一次性拷贝的，不同的是，Redis的字典只能是字符串，另外他们rehash的方式不一样，因为Java的HashMap的字典很大时，rehash是个耗时的操作，需要一次全部rehash。Redis为了追求高性能，不能堵塞服务，所以采用了渐进式rehash策略。<br>rehash的详细步骤<br><a href="https://www.cnblogs.com/meituantech/p/9376472.html">https://www.cnblogs.com/meituantech/p/9376472.html</a><br>与ConcurrentHashMap扩容的策略比较？<br>ConcurrentHashMap采用的扩容策略为： “多线程协同式rehash“。<br>1.扩容所花费的时间对比： 一个单线程渐进扩容，一个多线程协同扩容。在平均的情况下，是ConcurrentHashMap 快。这也意味着，扩容时所需要 花费的空间能够更快的进行释放。<br>2.读操作，两者性能相差不多。<br>3.写操作，Redis的字典返回更快些，因为它不像ConcurrentHashMap那样去帮着扩容(当要写的桶位已经搬到了newTable时)，等扩容完才能进行操作。<br>4.删除操作，与写一样。<br><a href="http://xytschool.com/resource/236.html">http://xytschool.com/resource/236.html</a><br>redis如何保证高可用<br>保证redis高可用机制需要redis主从复制、redis持久化机制、哨兵机制、keepalived等的支持。<br>主从复制的作用：数据备份、读写分离、分布式集群、实现高可用、宕机容错机制等。</p><p>redis主从复制原理<br>首先主从复制需要分为两个角色：master(主) 和 slave(从) ，注意：redis里面只支持一个主，不像Mysql、Nginx主从复制可以多主多从。</p><p>(1)redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</p><p>(2)通过redis的复制功能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p><p><a href="https://blog.csdn.net/itcats_cn/article/details/82428716">https://blog.csdn.net/itcats_cn/article/details/82428716</a></p><h1 id="说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？"><a href="#说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？" class="headerlink" title="说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？***"></a>说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？***</h1><p>个人理解：强一致性的数据是不适合放在缓存中的。另外MySQL对事务的支持也是redis本身不能达到的，需要单独实现<br>一般不是说redis or  MySQL,而是redis+MySQL<br><a href="https://blog.csdn.net/u011784767/article/details/76824822">https://blog.csdn.net/u011784767/article/details/76824822</a><br>为什么Redis进行RDB持久化数据时，新起一个进程而不是在原进程中起一个线程来持久化数据<br>(1)Redis RDB持久化机制会阻塞主进程，这样主进程就无法响应客户端请求。<br>(2)我们知道Redis对客户端响应请求的工作模型是单进程和单线程的，如果在主进程内启动一个线程，这样会造成对数据的竞争条件，为了避免使用锁降低性能。基于以上两点这就是为什么Redis通过启动一个进程来执行RDB了<br>—单线程的redis为什么这么快<br>(1)纯内存操作<br>(2)单线程操作，避免了频繁的上下文切换<br>(3)采用了非阻塞I/O多路复用机制</p><p>1<br>—Redis的数据类型以及使用场景<br>(1)String<br>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。<br>一般做一些复杂的计数功能的缓存。</p><p>(2)hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，<br>就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p><p>(3)list<br>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，<br>做基于redis的分页功能，性能极佳，用户体验好。</p><p>(4)set<br>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？<br>因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再启一个公共服务，太麻烦了。</p><p>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><p>(5)sorted set<br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。sorted set可以用来做延时任务。最后一个应用就是可以做范围查找</p><p>1</p><h1 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h1><p>redis采用的是定期删除+惰性删除+内存淘汰策略。<br>[2020年6月29日17:25:36在平时的项目中测试，不定期会产生无用token的key数据，平时可以进行模糊删除]</p><p>```<br>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p><p>解决方案:<br>(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试<br>(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，<br>异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。<br>(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。<br>迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p><p>缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p><p>解决方案:<br>(一)给缓存的失效时间，加上一个随机值，避免集体失效。<br>(二)使用互斥锁，但是该方案吞吐量明显下降了。<br>(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。<br>自己做缓存预热操作。然后细分以下几个小点<br>1 从缓存A读数据库，有则直接返回<br>2 A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。<br>3 更新线程同时更新缓存A和缓存B。</p><p>8、如何解决redis的并发竞争key问题</p><p>分析:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。<br>需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。<br>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，<br>这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。</p><p>回答:如下所示<br>(1)如果对这个key操作，不要求顺序<br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>(2)如果对这个key操作，要求顺序<br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，<br>需要保存一个时间戳。假设时间戳如下<br>系统A key 1 {valueA  3:00}<br>系统B key 1 {valueB  3:05}<br>系统C key 1 {valueC  3:10}<br>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。<br>redis分页<br>HSCAN testHash “0” count 10</p><p>注：测试field数量在22条时（没有测试Redis中Hash使分页生效时的field数量的下限），分页未生效。<br>#mysql 执行一个 sql 的过程<br>执行完毕之后有一个缓存的过程</p><p>mysql<br>mysql<br><a href="https://www.cnblogs.com/luoying/p/12073812.html">https://www.cnblogs.com/luoying/p/12073812.html</a></p><p>MySQL分页limit速度太慢的优化方法<br>1.子查询优化法<br>先找出第一条数据，然后大于等于这条数据的id就是要获取的数据<br>缺点：数据必须是连续的，可以说不能有where条件，where条件会筛选数据，导致数据失去连续性<br>2.limit限制优化法<br>把limit偏移量限制低于某个数<br>3.where条件先过滤后分页<br>wait notify 为什么要搭配使用？<br>单独调用会报异常<br>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。因为程序验证通常是在对象的同步方法或同步代码块中调用它们的。如果尝试在未获取对象锁时调用这三个方法，<br>“java.lang.IllegalMonitorStateException:current thread not owner”。<br>底层把对象作为一个监视器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java的同步容器，并发容器？&lt;br&gt;同步：即每次只有一个线程访问容器状态。&lt;br&gt;并发：即每次可有多个线程访问容器状态。&lt;br&gt;同步容器：Vector，HashTable&lt;br&gt;并发容器：ConCurrentHashMap，CopeyOnwrite&lt;br&gt;–当并发读远多于</summary>
      
    
    
    
    
    <category term="面试" scheme="https://zkkget.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>List遍历删除</title>
    <link href="https://zkkget.github.io/posts/20220726cl89v5wvi0008t4uj92992jyr.html"/>
    <id>https://zkkget.github.io/posts/20220726cl89v5wvi0008t4uj92992jyr.html</id>
    <published>2022-07-26T02:19:28.000Z</published>
    <updated>2022-07-26T02:20:44.374Z</updated>
    
    <content type="html"><![CDATA[<p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;ad&quot;</span>);</span><br><span class="line">       Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">       <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">           String next = iterator.next();</span><br><span class="line">           <span class="keyword">if</span>(<span class="string">&quot;a&quot;</span>.equals(next)||<span class="string">&quot;c&quot;</span>.equals(next))&#123;</span><br><span class="line">               iterator.remove();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(JSONObject.toJSONString(list));</span><br><span class="line">   &#125;</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;ad&quot;</span>]</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ad&quot;</span>);</span><br><span class="line">      list.removeIf(s-&gt;<span class="string">&quot;a&quot;</span>.equals(s)||<span class="string">&quot;c&quot;</span>.equals(s));</span><br><span class="line">        System.out.println(JSONObject.toJSONString(list));</span><br><span class="line">    &#125;</span><br><span class="line">异常操作</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">list.removeIf(s -&gt; <span class="string">&quot;a&quot;</span>.equals(s) || <span class="string">&quot;c&quot;</span>.equals(s));</span><br><span class="line">System.out.println(JSONObject.toJSONString(list));</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.UnsupportedOperationException</span><br><span class="line">        原因</span><br><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;varargs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T &gt; List &lt; T &gt; asList(T...a)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span> include</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractList做任何操作都是异常</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">( <span class="keyword">int</span> index, E element)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation always throws an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException     &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span> <span class="params">( <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line">修改</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String [] str=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;abcd&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; strs = Arrays.asList(str);</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.addAll(strs);</span><br><span class="line">list.removeIf(s-&gt;<span class="string">&quot;a&quot;</span>.equals(s)||<span class="string">&quot;c&quot;</span>.equals(s));</span><br><span class="line">System.out.println(JSONObject.toJSONString(list));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;方法一：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    
    <category term="List遍历删除" scheme="https://zkkget.github.io/tags/List%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4/"/>
    
  </entry>
  
  <entry>
    <title>Mysql海量数据存储与优化</title>
    <link href="https://zkkget.github.io/posts/20220725cl89v5wvl000dt4ujhfbhdsov.html"/>
    <id>https://zkkget.github.io/posts/20220725cl89v5wvl000dt4ujhfbhdsov.html</id>
    <published>2022-07-25T08:17:47.000Z</published>
    <updated>2022-07-25T08:24:40.644Z</updated>
    
    <content type="html"><![CDATA[<p>我坚信，机会永远属于有准备的人，我们与其羡慕他人的成功，不如从此刻起，积累足够多的知识和面试经验，为将来进入更好的公司做充足的准备<br>本片文章将会根据资料学习深入Mysql的设计与优化<br>1、Mysql基础知识</p><p>2、Mysql架构原理和存储机制</p><p>3、Mysql高可用方案</p><p>4、Mysql企业面试真题分享</p><p>Mysql基础知识<br>MySQL起源和分支<br>MySQL 是最流行的关系型数据库软件之一，由于其体积小、速度快、开源免费、简单易用、维护成本<br>低等，在集群架构中易于扩展、高可用，因此深受开发者和企业的欢迎。<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql1.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql2.jpg" alt="流程"></p><p>MySQL体系架构<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql3.jpg" alt="流程"></p><p>MySQL Server架构自顶向下大致可以分网络连接层、服务层、存储引擎层和系统文件层。<br>一、网络连接层<br>客户端连接器（Client Connectors）：提供与MySQL服务器建立的支持。目前几乎支持所有主流<br>的服务端编程技术，例如常见的 Java、C、Python、.NET等，它们通过各自API技术与MySQL建立<br>连接。<br>二、服务层（MySQL Server）<br>服务层是MySQL Server的核心，主要包含系统管理和控制工具、连接池、SQL接口、解析器、查询优<br>化器和缓存六个部分。<br>连接池（Connection Pool）：负责存储和管理客户端与数据库的连接，一个线程负责管理一个连接。<br>系统管理和控制工具（Management Services &amp; Utilities）：例如备份恢复、安全管理、集群<br>管理等<br>SQL接口（SQL Interface）：用于接受客户端发送的各种SQL命令，并且返回用户需要查询的结<br>果。比如DML、DDL、存储过程、视图、触发器等。<br>解析器（Parser）：负责将请求的SQL解析生成一个”解析树”。然后根据一些MySQL规则进一步<br>检查解析树是否合法。<br>查询优化器（Optimizer）：当“解析树”通过解析器语法检查后，将交由优化器将其转化成执行计<br>划，然后与存储引擎交互。<br>select uid,name from user where gender=1;<br>选取–》投影–》联接 策略<br>1）select先根据where语句进行选取，并不是查询出全部数据再过滤<br>2）select查询根据uid和name进行属性投影，并不是取出所有字段<br>3）将前面选取和投影联接起来最终生成查询结果<br>缓存（Cache&amp;Buffer）： 缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，权限缓<br>存，引擎缓存等。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。<br>三、存储引擎层（Pluggable Storage Engines）<br>存储引擎负责MySQL中数据的存储与提取，与底层系统文件进行交互。MySQL存储引擎是插件式的，<br>服务器中的查询执行引擎通过接口与存储引擎进行通信，接口屏蔽了不同存储引擎之间的差异 。现在有<br>很多种存储引擎，各有各的特点，最常见的是MyISAM和InnoDB。<br>四、系统文件层（File System）<br>该层负责将数据库的数据和日志存储在文件系统之上，并完成与存储引擎的交互，是文件的物理存储<br>层。主要包含日志文件，数据文件，配置文件，pid 文件，socket 文件等。<br>日志文件<br>错误日志（Error log）<br>默认开启，show variables like ‘%log_error%’<br>通用查询日志（General query log）<br>记录一般查询语句，show variables like ‘%general%’;<br>二进制日志（binary log）<br>记录了对MySQL数据库执行的更改操作，并且记录了语句的发生时间、执行时长；但是它不<br>记录select、show等不修改数据库的SQL。主要用于数据库恢复和主从复制。<br>show variables like ‘%log_bin%’; //是否开启<br>show variables like ‘%binlog%’; //参数查看<br>show binary logs;//查看日志文件<br>慢查询日志（Slow query log）<br>记录所有执行时间超时的查询SQL，默认是10秒。<br>show variables like ‘%slow_query%’; //是否开启<br>show variables like ‘%long_query_time%’; //时长<br>配置文件<br>用于存放MySQL所有的配置信息文件，比如my.cnf、my.ini等。<br>数据文件<br>db.opt 文件：记录这个库的默认使用的字符集和校验规则。<br>frm 文件：存储与表相关的元数据（meta）信息，包括表结构的定义信息等，每一张表都会<br>有一个frm 文件。<br>MYD 文件：MyISAM 存储引擎专用，存放 MyISAM 表的数据（data)，每一张表都会有一个<br>.MYD 文件。<br>MYI 文件：MyISAM 存储引擎专用，存放 MyISAM 表的索引相关信息，每一张 MyISAM 表对<br>应一个 .MYI 文件。<br>ibd文件和 IBDATA 文件：存放 InnoDB 的数据文件（包括索引）。InnoDB 存储引擎有两种<br>表空间方式：独享表空间和共享表空间。独享表空间使用 .ibd 文件来存放数据，且每一张<br>InnoDB 表对应一个 .ibd 文件。共享表空间使用 .ibdata 文件，所有表共同使用一个（或多<br>个，自行配置）.ibdata 文件。<br>ibdata1 文件：系统表空间数据文件，存储表元数据、Undo日志等 。<br>ib_logfile0、ib_logfile1 文件：Redo log 日志文件。<br>pid 文件<br>pid 文件是 mysqld 应用程序在 Unix/Linux 环境下的一个进程文件，和许多其他 Unix/Linux 服务<br>端程序一样，它存放着自己的进程 id。<br>socket 文件<br>socket 文件也是在 Unix/Linux 环境下才有的，用户在 Unix/Linux 环境下客户端连接可以不通过<br>TCP/IP 网络而直接使用 Unix Socket 来连接 MySQL</p><p>MySQL运行机制<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql4.jpg" alt="流程"></p><p>①建立连接（Connectors&amp;Connection Pool），通过客户端/服务器通信协议与MySQL建立连<br>接。MySQL 客户端与服务端的通信方式是 “ 半双工 ”。对于每一个 MySQL 的连接，时刻都有一个<br>线程状态来标识这个连接正在做什么。<br>通讯机制：<br>全双工：能同时发送和接收数据，例如平时打电话。<br>半双工：指的某一时刻，要么发送数据，要么接收数据，不能同时。例如早期对讲机<br>单工：只能发送数据或只能接收数据。例如单行道<br>线程状态：<br>show processlist; //查看用户正在运行的线程信息，root用户能查看所有线程，其他用户只能看自<br>己的<br>id：线程ID，可以使用kill xx；<br>user：启动这个线程的用户<br>Host：发送请求的客户端的IP和端口号<br>db：当前命令在哪个库执行<br>Command：该线程正在执行的操作命令<br>Create DB：正在创建库操作<br>Drop DB：正在删除库操作<br>Execute：正在执行一个PreparedStatement<br>Close Stmt：正在关闭一个PreparedStatement<br>Query：正在执行一个语句<br>Sleep：正在等待客户端发送语句<br>Quit：正在退出<br>Shutdown：正在关闭服务器<br>Time：表示该线程处于当前状态的时间，单位是秒<br>State：线程状态<br>Updating：正在搜索匹配记录，进行修改<br>Sleeping：正在等待客户端发送新请求<br>Starting：正在执行请求处理<br>Checking table：正在检查数据表<br>Closing table : 正在将表中数据刷新到磁盘中<br>Locked：被其他查询锁住了记录<br>Sending Data：正在处理Select查询，同时将结果发送给客户端<br>Info：一般记录线程执行的语句，默认显示前100个字符。想查看完整的使用show full<br>processlist;<br>②查询缓存（Cache&amp;Buffer），这是MySQL的一个可优化查询的地方，如果开启了查询缓存且在<br>查询缓存过程中查询到完全相同的SQL语句，则将查询结果直接返回给客户端；如果没有开启查询<br>缓存或者没有查询到完全相同的 SQL 语句则会由解析器进行语法语义解析，并生成“解析树”。<br>缓存Select查询的结果和SQL语句<br>执行Select查询时，先查询缓存，判断是否存在可用的记录集，要求是否完全相同（包括参<br>数值），这样才会匹配缓存数据命中。<br>即使开启查询缓存，以下SQL也不能缓存<br>查询语句使用SQL_NO_CACHE<br>查询的结果大于query_cache_limit设置<br>查询中有一些不确定的参数，比如now()<br>show variables like ‘%query_cache%’; //查看查询缓存是否启用，空间大小，限制等<br>show status like ‘Qcache%’; //查看更详细的缓存参数，可用缓存空间，缓存块，缓存多少等<br>③解析器（Parser）将客户端发送的SQL进行语法解析，生成”解析树”。预处理器根据一些MySQL<br>规则进一步检查“解析树”是否合法，例如这里将检查数据表和数据列是否存在，还会解析名字和别<br>名，看看它们是否有歧义，最后生成新的“解析树”。<br>④查询优化器（Optimizer）根据“解析树”生成最优的执行计划。MySQL使用很多优化策略生成最<br>优的执行计划，可以分为两类：静态优化（编译时优化）、动态优化（运行时优化）。<br>等价变换策略<br>5=5 and a&gt;5 改成 a &gt; 5<br>a &lt; b and a=5 改成b&gt;5 and a=5<br>基于联合索引，调整条件位置等<br>优化count、min、max等函数<br>InnoDB引擎min函数只需要找索引最左边<br>InnoDB引擎max函数只需要找索引最右边<br>MyISAM引擎count(*)，不需要计算，直接返回<br>提前终止查询<br>使用了limit查询，获取limit所需的数据，就不在继续遍历后面数据<br>in的优化<br>MySQL对in查询，会先进行排序，再采用二分法查找数据。比如where id in (2,1,3)，变<br>成 in (1,2,3)<br>⑤查询执行引擎负责执行 SQL 语句，此时查询执行引擎会根据 SQL 语句中表的存储引擎类型，以<br>及对应的API接口与底层存储引擎缓存或者物理文件的交互，得到查询结果并返回给客户端。若开<br>启用查询缓存，这时会将SQL 语句和结果完整地保存到查询缓存（Cache&amp;Buffer）中，以后若有<br>相同的 SQL 语句执行则直接返回结果。<br>如果开启了查询缓存，先将查询结果做缓存操作<br>返回结果过多，采用增量模式返回</p><p>MySQL存储引擎<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql5.jpg" alt="流程"></p><p>存储引擎在MySQL的体系架构中位于第三层，负责MySQL中的数据的存储和提取，是与文件打交道的<br>子系统，它是根据MySQL提供的文件访问层抽象接口定制的一种文件访问机制，这种机制就叫作存储引<br>擎。<br>使用show engines命令，就可以查看当前数据库支持的引擎信息。<br>在5.5版本之前默认采用MyISAM存储引擎，从5.5开始采用InnoDB存储引擎。<br>InnoDB：支持事务，具有提交，回滚和崩溃恢复能力，事务安全<br>MyISAM：不支持事务和外键，访问速度快<br>Memory：利用内存创建表，访问速度非常快，因为数据在内存，而且默认使用Hash索引，但是<br>一旦关闭，数据就会丢失<br>Archive：归档类型引擎，仅能支持insert和select语句<br>Csv：以CSV文件进行数据存储，由于文件限制，所有列必须强制指定not null，另外CSV引擎也不<br>支持索引和分区，适合做数据交换的中间表<br>BlackHole: 黑洞，只进不出，进来消失，所有插入数据都不会保存<br>Federated：可以访问远端MySQL数据库中的表。一个本地表，不保存数据，访问远程表内容。<br>MRG_MyISAM：一组MyISAM表的组合，这些MyISAM表必须结构相同，Merge表本身没有数据，<br>对Merge操作可以对一组MyISAM表进行操作。<br>3.1 InnoDB和MyISAM对比<br>InnoDB和MyISAM是使用MySQL时最常用的两种引擎类型，我们重点来看下两者区别。<br>事务和外键<br>InnoDB支持事务和外键，具有安全性和完整性，适合大量insert或update操作<br>MyISAM不支持事务和外键，它提供高速存储和检索，适合大量的select查询操作<br>锁机制<br>InnoDB支持行级锁，锁定指定记录。基于索引来加锁实现。<br>MyISAM支持表级锁，锁定整张表。<br>索引结构<br>InnoDB使用聚集索引（聚簇索引），索引和记录在一起存储，既缓存索引，也缓存记录。<br>MyISAM使用非聚集索引（非聚簇索引），索引和记录分开。<br>并发处理能力<br>MyISAM使用表锁，会导致写操作并发率低，读之间并不阻塞，读写阻塞。<br>InnoDB读写阻塞可以与隔离级别有关，可以采用多版本并发控制（MVCC）来支持高并发<br>存储文件<br>InnoDB表对应两个文件，一个.frm表结构文件，一个.ibd数据文件。InnoDB表最大支持64TB；<br>MyISAM表对应三个文件，一个.frm表结构文件，一个MYD表数据文件，一个.MYI索引文件。从<br>MySQL5.0开始默认限制是256TB。<br>适用场景<br>MyISAM<br>不需要事务支持（不支持）<br>并发相对较低（锁定机制问题）<br>数据修改相对较少，以读为主<br>数据一致性要求不高<br>InnoDB<br>需要事务支持（具有较好的事务特性）<br>行级锁定对高并发有很好的适应能力<br>数据更新较为频繁的场景<br>数据一致性要求较高<br>硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，减少磁盘IO<br>总结<br>两种引擎该如何选择？<br>是否需要事务？有，InnoDB<br>是否存在并发修改？有，InnoDB<br>是否追求快速查询，且数据修改少？是，MyISAM<br>在绝大多数情况下，推荐使用InnoDB</p><p>InnoDB存储结构<br>从MySQL 5.5版本开始默认使用InnoDB作为引擎，它擅长处理事务，具有自动崩溃恢复的特性，在日<br>常开发中使用非常广泛。下面是官方的InnoDB引擎架构图，主要分为内存结构和磁盘结构两大部分</p><p>内存结构主要包括Buffer Pool、Change Buffer、Adaptive Hash Index和Log Buffer四大组件。<br>Buffer Pool：缓冲池，简称BP。BP以Page页为单位，默认大小16K，BP的底层采用链表数<br>据结构管理Page。在InnoDB访问表记录和索引时会在Page页中缓存，以后使用可以减少磁<br>盘IO操作，提升效率。<br>Page管理机制<br>Page根据状态可以分为三种类型：<br>free page ： 空闲page，未被使用<br>clean page：被使用page，数据没有被修改过<br>dirty page：脏页，被使用page，数据被修改过，页中数据和磁盘的数据产生了不<br>一致<br>针对上述三种page类型，InnoDB通过三种链表结构来维护和管理<br>free list ：表示空闲缓冲区，管理free page<br>flush list：表示需要刷新到磁盘的缓冲区，管理dirty page，内部page按修改时间<br>排序。脏页即存在于flush链表，也在LRU链表中，但是两种互不影响，LRU链表负<br>责管理page的可用性和释放，而flush链表负责管理脏页的刷盘操作。<br>lru list：表示正在使用的缓冲区，管理clean page和dirty page，缓冲区以<br>midpoint为基点，前面链表称为new列表区，存放经常访问的数据，占63%；后<br>面的链表称为old列表区，存放使用较少数据，占37%。<br>改进型LRU算法维护<br>普通LRU：末尾淘汰法，新数据从链表头部加入，释放空间时从末尾淘汰<br>改性LRU：链表分为new和old两个部分，加入元素时并不是从表头插入，而是从中间<br>midpoint位置插入，如果数据很快被访问，那么page就会向new列表头部移动，如果<br>数据没有被访问，会逐步向old尾部移动，等待淘汰。<br>每当有新的page数据读取到buffer pool时，InnoDb引擎会判断是否有空闲页，是否足<br>够，如果有就将free page从free list列表删除，放入到LRU列表中。没有空闲页，就会<br>根据LRU算法淘汰LRU链表默认的页，将内存空间释放分配给新的页。<br>Buffer Pool配置参数<br>show variables like ‘%innodb_page_size%’; //查看page页大小<br>show variables like ‘%innodb_old%’; //查看lru list中old列表参数<br>show variables like ‘%innodb_buffer%’; //查看buffer pool参数<br>建议：将innodb_buffer_pool_size设置为总内存大小的60%-80%，<br>innodb_buffer_pool_instances可以设置为多个，这样可以避免缓存争夺。<br>Change Buffer：写缓冲区，简称CB。在进行DML操作时，如果BP没有其相应的Page数据，<br>并不会立刻将磁盘页加载到缓冲池，而是在CB记录缓冲变更，等未来数据被读取时，再将数<br>据合并恢复到BP中。<br>ChangeBuffer占用BufferPool空间，默认占25%，最大允许占50%，可以根据读写业务量来<br>进行调整。参数innodb_change_buffer_max_size;<br>当更新一条记录时，该记录在BufferPool存在，直接在BufferPool修改，一次内存操作。如<br>果该记录在BufferPool不存在（没有命中），会直接在ChangeBuffer进行一次内存操作，不<br>用再去磁盘查询数据，避免一次磁盘IO。当下次查询记录时，会先进性磁盘读取，然后再从<br>ChangeBuffer中读取信息合并，最终载入BufferPool中。<br>写缓冲区，仅适用于非唯一普通索引页，为什么？<br>如果在索引设置唯一性，在进行修改时，InnoDB必须要做唯一性校验，因此必须查询磁盘，<br>做一次IO操作。会直接将记录查询到BufferPool中，然后在缓冲池修改，不会在<br>ChangeBuffer操作。<br>Adaptive Hash Index：自适应哈希索引，用于优化对BP数据的查询。InnoDB存储引擎会监<br>控对表索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，所以<br>称之为自适应。InnoDB存储引擎会自动根据访问的频率和模式来为某些页建立哈希索引。<br>Log Buffer：日志缓冲区，用来保存要写入磁盘上log文件（Redo/Undo）的数据，日志缓冲<br>区的内容定期刷新到磁盘log文件中。日志缓冲区满时会自动将其刷新到磁盘，当遇到BLOB<br>或多行更新的大事务操作时，增加日志缓冲区可以节省磁盘I/O。<br>LogBuffer主要是用于记录InnoDB引擎日志，在DML操作时会产生Redo和Undo日志。<br>LogBuffer空间满了，会自动写入磁盘。可以通过将innodb_log_buffer_size参数调大，减少<br>磁盘IO频率<br>innodb_flush_log_at_trx_commit参数控制日志刷新行为，默认为1<br>0 ： 每隔1秒写日志文件和刷盘操作（写日志文件LogBuffer–&gt;OS cache，刷盘OS<br>cache–&gt;磁盘文件），最多丢失1秒数据<br>1：事务提交，立刻写日志文件和刷盘，数据不丢失，但是会频繁IO操作<br>2：事务提交，立刻写日志文件，每隔1秒钟进行刷盘操作</p><p>InnoDB磁盘结构<br>InnoDB磁盘主要包含Tablespaces，InnoDB Data Dictionary，Doublewrite Buffer、Redo Log<br>和Undo Logs。<br>表空间（Tablespaces）：用于存储表结构和数据。表空间又分为系统表空间、独立表空间、<br>通用表空间、临时表空间、Undo表空间等多种类型；<br>系统表空间（The System Tablespace）<br>包含InnoDB数据字典，Doublewrite Buffer，Change Buffer，Undo Logs的存储区<br>域。系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。系统表空<br>间是一个共享的表空间因为它是被多个表共享的。该空间的数据文件通过参数<br>innodb_data_file_path控制，默认值是ibdata1:12M:autoextend(文件名为ibdata1、<br>12MB、自动扩展)。<br>独立表空间（File-Per-Table Tablespaces）<br>默认开启，独立表空间是一个单表表空间，该表创建于自己的数据文件中，而非创建于<br>系统表空间中。当innodb_file_per_table选项开启时，表将被创建于表空间中。否则，<br>innodb将被创建于系统表空间中。每个表文件表空间由一个.ibd数据文件代表，该文件<br>默认被创建于数据库目录中。表空间的表文件支持动态（dynamic）和压缩<br>（commpressed）行格式。<br>通用表空间（General Tablespaces）<br>通用表空间为通过create tablespace语法创建的共享表空间。通用表空间可以创建于<br>mysql数据目录外的其他表空间，其可以容纳多张表，且其支持所有的行格式。<br>撤销表空间（Undo Tablespaces）<br>撤销表空间由一个或多个包含Undo日志文件组成。在MySQL 5.7版本之前Undo占用的<br>是System Tablespace共享区，从5.7开始将Undo从System Tablespace分离了出来。<br>InnoDB使用的undo表空间由innodb_undo_tablespaces配置选项控制，默认为0。参<br>数值为0表示使用系统表空间ibdata1;大于0表示使用undo表空间undo_001、<br>undo_002等。<br>临时表空间（Temporary Tablespaces） CREATE TABLESPACE ts1 ADD DATAFILE ts1.ibd Engine=InnoDB; //创建表空 间ts1 CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1; //将表添加到ts1 表空间<br>分为session temporary tablespaces 和global temporary tablespace两种。session<br>temporary tablespaces 存储的是用户创建的临时表和磁盘内部的临时表。global<br>temporary tablespace储存用户临时表的回滚段（rollback segments ）。mysql服务<br>器正常关闭或异常终止时，临时表空间将被移除，每次启动时会被重新创建。<br>数据字典（InnoDB Data Dictionary）<br>InnoDB数据字典由内部系统表组成，这些表包含用于查找表、索引和表字段等对象的元数<br>据。元数据物理上位于InnoDB系统表空间中。由于历史原因，数据字典元数据在一定程度上<br>与InnoDB表元数据文件（.frm文件）中存储的信息重叠。<br>双写缓冲区（Doublewrite Buffer）<br>位于系统表空间，是一个存储区域。在BufferPage的page页刷新到磁盘真正的位置前，会先<br>将数据存在Doublewrite 缓冲区。如果在page页写入过程中出现操作系统、存储子系统或<br>mysqld进程崩溃，InnoDB可以在崩溃恢复期间从Doublewrite 缓冲区中找到页面的一个好<br>备份。在大多数情况下，默认情况下启用双写缓冲区，要禁用Doublewrite 缓冲区，可以将<br>innodb_doublewrite设置为0。使用Doublewrite 缓冲区时建议将innodb_flush_method设<br>置为O_DIRECT。<br>MySQL的innodb_flush_method这个参数控制着innodb数据文件及redo log的打开、<br>刷写模式。有三个值：fdatasync(默认)，O_DSYNC，O_DIRECT。设置O_DIRECT表示<br>数据文件写入操作会通知操作系统不要缓存数据，也不要用预读，直接从Innodb<br>Buffer写到磁盘文件。<br>默认的fdatasync意思是先写入操作系统缓存，然后再调用fsync()函数去异步刷数据文<br>件与redo log的缓存信息。<br>重做日志（Redo Log）<br>重做日志是一种基于磁盘的数据结构，用于在崩溃恢复期间更正不完整事务写入的数据。<br>MySQL以循环方式写入重做日志文件，记录InnoDB中所有对Buffer Pool修改的日志。当出<br>现实例故障（像断电），导致数据未能更新到数据文件，则数据库重启时须redo，重新把数<br>据更新到数据文件。读写事务在执行的过程中，都会不断的产生redo log。默认情况下，重<br>做日志在磁盘上由两个名为ib_logfile0和ib_logfile1的文件物理表示。<br>撤销日志（Undo Logs）<br>撤消日志是在事务开始之前保存的被修改数据的备份，用于例外情况时回滚事务。撤消日志<br>属于逻辑日志，根据每行记录进行记录。撤消日志存在于系统表空间、撤消表空间和临时表<br>空间中。<br>MySQL 5.7 版本<br>将 Undo日志表空间从共享表空间 ibdata 文件中分离出来，可以在安装 MySQL 时由用<br>户自行指定文件大小和数量。<br>增加了 temporary 临时表空间，里面存储着临时表或临时查询结果集的数据。<br>Buffer Pool 大小可以动态修改，无需重启数据库实例。<br>MySQL 8.0 版本<br>将InnoDB表的数据字典和Undo都从共享表空间ibdata中彻底分离出来了，以前需要<br>ibdata中数据字典与独立表空间ibd文件中数据字典一致才行，8.0版本就不需要了。<br>temporary 临时表空间也可以配置多个物理文件，而且均为 InnoDB 存储引擎并能创建<br>索引，这样加快了处理的速度。<br>用户可以像 Oracle 数据库那样设置一些表空间，每个表空间对应多个物理文件，每个<br>表空间可以给多个表使用，但一个表只能存储在一个表空间中。<br>将Doublewrite Buffer从共享表空间ibdata中也分离出来了</p><p>InnoDB线程模型<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql6.jpg" alt="流程"></p><p>IO Thread<br>在InnoDB中使用了大量的AIO（Async IO）来做读写处理，这样可以极大提高数据库的性能。在<br>InnoDB1.0版本之前共有4个IO Thread，分别是write，read，insert buffer和log thread，后来<br>版本将read thread和write thread分别增大到了4个，一共有10个了。<br>read thread ： 负责读取操作，将数据从磁盘加载到缓存page页。4个<br>write thread：负责写操作，将缓存脏页刷新到磁盘。4个<br>log thread：负责将日志缓冲区内容刷新到磁盘。1个<br>insert buffer thread ：负责将写缓冲内容刷新到磁盘。1个<br>Purge Thread<br>事务提交之后，其使用的undo日志将不再需要，因此需要Purge Thread回收已经分配的undo<br>页。<br>show variables like ‘%innodb_purge_threads%’;<br>Page Cleaner Thread<br>作用是将脏数据刷新到磁盘，脏数据刷盘后相应的redo log也就可以覆盖，即可以同步数据，又能<br>达到redo log循环使用的目的。会调用write thread线程处理。<br>show variables like ‘%innodb_page_cleaners%’;<br>Master Thread<br>Master thread是InnoDB的主线程，负责调度其他各线程，优先级最高。作用是将缓冲池中的数<br>据异步刷新到磁盘 ，保证数据的一致性。包含：脏页的刷新（page cleaner thread）、undo页<br>回收（purge thread）、redo日志刷新（log thread）、合并写缓冲等。内部有两个主处理，分别<br>是每隔1秒和10秒处理。<br>每1秒的操作：<br>刷新日志缓冲区，刷到磁盘<br>合并写缓冲区数据，根据IO读写压力来决定是否操作<br>刷新脏页数据到磁盘，根据脏页比例达到75%才操作（innodb_max_dirty_pages_pct，<br>innodb_io_capacity） 每10秒的操作：<br>刷新脏页数据到磁盘<br>合并写缓冲区数据<br>刷新日志缓冲区<br>删除无用的undo页</p><p>Undolog and binlog and redoLog<br>Undo Log<br>3.5.1 Undo Log介绍<br>Undo：意为撤销或取消，以撤销操作为目的，返回指定某个状态的操作。<br>Undo Log：数据库事务开始之前，会将要修改的记录存放到 Undo 日志里，当事务回滚时或者数<br>据库崩溃时，可以利用 Undo 日志，撤销未提交事务对数据库产生的影响。<br>Undo Log产生和销毁：Undo Log在事务开始前产生；事务在提交时，并不会立刻删除undo<br>log，innodb会将该事务对应的undo log放入到删除列表中，后面会通过后台线程purge thread进<br>行回收处理。Undo Log属于逻辑日志，记录一个变化过程。例如执行一个delete，undolog会记<br>录一个insert；执行一个update，undolog会记录一个相反的update。<br>Undo Log存储：undo log采用段的方式管理和记录。在innodb数据文件中包含一种rollback<br>segment回滚段，内部包含1024个undo log segment。可以通过下面一组参数来控制Undo log存<br>储。<br>3.5.2 Undo Log作用<br>实现事务的原子性<br>Undo Log 是为了实现事务的原子性而出现的产物。事务处理过程中，如果出现了错误或者用户执<br>行了 ROLLBACK 语句，MySQL 可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。<br>实现多版本并发控制（MVCC）<br>Undo Log 在 MySQL InnoDB 存储引擎中用来实现多版本并发控制。事务未提交之前，Undo Log<br>保存了未提交之前的版本数据，Undo Log 中的数据可作为数据旧版本快照供其他并发事务进行快<br>照读。<br>事务A手动开启事务，执行更新操作，首先会把更新命中的数据备份到 Undo Buffer 中。<br>事务B手动开启事务，执行查询操作，会读取 Undo 日志数据返回，进行快照读<br>3.6 Redo Log和Binlog<br>Redo Log和Binlog是MySQL日志系统中非常重要的两种机制，也有很多相似之处，下面介绍下两者细<br>节和区别。<br>3.6.1 Redo Log日志<br>Redo Log介绍<br>show variables like ‘%innodb_undo%’;<br>Redo：顾名思义就是重做。以恢复操作为目的，在数据库发生意外时重现操作。<br>Redo Log：指事务中修改的任何数据，将最新的数据备份存储的位置（Redo Log），被称为重做<br>日志。<br>Redo Log 的生成和释放：随着事务操作的执行，就会生成Redo Log，在事务提交时会将产生<br>Redo Log写入Log Buffer，并不是随着事务的提交就立刻写入磁盘文件。等事务操作的脏页写入<br>到磁盘之后，Redo Log 的使命也就完成了，Redo Log占用的空间就可以重用（被覆盖写入）。<br>Redo Log工作原理<br>Redo Log 是为了实现事务的持久性而出现的产物。防止在发生故障的时间点，尚有脏页未写入表<br>的 IBD 文件中，在重启 MySQL 服务的时候，根据 Redo Log 进行重做，从而达到事务的未入磁盘<br>数据进行持久化这一特性。<br>Redo Log写入机制<br>Redo Log 文件内容是以顺序循环的方式写入文件，写满时则回溯到第一个文件，进行覆盖写。<br>如图所示：<br>write pos 是当前记录的位置，一边写一边后移，写到最后一个文件末尾后就回到 0 号文件开<br>头；<br>checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数<br>据文件；<br>write pos 和 checkpoint 之间还空着的部分，可以用来记录新的操作。如果 write pos 追上<br>checkpoint，表示写满，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint<br>推进一下。<br>Redo Log相关配置参数<br>每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组至少有2个重做日志文<br>件，默认为ib_logfile0和ib_logfile1。可以通过下面一组参数控制Redo Log存储：<br>show variables like ‘%innodb_log%’;<br>Redo Buffer 持久化到 Redo Log 的策略，可通过 Innodb_flush_log_at_trx_commit 设置：<br>0：每秒提交 Redo buffer -&gt;OS cache -&gt; flush cache to disk，可能丢失一秒内的事务数<br>据。由后台Master线程每隔 1秒执行一次操作。<br>1（默认值）：每次事务提交执行 Redo Buffer -&gt; OS cache -&gt; flush cache to disk，最安<br>全，性能最差的方式。<br>2：每次事务提交执行 Redo Buffer -&gt; OS cache，然后由后台Master线程再每隔1秒执行OS<br>cache -&gt; flush cache to disk 的操作。<br>一般建议选择取值2，因为 MySQL 挂了数据没有损失，整个服务器挂了才会损失1秒的事务提交数<br>据。<br>3.6.2 Binlog日志<br>Binlog记录模式<br>Redo Log 是属于InnoDB引擎所特有的日志，而MySQL Server也有自己的日志，即 Binary<br>log（二进制日志），简称Binlog。Binlog是记录所有数据库表结构变更以及表数据修改的二进制<br>日志，不会记录SELECT和SHOW这类操作。Binlog日志是以事件形式记录，还包含语句所执行的<br>消耗时间。开启Binlog日志有以下两个最重要的使用场景。<br>主从复制：在主库中开启Binlog功能，这样主库就可以把Binlog传递给从库，从库拿到<br>Binlog后实现数据恢复达到主从数据一致性。<br>数据恢复：通过mysqlbinlog工具来恢复数据。<br>Binlog文件名默认为“主机名_binlog-序列号”格式，例如oak_binlog-000001，也可以在配置文件<br>中指定名称。文件记录模式有STATEMENT、ROW和MIXED三种，具体含义如下。<br>ROW（row-based replication, RBR）：日志中会记录每一行数据被修改的情况，然后在<br>slave端对相同的数据进行修改。<br>优点：能清楚记录每一个行数据的修改细节，能完全实现主从数据同步和数据的恢复。<br>缺点：批量操作，会产生大量的日志，尤其是alter table会让日志暴涨。<br>STATMENT（statement-based replication, SBR）：每一条被修改数据的SQL都会记录到<br>master的Binlog中，slave在复制的时候SQL进程会解析成和原来master端执行过的相同的<br>SQL再次执行。简称SQL语句复制。<br>优点：日志量小，减少磁盘IO，提升存储和恢复速度<br>缺点：在某些情况下会导致主从数据不一致，比如last_insert_id()、now()等函数。<br>MIXED（mixed-based replication, MBR）：以上两种模式的混合使用，一般会使用<br>STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存<br>binlog，MySQL会根据执行的SQL语句选择写入模式。<br>Binlog文件结构<br>MySQL的binlog文件中记录的是对数据库的各种修改操作，用来表示修改操作的数据结构是Log<br>event。不同的修改操作对应的不同的log event。比较常用的log event有：Query event、Row event、Xid event等。binlog文件的内容就是各种Log event的集合。<br>Binlog文件中Log event结构如下图所示：<br>Binlog写入机制<br>根据记录模式和操作触发event事件生成log event（事件触发执行机制）<br>将事务执行过程中产生log event写入缓冲区，每个事务线程都有一个缓冲区<br>Log Event保存在一个binlog_cache_mngr数据结构中，在该结构中有两个缓冲区，一个是<br>stmt_cache，用于存放不支持事务的信息；另一个是trx_cache，用于存放支持事务的信息。<br>事务在提交阶段会将产生的log event写入到外部binlog文件中。<br>不同事务以串行方式将log event写入binlog文件中，所以一个事务包含的log event信息在<br>binlog文件中是连续的，中间不会插入其他事务的log event。<br>Binlog文件操作<br>Binlog状态查看<br>show variables like ‘log_bin’;<br>开启Binlog功能<br>mysql&gt; set global log_bin=mysqllogbin; ERROR 1238 (HY000): Variable ‘log_bin’ is a read only variable<br>需要修改my.cnf或my.ini配置文件，在[mysqld]下面增加log_bin=mysql_bin_log，重启<br>MySQL服务。<br>#log-bin=ON #log-bin-basename=mysqlbinlog binlog-format=ROW log-bin=mysqlbinlog<br>使用show binlog events命令<br>show binary logs; //等价于show master logs; show master status; show binlog events; show binlog events in ‘mysqlbinlog.000001’;<br>使用mysqlbinlog 命令<br>mysqlbinlog “文件名” mysqlbinlog “文件名” &gt; “test.sql”<br>使用 binlog 恢复数据<br>//按指定时间恢复 mysqlbinlog –start-datetime=”2020-04-25 18:00:00” –stop- datetime=”2020-04-26 00:00:00” mysqlbinlog.000002 | mysql -uroot -p1234 //按事件位置号恢复 mysqlbinlog –start-position=154 –stop-position=957 mysqlbinlog.000002 | mysql -uroot -p1234<br>mysqldump：定期全部备份数据库数据。mysqlbinlog可以做增量备份和恢复操作。<br>删除Binlog文件<br>purge binary logs to ‘mysqlbinlog.000001’; //删除指定文件 purge binary logs before ‘2020-04-28 00:00:00’; //删除指定时间之前的文件 reset master; //清除所有文件<br>可以通过设置expire_logs_days参数来启动自动清理功能。默认值为0表示没启用。设置为1表示超<br>出1天binlog文件会自动删除掉。<br>Redo Log和Binlog区别<br>Redo Log是属于InnoDB引擎功能，Binlog是属于MySQL Server自带功能，并且是以二进制<br>文件记录。<br>Redo Log属于物理日志，记录该数据页更新状态内容，Binlog是逻辑日志，记录更新过程。<br>Redo Log日志是循环写，日志空间大小是固定，Binlog是追加写入，写完一个写下一个，不<br>会覆盖使用。<br>Redo Log作为服务器异常宕机后事务数据自动恢复使用，Binlog可以作为主从复制和数据恢<br>复使用。Binlog没有自动crash-safe能力。</p><p>MySQL索引原理<br>索引类型<br>索引可以提升查询速度，会影响where查询，以及order by排序。MySQL索引类型如下：<br>从索引存储结构划分：B Tree索引、Hash索引、FULLTEXT全文索引、R Tree索引<br>从应用层次划分：普通索引、唯一索引、主键索引、复合索引<br>从索引键值类型划分：主键索引、辅助索引（二级索引）<br>从数据存储和索引键值逻辑关系划分：聚集索引（聚簇索引）、非聚集索引（非聚簇索引）<br>普通索引<br>这是最基本的索引类型，基于普通字段建立的索引，没有任何限制。<br>创建普通索引的方法如下：<br>CREATE INDEX &lt;索引的名字&gt; ON tablename (字段名);<br>ALTER TABLE tablename ADD INDEX [索引的名字] (字段名);<br>CREATE TABLE tablename ( […], INDEX [索引的名字] (字段名) );<br>1.2 唯一索引<br>与”普通索引”类似，不同的就是：索引字段的值必须唯一，但允许有空值 。在创建或修改表时追加唯一<br>约束，就会自动创建对应的唯一索引。<br>创建唯一索引的方法如下：<br>CREATE UNIQUE INDEX &lt;索引的名字&gt; ON tablename (字段名);<br>ALTER TABLE tablename ADD UNIQUE INDEX [索引的名字] (字段名);<br>CREATE TABLE tablename ( […], UNIQUE [索引的名字] (字段名) ;<br>1.3 主键索引<br>它是一种特殊的唯一索引，不允许有空值。在创建或修改表时追加主键约束即可，每个表只能有一个主<br>键。<br>创建主键索引的方法如下：<br>CREATE TABLE tablename ( […], PRIMARY KEY (字段名) );<br>ALTER TABLE tablename ADD PRIMARY KEY (字段名);<br>1.4 复合索引<br>单一索引是指索引列为一列的情况，即新建索引的语句只实施在一列上；用户可以在多个列上建立索<br>引，这种索引叫做组复合索引（组合索引）。复合索引可以代替多个单一索引，相比多个单一索引复合<br>索引所需的开销更小。<br>索引同时有两个概念叫做窄索引和宽索引，窄索引是指索引列为1-2列的索引，宽索引也就是索引列超<br>过2列的索引，设计索引的一个重要原则就是能用窄索引不用宽索引，因为窄索引往往比组合索引更有<br>效。<br>创建组合索引的方法如下：<br>CREATE INDEX &lt;索引的名字&gt; ON tablename (字段名1，字段名2…);<br>ALTER TABLE tablename ADD INDEX [索引的名字] (字段名1，字段名2…);<br>CREATE TABLE tablename ( […], INDEX [索引的名字] (字段名1，字段名2…) );<br>复合索引使用注意事项：<br>何时使用复合索引，要根据where条件建索引，注意不要过多使用索引，过多使用会对更新操作效<br>率有很大影响。<br>如果表已经建立了(col1，col2)，就没有必要再单独建立（col1）；如果现在有(col1)索引，如果查<br>询需要col1和col2条件，可以建立(col1,col2)复合索引，对于查询有一定提高。<br>1.5 全文索引<br>查询操作在数据量比较少时，可以使用like模糊查询，但是对于大量的文本数据检索，效率很低。如果<br>使用全文索引，查询速度会比like快很多倍。在MySQL 5.6 以前的版本，只有MyISAM存储引擎支持全<br>文索引，从MySQL 5.6开始MyISAM和InnoDB存储引擎均支持。<br>创建全文索引的方法如下：<br>CREATE FULLTEXT INDEX &lt;索引的名字&gt; ON tablename (字段名);<br>ALTER TABLE tablename ADD FULLTEXT [索引的名字] (字段名);<br>CREATE TABLE tablename ( […], FULLTEXT KEY [索引的名字] (字段名) ;<br>和常用的like模糊查询不同，全文索引有自己的语法格式，使用 match 和 against 关键字，比如<br>全文索引使用注意事项：<br>全文索引必须在字符串、文本字段上建立。<br>全文索引字段值必须在最小字符和最大字符之间的才会有效。（innodb：3-84；myisam：4-<br>84）<br>全文索引字段值要进行切词处理，按syntax字符进行切割，例如b+aaa，切分成b和aaa<br>全文索引匹配查询，默认使用的是等值匹配，例如a匹配a，不会匹配ab,ac。如果想匹配可以在布<br>尔模式下搜索a*<br>第2节 索引原理<br>MySQL官方对索引定义：是存储引擎用于快速查找记录的一种数据结构。需要额外开辟空间和数据维护<br>工作。<br>索引是物理数据页存储，在数据文件中（InnoDB，ibd文件），利用数据页(page)存储。<br>索引可以加快检索速度，但是同时也会降低增删改操作速度，索引维护需要代价。<br>索引涉及的理论知识：二分查找法、Hash和B+Tree。<br>2.1 二分查找法<br>二分查找法也叫作折半查找法，它是在有序数组中查找指定数据的搜索算法。它的优点是等值查询、范<br>围查询性能优秀，缺点是更新数据、新增数据、删除数据维护成本高。<br>首先定位left和right两个指针<br>select * from user where match(name) against(‘aaa’); select * from user where match(name) against(‘a*’ in boolean mode);<br>计算(left+right)/2<br>判断除2后索引位置值与目标值的大小比对<br>索引位置值大于目标值就-1，right移动；如果小于目标值就+1，left移动<br>举个例子，下面的有序数组有17 个值，查找的目标值是7，过程如下：<br>第一次查找<br>第二次查找<br>第三次查找<br>第四次查找<br>2.2 Hash结构<br>Hash底层实现是由Hash表来实现的，是根据键值 &lt;key,value&gt; 存储数据的结构。非常适合根据key查找<br>value值，也就是单个key查询，或者说等值查询。其结构如下所示：<br>从上面结构可以看出，Hash索引可以方便的提供等值查询，但是对于范围查询就需要全表扫描了。<br>Hash索引在MySQL 中Hash结构主要应用在Memory原生的Hash索引 、InnoDB 自适应哈希索引。<br>InnoDB提供的自适应哈希索引功能强大，接下来重点描述下InnoDB 自适应哈希索引。<br>InnoDB自适应哈希索引是为了提升查询效率，InnoDB存储引擎会监控表上各个索引页的查询，当<br>InnoDB注意到某些索引值访问非常频繁时，会在内存中基于B+Tree索引再创建一个哈希索引，使得内<br>存中的 B+Tree 索引具备哈希索引的功能，即能够快速定值访问频繁访问的索引页。<br>InnoDB自适应哈希索引：在使用Hash索引访问时，一次性查找就能定位数据，等值查询效率要优于<br>B+Tree。<br>自适应哈希索引的建立使得InnoDB存储引擎能自动根据索引页访问的频率和模式自动地为某些热点页<br>建立哈希索引来加速访问。另外InnoDB自适应哈希索引的功能，用户只能选择开启或关闭功能，无法<br>进行人工干涉。<br>show engine innodb status \G; show variables like ‘%innodb_adaptive%’;<br>2.3 B+Tree结构<br>MySQL数据库索引采用的是B+Tree结构，在B-Tree结构上做了优化改造。<br>B-Tree结构<br>索引值和data数据分布在整棵树结构中<br>每个节点可以存放多个索引值及对应的data数据<br>树节点中的多个索引值从左到右升序排列<br>B树的搜索：从根节点开始，对节点内的索引值序列采用二分法查找，如果命中就结束查找。没有<br>命中会进入子节点重复查找过程，直到所对应的的节点指针为空，或已经是叶子节点了才结束。<br>B+Tree结构<br>非叶子节点不存储data数据，只存储索引值，这样便于存储更多的索引值<br>叶子节点包含了所有的索引值和data数据<br>叶子节点用指针连接，提高区间的访问性能<br>相比B树，B+树进行范围查找时，只需要查找定位两个节点的索引值，然后利用叶子节点的指针进<br>行遍历即可。而B树需要遍历范围内所有的节点和数据，显然B+Tree效率高。<br>2.4 聚簇索引和辅助索引<br>聚簇索引和非聚簇索引：B+Tree的叶子节点存放主键索引值和行记录就属于聚簇索引；如果索引值和行<br>记录分开存放就属于非聚簇索引。<br>主键索引和辅助索引：B+Tree的叶子节点存放的是主键字段值就属于主键索引；如果存放的是非主键值<br>就属于辅助索引（二级索引）。<br>在InnoDB引擎中，主键索引采用的就是聚簇索引结构存储。<br>聚簇索引（聚集索引）<br>聚簇索引是一种数据存储方式，InnoDB的聚簇索引就是按照主键顺序构建 B+Tree结构。B+Tree<br>的叶子节点就是行记录，行记录和主键值紧凑地存储在一起。 这也意味着 InnoDB 的主键索引就<br>是数据表本身，它按主键顺序存放了整张表的数据，占用的空间就是整个表数据量的大小。通常说<br>的主键索引就是聚集索引。<br>InnoDB的表要求必须要有聚簇索引：<br>如果表定义了主键，则主键索引就是聚簇索引<br>如果表没有定义主键，则第一个非空unique列作为聚簇索引<br>否则InnoDB会从建一个隐藏的row-id作为聚簇索引<br>辅助索引<br>InnoDB辅助索引，也叫作二级索引，是根据索引列构建 B+Tree结构。但在 B+Tree 的叶子节点中<br>只存了索引列和主键的信息。二级索引占用的空间会比聚簇索引小很多， 通常创建辅助索引就是<br>为了提升查询效率。一个表InnoDB只能创建一个聚簇索引，但可以创建多个辅助索引。<br>非聚簇索引<br>与InnoDB表存储不同，MyISAM数据表的索引文件和数据文件是分开的，被称为非聚簇索引结<br>构。</p><p>查询优化<br>MySQL 提供了一个 EXPLAIN 命令，它可以对 SELECT 语句进行分析，并输出 SELECT 执行的详细信<br>息，供开发人员有针对性的优化。例如：<br>EXPLAIN 命令的输出内容大致如下：<br>select_type<br>表示查询的类型。常用的值如下：<br>SIMPLE ： 表示查询语句不包含子查询或union<br>PRIMARY：表示此查询是最外层的查询<br>UNION：表示此查询是UNION的第二个或后续的查询<br>EXPLAIN SELECT * from user WHERE id &lt; 3;<br>DEPENDENT UNION：UNION中的第二个或后续的查询语句，使用了外面查询结果<br>UNION RESULT：UNION的结果<br>SUBQUERY：SELECT子查询语句<br>DEPENDENT SUBQUERY：SELECT子查询语句依赖外层查询的结果。<br>最常见的查询类型是SIMPLE，表示我们的查询没有子查询也没用到UNION查询。<br>type<br>表示存储引擎查询数据时采用的方式。比较重要的一个属性，通过它可以判断出查询是全表扫描还<br>是基于索引的部分扫描。常用属性值如下，从上至下效率依次增强。<br>ALL：表示全表扫描，性能最差。<br>index：表示基于索引的全表扫描，先扫描索引再扫描全表数据。<br>range：表示使用索引范围查询。使用&gt;、&gt;=、&lt;、&lt;=、in等等。<br>ref：表示使用非唯一索引进行单值查询。<br>eq_ref：一般情况下出现在多表join查询，表示前面表的每一个记录，都只能匹配后面表的一<br>行结果。<br>const：表示使用主键或唯一索引做等值查询，常量查询。<br>NULL：表示不用访问表，速度最快。<br>possible_keys<br>表示查询时能够使用到的索引。注意并不一定会真正使用，显示的是索引名称。<br>key<br>表示查询时真正使用到的索引，显示的是索引名称。<br>rows<br>MySQL查询优化器会根据统计信息，估算SQL要查询到结果需要扫描多少行记录。原则上rows是<br>越少效率越高，可以直观的了解到SQL效率高低。<br>key_len<br>表示查询使用了索引的字节数量。可以判断是否全部使用了组合索引。<br>key_len的计算规则如下：<br>字符串类型<br>字符串长度跟字符集有关：latin1=1、gbk=2、utf8=3、utf8mb4=4<br>char(n)：n*字符集长度<br>varchar(n)：n * 字符集长度 + 2字节<br>数值类型<br>TINYINT：1个字节<br>SMALLINT：2个字节<br>MEDIUMINT：3个字节<br>INT、FLOAT：4个字节<br>BIGINT、DOUBLE：8个字节<br>时间类型<br>DATE：3个字节<br>TIMESTAMP：4个字节<br>DATETIME：8个字节<br>字段属性<br>NULL属性占用1个字节，如果一个字段设置了NOT NULL，则没有此项。<br>Extra<br>Extra表示很多额外的信息，各种操作会在Extra提示相关信息，常见几种如下：<br>Using where<br>表示查询需要通过索引回表查询数据。<br>Using index<br>表示查询需要通过索引，索引就可以满足所需数据。<br>Using filesort<br>表示查询出来的结果需要额外排序，数据量小在内存，大的话在磁盘，因此有Using filesort<br>建议优化。<br>Using temprorary<br>查询使用到了临时表，一般出现于去重、分组等操作。<br>3.2 回表查询<br>在之前介绍过，InnoDB索引有聚簇索引和辅助索引。聚簇索引的叶子节点存储行记录，InnoDB必须要<br>有，且只有一个。辅助索引的叶子节点存储的是主键值和索引字段值，通过辅助索引无法直接定位行记<br>录，通常情况下，需要扫码两遍索引树。先通过辅助索引定位主键值，然后再通过聚簇索引定位行记<br>录，这就叫做回表查询，它的性能比扫一遍索引树低。<br>总结：通过索引查询主键值，然后再去聚簇索引查询记录信息<br>3.3 覆盖索引<br>在SQL-Server官网的介绍如下：<br>在MySQL官网，类似的说法出现在explain查询计划优化章节，即explain的输出结果Extra字段为Using<br>index时，能够触发索引覆盖。<br>不管是SQL-Server官网，还是MySQL官网，都表达了：只需要在一棵索引树上就能获取SQL所需的所<br>有列数据，无需回表，速度更快，这就叫做索引覆盖。<br>实现索引覆盖最常见的方法就是：将被查询的字段，建立到组合索引。<br>3.4 最左前缀原则<br>复合索引使用时遵循最左前缀原则，最左前缀顾名思义，就是最左优先，即查询中使用到最左边的列，<br>那么查询就会使用到索引，如果从索引的第二列开始查找，索引将失效。<br>3.5 LIKE查询<br>面试题：MySQL在使用like模糊查询时，索引能不能起作用？<br>回答：MySQL在使用Like模糊查询时，索引是可以被使用的，只有把%字符写在后面才会使用到索引。<br>select * from user where name like ‘%o%’; //不起作用<br>select * from user where name like ‘o%’; //起作用<br>select * from user where name like ‘%o’; //不起作用<br>3.6 NULL查询<br>面试题：如果MySQL表的某一列含有NULL值，那么包含该列的索引是否有效？<br>对MySQL来说，NULL是一个特殊的值，从概念上讲，NULL意味着“一个未知值”，它的处理方式与其他<br>值有些不同。比如：不能使用=，&lt;，&gt;这样的运算符，对NULL做算术运算的结果都是NULL，count时<br>不会包括NULL行等，NULL比空字符串需要更多的存储空间等。<br>NULL列需要增加额外空间来记录其值是否为NULL。对于MyISAM表，每一个空列额外占用一位，四舍<br>五入到最接近的字节。<br>虽然MySQL可以在含有NULL的列上使用索引，但NULL和其他数据还是有区别的，不建议列上允许为<br>NULL。最好设置NOT NULL，并给一个默认值，比如0和 ‘’ 空字符串等，如果是datetime类型，也可以<br>设置系统当前时间或某个固定的特殊值，例如’1970-01-01 00:00:00’。 “NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”<br>3.7 索引与排序<br>MySQL查询支持filesort和index两种方式的排序，filesort是先把结果查出，然后在缓存或磁盘进行排序<br>操作，效率较低。使用index是指利用索引自动实现排序，不需另做排序操作，效率会比较高。<br>filesort有两种排序算法：双路排序和单路排序。<br>双路排序：需要两次磁盘扫描读取，最终得到用户数据。第一次将排序字段读取出来，然后排序；第二<br>次去读取其他字段数据。<br>单路排序：从磁盘查询所需的所有列数据，然后在内存排序将结果返回。如果查询数据超出缓存<br>sort_buffer，会导致多次磁盘读取操作，并创建临时表，最后产生了多次IO，反而会增加负担。解决方<br>案：少使用select *；增加sort_buffer_size容量和max_length_for_sort_data容量。<br>如果我们Explain分析SQL，结果中Extra属性显示Using filesort，表示使用了filesort排序方式，需要优<br>化。如果Extra属性显示Using index时，表示覆盖索引，也表示所有操作在索引上完成，也可以使用<br>index排序方式，建议大家尽可能采用覆盖索引。<br>以下几种情况，会使用index方式的排序。<br>ORDER BY 子句索引列组合满足索引最左前列<br>WHERE子句+ORDER BY子句索引列组合满足索引最左前列<br>以下几种情况，会使用filesort方式的排序。<br>对索引列同时使用了ASC和DESC<br>WHERE子句和ORDER BY子句满足最左前缀，但where子句使用了范围查询（例如&gt;、&lt;、in<br>等）<br>ORDER BY或者WHERE+ORDER BY索引列没有满足索引最左前列<br>使用了不同的索引，MySQL每次只采用一个索引，ORDER BY涉及了两个索引<br>WHERE子句与ORDER BY子句，使用了不同的索引<br>explain select id from user order by id; //对应(id)、(id,name)索引有效 explain select id from user where age=18 order by name; //对应 (age,name)索引 explain select id from user order by age asc,name desc; //对应 (age,name)索引 explain select id from user where age&gt;10 order by name; //对应 (age,name)索引 explain select id from user order by name; //对应(age,name)索引 explain select id from user order by name,age; //对应(name)、(age)两个索 引explain select id from user where name=’tom’ order by age; //对应 (name)、(age)索引<br>WHERE子句或者ORDER BY子句中索引列使用了表达式，包括函数表达式<br>第4节 查询优化<br>4.1 慢查询定位<br>开启慢查询日志<br>查看 MySQL 数据库是否开启了慢查询日志和慢查询日志文件的存储位置的命令如下：<br>通过如下命令开启慢查询日志：<br>long_query_time：指定慢查询的阀值，单位秒。如果SQL执行时间超过阀值，就属于慢查询<br>记录到日志文件中。<br>log_queries_not_using_indexes：表示会记录没有使用索引的查询SQL。前提是slow_query_log<br>的值为ON，否则不会奏效。<br>查看慢查询日志<br>文本方式查看<br>直接使用文本编辑器打开slow.log日志即可。<br>time：日志记录的时间<br>User@Host：执行的用户及主机<br>Query_time：执行的时间<br>Lock_time：锁表时间<br>Rows_sent：发送给请求方的记录数，结果数量<br>Rows_examined：语句扫描的记录条数<br>SET timestamp：语句执行的时间点<br>select….：执行的具体的SQL语句<br>使用mysqldumpslow查看<br>MySQL 提供了一个慢查询日志分析工具mysqldumpslow，可以通过该工具分析慢查询日志<br>内容。<br>在 MySQL bin目录下执行下面命令可以查看该使用格式。<br>运行如下命令查看慢查询日志信息：<br>explain select id from user order by abs(age); //对应(age)索引 SHOW VARIABLES LIKE ‘slow_query_log%’ SET global slow_query_log = ON; SET global slow_query_log_file = ‘OAK-slow.log’; SET global log_queries_not_using_indexes = ON; SET long_query_time = 10; perl mysqldumpslow.pl –help<br>除了使用mysqldumpslow工具，也可以使用第三方分析工具，比如pt-query-digest、<br>mysqlsla等。<br>4.2 慢查询优化<br>索引和慢查询<br>如何判断是否为慢查询？<br>MySQL判断一条语句是否为慢查询语句，主要依据SQL语句的执行时间，它把当前语句的执<br>行时间跟 long_query_time 参数做比较，如果语句的执行时间 &gt; long_query_time，就会把<br>这条执行语句记录到慢查询日志里面。long_query_time 参数的默认值是 10s，该参数值可<br>以根据自己的业务需要进行调整。<br>如何判断是否应用了索引？<br>SQL语句是否使用了索引，可根据SQL语句执行过程中有没有用到表的索引，可通过 explain<br>命令分析查看，检查结果中的 key 值，是否为NULL。<br>应用了索引是否一定快？<br>下面我们来看看下面语句的 explain 的结果，你觉得这条语句有用上索引吗？比如<br>虽然使用了索引，但是还是从主键索引的最左边的叶节点开始向右扫描整个索引树，进行了<br>全表扫描，此时索引就失去了意义。<br>而像 select * from user where id = 2; 这样的语句，才是我们平时说的使用了索引。它表示<br>的意思是，我们使用了索引的快速搜索功能，并且有效地减少了扫描行数。<br>查询是否使用索引，只是表示一个SQL语句的执行过程；而是否为慢查询，是由它执行的时间决定<br>的，也就是说是否使用了索引和是否是慢查询两者之间没有必然的联系。<br>我们在使用索引时，不要只关注是否起作用，应该关心索引是否减少了查询扫描的数据行数，如果<br>扫描行数减少了，效率才会得到提升。对于一个大表，不止要创建索引，还要考虑索引过滤性，过<br>滤性好，执行速度才会快。<br>提高索引过滤性<br>假如有一个5000万记录的用户表，通过sex=’男’索引过滤后，还需要定位3000万，SQL执行速度也<br>不会很快。其实这个问题涉及到索引的过滤性，比如1万条记录利用索引过滤后定位10条、100<br>条、1000条，那他们过滤性是不同的。索引过滤性与索引字段、表的数据量、表设计结构都有关<br>系。<br>下面我们看一个案例：<br>优化1 perl mysqldumpslow.pl -t 5 -s at C:\ProgramData\MySQL\Data\OAK-slow.log select * from user where id&gt;0; 表：student 字段：id,name,sex,age 造数据：insert into student (name,sex,age) select name,sex,age from student; SQL案例：select * from student where age=18 and name like ‘张%’;（全表扫 描）alter table student add index(name); //追加name索引<br>优化3<br>慢查询原因总结<br>全表扫描：explain分析type属性all<br>全索引扫描：explain分析type属性index<br>索引过滤性不好：靠索引字段选型、数据量和状态、表设计<br>频繁的回表查询开销：尽量少用select *，使用覆盖索引<br>4.3 分页查询优化<br>一般性分页<br>般的分页查询使用简单的 limit 子句就可以实现。limit格式如下：<br>第一个参数指定第一个返回记录行的偏移量，注意从0开始；<br>第二个参数指定返回记录行的最大数目；<br>如果只给定一个参数，它表示返回最大的记录行数目；<br>思考1：如果偏移量固定，返回记录量对执行时间有什么影响？<br>结果：在查询记录时，返回记录量低于100条，查询时间基本没有变化，差距不大。随着查询记录<br>量越大，所花费的时间也会越来越多。<br>思考2：如果查询偏移量变化，返回记录数固定对执行时间有什么影响？</p><p>优化2 alter table student add index(age,name); //追加age,name索引 可以看到，index condition pushdown 优化的效果还是很不错的。再进一步优化，我们可以把名 字的第一个字和年龄做一个联合索引，这里可以使用 MySQL 5.7 引入的虚拟列来实现。 //为user表添加first_name虚拟列，以及联合索引(first_name,age) alter table student add first_name varchar(2) generated always as (left(name, 1)), add index(first_name, age); explain select * from student where first_name=’张’ and age=18; SELECT * FROM 表名 LIMIT [offset,] rows select * from user limit 10000,1; select * from user limit 10000,10; select * from user limit 10000,100; select * from user limit 10000,1000; select * from user limit 10000,10000;<br>结果：在查询记录时，如果查询记录量相同，偏移量超过100后就开始随着偏移量增大，查询时间<br>急剧的增加。（这种分页查询机制，每次都会从数据库第一条记录开始扫描，越往后查询越慢，而<br>且查询的数据越多，也会拖慢总查询速度。）<br>分页优化方案<br>第一步：利用覆盖索引优化<br>第二步：利用子查询优化<br>原因：使用了id做主键比较(id&gt;=)，并且子查询使用了覆盖索引进行优化。<br>MySQL事务和锁<br>第1节 ACID 特性<br>在关系型数据库管理系统中，一个逻辑工作单元要成为事务，必须满足这 4 个特性，即所谓的 ACID：<br>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p><p>1.1 原子性<br>原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。<br>修改—》Buffer Pool修改—》刷盘。可能会有下面两种情况：<br>事务提交了，如果此时Buffer Pool的脏页没有刷盘，如何保证修改的数据生效？ Redo<br>如果事务没提交，但是Buffer Pool的脏页刷盘了，如何保证不该存在的数据撤销？Undo<br>每一个写事务，都会修改BufferPool，从而产生相应的Redo/Undo日志，在Buffer Pool 中的页被刷到<br>磁盘之前，这些日志信息都会先写入到日志文件中，如果 Buffer Pool 中的脏页没有刷成功，此时数据<br>库挂了，那在数据库再次启动之后，可以通过 Redo 日志将其恢复出来，以保证脏页写的数据不会丢<br>失。如果脏页刷新成功，此时数据库挂了，就需要通过Undo来实现了。<br>1.2 持久性<br>持久性：指的是一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，后续的操作或故障不<br>应该对其有任何影响，不会丢失。<br>如下图所示，一个“提交”动作触发的操作有：binlog落地、发送binlog、存储引擎提交、flush_logs，<br>check_point、事务提交标记等。这些都是数据库保证其数据完整性、持久性的手段。<br>select * from user limit 1,100; select * from user limit 10,100; select * from user limit 100,100; select * from user limit 1000,100; select * from user limit 10000,100; select * from user limit 10000,100; select id from user limit 10000,100; select * from user limit 10000,100; select * from user where id&gt;= (select id from user limit 10000,1) limit 100;<br>MySQL的持久性也与WAL技术相关，redo log在系统Crash重启之类的情况时，可以修复数据，从而保<br>障事务的持久性。通过原子性可以保证逻辑上的持久性，通过存储引擎的数据刷盘可以保证物理上的持<br>久性。<br>1.3 隔离性<br>隔离性：指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并<br>发事务是隔离的。<br>InnoDB 支持的隔离性有 4 种，隔离性从低到高分别为：读未提交、读提交、可重复读、可串行化。锁<br>和多版本控制（MVCC）技术就是用于保障隔离性的（后面课程详解）。<br>1.4 一致性<br>一致性：指的是事务开始之前和事务结束之后，数据库的完整性限制未被破坏。一致性包括两方面的内<br>容，分别是约束一致性和数据一致性。<br>约束一致性：创建表结构时所指定的外键、Check、唯一索引等约束，可惜在 MySQL 中不支持<br>Check 。<br>数据一致性：是一个综合性的规定，因为它是由原子性、持久性、隔离性共同保证的结果，而不是<br>单单依赖于某一种技术。<br>一致性也可以理解为数据的完整性。数据的完整性是通过原子性、隔离性、持久性来保证的，而这3个<br>特性又是通过 Redo/Undo 来保证的。逻辑上的一致性，包括唯一索引、外键约束、check 约束，这属<br>于业务逻辑范畴。<br>ACID 及它们之间的关系如下图所示，4个特性中有3个与 WAL 有关系，都需要通过 Redo、Undo 日志<br>来保证等。<br>WAL的全称为Write-Ahead Logging，先写日志，再写磁盘。<br>第2节 事务控制的演进<br>2.1 并发事务<br>事务并发处理可能会带来一些问题，比如：更新丢失、脏读、不可重复读、幻读等。<br>更新丢失<br>当两个或多个事务更新同一行记录，会产生更新丢失现象。可以分为回滚覆盖和提交覆盖。<br>回滚覆盖：一个事务回滚操作，把其他事务已提交的数据给覆盖了。<br>提交覆盖：一个事务提交操作，把其他事务已提交的数据给覆盖了。<br>脏读<br>一个事务读取到了另一个事务修改但未提交的数据。<br>不可重复读<br>一个事务中多次读取同一行记录不一致，后面读取的跟前面读取的不一致。<br>幻读<br>一个事务中多次按相同条件查询，结果不一致。后续查询的结果和面前查询结果不同，多了或少了<br>几行记录。<br>2.3 排队<br>最简单的方法，就是完全顺序执行所有事务的数据库操作，不需要加锁，简单的说就是全局排队。序列<br>化执行所有的事务单元，数据库某个时刻只处理一个事务操作，特点是强一致性，处理性能低。<br>2.2 排他锁<br>引入锁之后就可以支持并发处理事务，如果事务之间涉及到相同的数据项时，会使用排他锁，或叫互斥<br>锁，先进入的事务独占数据项以后，其他事务被阻塞，等待前面的事务释放锁。<br>注意，在整个事务1结束之前，锁是不会被释放的，所以，事务2必须等到事务1结束之后开始。<br>2.3 读写锁<br>读和写操作：读读、写写、读写、写读。<br>读写锁就是进一步细化锁的颗粒度，区分读操作和写操作，让读和读之间不加锁，这样下面的两个事务<br>就可以同时被执行了。<br>读写锁，可以让读和读并行，而读和写、写和读、写和写这几种之间还是要加排他锁。<br>2.4 MVCC<br>多版本控制MVCC，也就是Copy on Write的思想。MVCC除了支持读和读并行，还支持读和写、写和读<br>的并行，但为了保证一致性，写和写是无法并行的。<br>在事务1开始写操作的时候会copy一个记录的副本，其他事务读操作会读取这个记录副本，因此不会影<br>响其他事务对此记录的读取，实现写和读并行。<br>一、MVCC概念<br>MVCC（Multi Version Concurrency Control）被称为多版本控制，是指在数据库中为了实现高并发的<br>数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。<br>多版本控制很巧妙地将稀缺资源的独占互斥转换为并发，大大提高了数据库的吞吐量及读写性能。<br>如何生成的多版本？每次事务修改操作之前，都会在Undo日志中记录修改之前的数据状态和事务号，<br>该备份记录可以用于其他事务的读取，也可以进行必要时的数据回滚。<br>二、MVCC实现原理<br>MVCC最大的好处是读不加锁，读写不冲突。在读多写少的系统应用中，读写不冲突是非常重要的，极<br>大的提升系统的并发性能，这也是为什么现阶段几乎所有的关系型数据库都支持 MVCC 的原因，不过目<br>前MVCC只在 Read Commited 和 Repeatable Read 两种隔离级别下工作。<br>在 MVCC 并发控制中，读操作可以分为两类: 快照读（Snapshot Read）与当前读 （Current Read）。<br>快照读：读取的是记录的快照版本（有可能是历史版本），不用加锁。（select）<br>当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发<br>修改这条记录。（select… for update 或lock in share mode，insert/delete/update）<br>为了让大家更直观地理解 MVCC 的实现原理，举一个记录更新的案例来讲解 MVCC 中多版本的实现。<br>假设 F1～F6 是表中字段的名字，1～6 是其对应的数据。后面三个隐含字段分别对应该行的隐含ID、事<br>务号和回滚指针，如下图所示。<br>具体的更新过程如下：<br>假如一条数据是刚 INSERT 的，DB_ROW_ID 为 1，其他两个字段为空。当事务 1 更改该行的数据值<br>时，会进行如下操作，如下图所示。<br>用排他锁锁定该行；记录 Redo log；<br>把该行修改前的值复制到 Undo log，即图中下面的行；<br>修改当前行的值，填写事务编号，使回滚指针指向 Undo log 中修改前的行。<br>接下来事务2操作，过程与事务 1 相同，此时 Undo log 中会有两行记录，并且通过回滚指针连在一<br>起，通过当前记录的回滚指针回溯到该行创建时的初始内容，如下图所示。<br>MVCC已经实现了读读、读写、写读并发处理，如果想进一步解决写写冲突，可以采用下面两种方案：<br>乐观锁<br>悲观锁<br>第3节 事务隔离级别<br>3.1 隔离级别类型<br>前面提到的“更新丢失”、”脏读”、“不可重复读”和“幻读”等并发事务问题，其实都是数据库一致性问题，<br>为了解决这些问题，MySQL数据库是通过事务隔离级别来解决的，数据库系统提供了以下 4 种事务隔<br>离级别供用户选择。<br>读未提交<br>Read Uncommitted 读未提交：解决了回滚覆盖类型的更新丢失，但可能发生脏读现象，也就是<br>可能读取到其他会话中未提交事务修改的数据。<br>已提交读<br>Read Committed 读已提交：只能读取到其他会话中已经提交的数据，解决了脏读。但可能发生<br>不可重复读现象，也就是可能在一个事务中两次查询结果不一致。<br>可重复度<br>Repeatable Read 可重复读：解决了不可重复读，它确保同一事务的多个实例在并发读取数据<br>时，会看到同样的数据行。不过理论上会出现幻读，简单的说幻读指的的当用户读取某一范围的数<br>据行时，另一个事务又在该范围插入了新行，当用户在读取该范围的数据时会发现有新的幻影行。<br>可串行化<br>Serializable 串行化：所有的增删改查串行执行。它通过强制事务排序，解决相互冲突，从而解决<br>幻度的问题。这个级别可能导致大量的超时现象的和锁竞争，效率低下。<br>数据库的事务隔离级别越高，并发问题就越小，但是并发处理能力越差（代价）。读未提交隔离级别最<br>低，并发问题多，但是并发处理能力好。以后使用时，可以根据系统特点来选择一个合适的隔离级别，<br>比如对不可重复读和幻读并不敏感，更多关心数据库并发处理能力，此时可以使用Read Commited隔<br>离级别。<br>事务隔离级别，针对Innodb引擎，支持事务的功能。像MyISAM引擎没有关系。<br>事务隔离级别和锁的关系<br>1）事务隔离级别是SQL92定制的标准，相当于事务并发控制的整体解决方案，本质上是对锁和MVCC使<br>用的封装，隐藏了底层细节。<br>2）锁是数据库实现并发控制的基础，事务隔离性是采用锁来实现，对相应操作加不同的锁，就可以防<br>止其他事务同时对数据进行读写操作。<br>3）对用户来讲，首先选择使用隔离级别，当选用的隔离级别不能解决并发问题或需求时，才有必要在<br>开发中手动的设置锁。<br>MySQL默认隔离级别：可重复读<br>Oracle、SQLServer默认隔离级别：读已提交<br>一般使用时，建议采用默认隔离级别，然后存在的一些并发问题，可以通过悲观锁、乐观锁等实现处<br>理。<br>3.2 MySQL隔离级别控制<br>MySQL默认的事务隔离级别是Repeatable Read，查看MySQL当前数据库的事务隔离级别命令如下：<br>或show variables like ‘tx_isolation’;<br>设置事务隔离级别可以如下命令：<br>第4节 锁机制和实战<br>4.1 锁分类<br>在 MySQL中锁有很多不同的分类。<br>从操作的粒度可分为表级锁、行级锁和页级锁。<br>表级锁：每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在<br>MyISAM、InnoDB、BDB 等存储引擎中。<br>行级锁：每次操作锁住一行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应<br>用在InnoDB 存储引擎中。<br>页级锁：每次锁定相邻的一组记录，锁定粒度界于表锁和行锁之间，开销和加锁时间界于表<br>锁和行锁之间，并发度一般。应用在BDB 存储引擎中。<br>从操作的类型可分为读锁和写锁。<br>读锁（S锁）：共享锁，针对同一份数据，多个读操作可以同时进行而不会互相影响。<br>写锁（X锁）：排他锁，当前写操作没有完成前，它会阻断其他写锁和读锁。<br>IS锁、IX锁：意向读锁、意向写锁，属于表级锁，S和X主要针对行级锁。在对表记录添加S或X锁之<br>前，会先对表添加IS或IX锁。<br>S锁：事务A对记录添加了S锁，可以对记录进行读操作，不能做修改，其他事务可以对该记录追加<br>S锁，但是不能追加X锁，需要追加X锁，需要等记录的S锁全部释放。<br>X锁：事务A对记录添加了X锁，可以对记录进行读和修改操作，其他事务不能对记录做读和修改操<br>作。<br>从操作的性能可分为乐观锁和悲观锁。<br>乐观锁：一般的实现方式是对记录数据版本进行比对，在数据更新提交的时候才会进行冲突<br>检测，如果发现冲突了，则提示错误信息。<br>悲观锁：在对一条数据修改的时候，为了避免同时被其他人修改，在修改数据之前先锁定，<br>再修改的控制方式。共享锁和排他锁是悲观锁的不同实现，但都属于悲观锁范畴。<br>4.2 行锁原理<br>在InnoDB引擎中，我们可以使用行锁和表锁，其中行锁又分为共享锁和排他锁。InnoDB行锁是通过对<br>索引数据页上的记录加锁实现的，主要实现算法有 3 种：Record Lock、Gap Lock 和 Next-key Lock。 select @@tx_isolation; set tx_isolation=’READ-UNCOMMITTED’; set tx_isolation=’READ-COMMITTED’; set tx_isolation=’REPEATABLE-READ’; set tx_isolation=’SERIALIZABLE’;<br>RecordLock锁：锁定单个行记录的锁。（记录锁，RC、RR隔离级别都支持）<br>GapLock锁：间隙锁，锁定索引记录间隙，确保索引记录的间隙不变。（范围锁，RR隔离级别支<br>持）<br>Next-key Lock 锁：记录锁和间隙锁组合，同时锁住数据，并且锁住数据前后范围。（记录锁+范<br>围锁，RR隔离级别支持）<br>在RR隔离级别，InnoDB对于记录加锁行为都是先采用Next-Key Lock，但是当SQL操作含有唯一索引<br>时，Innodb会对Next-Key Lock进行优化，降级为RecordLock，仅锁住索引本身而非范围。<br>1）select … from 语句：InnoDB引擎采用MVCC机制实现非阻塞读，所以对于普通的select语句，<br>InnoDB不加锁<br>2）select … from lock in share mode语句：追加了共享锁，InnoDB会使用Next-Key Lock锁进行处<br>理，如果扫描发现唯一索引，可以降级为RecordLock锁。<br>3）select … from for update语句：追加了排他锁，InnoDB会使用Next-Key Lock锁进行处理，如果扫<br>描发现唯一索引，可以降级为RecordLock锁。<br>4）update … where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以<br>降级为RecordLock锁。<br>5）delete … where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降<br>级为RecordLock锁。<br>6）insert语句：InnoDB会在将要插入的那一行设置一个排他的RecordLock锁。<br>下面以“update t1 set name=‘XX’ where id=10”操作为例，举例子分析下 InnoDB 对不同索引的加锁行<br>为，以RR隔离级别为例。<br>主键加锁<br>加锁行为：仅在id=10的主键索引记录上加X锁。<br>唯一键加锁<br>加锁行为：现在唯一索引id上加X锁，然后在id=10的主键索引记录上加X锁。<br>非唯一键加锁<br>加锁行为：对满足id=10条件的记录和主键分别加X锁，然后在(6,c)-(10,b)、(10,b)-(10,d)、(10,d)-<br>(11,f)范围分别加Gap Lock。<br>无索引加锁<br>加锁行为：表里所有行和间隙都会加X锁。（当没有索引时，会导致全表锁定，因为InnoDB引擎<br>锁机制是基于索引实现的记录锁定）。<br>4.3 悲观锁<br>悲观锁（Pessimistic Locking），是指在数据处理过程，将数据处于锁定状态，一般使用数据库的锁机<br>制实现。从广义上来讲，前面提到的行锁、表锁、读锁、写锁、共享锁、排他锁等，这些都属于悲观锁<br>范畴。<br>表级锁<br>表级锁每次操作都锁住整张表，并发度最低。常用命令如下：<br>手动增加表锁<br>查看表上加过的锁<br>删除表锁<br>表级读锁：当前表追加read锁，当前连接和其他的连接都可以读操作；但是当前连接增删改操作<br>会报错，其他连接增删改会被阻塞。<br>lock table 表名称 read|write,表名称2 read|write; show open tables; unlock tables;<br>表级写锁：当前表追加write锁，当前连接可以对表做增删改查操作，其他连接对该表所有操作都<br>被阻塞（包括查询）。<br>总结：表级读锁会阻塞写操作，但是不会阻塞读操作。而写锁则会把读和写操作都阻塞。<br>共享锁（行级锁-读锁）<br>共享锁又称为读锁，简称S锁。共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数<br>据，但是只能读不能修改。使用共享锁的方法是在select … lock in share mode，只适用查询语<br>句。<br>总结：事务使用了共享锁（读锁），只能读取，不能修改，修改操作被阻塞。<br>排他锁（行级锁-写锁）<br>排他锁又称为写锁，简称X锁。排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排<br>他锁，其他事务就不能对该行记录做其他操作，也不能获取该行的锁。<br>使用排他锁的方法是在SQL末尾加上for update，innodb引擎默认会在update，delete语句加上<br>for update。行级锁的实现其实是依靠其对应的索引，所以如果操作没用到索引的查询，那么会锁<br>住全表记录。<br>总结：事务使用了排他锁（写锁），当前事务可以读取和修改，其他事务不能修改，也不能获取记录<br>锁（select… for update）。如果查询没有使用到索引，将会锁住整个表记录。<br>4.4 乐观锁<br>乐观锁是相对于悲观锁而言的，它不是数据库提供的功能，需要开发者自己去实现。在数据库操作时，<br>想法很乐观，认为这次的操作不会导致冲突，因此在数据库操作时并不做任何的特殊处理，即不加锁，<br>而是在进行事务提交时再去判断是否有冲突了。<br>乐观锁实现的关键点：冲突的检测。<br>悲观锁和乐观锁都可以解决事务写写并发，在应用中可以根据并发处理能力选择区分，比如对并发率要<br>求高的选择乐观锁；对于并发率要求低的可以选择悲观锁。<br>乐观锁实现原理<br>使用版本字段（version）<br>先给数据表增加一个版本(version) 字段，每操作一次，将那条记录的版本号加 1。version<br>是用来查看被读的记录有无变化，作用是防止记录在业务处理期间被其他事务修改。<br>使用时间戳（Timestamp）<br>与使用version版本字段相似，同样需要给在数据表增加一个字段，字段类型使用timestamp<br>时间戳。也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳<br>进行对比，如果一致则提交更新，否则就是版本冲突，取消操作。<br>乐观锁案例<br>下面我们使用下单过程作为案例，描述下乐观锁的使用。<br>第一步：查询商品信息<br>第二部：根据商品信息生成订单<br>第三部：修改商品库存<br>除了自己手动实现乐观锁之外，许多数据库访问框架也封装了乐观锁的实现，比如<br>hibernate框架。MyBatis框架大家可以使用OptimisticLocker插件来扩展。<br>4.5 死锁与解决方案<br>下面介绍几种常见的死锁现象和解决方案：<br>一、表锁死锁<br>产生原因：<br>select (quantity,version) from products where id=1; insert into orders … insert into items … update products set quantity=quantity-1,version=version+1 where id=1 and version=#{version};<br>用户A访问表A（锁住了表A），然后又访问表B；另一个用户B访问表B（锁住了表B），然后企图<br>访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要<br>等用户A释放表A才能继续，这就死锁就产生了。<br>用户A–》A表（表锁）–》B表（表锁）<br>用户B–》B表（表锁）–》A表（表锁）<br>解决方案：<br>这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分<br>析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个<br>资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任<br>何时刻都应该按照相同的顺序来锁定资源。<br>二、行级锁死锁<br>产生原因1：<br>如果在事务中执行了一条没有索引条件的查询，引发全表扫描，把行级锁上升为全表记录锁定（等<br>价于表级锁），多个这样的事务执行后，就很容易产生死锁和阻塞，最终应用系统会越来越慢，发<br>生阻塞或死锁。<br>解决方案1：<br>SQL语句中不要使用太复杂的关联多表的查询；使用explain“执行计划”对SQL语句进行分析，对于<br>有全表扫描和全表锁定的SQL语句，建立相应的索引进行优化。<br>产生原因2：<br>两个事务分别想拿到对方持有的锁，互相等待，于是产生死锁。<br>解决方案2：<br>在同一个事务中，尽可能做到一次锁定所需要的所有资源<br>按照id对资源排序，然后按顺序进行处理<br>三、共享锁转换为排他锁<br>产生原因：<br>事务A 查询一条纪录，然后更新该条纪录；此时事务B 也更新该条纪录，这时事务B 的排他锁由于<br>事务A 有共享锁，必须等A 释放共享锁后才可以获取，只能排队等待。事务A 再执行更新操作时，<br>此处发生死锁，因为事务A 需要排他锁来做更新操作。但是，无法授予该锁请求，因为事务B 已经<br>有一个排他锁请求，并且正在等待事务A 释放其共享锁。<br>事务A: select * from dept where deptno=1 lock in share mode; //共享锁,1<br>update dept set dname=’java’ where deptno=1;//排他锁,3<br>事务B: update dept set dname=’Java’ where deptno=1;//由于1有共享锁，没法获取排他锁，需<br>等待，2<br>解决方案：<br>对于按钮等控件，点击立刻失效，不让用户重复点击，避免引发同时对同一条记录多次操<br>作；<br>使用乐观锁进行控制。乐观锁机制避免了长事务中的数据库加锁开销，大大提升了大并发量<br>下的系统性能。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用<br>户更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中；<br>四、死锁排查<br>MySQL提供了几个与锁有关的参数和命令，可以辅助我们优化锁操作，减少死锁发生。<br>查看死锁日志<br>通过show engine innodb status\G命令查看近期死锁日志信息。<br>使用方法：1、查看近期死锁日志信息；2、使用explain查看下SQL执行计划<br>查看锁状态变量<br>通过show status like’innodb_row_lock%‘命令检查状态变量，分析系统中的行锁的争夺<br>情况<br>Innodb_row_lock_current_waits：当前正在等待锁的数量<br>Innodb_row_lock_time：从系统启动到现在锁定总时间长度<br>Innodb_row_lock_time_avg： 每次等待锁的平均时间<br>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次锁的时间<br>Innodb_row_lock_waits：系统启动后到现在总共等待的次数<br>如果等待次数高，而且每次等待时间长，需要分析系统中为什么会有如此多的等待，然后着<br>手定制优化</p><p>除了自己手动实现乐观锁之外，许多数据库访问框架也封装了乐观锁的实现，比如<br>hibernate框架。MyBatis框架大家可以使用OptimisticLocker插件来扩展。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我坚信，机会永远属于有准备的人，我们与其羡慕他人的成功，不如从此刻起，积累足够多的知识和面试经验，为将来进入更好的公司做充足的准备&lt;br&gt;本片文章将会根据资料学习深入Mysql的设计与优化&lt;br&gt;1、Mysql基础知识&lt;/p&gt;
&lt;p&gt;2、Mysql架构原理和存储机制&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="Mysql" scheme="https://zkkget.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>主站博客迁移之线上对事务的处理</title>
    <link href="https://zkkget.github.io/posts/20220725cl89v5ww90017t4uj9ct72mzu.html"/>
    <id>https://zkkget.github.io/posts/20220725cl89v5ww90017t4uj9ct72mzu.html</id>
    <published>2022-07-25T08:15:07.000Z</published>
    <updated>2022-07-25T08:17:19.220Z</updated>
    
    <content type="html"><![CDATA[<p>事务是我们平时项目中对数据操作最为直接、常用的方式，现在无论是大小公司都离不开对事务的操作，伴随业务的提升，客户量的积累也大大增加了对事务管理的难度。<br>在本章节中将会讲到如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、线上环境对roll back only 的处理</span><br><span class="line"></span><br><span class="line">2、线上环境对嵌套事务的解决方案</span><br><span class="line"></span><br><span class="line">3、11个demo分析事务失效的场景</span><br><span class="line"></span><br><span class="line">4、分布式事务</span><br><span class="line"></span><br><span class="line">5、事务也能异步</span><br></pre></td></tr></table></figure><p>1、线上环境对roll back only 的处理与产生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.dao.CannotAcquireLockException: </span><br><span class="line">### Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br><span class="line">### The error may involve xxxMapper.insert-Inline</span><br><span class="line">### The error occurred <span class="keyword">while</span> setting parameters</span><br><span class="line">### SQL: INSERT INTO xxx</span><br><span class="line">### Cause: com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br><span class="line">; Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction; nested exception is com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br></pre></td></tr></table></figure><p>产生原因：<br>事务嵌套，内层事务将异常捕获未抛出。</p><p>2、线上环境对嵌套事务的解决方案<br>优化点可以从以下几点进行考虑：<br>最为直接的方法便是去掉嵌套事务，在controller层统一决定异常处理<br>对于类似开发过程中，需考虑将相关方法长事务中查询方法剔除，将方法内事务缩短为最小事务<br>出现突发情况，应提供最为简单有效的方案，让业务正常操作，不受影响<br>开发应对当时的技术方案告知相关测试<br>在代码层面,后续代码需要前面操作事务释放锁<br>无需等待插入结果   直接插入后续数据<br>将查询放在事务外面尽量将大事务变为小事务<br>捕获异常  自动重试<br>但是短时间内我还没有时间进行整改，在不影响主流程的情况下未进行整改，但我后续才知道大错特错。<br>排查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timestamp</span> September 1st <span class="number">2021</span>, <span class="number">10</span>:<span class="number">20</span>:<span class="number">24.637</span></span><br><span class="line"># <span class="meta">@version</span>  <span class="number">1</span></span><br><span class="line">t LOG_DATEFORMAT_PATTERN    yyyy-MM-dd HH:mm:ss.SSS</span><br><span class="line">t LOG_LEVEL_PATTERN %5p</span><br><span class="line">t _id   VMaG</span><br><span class="line">t _index    applog-<span class="number">2021.09</span><span class="number">.01</span></span><br><span class="line"># _score    <span class="number">1</span></span><br><span class="line">t _type doc</span><br><span class="line">t appindex  applog</span><br><span class="line">t appname   app</span><br><span class="line">t host  <span class="number">10.0</span><span class="number">.74</span><span class="number">.157</span></span><br><span class="line">t level ERROR</span><br><span class="line"># level_value   <span class="number">40</span>,<span class="number">000</span></span><br><span class="line">t logger_name   ExceptionLogCollector</span><br><span class="line">t message   未知异常[<span class="number">500</span>] =&gt; Transaction rolled back because it has been marked as rollback-only</span><br><span class="line"># port  <span class="number">10</span>,<span class="number">792</span></span><br><span class="line">t stack_trace   org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br><span class="line">at org.springframework.transaction.support.AbstractPlatformTransactionManager.processRollback(AbstractPlatformTransactionManager.java:<span class="number">873</span>) ~[spring-tx-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:<span class="number">710</span>) ~[spring-tx-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:<span class="number">533</span>) ~[spring-tx-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:<span class="number">304</span>) ~[spring-tx-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:<span class="number">98</span>) ~[spring-tx-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:<span class="number">186</span>) ~[spring-aop-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:<span class="number">688</span>) ~[spring-aop-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">spring-tx-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar-</span><br><span class="line">org.springframework.transaction.interceptor.TransactionInterceptor#事务拦截器</span><br><span class="line">avatar</span><br></pre></td></tr></table></figure><p>spring事务分为声明式事务和编程式事务，若目标方法存在事务，spring会对bean生成一个代理对象，从日志来看是cglib的<br>入口98行springaop事务增强 TransactionAspectSupport在事务中的调用，执行代理类的目标方法触发invoke</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">方法为<span class="keyword">protected</span>的，根据源代码注释解析</span></span><br></pre></td></tr></table></figure><p>if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager))<br>如果事务属性为null 且事务类型是CallbackPreferringPlatformTransactionManager进入304行commitTransactionAfterReturning(txInfo);方法<br>意为事务成功后执行，有异常不执行，没有事务不执行，也就是为后面的事务方法异常时没执行进行了铺垫，533行<br>txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());事务进行commit时进行判断<br>如果不是进行全局事务提交 但是是RollbackOnly的话<br>走processRollback处理实际回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">                    <span class="string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">        <span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Transactional code has requested rollback&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            processRollback(defStatus, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            日志追踪的<span class="number">710</span>行-----记住此处传<span class="function"><span class="keyword">true</span></span></span><br><span class="line"><span class="function">            <span class="title">processRollback</span><span class="params">(defStatus, <span class="keyword">true</span>)</span></span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        processCommit(defStatus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="keyword">boolean</span> unexpected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            入参为<span class="keyword">true</span></span><br><span class="line">            <span class="keyword">boolean</span> unexpectedRollback = unexpected;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                triggerBeforeCompletion(status);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Rolling back transaction to savepoint&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    status.rollbackToHeldSavepoint();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Initiating transaction rollback&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    doRollback(status);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Participating in larger transaction</span></span><br><span class="line">                    <span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                                logger.debug(<span class="string">&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            doSetRollbackOnly(status);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                                logger.debug(<span class="string">&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Should roll back transaction but cannot - no transaction available&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Unexpected rollback only matters here if we&#x27;re asked to fail early</span></span><br><span class="line">                    <span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">                        unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">                triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">            日志追踪的<span class="number">873</span>行  抛出异常</span><br><span class="line">            <span class="comment">// Raise UnexpectedRollbackException if we had a global rollback-only marker</span></span><br><span class="line">            <span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line">                        <span class="string">&quot;Transaction rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            cleanupAfterCompletion(status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>事务这里场景和传播行为相关知识点太多了，这个后续接着分析<br>但就此场景将伪代码贴一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        methodA()</span><br><span class="line">    &#125;<span class="keyword">catch</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        methodB()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodC()</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    methodC() &#123;</span><br><span class="line">        当C方法抛出异常时</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不知道大家对于rpc行为调用的接口是如何处理的，我们以前是将rpc调用的接口有Biz接收进来，进行参数处理，领域模型转换后，调取service进行内部数据处理的，但此时的接口在主流程上会伴随着另一个第三方接口的写操作，需进行事务处理，那么内层service接口为什么还要进行事务管理？在设计上理应不对rpc接口操作的service进行开放调用的，但业务上区分不同场景，不同供应商，不同酒店等对接口进行了反射调用，或者app调用，导致内层service也进行了事务操作，那么问题来了，嵌套事务时，如果内层事务注解取消不抛出<br>UnexpectedRollbackException，实际此方法内并没有完全执行完，<br>我希望是怎样的？我希望在保持事务原子性的前提，内层事务回滚则整个全局事务回滚，且不报此异常<br>第一种方法isGlobalRollbackOnParticipationFailure方法，让主事务来决定是否回滚，</p><p>改动成本大<br>而在Springaop中，被拦截的方法需要显式的抛出异常，并不能经过任何处理，这样aop才能进行回滚，默认aop是只catchruntimeException的异常 第二种方法可以在catch块里加上 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly() 手动回滚 即便上层事务发生了异常，也想要最终提交整个事务呢？如果有这样的需求的话，可以给事务管理器配置一个参数 setGlobalRollbackOnParticipationFailure(false); # 改动成本大<br>解决方案：在内层方法中不进行方法的try catch，有异常操作时在外层事务进行处理，且可决定是否回滚，特定的异常也再次处理</p><p>回顾：事务的失效场景(事务不生效和事务不回滚)</p><p>3、11个demo分析事务失效的场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class DemoService &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private Test1Mapper test1Mapper;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private TestMapper testMapper;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private InvalidTransactionService invalidTransactionService;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private DemoService _self;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private ValidTransactionService validTransactionService;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private RequireNewTransactionService requireNewTransactionService;</span><br><span class="line"></span><br><span class="line">/********************************************************</span><br><span class="line"> * 事务不生效场景1</span><br><span class="line"> * 相当于调用this调用，没有产生代理对象调用，解决方法，自己把自己注入以后调用</span><br><span class="line"> ********************************************************/</span><br><span class="line">public void demo1() &#123;</span><br><span class="line"></span><br><span class="line">invalidTransaction();</span><br><span class="line"></span><br><span class="line">//TODO other logic code here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">public void invalidTransaction() &#123;</span><br><span class="line">TestDO test = new TestDO();</span><br><span class="line">test.setName(&quot;11111&quot;);</span><br><span class="line">testMapper.insert(test);</span><br><span class="line"></span><br><span class="line">Test1DO test1 = new Test1DO();</span><br><span class="line">test1.setCust(&quot;2222&quot;);</span><br><span class="line">test1Mapper.insert(test1);</span><br><span class="line">throw new WMSException(ErrorCodeEnum.BD10001001.code(),&quot;事务不生效场景1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********************************************************</span><br><span class="line"> * 事务不生效场景二</span><br><span class="line"> * 这个例子的目的是为了catch住内层事务的异常，让外层事务成功，但是实际上没有内外层事务都回滚了</span><br><span class="line"> *</span><br><span class="line"> * 这里A和B都受事务控制，并且是处于同一个事务的。</span><br><span class="line"> * A调用B，A中抓了B的异常，当B发生异常的时候，B的操作应该回滚，但是A吃了异常，A方法中没有产生异常，所以A的操作又应该提交，二者是相互矛盾的。</span><br><span class="line"> * spring的事务关联拦截器在抓到B的异常后就会标记rollback-only为true，当A执行完准备提交后，发现rollback-only为true，也会回滚，并抛出异常告诉调用者。</span><br><span class="line"> *</span><br><span class="line"> * 报错提示：Transaction rolled back because it has been marked as rollback-only</span><br><span class="line"> *</span><br><span class="line"> * 如果想使外层事务生效可以把内层事务传播特性修改为：@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"> * </span><br><span class="line"> ********************************************************/</span><br><span class="line">@Transactional</span><br><span class="line">public void demo2() &#123;</span><br><span class="line">TestDO test = new TestDO();</span><br><span class="line">test.setName(&quot;3333&quot;);</span><br><span class="line">testMapper.insert(test);</span><br><span class="line">try &#123;</span><br><span class="line">invalidTransactionService.transaction();</span><br><span class="line">&#125;catch (Exception e) &#123;</span><br><span class="line">log.error(&quot;服务异常，异常被捕获&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********************************************************</span><br><span class="line"> * 事务不生效场景三</span><br><span class="line"> *</span><br><span class="line"> * 因为开了线程异步执行，等于事务完全在两个线程内，不在一个线程，所以即使抛错，也是一个生效一个不生效，</span><br><span class="line"> * 事务没有回滚</span><br><span class="line"> * </span><br><span class="line"> ********************************************************/</span><br><span class="line">@Transactional</span><br><span class="line">public void demo3() &#123;</span><br><span class="line">TestDO test = new TestDO();</span><br><span class="line">test.setName(&quot;5555&quot;);</span><br><span class="line">testMapper.insert(test);</span><br><span class="line"></span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">Test1DO test1 = new Test1DO();</span><br><span class="line">test1.setCust(&quot;6666&quot;);</span><br><span class="line">test1Mapper.insert(test1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">throw new WMSException(ErrorCodeEnum.BD10001001.code(),&quot;事务不生效场景3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********************************************************</span><br><span class="line"> * 事务不生效场景八</span><br><span class="line"> * Spring默认情况下会对运行期例外(RunTimeException)进行事务回滚。这个例外是unchecked，如果遇到checked意外就不回滚。</span><br><span class="line"> * Exception包含RuntimeException体系和其他非RuntimeException的体系</span><br><span class="line"> * Error和RuntimeException及其子类成为未检查异常（unchecked），其它异常成为已检查异常（checked）。</span><br><span class="line"> * spring声明式事务管理默认对非检查型异常和运行时异常进行事务回滚，而对检查型异常则不进行回滚操作</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *那么什么是检查型异常什么又是非检查型异常呢？</span><br><span class="line"> * 1.继承自runtimeexception或error的是非检查型异常，而继承自exception的则是检查型异常（当然，runtimeexception本身也是exception的子类）。</span><br><span class="line"> * 2.对非检查型类异常可以不用捕获，而检查型异常则必须用try语句块进行处理或者把异常交给上级方法处理总之就是必须写代码处理它。所以必须在service捕获异常，然后再次抛出，这样事务方才起效。</span><br><span class="line"> *</span><br><span class="line"> * @throws IOException </span><br><span class="line"> * </span><br><span class="line"> ********************************************************/</span><br><span class="line">@Transactional</span><br><span class="line">public void demo8() throws IOException &#123;</span><br><span class="line">TestDO test = new TestDO();</span><br><span class="line">test.setName(&quot;11111&quot;);</span><br><span class="line">testMapper.insert(test);</span><br><span class="line"></span><br><span class="line">Test1DO test1 = new Test1DO();</span><br><span class="line">test1.setCust(&quot;2222&quot;);</span><br><span class="line">test1Mapper.insert(test1);</span><br><span class="line">throw new IOException(&quot;事务不生效场景8&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********************************************************</span><br><span class="line"> * 事务不生效场景九</span><br><span class="line"> * @throws IOException </span><br><span class="line"> * </span><br><span class="line"> ********************************************************/</span><br><span class="line"></span><br><span class="line">public void demo9()&#123;</span><br><span class="line">invalidTransaction2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">private void invalidTransaction2() &#123;</span><br><span class="line">TestDO test = new TestDO();</span><br><span class="line">test.setName(&quot;11111&quot;);</span><br><span class="line">testMapper.insert(test);</span><br><span class="line"></span><br><span class="line">Test1DO test1 = new Test1DO();</span><br><span class="line">test1.setCust(&quot;2222&quot;);</span><br><span class="line">test1Mapper.insert(test1);</span><br><span class="line">throw new WMSException(&quot;事务不生效场景9&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********************************************************</span><br><span class="line"> * 事务生效场景1</span><br><span class="line"> * </span><br><span class="line"> ********************************************************/</span><br><span class="line">public void demo4() &#123;</span><br><span class="line"></span><br><span class="line">_self.invalidTransaction();</span><br><span class="line"></span><br><span class="line">//TODO other logic code here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********************************************************</span><br><span class="line"> * 事务生效场景二</span><br><span class="line"> *</span><br><span class="line"> * 因为内层没有事务控制，所以内层报错，不会混回滚，同样外层catch住，所以外层业务成功</span><br><span class="line"> ********************************************************/</span><br><span class="line">@Transactional</span><br><span class="line">public void demo5() &#123;</span><br><span class="line">TestDO test = new TestDO();</span><br><span class="line">test.setName(&quot;7777&quot;);</span><br><span class="line">testMapper.insert(test);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">validTransactionService.transaction();</span><br><span class="line">&#125;catch (Exception e) &#123;</span><br><span class="line">log.error(&quot;服务异常，异常被捕获&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********************************************************</span><br><span class="line"> * 事务生效场景三</span><br><span class="line"> *</span><br><span class="line"> *内层事务配置的是REQUIRES_NEW，表示自己用自己的，不和外层有牵连，内层如果报错，事务会回滚</span><br><span class="line"> * 外层如果catch住了，就可以正常执行，外层生效，内层回滚</span><br><span class="line"> ********************************************************/</span><br><span class="line">@Transactional</span><br><span class="line">public void demo6() &#123;</span><br><span class="line">TestDO test = new TestDO();</span><br><span class="line">test.setName(&quot;9999&quot;);</span><br><span class="line">testMapper.insert(test);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">requireNewTransactionService.transactionWithException();</span><br><span class="line">&#125;catch (Exception e) &#123;</span><br><span class="line">log.error(&quot;服务异常，异常被捕获&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********************************************************</span><br><span class="line"> * 独立事务</span><br><span class="line"> * 内外层事务独立，内层操作未报错，事务正常执行，外层有错，事务回滚。</span><br><span class="line"> ********************************************************/</span><br><span class="line">@Transactional</span><br><span class="line">public void demo7() &#123;</span><br><span class="line">TestDO test = new TestDO();</span><br><span class="line">test.setName(&quot;9999&quot;);</span><br><span class="line">testMapper.insert(test);</span><br><span class="line"></span><br><span class="line">requireNewTransactionService.transaction();</span><br><span class="line">throw new WMSException(ErrorCodeEnum.BD10001001.code(),&quot;独立事务&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、分布式事务以及分布式事务嵌套<br>一次业务操作需要跨多个数据源或需要垮多个系统进行远程调用,就会产生分布式事务问题<br>全局事务一致性问题<br>全局事务id+三组件 tc+tm+rm<br>Seata（AT 模式）的默认全局隔离级别是 读未提交（Read Uncommitted）</p><p>Seata 是 Simple Extensible Autonomous Transaction Architecture 的简写，由 feascar 改名而来。<br>AT模式 默认<br>TCC模式<br>XA模式<br>SAGA模式 长事务解决方案</p><p>XID 由ip 端口号 加全局事务id生成</p><p>关于分布式事务，工程领域主要讨论的是强一致性和最终一致性的解决方案。典型方案包括：<br>两阶段提交（2PC, Two-phase Commit）方案<br>eBay 事件队列方案<br>TCC 补偿模式<br>缓存数据最终一致性</p><p>一致性理论<br>分布式事务的目的是保障分库数据一致性，而跨库事务会遇到各种不可控制的问题，如个别节点永久性宕机，像单机事务一样的ACID是无法奢望的。另外，业界著名的CAP理论也告诉我们，对分布式系统，需要将数据一致性和系统可用性、分区容忍性放在天平上一起考虑。<br>两阶段提交协议（简称2PC）是实现分布式事务较为经典的方案，但2PC 的可扩展性很差，在分布式架构下应用代价较大，eBay 架构师Dan Pritchett 提出了BASE 理论，用于解决大规模分布式系统下的数据一致性问题。BASE 理论告诉我们：可以通过放弃系统在每个时刻的强一致性来换取系统的可扩展性。<br>CAP理论在分布式系统中，一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）3 个要素最多只能同时满足两个，不可兼得。<br>其中，分区容忍性又是不可或缺的。<br>avatar<br>一致性：分布式环境下多个节点的数据是否强一致。可用性：分布式服务能一直保证可用状态。当用户发出一个请求后，服务能在有限时间内返回结果。分区容忍性：特指对网络分区的容忍性。举例：Cassandra、Dynamo<br>等，默认优先选择AP，弱化C；HBase、MongoDB 等，默认优先选择CP，弱化A。<br>BASE理论核心思想：<br>基本可用（BasicallyAvailable）：指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用。<br>软状态（SoftState）：指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。<br>最终一致性（EventualConsistency）：指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态。<br>2. 一致性模型<br>数据的一致性模型可以分成以下 3 类：<br>强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。 弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。 最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。 分布式系统数据的强一致性、弱一致性和最终一致性可以通过Quorum NRW算法分析。<br>3. 分布式事务解决方案<br>2PC方案——强一致性<br>2PC的核心原理是通过提交分阶段和记日志的方式，记录下事务提交所处的阶段状态，在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在这个状态节点重试，如Coordinator重启后，通过日志可以确定提交处于Prepare还是PrepareAll状态，若是前者，说明有节点可能没有Prepare成功，或所有节点Prepare成功但还没有下发Commit，状态恢复后给所有节点下发RollBack；若是PrepareAll状态，需要给所有节点下发Commit，数据库节点需要保证Commit幂等。<br>avatar<br>2PC方案的问题：同步阻塞。数据不一致。单点问题。升级的3PC方案旨在解决这些问题，主要有两个改进：增加超时机制。两阶段之间插入准备阶段。但三阶段提交也存在一些缺陷，要彻底从协议层面避免数据不一致，可以采用Paxos或者Raft算法。<br>eBay 事件队列方案——最终一致性<br>eBay 的架构师Dan Pritchett，曾在一篇解释BASE 原理的论文《Base：An Acid<br>Alternative》中提到一个eBay<br>分布式系统一致性问题的解决方案。它的核心思想是将需要分布式处理的任务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行失败重试，它要求各服务的接口是幂等的。描述的场景为，有用户表user<br>和交易表transaction，用户表存储用户信息、总销售额和总购买额，交易表存储每一笔交易的流水号、买家信息、卖家信息和交易金额。如果产生了一笔交易，需要在交易表增加记录，同时还要修改用户表的金额。<br>avatar<br>论文中提出的解决方法是将更新交易表记录和用户表更新消息放在一个本地事务来完成，为了避免重复消费用户表更新消息带来的问题，增加一个操作记录表updates_applied来记录已经完成的交易相关的信息。</p><p>这个方案的核心在于第二阶段的重试和幂等执行。失败后重试，这是一种补偿机制，它是能保证系统最终一致的关键流程。<br>TCC （Try-Confirm-Cancel）补偿模式——最终一致性<br>某业务模型如图，由服务 A、服务B、服务C、服务D 共同组成的一个微服务架构系统。服务A 需要依次调用服务B、服务C 和服务D<br>共同完成一个操作。当服务A 调用服务D 失败时，若要保证整个系统数据的一致性，就要对服务B 和服务C 的invoke<br>操作进行回滚，执行反向的revert 操作。回滚成功后，整个微服务系统是数据一致的。<br>avatar<br>实现关键要素：服务调用链必须被记录下来。每个服务提供者都需要提供一组业务逻辑相反的操作，互为补偿，同时回滚操作要保证幂等。必须按失败原因执行不同的回滚策略。<br>缓存数据最终一致性<br>在我们的业务系统中，缓存（Redis 或者Memcached）通常被用在数据库前面，作为数据读取的缓冲，使得I/O<br>操作不至于直接落在数据库上。以商品详情页为例，假如卖家修改了商品信息，并写回到数据库，但是这时候用户从商品详情页看到的信息还是从缓存中拿到的过时数据，这就出现了缓存系统和数据库系统中的数据不一致的现象。<br>要解决该场景下缓存和数据库数据不一致的问题我们有以下两种解决方案：为缓存数据设置过期时间。当缓存中数据过期后，业务系统会从数据库中获取数据，并将新值放入缓存。这个过期时间就是系统可以达到最终一致的容忍时间。更新数据库数据后同时清除缓存数据。数据库数据更新后，同步删除缓存中数据，使得下次对商品详情的获取直接从数据库中获取，并同步到缓存。<br>常用组件： Seata，Sega，Atomikos<br>avatar<br>TC (Transaction Coordinator) - 事务协调者<br>维护全局和分支事务的状态，驱动全局事务提交或回滚。<br>TM (Transaction Manager) - 事务管理器<br>定义全局事务的范围：开始全局事务、提交或回滚全局事务。<br>RM (Resource Manager) - 资源管理器<br>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。<br>avatar<br>安装<br>关键注解全局@GlobalTranstional<br>1.更改事务组名称service<br>2.store更改mode 修改db<br>3.执行sql<br>4.修改注册进nacos<br>5.启动seata-server.bat<br>如何保证分布唯一全局id的生成</p><p>5、分布式事务异步方案<br>看下分布式事务的异步问题，根据事务的xid搭配future在切面里对注解进行处理，实现异步+分布式事务的并存<br>注意事项<br>这个依赖只是用来解决部分问题，不是解决全部问题<br>这个仅用于TM端，不要用来RM端(其实要实现RM端的话，可以仿照SeataAsyncAspect，写一个aspect，很简单的)<br>不要进行事务嵌套，不支持事务嵌套！！！<br>确保异步的多个操作之间是没有先后顺序的<br>这个是一个私人包装处理，仅供参考，还未应用到生产环境<br>—-待续</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;事务是我们平时项目中对数据操作最为直接、常用的方式，现在无论是大小公司都离不开对事务的操作，伴随业务的提升，客户量的积累也大大增加了对事务管理的难度。&lt;br&gt;在本章节中将会讲到如下内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;ta</summary>
      
    
    
    
    
    <category term="事务" scheme="https://zkkget.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>【声明】阿里云服务器导致图片不显示[可在此贴下方留言]</title>
    <link href="https://zkkget.github.io/posts/20220725cl89v5wvx000qt4ujb6v7c73k.html"/>
    <id>https://zkkget.github.io/posts/20220725cl89v5wvx000qt4ujb6v7c73k.html</id>
    <published>2022-07-25T08:10:26.000Z</published>
    <updated>2022-07-25T08:11:46.075Z</updated>
    
    <content type="html"><![CDATA[<p>1.图片服务器原因不定期修复…紧急修复中….<br>2.重要重要【图片不显示，请更换为火狐浏览器打开！！！或者手机在微信中打开也可食用】,放大图片更清晰<br>3.服务器内存过小,2020年10月13日后续部分内容将图片转至腾讯云<br>4.2d妹子会叫,有问题请留言</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.图片服务器原因不定期修复…紧急修复中….&lt;br&gt;2.重要重要【图片不显示，请更换为火狐浏览器打开！！！或者手机在微信中打开也可食用】,放大图片更清晰&lt;br&gt;3.服务器内存过小,2020年10月13日后续部分内容将图片转至腾讯云&lt;br&gt;4.2d妹子会叫,有问题请留言&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>主站博客迁移之字节跳动面经个人搜索答案</title>
    <link href="https://zkkget.github.io/posts/20220725cl89v5ww50011t4uj7xbf6kqg.html"/>
    <id>https://zkkget.github.io/posts/20220725cl89v5ww50011t4uj7xbf6kqg.html</id>
    <published>2022-07-25T07:47:01.000Z</published>
    <updated>2022-07-26T02:30:47.107Z</updated>
    
    <content type="html"><![CDATA[<p>问题来源<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E9%A2%98.jpg" alt="流程"></p><h1 id="1-线程池参数的含义？"><a href="#1-线程池参数的含义？" class="headerlink" title="1.线程池参数的含义？"></a>1.线程池参数的含义？</h1><p>int corePoolSize：常驻线程数<br>int maximumPoolSize：线程池同时执行的最大线程数，&gt;=1<br>long keepAliveTime:空闲线程的存活时间<br>TimeUnit unit：keepAliveTime的单位<br>BlockingQueueworkQueue：被提交等待被执行的任务<br>ThreadFactory threadFactory：工作线程的线程工厂<br>RejectedExecutionHandler handler：线程池拒绝策略<br>线程池拒绝策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize时，</span><br><span class="line">如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</span><br><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。 </span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务 </span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务</span><br></pre></td></tr></table></figure><h1 id="2-innodb的索引实现"><a href="#2-innodb的索引实现" class="headerlink" title="2.innodb的索引实现"></a>2.innodb的索引实现</h1><p>1.表数据文件本身是按照B+tree组织的一个索引文件结构<br>2.聚集索引叶子结点包含了完整的数据记,这个索引的key是数据表的主键</p><h1 id="3-为什么是B-tree？"><a href="#3-为什么是B-tree？" class="headerlink" title="3.为什么是B+tree？"></a>3.为什么是B+tree？</h1><p>其实选择B+tree是因为树的高度小,Hash有个致命的缺点就是浪费内存,如果采用二叉树，那么当数据量越大的时候，这棵树就越深，树越深IO的次数就会越多（提高系统效率的两种方式：1、减少IO次数 2、减少IO量）<br>根据上述分析得出我们需要得出结论：我们需要找一个有多个分支且有序的多叉有序树<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/B%2Btree.jpg" alt="流程"></p><h1 id="4-操作系统虚拟内存换页的过程是什么？"><a href="#4-操作系统虚拟内存换页的过程是什么？" class="headerlink" title="4.操作系统虚拟内存换页的过程是什么？"></a>4.操作系统虚拟内存换页的过程是什么？</h1><p>1.如果内存中有空闲的物理页面，则分配一物理页帧r，然后转第4步，否则转第2步；<br>2.选择某种页面置换算法，选择一个将被替换的物理页帧r，它所对应的逻辑页为q，如果该页在内存期间被修改过，则需把它写回到外存；<br>3.将q所对应的页表项进行修改，把驻留位置0；<br>4.将需要访问的页p装入到物理页面r中；<br>5.修改p所对应的页表项的内容，把驻留位置1，把物理页帧号置为x；<br>6.重新运行被中断的指令。</p><h1 id="5-线程池大小与-CPU-处理器的利用率之比可以用下面公式估算"><a href="#5-线程池大小与-CPU-处理器的利用率之比可以用下面公式估算" class="headerlink" title="5.线程池大小与 CPU 处理器的利用率之比可以用下面公式估算"></a>5.线程池大小与 CPU 处理器的利用率之比可以用下面公式估算</h1><p>CPU密集型多为cpu运算频繁的：设置CPU核数+1<br>IO密集型：设置cpu核数*10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Support class for thread pool size</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Nadeem Mohammad</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadPoolUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Each tasks blocks 90% of the time, and works only 10% of its</span></span><br><span class="line"><span class="comment"> *lifetime. That is, I/O intensive pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> io intesive Thread pool size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ioIntesivePoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> blockingCoefficient = <span class="number">0.9</span>;</span><br><span class="line"><span class="keyword">return</span> poolSize(blockingCoefficient);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Number of threads = Number of Available Cores / (1 - Blocking</span></span><br><span class="line"><span class="comment"> * Coefficient) where the blocking coefficient is between 0 and 1.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * A computation-intensive task has a blocking coefficient of 0, whereas an</span></span><br><span class="line"><span class="comment"> * IO-intensive task has a value close to 1,</span></span><br><span class="line"><span class="comment"> * so we don&#x27;t have to worry about the value reaching 1.</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> blockingCoefficient the coefficient</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@return</span> Thread pool size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">poolSize</span><span class="params">(<span class="keyword">double</span> blockingCoefficient)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//cpu核数</span></span><br><span class="line"><span class="keyword">int</span> numberOfCores = Runtime.getRuntime().availableProcessors();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> poolSize = (<span class="keyword">int</span>) (numberOfCores / (<span class="number">1</span> - blockingCoefficient));</span><br><span class="line"><span class="keyword">return</span> poolSize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-Redis的使用—分布式锁的实现"><a href="#6-Redis的使用—分布式锁的实现" class="headerlink" title="6.Redis的使用—分布式锁的实现"></a>6.Redis的使用—分布式锁的实现</h1><p>1.数据库乐观锁；<br>2.基于Redis的分布式锁；<br>3.基于ZooKeeper的分布式锁<br>4.redisson的红锁<br>一 基于数据库<br>a.数据库建一张表，字段方法名并且作为唯一性，当一个方法执行时插入，则相当于获得锁，其他线程将无法访问，方法执行完则释放锁。</p><p>但是上面这种存在问题：</p><p>1、数据库单点，出现故障则将导致系统不可用。</p><p>2、没有失效时间，一旦操作方法异常，导致一直没有解锁，也将导致其他不可用用。</p><p>b.使用select * from user u where username = ‘’ for update 来对记录加上排他锁。操作完成后使用commit命令释放锁。<br>二基于缓存 redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">&quot;NX&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">&quot;PX&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三基于zk<br>大致思路：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p><p>ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同步到所有的Follower机器上，所以性能上不如基于缓存实现。<br>综合比较:1.3性能低，推荐redis<br>如果对数据有强一致性要求,不能放缓存</p><h1 id="7-TCP-三次握手和四次挥手"><a href="#7-TCP-三次握手和四次挥手" class="headerlink" title="7.TCP 三次握手和四次挥手"></a>7.TCP 三次握手和四次挥手</h1><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="流程"></p><p>三次握手只是在建立连接。三次握手之后，才有资源的开辟。可以开始传输数据了。<br>C -&gt; S (syn, seq=j) C 说，我想连接<br>S -&gt; C (syn+ack, ack=j+1, syn=k) 发完之后，C 知道了 S 能收到自己的消息<br>C -&gt; S (ack, ack=k+1) 发完之后，S 知道了 C 能收到自己的消息（确认是双向的），这就是为什么需要第三次握手<br>三次握手之后，双方开辟资源，建立了 socket，实际应用时，第三次握手包和发送的数据包是粘连在一起的。</p><p>如果类比三次握手，在第二次挥手的时候同时发 FIN + ACK 明显不合理，因为被动方可能没有数据发送完，你这么关太草率了，所以需要四次。<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="流程"><br>①客户端发送报文===&gt;<br>②服务端收到报文，结束监听，返回一段报文<br>③客户端确认收到TCP报文，并返回最后一段TCP报文<br>即SYN建立连接报文与ACK确认接收报文是在同一次”握手”当中传输的，所以”三次握手”不多也不少，正好让双方明确彼此信息互通<br>所谓的四次挥手即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放<br>都是由客户端发起</p><h1 id="8-为什么四次分手之后，还会等两个传输时间，才会释放资源"><a href="#8-为什么四次分手之后，还会等两个传输时间，才会释放资源" class="headerlink" title="8.为什么四次分手之后，还会等两个传输时间，才会释放资源"></a>8.为什么四次分手之后，还会等两个传输时间，才会释放资源</h1><p>因为如果最后 C 端返回的 ACK 号丢失了，这时 S 端没有收到 ACK，会重发一遍 FIN，如果此时客户端的套接字已经被删除了，会发生什么呢？套接字被删除，端口被释放，这时别的应用可能创建新的套接字，恰好分配了同一个端口号，而服务器重发的 FIN 正好到达，这个 FIN 就会错误的跑到新的套接字里面，新的套接字就开始执行断开操作了。为了避免这样的误操作，C 端会等几分钟再删除套接字。</p><h1 id="9-volatile关键字的作用"><a href="#9-volatile关键字的作用" class="headerlink" title="9.volatile关键字的作用"></a>9.volatile关键字的作用</h1><p>被volatile修饰的变量在编译成字节码文件时会多个lock指令，该指令在执行过程中会生成相应的内存屏障，以此来解决可见性跟重排序的问题。</p><p>1.解决的是多核CPU带来的缓存与CPU之间数据的可见性<br>JMM:java内存模型<br>1.线程解锁前，必须把共享变量刷新回主内存<br>2.线程加锁前，必须读取主内存的最新值到自己的工作内存<br>3.加锁与解锁必须是同一把锁<br>volatile实现内存指令重排，保证可见性和禁止指令重排，<br>可保证一段内存中一个变量的原子性，原生类型都是原子性的。所以java中 volatile long，volatile double都是线程安全的</p><h1 id="10-乐观锁，悲观"><a href="#10-乐观锁，悲观" class="headerlink" title="10.乐观锁，悲观"></a>10.乐观锁，悲观</h1><p>乐观锁(Optimistic Lock):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</span><br><span class="line">两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，</span><br><span class="line">这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适</span><br></pre></td></tr></table></figure><p>悲观锁(Pessimistic Lock)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</span><br></pre></td></tr></table></figure><h1 id="11-HashMap结构，是否线程安全-ConcurrentHashMap如何保证线程安全"><a href="#11-HashMap结构，是否线程安全-ConcurrentHashMap如何保证线程安全" class="headerlink" title="11.HashMap结构，是否线程安全?ConcurrentHashMap如何保证线程安全"></a>11.HashMap结构，是否线程安全?ConcurrentHashMap如何保证线程安全</h1><p>HashMap在java1.7之前底层数据结构是数组+链表，1.8之后是数组+链表+红黑树，<br>在1.7以前的put方法采用的是头插法，当hash碰撞次数到达8，且桶内元素到达64个的时候形成链表，但是在极端情况下会造成链表过长，效率变低，并且在rehash的时候，头插法会造成回环链首尾相连，形成死锁，在java1.8以后采用红黑树，除了添加效率都高，是线程不安全的，不安全示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMapThread thread0 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        HashMapThread thread1 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        HashMapThread thread2 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        HashMapThread thread3 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        HashMapThread thread4 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMapThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ai.get() &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">            map.put(ai.get(), ai.get());</span><br><span class="line">            ai.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.通常代替HashMap的安全由HashTable代替，但是多线程下他的put.get方法都是synchronized，效率太低，<br>2.Collections.synchronizedMap(),底层仍是synchronized<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/java9.jpg" alt="流程"><br>3.ConcurrentHashMap 与 ConcurrentSkipListMap<br>ConcurrentHashMap 加锁<br>ConcurrentSkipListMap 不需要加锁，浪费空间，<br>4.ConcurrentHashMap<br>ConcurrentHashMap如何保证线程安全，在1.7以前由划分segment分段锁机制，共计16个并发级别，隔离级别太大，有很多空间就浪费了，太小就段内的元素过多<br>1.8以后是cas算法C语言写得，无锁算法，put添加的时候，链表+红黑树<br>put方法（无锁添加）</p><h1 id="12-之前用过哪些设计模式"><a href="#12-之前用过哪些设计模式" class="headerlink" title="12.之前用过哪些设计模式"></a>12.之前用过哪些设计模式</h1><p>目前项目再用的是责任链设计模型，像动态代理，装饰者，工厂模式，在Spring的源码中都有体现，责任链模式旨在降低处理请求流程的耦合<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&mid=2247484453&idx=1&sn=3f4160943cab8fa5f22048b66f7bc588&chksm=ceb09b58f9c7124e65565183cac89fe041f8cec1e06f4e1711d614957ea2ce4bb02a16b8ff3d&token=827240829&lang=zh_CN#rd" title="责任链模式">责任链模式</a></p><h1 id="13-滑动窗口"><a href="#13-滑动窗口" class="headerlink" title="13.滑动窗口"></a>13.滑动窗口</h1><p>题目描述<br>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和≥ s的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p><p>示例:</p><p>输入: s = 7, nums = [2,3,1,2,4,3]<br>输出: 2<br>解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析  滑动窗口 Sliding  Window</span></span><br><span class="line">          <span class="comment">/*1+2+3=6</span></span><br><span class="line"><span class="comment">            6-1+6=11    = 2+3+6  6-移除的数+加入的数</span></span><br><span class="line"><span class="comment">            11-2+4=13  =3+6+4</span></span><br><span class="line"><span class="comment">            13-3+5=15  =6+4+5</span></span><br><span class="line"><span class="comment">            数组定长</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, result = nums.length + <span class="number">1</span>, total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; nums.length) &#123;</span><br><span class="line">            total += nums[j];</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">while</span> (total &gt;= s) &#123;</span><br><span class="line">                result = Math.min(result, j - i);</span><br><span class="line">                total -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == nums.length + <span class="number">1</span> ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="14-Btree和-B-tree的优缺点"><a href="#14-Btree和-B-tree的优缺点" class="headerlink" title="14.Btree和 B+tree的优缺点"></a>14.Btree和 B+tree的优缺点</h1><p>B+树中的B代表平衡（balance），而不是二叉（binary）<br>二叉查找树<br>二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。<br>平衡二叉树<br>如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。</p><p>B+Tree<br>B+Tree相对于B-Tree有几点不同：<br>非叶子节点只存储键值信息。<br>所有叶子节点之间都有一个链指针。<br>数据记录都存放在叶子节点中。<br>查询速度快，但是占用空间<br>索引结构：B-Tree B+Tree B：balance<br>B-Tree：平衡二叉树<br>特点：<br>1.具有数据节点<br>2.指向下层指针<br>3.指向数据指针<br>缺页查询,产生IO<br>B+Tree：<br>特点:<br>1.具有数据节点<br>2.指向下层指针<br>命中数据3层查找后查询数据指针<br>加载更快，产生更少IO<br>效率：BTree更高，但从IO角度，Mysql选择B+Tree</p><h1 id="15-说一下HashMap的实现，扩容机制，扩容时如何保证操作"><a href="#15-说一下HashMap的实现，扩容机制，扩容时如何保证操作" class="headerlink" title="15.说一下HashMap的实现，扩容机制，扩容时如何保证操作"></a>15.说一下HashMap的实现，扩容机制，扩容时如何保证操作</h1><p>put 方法比较复杂，实现步骤大致如下：<br>1、先通过 hash 值计算出 key 映射到哪个桶。<br>2、如果桶上没有碰撞冲突，则直接插入。<br>3、如果出现碰撞冲突了，则需要处理冲突：<br>（1）如果该桶使用红黑树处理冲突，则调用红黑树的方法插入。<br>（2）否则采用传统的链式方法插入。如果链的长度到达临界值，则把链转变为红<br>黑树。<br>4、如果桶中存在重复的键，则为该键替换新值。<br>5、如果 size 大于阈值(8)，则进行扩容</p><p>根据hash算法得到hash码值，也就是数组的索引值，在判断是否有对象，如果没有则放入<br>如果有则先通过equals比较两个对象的内容，如果内容一样，则覆盖value，<br>如果内容不一样，形成链表，1.7后加的放前面，这种情况叫做hash碰撞，这种情况我们是尽可能避免的，如果这里的元素过多的话，插入效率过低，为了避免的话，重写hashcode和equals方法保持一致，这种情况避免不了<br>加载因子，当到达元素个数的0.75，进行扩容，扩容则每个元素重新运算位置，，如果到达100%其他位置可能会不存入，如果太小，则频繁扩容，可浪费空间。这样碰撞的概率会降低，但是极端情况下还是需要查询每个元素比较，效率极低。<br>1.8以后，数组+链表+红黑树<br>当碰撞的个数大于8时，并且总容量大于64时，将链表转为红黑树，除了添加以外其他的效率都高，jdk1.8加到链表末尾，扩容以后不需要运行hash算法计算hashcode值。原来hash表的总长度，加上hash表的现在的位置，就放到第8个位置即可。<br>3.redis扩容机制(渐进式单线程扩容)<br>Redis是一个键值对（key-value pair）数据库服务器，Redis服务器结构是redis.h/redisServer结构表示，Redis服务器中的所有数据库保存在db数组中，数据库的结构是redis.h/redisDb，其中，redisDb结构的dict字典保存了数据库中的所有键值对，所以，说起Redis的扩容机制，指的就是字典中哈希表的rehash（重新散列）操作<br>在实际开发过程中，这个rehash 操作并不是一次性、集中式完成的，而是分多次、渐进式地完成的。<br>　　　　渐进式rehash 的详细步骤：<br>　　　　　　1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表<br>　　　　　　2、在几点钟维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始<br>　　　　　　3、在rehash 进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一<br>　　　　　　4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束<br>　　　　采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量。</p><h1 id="16-SpringAop，ioc的原理，如何解决循环依赖"><a href="#16-SpringAop，ioc的原理，如何解决循环依赖" class="headerlink" title="16.SpringAop，ioc的原理，如何解决循环依赖"></a>16.SpringAop，ioc的原理，如何解决循环依赖</h1><p>SpringIoc可以对我们应用程序中的java对象做一个集中化的管理，从而使我们从繁琐的new Object()；中解脱出来<br>Spring中AOP的有两种实现方式：<br>1、JDK动态代理<br>2、Cglib动态代理<br>在没有修改原有类的代码的情况下，对原有类的功能进行了增强<br>静态代理模式：静态代理说白了就是在程序运行前就已经存在代理类的字节码文件，代理类和原始类的关系在运行前就已经确定<br>动态代理模式:动态代理类的源码是在程序运行期间通过JVM反射等机制动态生成，代理类和委托类的关系是运行时才确定的<br>使用jdk生成的动态代理的前提是目标类必须有实现的接口。但这里又引入一个问题,如果某个类没有实现接口,就不能使用JDK动态代理,所以Cglib代理就是解决这个问题的<br>Cglib使用的前提是目标类不能为final修饰。因为final修饰的类不能被继承。<br>核心原理是使用动态代理模式在方法执行前后或出现异常时加入相关逻辑。<br>通过定义和前面代码我们可以发现3点：<br>1.AOP是基于动态代理模式。<br>2.AOP是方法级别的（要测试的方法不能为static修饰，因为接口中不能存在静态方法，编译就会报错）。<br>3.AOP可以分离业务代码和关注点代码（重复代码），在执行业务代码时，动态的注入关注点代码。切面就是关注点代码形成的类。</p><p>循环依赖解决<br>1.在字段上使用@Autowired注解，让Spring决定在合适的时机注入<br>2.用基于setter方法的依赖注入</p><h1 id="17-两个线程对变量i进行加1操作，结果如何？为什么？如何解决？"><a href="#17-两个线程对变量i进行加1操作，结果如何？为什么？如何解决？" class="headerlink" title="17.两个线程对变量i进行加1操作，结果如何？为什么？如何解决？"></a>17.两个线程对变量i进行加1操作，结果如何？为什么？如何解决？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i=i+<span class="number">1</span>;</span><br><span class="line">    action();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;==&gt;&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    Thread t2= <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==&gt;t1:<span class="number">1</span></span><br><span class="line">==&gt;t2:<span class="number">2</span></span><br><span class="line"></span><br><span class="line">==&gt;t1:<span class="number">2</span></span><br><span class="line">==&gt;t2:<span class="number">1</span></span><br><span class="line"></span><br><span class="line">==&gt;t1:<span class="number">2</span></span><br><span class="line">==&gt;t2:<span class="number">2</span></span><br></pre></td></tr></table></figure><p>线程安全问题，对共享变量进行修改<br>改进方法1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SysUserServiceImpl.class)&#123;</span><br><span class="line">        i=i+<span class="number">1</span>;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;==&gt;&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    Thread t2= <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized在多jvm情况下不生效,且效率低下<br>方法2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = num.getAndIncrement();</span><br><span class="line">    action(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;由&quot;</span>+i+<span class="string">&quot;==&gt;&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    Thread t2= <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==&gt;&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            i=i+<span class="number">1</span>;</span><br><span class="line">            action();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(SysUserServiceImpl::inc,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2= <span class="keyword">new</span> Thread(SysUserServiceImpl::inc,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="18-CAS概念，原子类实现"><a href="#18-CAS概念，原子类实现" class="headerlink" title="18.CAS概念，原子类实现"></a>18.CAS概念，原子类实现</h1><p>CAS锁是比较偏重的操作？<br>CAS在操作锁时，执行比较并交换操作，相对synchronized瘦锁是比较重的锁，偏向锁在这里避免了CAS操作。UseBiaseLocking对synchronize有用<br>比较并交换，判断取出内存中某时刻的数据并在当下时刻进行交换，缺点：循环时间长，只能保证一个共享变量的原子操作，引来ABA问题?<br>CAS核心是由native修饰的Unsafe类，其中valueOff为内存偏移量地址，变量由volatile修饰。<br>private static final Unsafe unsafe<br>private volatile int value;<br>unsafe类是CAS的核心类，是由C语言native方法来访问的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中getAndAddInt方法，this表示当前对象valueoffset表示内存中的偏移地址，delta是当前value增加的变量<br>CAS即比较当前值与预设值，交换并增加，如果与预想一致就交换，否则再次自旋，所以带来循环开销问题，进而引来ABA问题。<br>原子类的话经典类：AtomicInteger，其共享变量是由volatile修饰的，<br>getAndIncrement是unsafe类操作，底层也是cas</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized</p><h1 id="19-synchronized和Lock有什么区别？"><a href="#19-synchronized和Lock有什么区别？" class="headerlink" title="19.synchronized和Lock有什么区别？"></a>19.synchronized和Lock有什么区别？</h1><p>①:synchronized是JVM层面实现的，java提供的关键字，Lock是API层面的锁。<br>②:synchronized不需要手动释放锁，底层会自动释放，<br>Lock则需要手动释放锁，否则有可能导致死锁<br>③:synchronized等待不可中断，除非抛出异常或者执行完成<br>Lock可以中断，通过interrupt()可中断<br>④:synchronized是非公平锁<br>Lock是默认公平锁，当传入false时是非公平锁<br>⑤:synchronized不可绑定多个条件<br>Lock可实现分组唤醒需要唤醒的锁<br>monitorenter<br>monitorexit<br>synchronized通过监控对象来完成，本质是锁一个对象<br>同步方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;  </span><br><span class="line">  public synchronized void method() &#123;</span><br><span class="line">          System.out.println(&quot;synchronized....&quot;);  </span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰方法与修饰代码块产生字节码不同<br>如何实现lock，AQS:AbstractQueuedSynchronizer,AQS是ReentrantLock的核心实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock的子类Sync类的final static子类FairSync和NonFairSync用于支持公平锁和非公平锁。<br>AQS的tryAcquire()和FairSync的tryAcquire()判定是否为公平锁，其实现也是偏向锁UseBiaseLock的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br><span class="line">     * recursive call or no waiters or is first.</span><br><span class="line">     */</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先会判断当前线程的状态，如果c==0 说明没有线程正在竞争锁。（反过来，如果c!=0则说明已经有其他线程已经拥有了锁）。如果c==0，则通过CAS将状态设置为acquires(独占锁的acquires为1)，后续每次重入该锁都会+1，每次unlock都会-1，当数据为0时则释放锁资源。其中精妙的部分在于：并发访问时，有可能多个线程同时检测到c为0，此时执行compareAndSetState(0, acquires))设置，可以预见，如果当前线程CAS成功，则其他线程都不会再成功，也就默认当前线程获取了锁，直接作为running线程，很显然这个线程并没有进入等待队列。如果c!=0，首先判断获取锁的线程是不是当前线程，如果是当前线程，则表明为锁重入，继续+1，修改state的状态，此时并没有锁竞争，也非CAS，因此这段代码也非常漂亮的实现了偏向锁。</p><h1 id="20-AQS有什么特点"><a href="#20-AQS有什么特点" class="headerlink" title="20.AQS有什么特点"></a>20.AQS有什么特点</h1><p>AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.util.concurrent）下locks包内的一个类。它实现了一个FIFO(FirstIn、FisrtOut先进先出)的队列。底层实现的数据结构是一个双向链表<br>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中</p><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p><p>//返回同步状态的当前值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected final int getState() &#123;  </span><br><span class="line">        return state;</span><br><span class="line">&#125;</span><br><span class="line"> // 设置同步状态的值</span><br><span class="line">protected final void setState(int newState) &#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span><br><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、AQS设计思想<br>使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。</p><p>利用int类型标识状态。在AQS类中有一个叫做state的成员变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The synchronization state.</span><br><span class="line"> */</span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><p>基于AQS有一个同步组件，叫做ReentrantLock。在这个组件里，stste表示获取锁的线程数，假如state=0，表示还没有线程获取锁，1表示有线程获取了锁。大于1表示重入锁的数量。</p><p>继承：子类通过继承并通过实现它的方法管理其状态（acquire和release方法操纵状态）。</p><p>可以同时实现排它锁和共享锁模式（独占、共享），站在一个使用者的角度，AQS的功能主要分为两类：独占和共享。它的所有子类中，要么实现并使用了它的独占功能的api，要么使用了共享锁的功能，而不会同时使用两套api，即便是最有名的子类ReentrantReadWriteLock也是通过两个内部类读锁和写锁分别实现了两套api来实现的。</p><p>3、AQS的大致实现思路<br>AQS内部维护了一个CLH队列来管理锁。线程会首先尝试获取锁，如果失败就将当前线程及等待状态等信息包装成一个node节点加入到同步队列sync queue里。 接着会不断的循环尝试获取锁，条件是当前节点为head的直接后继才会尝试。如果失败就会阻塞自己直到自己被唤醒。而当持有锁的线程释放锁的时候，会唤醒队列中的后继线程。</p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p><h1 id="Spring-主要思想-IOC-AOP"><a href="#Spring-主要思想-IOC-AOP" class="headerlink" title="Spring 主要思想 IOC,AOP"></a>Spring 主要思想 IOC,AOP</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问题来源&lt;br&gt;&lt;img src=&quot;https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E9%A2%98.jpg&quot; alt=&quot;流程&quot;&gt;&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    
    <category term="面试,字节跳动" scheme="https://zkkget.github.io/tags/%E9%9D%A2%E8%AF%95-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>主站博客迁移之Nginx安装与原理</title>
    <link href="https://zkkget.github.io/posts/20220725cl89v5wvy000st4uj12n6bmhz.html"/>
    <id>https://zkkget.github.io/posts/20220725cl89v5wvy000st4uj12n6bmhz.html</id>
    <published>2022-07-25T07:39:59.000Z</published>
    <updated>2022-07-25T07:41:06.698Z</updated>
    
    <content type="html"><![CDATA[<p>官网<a href="http://nginx.org/">http://nginx.org/</a><br>需要的素材</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pcre-<span class="number">8.37</span>.tar.gz</span><br><span class="line">openssl-<span class="number">1.0</span>.1t.tar.gz</span><br><span class="line">zlib-<span class="number">1.2</span><span class="number">.8</span>.tar.gz</span><br><span class="line">nginx-<span class="number">1.11</span><span class="number">.1</span>.tar.gz</span><br></pre></td></tr></table></figure><p>1.1.安装pcre<br>解压缩pcre-xx.tar.gz包<br>进入解压缩目录，执行./configure<br>如果提示，需要提前安装gcc++<br>进入安装光盘目录的软件包(/media/CentOSXX/Package)<br>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh libstdc++-devel-<span class="number">4.4</span><span class="number">.7</span>-<span class="number">17.</span>el6.x86_64.rpm</span><br><span class="line">rpm -ivh gcc-c++-<span class="number">4.4</span><span class="number">.7</span>-<span class="number">17.</span>el6.x86_64.rpm</span><br></pre></td></tr></table></figure><p>./configure完成后，回到pcre目录下执行make，再执行make install<br>2. 安装openssl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 解压缩openssl-xx.tar.gz包。</span><br><span class="line"><span class="number">2</span>、 进入解压缩目录，执行./config</span><br><span class="line"><span class="number">3</span>、 make &amp;&amp; make install</span><br><span class="line"><span class="number">3.</span> 安装zlib</span><br><span class="line"><span class="number">1</span>、 解压缩zlib-xx.tar.gz包。</span><br><span class="line"><span class="number">2</span>、 进入解压缩目录，执行./configure。</span><br><span class="line"><span class="number">3</span>、 make &amp;&amp; make install</span><br><span class="line"><span class="number">4.</span> 安装nginx</span><br><span class="line"><span class="number">1</span>、 解压缩nginx-xx.tar.gz包。</span><br><span class="line"><span class="number">2</span>、 进入解压缩目录，执行./configure。</span><br><span class="line"><span class="number">3</span>、 make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>nginx无法启动: libpcre.so.1/libpcre.so.0: cannot<br>open shared object file解决办法<br>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/lib/libpcre.so.1 /lib64</span><br><span class="line">32位系统则：</span><br><span class="line">ln -s /usr/local/lib/libpcre.so.1 /lib</span><br></pre></td></tr></table></figure><p>在/usr/local/nginx/sbin目录下<br>执行 ./nginx<br>启动命令 在/usr/local/nginx/sbin目录下<br>执行 ./nginx<br>关闭命令 在/usr/local/nginx/sbin目录下<br>执行 ./nginx -s stop<br>重新加载命令 在/usr/local/nginx/sbin目录下<br>执行 ./nginx -s reload<br>设置nginx为自启动服务<br>修改linux 启动脚本/etc/rc.d/rc<br>加入 :<br>/usr/local/nginx/sbin/nginx<br>5、配置nginx.conf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">......</span><br><span class="line">upstream myserver&#123;</span><br><span class="line">ip_hash;<span class="comment">//ip取哈希码  与反向代理服务器取模 分在那一台</span></span><br><span class="line">server <span class="number">115.28</span><span class="number">.52</span><span class="number">.63</span>:<span class="number">8080</span> weight=<span class="number">1</span>;</span><br><span class="line">server <span class="number">115.28</span><span class="number">.52</span><span class="number">.63</span>:<span class="number">8180</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">server&#123;</span><br><span class="line">location / &#123;</span><br><span class="line">.........</span><br><span class="line">proxy_pass http:<span class="comment">//myserver;</span></span><br><span class="line">proxy_connect_timeout <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>master-workers的机制的好处<br>首先，对于每个worker进程来说，独立的进程，不需要加锁，<br>所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方<br>便很多。<br>其次，采用独立的进程，可以让互相之间不会影响，一个进程<br>退出后，其它进程还在工作，服务不会中断，master进程则很快启<br>动新的worker进程。当然，worker进程的异常退出，肯定是程序有<br>bug了，异常退出，会导致当前worker上的所有请求失败，不过不<br>会影响到所有请求，所以降低了风险<br>需要设置多少个worker<br>Nginx 同redis类似都采用了io多路复用机制，每个<br>worker都是一个独立的进程，但每个进程里只有一个主线<br>程，通过异步非阻塞的方式来处理请求， 即使是千上万个<br>请求也不在话下。每个worker的线程可以把一个cpu的性<br>能发挥到极致。<br>所以worker数和服务器的cpu数相等是最为适宜的。设<br>少了会浪费cpu，设多了会造成cpu频繁切换上下文带来的<br>损耗。</p><p>//静态资源请求 2个<br>//动态资源请求 4个</p><p>#设置worker数量。<br>worker_processes 4<br>#work绑定cpu(4 work绑定4cpu)。<br>worker_cpu_affinity 0001 0010 0100 1000<br>#work绑定cpu (4 work绑定8cpu中的4个) 。<br>worker_cpu_affinity 0000001 00000010 00000100<br>00001000<br>连接数worker_connection<br>• 这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx<br>能建立的最大连接数，应该是worker_connections * worker_processes。<br>当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的<br>最大并发数量是worker_connections * worker_processes，如果是支持<br>http1.1的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数<br>是： worker_connections * worker_processes /2，而如果是HTTP作<br>为反向代理来说，最大并发数量应该是worker_connections *<br>worker_processes/4。因为作为反向代理服务器，每个并发会建立与客<br>户端的连接和与后端服务的连接，会占用两个连接。</p><p>worker_connections * worker_processes /2 静态<br>worker_connections * worker_processes /4 动态</p><p>work最先处理请求 nobody表示权限最低 路人甲<br>use epoll</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官网&lt;a href=&quot;http://nginx.org/&quot;&gt;http://nginx.org/&lt;/a&gt;&lt;br&gt;需要的素材&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    
    <category term="Nginx" scheme="https://zkkget.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>主站博客迁移之Thymleaf项目常用操作</title>
    <link href="https://zkkget.github.io/posts/20220725cl89v5ww3000yt4uj4uac4z0a.html"/>
    <id>https://zkkget.github.io/posts/20220725cl89v5ww3000yt4uj4uac4z0a.html</id>
    <published>2022-07-25T07:36:44.000Z</published>
    <updated>2022-07-25T07:39:16.989Z</updated>
    
    <content type="html"><![CDATA[<p>Thymleaf搭配Springboot完成页面渲染，整理下日常开发中常见常用操作<br>1.下拉框动态被选中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;inputLevel&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;col-6 col-form-label form-label&quot;</span>&gt;用户等级:&lt;/label&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;col-6&quot;</span>&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;inputLevel&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;form-control&quot;</span> name=<span class="string">&quot;level&quot;</span>&gt;</span><br><span class="line">&lt;option value=<span class="string">&quot;&quot;</span></span><br><span class="line">th:selected=<span class="string">&quot;$&#123;null==req?&#x27;selected&#x27;:req.level==null?&#x27;select&#x27;:&#x27;false&#x27;&#125;&quot;</span>&gt;</span><br><span class="line">全部</span><br><span class="line">&lt;/option&gt;</span><br><span class="line">&lt;option value=<span class="string">&quot;1&quot;</span></span><br><span class="line">th:selected=<span class="string">&quot;$&#123;null==req?&#x27;false&#x27;:req.level==&#x27;1&#x27;?&#x27;select&#x27;:&#x27;false&#x27;&#125;&quot;</span>&gt;<span class="number">1</span>级</span><br><span class="line">&lt;/option&gt;</span><br><span class="line">&lt;option value=<span class="string">&quot;2&quot;</span></span><br><span class="line">th:selected=<span class="string">&quot;$&#123;null==req?&#x27;false&#x27;:req.level==&#x27;2&#x27;?&#x27;select&#x27;:&#x27;false&#x27;&#125;&quot;</span>&gt;<span class="number">2</span>级</span><br><span class="line">&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>2.动态复选框选中(判断List是否包含)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;checkbox&quot;</span></span><br><span class="line">  th:id=<span class="string">&quot;&#x27;checkboxResource&#x27; + $&#123;resourceEn.key&#125;&quot;</span></span><br><span class="line">  th:checked=<span class="string">&quot;$&#123;null==req.resourceIdList?&#x27;false&#x27;:#arrays.contains(req.resourceIdList, #strings.toString(resourceEn.key))?&#x27;checked&#x27;:&#x27;false&#x27;&#125;&quot;</span></span><br><span class="line">  name=<span class="string">&quot;resourceIdList&quot;</span> th:value=<span class="string">&quot;$&#123;resourceEn.key&#125;&quot;</span>&gt;</span><br><span class="line">  &lt;label th:text=<span class="string">&quot;$&#123;resourceEn.value.name&#125;&quot;</span> th:<span class="keyword">for</span>=<span class="string">&quot;&#x27;checkboxResource&#x27; + $&#123;resourceEn.key&#125;&quot;</span>&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure><p>3.onclick动态传值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> th:text=<span class="string">&quot;*&#123;status&#125;==0?&#x27;开启&#x27;:&#x27;关闭&#x27;&quot;</span></span><br><span class="line">th:attr=<span class="string">&quot;disabled=*&#123;status==10?true:false&#125;&quot;</span></span><br><span class="line">th:data-id=<span class="string">&quot;$&#123;supplier.id&#125;&quot;</span></span><br><span class="line">th:data-status=<span class="string">&quot;*&#123;status==0?1:0&#125;&quot;</span></span><br><span class="line">th:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;*&#123;status ==0||status!=1&#125;?&#x27;btn btn-block btn-success&#x27;:&#x27;btn btn-block btn-danger&#x27;&quot;</span></span><br><span class="line">onclick=<span class="string">&quot;enable(this.getAttribute(&#x27;data-id&#x27;),this.getAttribute(&#x27;data-status&#x27;))&quot;</span>&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>4.日期格式化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;td th:text=<span class="string">&quot;*&#123;#dates.format(updateTime, &#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>5.保留小数点后两位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;label <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;ml-3&quot;</span> th:<span class="keyword">if</span>=<span class="string">&quot;*&#123;price ne 1.0&#125;&quot;</span> th:text=<span class="string">&quot;*&#123;#numbers.formatDecimal(price * 10,0,2)&#125;&quot;</span>&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure><p>6.点击详情/编辑回显下拉被选中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;form-control select2bs4&quot;</span> style=<span class="string">&quot;width: 100%;&quot;</span> name=<span class="string">&quot;id&quot;</span>&gt;</span><br><span class="line">&lt;option value=<span class="string">&quot;&quot;</span> selected=<span class="string">&quot;selected&quot;</span>&gt;==请选择==&lt;/option&gt;</span><br><span class="line">&lt;option th:each=<span class="string">&quot;user : $&#123;users&#125;&quot;</span> th:selected=<span class="string">&quot;$&#123;user.id eq dept.id&#125;&quot;</span>  th:text=<span class="string">&quot;$&#123;user.Name&#125;&quot;</span>&gt;&lt;/option&gt;&lt;/select&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Thymleaf搭配Springboot完成页面渲染，整理下日常开发中常见常用操作&lt;br&gt;1.下拉框动态被选中&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    
    <category term="Thymleaf" scheme="https://zkkget.github.io/tags/Thymleaf/"/>
    
  </entry>
  
  <entry>
    <title>主站博客迁移之SpringCloudAlibaba服务注册新发现</title>
    <link href="https://zkkget.github.io/posts/20220725cl89v5ww1000vt4uj97hv50qp.html"/>
    <id>https://zkkget.github.io/posts/20220725cl89v5ww1000vt4uj97hv50qp.html</id>
    <published>2022-07-25T07:18:07.000Z</published>
    <updated>2022-07-25T07:31:33.474Z</updated>
    
    <content type="html"><![CDATA[<p>2018.09.21「小马哥技术周报」- 第一期《Spring Cloud 服务发现新选择 - Alibaba Nacos Discovery</p><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud1.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud2.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud3.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud4.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud5.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud6.jpg" alt="流程"><br>基本是刚出来的时候就已经讲了，现在都2020了<br>不太适合大规模的分布式服务发现ZAB算法<br>内存型，有内存限制</p><p>Springcloudcommons as servicediscovery load balancing  circuit break<br>EnableDiscoveryClient是通用API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscoveryClient</span> <span class="keyword">extends</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> DEFAULT_ORDER = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;ServiceInstance&gt; <span class="title">getInstances</span><span class="params">(String serviceId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getServices</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类的其中一种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaDiscoveryClient</span> <span class="keyword">implements</span> <span class="title">DiscoveryClient</span> </span>&#123;</span><br><span class="line">    实现方法的返回值的ServiceInstance源码</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getInstanceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zk是唯一标识；eureka是ip+服务名</span><br><span class="line">    <span class="function">String <span class="title">getServiceId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getHost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否是HTTPs协议or not</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">URI <span class="title">getUri</span><span class="params">()</span></span>;</span><br><span class="line">    源信息  zk是又专门存储字段  补充信息</span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Eureka传递序列化或反序列化通过metadata传递，相关的开销比较大<br>超类接口Registration cloud commons 继承了上面的serviceInstance<br>现在的位置<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud7.jpg" alt="流程"></p><p>空继承，为了扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span>&lt;<span class="title">R</span> <span class="keyword">extends</span> <span class="title">Registration</span>&gt; </span>&#123;</span><br><span class="line">    注册</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(R registration)</span></span>;</span><br><span class="line">    de解除注册</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(R registration)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(R registration, String status)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getStatus</span><span class="params">(R registration)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nacos的实现注册"><a href="#Nacos的实现注册" class="headerlink" title="Nacos的实现注册"></a>Nacos的实现注册</h2><p> com.alibaba.nacos.api.naming;NamingService<br>现在我下载源码总是下不下来，以为是maven出问题，忘记因为其他项目公用maven，导致maven配置的是私服地址，改下maven就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F:\cloud2020&gt;mvn dependency:resolve -Dclassifier=sources</span><br><span class="line">[INFO] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">Downloading from nexus-server: xxx</span><br><span class="line">ependencies/<span class="number">2.2</span><span class="number">.2</span>.RELEASE/spring-boot-dependencies-<span class="number">2.2</span><span class="number">.2</span>.RELEASE.pom</span><br><span class="line">Downloading from nexus-server: xxx</span><br><span class="line">-dependencies/Hoxton.SR1/spring-cloud-dependencies-Hoxton.SR1.pom</span><br><span class="line">Downloading from nexus-server: xxx</span><br><span class="line">-dependencies/<span class="number">2.1</span><span class="number">.0</span>.RELEASE/spring-cloud-alibaba-dependencies-<span class="number">2.1</span><span class="number">.0</span>.RELEASE.pom</span><br></pre></td></tr></table></figure><p>namingSpace有很多重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NamingService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * register a instance to service</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName name of service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip          instance ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port        instance port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NacosException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String ip, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * register a instance to service</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName name of service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName   group of service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip          instance ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port        instance port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NacosException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String groupName, String ip, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> NacosException</span>;</span><br></pre></td></tr></table></figure><p>返回的是Instance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get all instances of a service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceName name of service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A list of instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NacosException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 服务名   是否健康</span><br><span class="line"><span class="function">List&lt;Instance&gt; <span class="title">getAllInstances</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line">Ribbon--&gt;server  </span><br><span class="line">Eureka==&gt;ServiceInstance</span><br></pre></td></tr></table></figure><p>namingSpace以及instance都是Nacos的Api,而registration是Spring 为了适配实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Registration registration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;No service to register for nacos client...&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String serviceId = registration.getServiceId();</span><br><span class="line">        <span class="comment">//this.getNacosInstanceFromRegistration  get  set</span></span><br><span class="line">        Instance instance = <span class="keyword">this</span>.getNacosInstanceFromRegistration(registration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            放入nacos  注册中心持久化  可以连db</span><br><span class="line">            <span class="keyword">this</span>.namingService.registerInstance(serviceId, instance);</span><br><span class="line">            log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, <span class="keyword">new</span> Object[]&#123;serviceId, instance.getIp(), instance.getPort()&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;nacos registry, &#123;&#125; register failed...&#123;&#125;,&quot;</span>, <span class="keyword">new</span> Object[]&#123;serviceId, registration.toString(), var5&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放入nacos  注册中心持久化  可以连db<br>this.namingService.registerInstance(serviceId, instance);<br>Nacos  =Naming +config server<br>上面的实现类图可以看到ZK的实现<br>org.springframework.cloud.zookeeper.serviceregistry;<br>ZK的注册 反注册就跟现在的Nacos有一定程度的相似<br>注解驱动<br>依赖注入<br>外部化配置<br>事件驱动<br>github.com/nacos-group/nacos-spring-project<br>github.com/nacos-group/nacos-spring-boot-project</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2018.09.21「小马哥技术周报」- 第一期《Spring Cloud 服务发现新选择 - Alibaba Nacos Discovery&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zkk-1300025204.cos.ap-nanjing.myqcloud.c</summary>
      
    
    
    
    
    <category term="SpringCloudAlibaba" scheme="https://zkkget.github.io/tags/SpringCloudAlibaba/"/>
    
  </entry>
  
  <entry>
    <title>主站博客迁移之拒绝解析又臭又长的JSON</title>
    <link href="https://zkkget.github.io/posts/20220725cl89v5ww70014t4ujdgnd1n46.html"/>
    <id>https://zkkget.github.io/posts/20220725cl89v5ww70014t4ujdgnd1n46.html</id>
    <published>2022-07-25T07:10:12.000Z</published>
    <updated>2022-07-25T07:11:54.562Z</updated>
    
    <content type="html"><![CDATA[<p>在日常工作中，不管是因为接收前端返回约定格式的JSON字符串，还是因为需要约定格式请求第三方服务，或者需要将前端画像xml解析成JSON，再或者需要接入第三方短信，供应商，数据提供商的JSON数据，或是需要提供对外暴露接口的API，可见解析JSON是一个常见操作。</p><p>JSON是一个轻量级的数据交换格式。</p><p>一：表单数据由数据库实体对象接收</p><p>常见的前后端约定字段，指定字段名称后，由数据库实体接收序列化后的表单数据，无序解析。</p><p>二：JSONObject解析</p><p>前后端约定格式，实体接收String类型，通过JSONObject解析JSON，JSONArray等操作</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">            </span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;createBy&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createTime&quot;</span>: <span class="number">1521171180000</span>,</span><br><span class="line">        <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;fa fa-gear&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuId&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;menuName&quot;</span>: <span class="string">&quot;系统管理&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuType&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line">        <span class="string">&quot;orderNum&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;params&quot;</span>: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;perms&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;#&quot;</span>,</span><br><span class="line">        <span class="string">&quot;visible&quot;</span>: <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">            </span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;createBy&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createTime&quot;</span>: <span class="number">1521171180000</span>,</span><br><span class="line">        <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;fa fa-video-camera&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuId&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;menuName&quot;</span>: <span class="string">&quot;系统监控&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuType&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line">        <span class="string">&quot;orderNum&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;params&quot;</span>: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;perms&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;#&quot;</span>,</span><br><span class="line">        <span class="string">&quot;visible&quot;</span>: <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">            </span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;createBy&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createTime&quot;</span>: <span class="number">1521171180000</span>,</span><br><span class="line">        <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;fa fa-bars&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuId&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">&quot;menuName&quot;</span>: <span class="string">&quot;系统工具&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuType&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line">        <span class="string">&quot;orderNum&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;params&quot;</span>: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;perms&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;#&quot;</span>,</span><br><span class="line">        <span class="string">&quot;visible&quot;</span>: <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过JSONObject以及解析JSONArray获取<br>三：接入第三方API</p><p>接入第三方API，或者按约定调用第三方服务时，你会发现约定了又臭有长的JSON格式，包含特定字段，包含token，包含秘钥，一个详细数据解析接口，上百个字段是常见的，而且多种格式嵌套解析，如果单纯将收到的字符串手动转化成JSONObject，还要判空，还要层层遍历，还要验证数据的有效性，这是在是不小的工作量。</p><p>改造方法：提取最长，覆盖字段最全的作为实体列接收，含有List数据就由List接收，最外层K值由字段接收，涉及类型判断需按约定传不同数值的，定义为枚举，秘钥等特殊Key值MD5加解密传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果url是空，则认为是解析历史数据 不需要拼装请求</span></span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(url)) &#123;</span><br><span class="line">            Client client = <span class="keyword">new</span> Client();</span><br><span class="line">            Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;mobileReli&quot;</span>.equals(interfaceCode)) &#123; <span class="comment">//if类型判断定义为枚举      </span></span><br><span class="line">                String infoJson = String.format(<span class="string">&quot;&#123;\&quot;phone\&quot;:\&quot;%s\&quot;,\&quot;name\&quot;:\&quot;%s\&quot;,\&quot;curDate\&quot;:\&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">                        applyRecord.getPhone(), applyRecord.getName(), applyRecord.getFlashblackDate());</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">long</span> time = System.currentTimeMillis();<span class="comment">//重复度高的字段由优特实体类接收</span></span><br><span class="line">                sb.append(secret + <span class="string">&quot;!&quot;</span> + appKey + <span class="string">&quot;!&quot;</span> + time + <span class="string">&quot;!&quot;</span> + applyRecord.getName() + <span class="string">&quot;!&quot;</span></span><br><span class="line">                        + applyRecord.getPhone() + <span class="string">&quot;!&quot;</span> + secret + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">                sign = hdsClient.md5(sb.toString());</span><br><span class="line">                String param = String.format(<span class="string">&quot;appKey=%s&amp;infoJson=%s&amp;sign=%s&amp;time=%s&quot;</span>, appKey, infoJson, sign, time);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jsonData = hdsClient.getResult(url, param);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;DSModel&quot;</span>.equals(interfaceCode)) &#123;</span><br><span class="line">                String infoJson = String.format(<span class="string">&quot;&#123;\&quot;mobile\&quot;:\&quot;%s\&quot;,\&quot;name\&quot;:\&quot;%s\&quot;,\&quot;starttime\&quot;:\&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">                        applyRecord.getPhone(), applyRecord.getName(), applyRecord.getFlashblackDate());</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">                sb.append(secret + <span class="string">&quot;!&quot;</span> + appKey + <span class="string">&quot;!&quot;</span> + time + <span class="string">&quot;!&quot;</span> + applyRecord.getName() + <span class="string">&quot;!&quot;</span></span><br><span class="line">                        + applyRecord.getPhone() + <span class="string">&quot;!&quot;</span> + applyRecord.getFlashblackDate() + <span class="string">&quot;!&quot;</span> + secret + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">                sign = hdsClient.md5(sb.toString());</span><br><span class="line">                String param = String.format(<span class="string">&quot;appKey=%s&amp;infoJson=%s&amp;sign=%s&amp;time=%s&quot;</span>, appKey, infoJson, sign, time);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jsonData = hdsClient.getResult(url, param);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;addressDetection&quot;</span>.equals(interfaceCode)) &#123;   </span><br><span class="line">                String infoJson = String.format(<span class="string">&quot;&#123;\&quot;phone\&quot;:\&quot;%s\&quot;,\&quot;address\&quot;:\&quot;%s\&quot;,\&quot;curDate\&quot;:\&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">                        applyRecord.getPhone(), applyRecord.getAddress(), applyRecord.getFlashblackDate());</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">                sb.append(secret + <span class="string">&quot;!&quot;</span> + appKey + <span class="string">&quot;!&quot;</span> + time + <span class="string">&quot;!&quot;</span> + applyRecord.getPhone() + <span class="string">&quot;!&quot;</span></span><br><span class="line">                        + applyRecord.getAddress() + <span class="string">&quot;!&quot;</span> + applyRecord.getFlashblackDate() + <span class="string">&quot;!&quot;</span> + secret + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">                sign = hdsClient.md5(sb.toString());</span><br><span class="line">                String param = String.format(<span class="string">&quot;appKey=%s&amp;infoJson=%s&amp;sign=%s&amp;time=%s&quot;</span>, appKey, infoJson, sign, time);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jsonData = hdsClient.getResult(url, param);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">InterfaceCodeEnum</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    InterfaceCode1(<span class="number">1</span>,<span class="string">&quot;mobileReli&quot;</span>),</span><br><span class="line">    InterfaceCode2(<span class="number">2</span>,<span class="string">&quot;DSModel&quot;</span>),</span><br><span class="line">    InterfaceCode3(<span class="number">3</span>,<span class="string">&quot;addressDetection&quot;</span>),</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    InterfaceCodeEnum(Integer code, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNameBycode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (InterfaceCodeEnum a : InterfaceCodeEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.code.equals(code)) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceCodeResult</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//基础信息</span></span><br><span class="line">    <span class="keyword">private</span> Base base;</span><br><span class="line">    <span class="comment">//秘钥信息</span></span><br><span class="line">    <span class="keyword">private</span> AuthInfo authInfo;</span><br><span class="line">    <span class="comment">//外层字段封装为对象接收</span></span><br><span class="line">    <span class="keyword">private</span> AddressResult  addressResult;</span><br><span class="line">    <span class="comment">//重复多层信息List接收</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Flashblack&gt; flashblack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接收到JSON字符串时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InterfaceCodeResult codeResult=JSONObject.parseObject(InterfaceCodeResult.getRequestInfo(),InterfaceCodeResult.class);</span><br><span class="line">if(PreInterfaceStatus.equals(codeResult.base.getTyep()))&#123;</span><br><span class="line">  return JavaConvertUtil.conversion(codeResult, CodeParams.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅需要判断多个类型即可，对应字段会自动解析，当接收又臭又长的XML解析还需要后端验证时，需要封装Util类进行验证调用</p><p>同步更新至微信公众号，请搜索:赵KK日常技术记录，不定时更新文章内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常工作中，不管是因为接收前端返回约定格式的JSON字符串，还是因为需要约定格式请求第三方服务，或者需要将前端画像xml解析成JSON，再或者需要接入第三方短信，供应商，数据提供商的JSON数据，或是需要提供对外暴露接口的API，可见解析JSON是一个常见操作。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="JSON" scheme="https://zkkget.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>项目实战----行政优先级分析</title>
    <link href="https://zkkget.github.io/posts/20220510cl89v5wwm001qt4uj7dh53hv8.html"/>
    <id>https://zkkget.github.io/posts/20220510cl89v5wwm001qt4uj7dh53hv8.html</id>
    <published>2022-05-10T03:00:00.000Z</published>
    <updated>2022-06-13T06:24:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>在现有地点中解析其地点优先级,最小到区县,当前区县可指定作业优先级,当绑定优先级数据后的数据应在选择时优先展示。</p><h2 id="行政优先级维护"><a href="#行政优先级维护" class="headerlink" title="行政优先级维护"></a>行政优先级维护</h2><p>采用百度地图数据很行行政区域编码维护,考虑到现有数据是人工维护,获取其省市区县可能不准确,所以先根据其经纬度定位后可准确获取其省市区县,然后再进行编码维护。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>地点北京市东城区天安门，百度坐标116.403963,39.915119</p><h2 id="API"><a href="#API" class="headerlink" title="API:"></a>API:</h2><p><a href="https://lbsyun.baidu.com/index.php?title=webapi/district-search">https://lbsyun.baidu.com/index.php?title=webapi/district-search</a><br><a href="https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding-abroad">https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding-abroad</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"> Map&lt;String, String&gt; map = IbsBMapUtils.reverseGeocoding(&quot;116.403963&quot;, &quot;39.915119&quot;);</span><br><span class="line">                String province = map.get(&quot;province&quot;);</span><br><span class="line"></span><br><span class="line">List&lt;IbsBMapUtils.Districts&gt; districts = IbsBMapUtils.regionSearch(province.substring(0, 2));</span><br><span class="line">                for (IbsBMapUtils.Districts district : districts) &#123;</span><br><span class="line">                    DivisionDo divisionDo = new DivisionDo();</span><br><span class="line">                    divisionDo.setProvinceCode(district.getCode());</span><br><span class="line">                    divisionDo.setProvinceName(district.getName());</span><br><span class="line">                    divisionDo.setWarehouseCode(locationConfigDO.getWarehouseCode());</span><br><span class="line">                    List&lt;IbsBMapUtils.Districts&gt; districtsList = district.getDistricts();</span><br><span class="line">                    if (org.apache.commons.collections.CollectionUtils.isNotEmpty(districtsList)) &#123;</span><br><span class="line">                        for (IbsBMapUtils.Districts districts2 : districtsList) &#123;</span><br><span class="line">                            divisionDo.setCityCode(districts2.getCode());</span><br><span class="line">                            divisionDo.setCityName(districts2.getName());</span><br><span class="line">                            List&lt;IbsBMapUtils.Districts&gt; districts3 = districts2.getDistricts();</span><br><span class="line">                            if (org.apache.commons.collections.CollectionUtils.isNotEmpty(districts3)) &#123;</span><br><span class="line">                                for (IbsBMapUtils.Districts district3 : districts3) &#123;</span><br><span class="line">                                    divisionDo.setRegionName(district3.getName());</span><br><span class="line">                                    divisionDo.setRegionCode(district3.getCode());</span><br><span class="line">                                    divisionRepository.insert(divisionDo);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                divisionRepository.insert(divisionDo);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        divisionRepository.insert(divisionDo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="当前区域指定优先级作业后数据优先展示"><a href="#当前区域指定优先级作业后数据优先展示" class="headerlink" title="当前区域指定优先级作业后数据优先展示"></a>当前区域指定优先级作业后数据优先展示</h2><p>例如北京市有N个区,指定了N个规划路线,当东城区指定了由最近的骑手配送时，则点击东城区商家的配送线路优先展示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;MunicipalLevel&gt;  list = MunicipalLevelMapper.selectMunicipalLevelList(&quot;北京市-东城区&quot;);</span><br><span class="line"></span><br><span class="line">       if(CollectionUtils.isEmpty(list))&#123;</span><br><span class="line">           return Collections.emptyList();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">List&lt;String&gt; riderList = divisionMapper.getRiderByProvince(&quot;11001&quot;, &quot;北京市&quot;,&quot;东城区&quot;);</span><br><span class="line">               //错误实例</span><br><span class="line">if (CollectionUtils.isNotEmpty(riderList)) &#123;</span><br><span class="line">                   for (String riderName : riderList) &#123;</span><br><span class="line">                       List&lt;RirderListResponse&gt; listResponses = list.stream().filter(vo -&gt; StringUtils.isNotEmpty(vo.getRirderName()) &amp;&amp; vo.getRiderName().equals(riderName)).collect(Collectors.toList());</span><br><span class="line">                       if (CollectionUtils.isNotEmpty(listResponses)) &#123;</span><br><span class="line">                           for (int i = 0; i &lt; listResponses.size(); i++) &#123;</span><br><span class="line">                               RirderListResponse response = listResponses.get(i);</span><br><span class="line">                               final List l = list;</span><br><span class="line">                               l.set(i, l.set(j, l.get(i)));</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       log.warn(&quot;响应&#123;&#125;&quot;, JSONObject.toJSONString(list));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="bug修复"><a href="#bug修复" class="headerlink" title="bug修复"></a>bug修复</h2><p>当前查询出东城区绑定优先级为1.2.3.4时，查询出来的顺序更新索引位置会变为4.3.2.1，且考虑到list会多个且可重复重新更改代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MunicipalLevel&gt;  list = MunicipalLevelMapper.selectMunicipalLevelList(&quot;北京市-东城区&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       if(CollectionUtils.isEmpty(list))&#123;</span><br><span class="line">           return Collections.emptyList();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">              List&lt;String&gt; riderList = divisionMapper.getRiderByProvince(&quot;11001&quot;, &quot;北京市&quot;,&quot;东城区&quot;);</span><br><span class="line">               riderList = riderList.stream().filter(item -&gt; responseList.stream().map(RouteListResponse::getName).collect(Collectors.toList()).contains(item)).collect(Collectors.toList());</span><br><span class="line">               Collections.reverse(riderList);</span><br><span class="line">                   Collections.reverse(riderList);</span><br><span class="line">                   for (int i = 0; i &lt; riderList.size(); i++) &#123;</span><br><span class="line">                       for (MunicipalLevel res : list) &#123;</span><br><span class="line">                           if(res.getName().equals(riderList.get(i)))&#123;</span><br><span class="line">                               Collections.swap(list, list.indexOf(res), i);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;         </span><br><span class="line">           </span><br></pre></td></tr></table></figure><h2 id="bug再次修复终极版"><a href="#bug再次修复终极版" class="headerlink" title="bug再次修复终极版"></a>bug再次修复终极版</h2><p>当存在多个优先级相同的区域路线时，会因为本身在list的位置不同，导致最后只有第一个正确，其他元素位置不正确</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if(CollectionUtils.isEmpty(list))&#123;</span><br><span class="line">            return Collections.emptyList();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">              // List&lt;String&gt; riderList = divisionMapper.getRiderByProvince(&quot;11001&quot;, &quot;北京市&quot;,&quot;东城区&quot;);</span><br><span class="line">                //riderList = riderList.stream().filter(item -&gt; responseList.stream().map(RouteListResponse::getName).collect(Collectors.toList()).contains(item)).collect(Collectors.toList());</span><br><span class="line">                    //Collections.reverse(riderList);</span><br><span class="line">                    //借助外部元素记录交换元素位置</span><br><span class="line">                    if (CollectionUtils.isNotEmpty(supplierList)) &#123;</span><br><span class="line">                    int a = 0 ;</span><br><span class="line">                    for (int i = 0; i &lt; riderList.size(); i++) &#123;</span><br><span class="line">                        for (MunicipalLevel res : list) &#123;</span><br><span class="line">                            if(res.getName().equals(riderList.get(i)))&#123;</span><br><span class="line">                                Collections.swap(list, list.indexOf(res), i);</span><br><span class="line">                                a++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h2&gt;&lt;p&gt;在现有地点中解析其地点优先级,最小到区县,当前区县可指定作业优先级,当绑定优先级数据后的数据应在选择时优先展示。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="实战" scheme="https://zkkget.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>mysql中的锁表语句查看方法汇总</title>
    <link href="https://zkkget.github.io/posts/20220428cl89v5wvw000nt4ujej6tcibf.html"/>
    <id>https://zkkget.github.io/posts/20220428cl89v5wvw000nt4ujej6tcibf.html</id>
    <published>2022-04-28T08:48:51.000Z</published>
    <updated>2022-09-15T09:34:18.463Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">&#x27;Table%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">+----------------------------+----------+</span><br><span class="line"></span><br><span class="line">| Variable_name        | Value |</span><br><span class="line"></span><br><span class="line">+----------------------------+----------+</span><br><span class="line"></span><br><span class="line">| Table_locks_immediate | <span class="number">105</span>         |</span><br><span class="line"></span><br><span class="line">| Table_locks_waited   | <span class="number">3</span>           |</span><br><span class="line"></span><br><span class="line">+----------------------------+----------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Table_locks_immediate    26839653<br>Table_locks_waited            0<br>Table_open_cache_hits    3<br>Table_open_cache_misses    2<br>Table_open_cache_overflows    2</p><p>Table_locks_immediate  指的是能够立即获得表级锁的次数</p><p>Table_locks_waited  指的是不能立即获取表级锁而需要等待的次数</p><p>Table_open_cache_hits  表缓存被命中的次数</p><p>Table_open_cache_misses 表缓存未被命中的次数</p><p>Table_open_cache_overflows  就是上面说的淘汰的instance（table cache）的数量</p><p>查看正在被锁定的的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>怎么查找mysql中的锁表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> processlist;</span><br><span class="line">与<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.processlist效果相同</span><br></pre></td></tr></table></figure><p>SHOW PROCESSLIST显示哪些线程正在运行。您也可以使用mysqladmin processlist语句得到此信息。如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程（也就是，与您正在使用的MySQL账户相关的线程）。如果有线程在update或者insert 某个表，此时进程的status为updating 或者 sending data。<br>show processlist 是显示用户正在运行的线程，需要注意的是，除了 root 用户能看到所有正在运行的线程外，其他用户都只能看到自己正在运行的线程，看不到其它用户正在运行的线程。除非单独个这个用户赋予了PROCESS 权限<br>– 查看那些表锁到了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>– 查看进程号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> processlist;</span><br></pre></td></tr></table></figure><p>–删除进程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill <span class="number">1085850</span>；</span><br></pre></td></tr></table></figure><p> <img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql.png" alt="流程"></p><p>Id: 就是这个线程的唯一标识，当我们发现这个线程有问题的时候，可以通过 kill 命令，加上这个Id值将这个线程杀掉。前面我们说了show processlist 显示的信息时来自information_schema.processlist 表，所以这个Id就是这个表的主键。<br>User: 就是指启动这个线程的用户。<br>Host: 记录了发送请求的客户端的 IP 和 端口号。通过这些信息在排查问题的时候，我们可以定位到是哪个客户端的哪个进程发送的请求。<br>DB: 当前执行的命令是在哪一个数据库上。如果没有指定数据库，则该值为 NULL 。<br>Command: 是指此刻该线程正在执行的命令。这个很复杂，下面单独解释<br>Time: 表示该线程处于当前状态的时间。<br>State: 线程的状态，和 Command 对应，下面单独解释。<br>Info: 一般记录的是线程执行的语句。默认只显示前100个字符，也就是你看到的语句可能是截断了的，要看全部信息，需要使用 show full processlist。<br>下面我们单独看一下 Command 的值：<br>Binlog Dump: 主节点正在将二进制日志 ，同步到从节点<br>Change User: 正在执行一个 change-user 的操作<br>Close Stmt: 正在关闭一个Prepared Statement 对象<br>Connect: 一个从节点连上了主节点<br>Connect Out: 一个从节点正在连主节点<br>Create DB: 正在执行一个create-database 的操作<br>Daemon: 服务器内部线程，而不是来自客户端的链接<br>Debug: 线程正在生成调试信息<br>Delayed Insert: 该线程是一个延迟插入的处理程序<br>Drop DB: 正在执行一个 drop-database 的操作<br>Execute: 正在执行一个 Prepared Statement<br>Fetch: 正在从Prepared Statement 中获取执行结果<br>Field List: 正在获取表的列信息<br>Init DB: 该线程正在选取一个默认的数据库<br>Kill : 正在执行 kill 语句，杀死指定线程<br>Long Data: 正在从Prepared Statement 中检索 long data<br>Ping: 正在处理 server-ping 的请求<br>Prepare: 该线程正在准备一个 Prepared Statement<br>ProcessList: 该线程正在生成服务器线程相关信息<br>Query: 该线程正在执行一个语句<br>Quit: 该线程正在退出<br>Refresh：该线程正在刷表，日志或缓存；或者在重置状态变量，或者在复制服务器信息<br>Register Slave： 正在注册从节点<br>Reset Stmt: 正在重置 prepared statement<br>Set Option: 正在设置或重置客户端的 statement-execution 选项<br>Shutdown: 正在关闭服务器<br>Sleep: 正在等待客户端向它发送执行语句<br>Statistics: 该线程正在生成 server-status 信息<br>Table Dump: 正在发送表的内容到从服务器<br>Time: Unused</p><p>那么MySQL突然飙升,首先查询当下主库内正在运行的线程以及是否有占用资源的SQL。然后执行分析info语句，看此次SQL是否是新发版功能引起，如果是新功能引起，立即回滚。</p><p>– 查询非 Sleep 状态的链接，按消耗时间倒序展示，自己加条件过滤</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, db, <span class="keyword">user</span>, host, command, <span class="type">time</span>, state, info</span><br><span class="line"><span class="keyword">from</span> information_schema.processlist</span><br><span class="line"><span class="keyword">where</span> command <span class="operator">!=</span> <span class="string">&#x27;Sleep&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="type">time</span> <span class="keyword">desc</span> </span><br></pre></td></tr></table></figure><p>其次查看CAT，但是CAT中除了Heartbeat报表GC异常以外，只有一条一分钟的SQL，并没有其他超时SQL</p><p>然后查看Grafana可以看到飙升时间在7点18分</p><p>在这个时间段查询PMM</p><p>没有异常，但是在其他服务中查询到有长达10分钟SQL未返回。</p><p>运行show full processlist命令查看是否有线程递增的情况</p><p>查询发现每一秒都有一个SQL在查询，经过代码分析，是某个接口前端轮询调用每秒都在进行查询导致的，没想到一个查询频率超高的SQL能导致CPU超高</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=90978812&cid=155358422&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="MySQL" scheme="https://zkkget.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://zkkget.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>人工智能vs人工智障之图片识别</title>
    <link href="https://zkkget.github.io/posts/20220407cl89v5wwa0019t4ujh81hg5tk.html"/>
    <id>https://zkkget.github.io/posts/20220407cl89v5wwa0019t4ujh81hg5tk.html</id>
    <published>2022-04-07T08:04:30.000Z</published>
    <updated>2022-04-21T05:56:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>从车牌识别到图片的相似度处理。开始的目的是识别车牌，以供研究opencv的,在接触车牌的识别的过程中,接触到java的tess4j以及java整合opencv的过程,但是车牌识别效率很低。人为识别是很清晰的但是仍然解析不出来。</p><h2 id="1-Tess4j"><a href="#1-Tess4j" class="headerlink" title="1.Tess4j"></a>1.Tess4j</h2><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/net.sourceforge.tess4j/tess4j --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.sourceforge.tess4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tess4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.4</span><span class="number">.8</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>下载中文检索所需包否则会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please make sure the TESSDATA_PREFIX environment variable is set to your “tessdata” directory</span><br></pre></td></tr></table></figure><p>我是直接在gitee拉下来的包手动添加的<br><a href="https://gitee.com/it_moon/tessdata?_from=gitee_search">https://gitee.com/it_moon/tessdata?_from=gitee_search</a></p><h2 id="2-Demo"><a href="#2-Demo" class="headerlink" title="2.Demo"></a>2.Demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建实例</span></span><br><span class="line">       ITesseract instance = <span class="keyword">new</span> Tesseract();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置识别语言</span></span><br><span class="line"></span><br><span class="line">       instance.setLanguage(<span class="string">&quot;chi_sim&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置识别引擎</span></span><br><span class="line"></span><br><span class="line">       instance.setOcrEngineMode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件</span></span><br><span class="line"></span><br><span class="line">       BufferedImage image = ImageIO.read(TestTextOcr.class.getResourceAsStream(<span class="string">&quot;/2.jpg&quot;</span>));</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 识别</span></span><br><span class="line">           String result = instance.doOCR(image);</span><br><span class="line">           System.out.println(result);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (TesseractException e) &#123;</span><br><span class="line">           System.err.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>车牌识别对应EL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String el =&quot;/^[京津晋冀蒙辽吉黑沪苏浙皖闽赣鲁豫鄂湘粤桂琼渝川贵云藏陕甘青宁新][ABCDEFGHJKLMNPQRSTUVWXY][\\dABCDEFGHJKLNMxPQRSTUVWXYZ]&#123;5&#125;$/&quot;;</span><br></pre></td></tr></table></figure><p>但是识别效率很低很低<br>参考其他的识别算法仍然识别不出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws TesseractException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        ITesseract instance = new Tesseract();</span><br><span class="line">        //如果未将tessdata放在根目录下需要指定绝对路径</span><br><span class="line">        //设置训练库的位置</span><br><span class="line">        //instance.setDatapath(&quot;the absolute path of tessdata&quot;);</span><br><span class="line"></span><br><span class="line">        //如果需要识别英文之外的语种，需要指定识别语种，并且需要将对应的语言包放进项目中</span><br><span class="line">        // chi_sim ：简体中文， eng    根据需求选择语言库</span><br><span class="line">        instance.setLanguage(&quot;chi_sim&quot;);</span><br><span class="line"></span><br><span class="line">        // 指定识别图片</span><br><span class="line">        instance.setOcrEngineMode(0);</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        String ocrResultNew = dealImage(&quot;C:\\Users\\Admin\\Desktop\\9-160514164SDY.jpg&quot;);</span><br><span class="line">        File imgDir = new File(ocrResultNew);</span><br><span class="line">        String ocrResult = instance.doOCR(imgDir);</span><br><span class="line">        String el =&quot;/^[京津晋冀蒙辽吉黑沪苏浙皖闽赣鲁豫鄂湘粤桂琼渝川贵云藏陕甘青宁新][ABCDEFGHJKLMNPQRSTUVWXY][\\dABCDEFGHJKLNMxPQRSTUVWXYZ]&#123;5&#125;$/&quot;;</span><br><span class="line">        System.out.println(&quot;识别结果: \n&quot; + ocrResult + &quot;\n 耗时：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br><span class="line">        if(ocrResult.matches(el))&#123;</span><br><span class="line">            // 输出识别结果</span><br><span class="line">            System.out.println(&quot;识别结果: \n&quot; + ocrResult + &quot;\n 耗时：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            log.error(&quot;车牌识别有误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后我开始搜索java结合opencv的项目，但是仍然识别失败。<br>识别过程为：识别切图–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从车牌识别到图片的相似度处理。开始的目的是识别车牌，以供研究opencv的,在接触车牌的识别的过程中,接触到java的tess4j以及java整合opencv的过程,但是车牌识别效率很低。人为识别是很清晰的但是仍然解析不出来。&lt;/p&gt;
&lt;h2 id=&quot;1-Tess4j&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="opencv" scheme="https://zkkget.github.io/tags/opencv/"/>
    
  </entry>
  
</feed>
