<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵KK个人博客第三站</title>
  
  <subtitle>纠结体本体,同步记录日常笔记，Write the code, Change the world！</subtitle>
  <link href="https://zkkget.github.io/atom.xml" rel="self"/>
  
  <link href="https://zkkget.github.io/"/>
  <updated>2023-05-15T01:46:30.375Z</updated>
  <id>https://zkkget.github.io/</id>
  
  <author>
    <name>赵KK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>免费的ChatGpt专栏</title>
    <link href="https://zkkget.github.io/posts/20230515a1.html"/>
    <id>https://zkkget.github.io/posts/20230515a1.html</id>
    <published>2023-05-15T01:40:04.000Z</published>
    <updated>2023-05-15T01:46:30.375Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h1 id="温馨提示：本站所有资料仅供学习交流-严禁用于商业用途-请于24小时内删除"><a href="#温馨提示：本站所有资料仅供学习交流-严禁用于商业用途-请于24小时内删除" class="headerlink" title="温馨提示：本站所有资料仅供学习交流,严禁用于商业用途,请于24小时内删除"></a>温馨提示：本站所有资料仅供学习交流,严禁用于商业用途,请于24小时内删除</h1><h1 id="文章底部有文章目录按钮"><a href="#文章底部有文章目录按钮" class="headerlink" title="文章底部有文章目录按钮~~~~~"></a>文章底部有文章目录按钮~~~~~</h1><h1 id="需要什么资料可以在最下方留言-不定期更新"><a href="#需要什么资料可以在最下方留言-不定期更新" class="headerlink" title="需要什么资料可以在最下方留言,不定期更新"></a>需要什么资料可以在最下方留言,不定期更新</h1><h1 id="AI-Gamma一键生成PPT工具直达链接"><a href="#AI-Gamma一键生成PPT工具直达链接" class="headerlink" title="AI Gamma一键生成PPT工具直达链接"></a>AI Gamma一键生成PPT工具直达链接</h1><h2 id="https-gamma-app-signup-r-sqgovd3iif5btr4"><a href="#https-gamma-app-signup-r-sqgovd3iif5btr4" class="headerlink" title="https://gamma.app/signup?r=sqgovd3iif5btr4"></a><a href="https://gamma.app/signup?r=sqgovd3iif5btr4">https://gamma.app/signup?r=sqgovd3iif5btr4</a></h2><p><img src="/posts/20230515a1/640.png" alt="Gamma"><br><img src="/posts/20230515a1/1.png" alt="求关注"><br><img src="/posts/20230515a1/2.png" alt="求点赞"><br><img src="/posts/20230515a1/3.png" alt="求转发"></p><h2 id="chatgpt使用小技巧"><a href="#chatgpt使用小技巧" class="headerlink" title="chatgpt使用小技巧"></a>chatgpt使用小技巧</h2><p>第一，给他定一个人群，或者定一个团队的角色。一定要明确ChatGPT的角色定位，把它当成你的同事。<br>第二，让chatgpt明确词汇的定义。<br>第三，了解并学会运用ChatGPT递进式的提问。<br>第四，不管ChatGPT回答的对或者不对，都要有所反馈，因为ChatGPT，它是有记忆的。<br>第五，用chatgpt调研你想要的人群的一些反馈。</p><h2 id="中文版prompt教程"><a href="#中文版prompt教程" class="headerlink" title="中文版prompt教程"></a>中文版prompt教程</h2><p><a href="https://pan.baidu.com/s/1e1aCUIktDumwIFs_Z9a7UQ">https://pan.baidu.com/s/1e1aCUIktDumwIFs_Z9a7UQ</a><br>提取码: AIGC</p><h2 id="prompt提示词"><a href="#prompt提示词" class="headerlink" title="prompt提示词"></a>prompt提示词</h2><p><a href="https://moonvy.com/apps/ops/?utm_source=appinn.com">https://moonvy.com/apps/ops/?utm_source=appinn.com</a><br>AIPRM<br>Prompt Storm<br>novelai：<a href="https://tags-dev.novelai.dev/">https://tags-dev.novelai.dev/</a><br>black lily: <a href="http://heizicao.gitee.io/novelai/#/home">http://heizicao.gitee.io/novelai/#/home</a><br>tag zoo:<a href="http://tag.zoos.life/">http://tag.zoos.life/</a></p><p>GitHub开源项目: github.com/pengzhile/pandora<br>ChatGPT免费共享: chat-shared1.zhile.io<br>获取access token路径: chat.openai.com/api/auth/session</p><p> <a href="https://chat.theb.ai/">https://chat.theb.ai/</a><br><a href="https://chatforai.com/">https://chatforai.com/</a><br><a href="https://chatgpt.h7ml.cn/">https://chatgpt.h7ml.cn/</a><br><a href="https://poe.com/">https://poe.com/</a><br><a href="https://chatgpt.poshist.cn/">https://chatgpt.poshist.cn/</a><br><a href="https://gpt.h7ml.cn/">https://gpt.h7ml.cn/</a><br><a href="https://chat.wxredcover.cn/">https://chat.wxredcover.cn/</a><br><a href="https://chat.yqcloud.top/">https://chat.yqcloud.top/</a><br><a href="https://chat.forchange.cn/">https://chat.forchange.cn/</a><br><a href="https://ai.v2less.com/">https://ai.v2less.com/</a> 访问密码：lessismore<br><a href="https://www.aicodehelper.com/">https://www.aicodehelper.com/</a><br><a href="https://ai-toolbox.codefuture.top/">https://ai-toolbox.codefuture.top/</a><br><a href="https://chilloutai.com/">https://chilloutai.com/</a><br><a href="https://harry-potter.openai-lab.com/">https://harry-potter.openai-lab.com</a><br><a href="https://wordstory.streamlit.app/">https://wordstory.streamlit.app/</a><br><a href="https://hotoke.ai/">https://hotoke.ai/</a><br><a href="https://chat.geekr.dev/">https://chat.geekr.dev/</a><br><a href="https://desk.im/">https://desk.im</a><br><a href="https://xc.com/">https://xc.com/</a><br><a href="https://chat.51buygpt.com/">https://chat.51buygpt.com/</a><br><a href="https://freechatgpt.chat/">https://freechatgpt.chat/</a><br><a href="https://askai.ws/">https://askai.ws/</a><br><a href="https://ai.yiios.com/">https://ai.yiios.com/</a><br><a href="http://chat.apigpt.cn/">http://chat.apigpt.cn/</a><br><a href="https://94gpt.com/">https://94gpt.com/</a><br><a href="https://www.teach-anything.com/">https://www.teach-anything.com/</a><br><a href="http://itecheasy.com.cn/">http://itecheasy.com.cn/</a><br><a href="https://trychatgp.com/">https://trychatgp.com/</a><br><a href="https://chatgpt.ddiu.io/">https://chatgpt.ddiu.io/</a><br><a href="https://ai117.com/">https://ai117.com/</a><br><a href="http://chat.livepo.top/">http://chat.livepo.top/</a><br><a href="https://freechatgpt.lol/">https://freechatgpt.lol/</a><br><a href="https://freegpt.cc/">https://freegpt.cc</a><br><a href="https://ai.ls/">https://ai.ls</a><br><a href="https://chat.alpaca-bi.com/">https://chat.alpaca-bi.com/</a><br><a href="https://chat.paoying.net/">https://chat.paoying.net/</a><br><a href="https://chat.eaten.fun/">https://chat.eaten.fun/</a><br><a href="https://www.askopenai.cn/">https://www.askopenai.cn/</a><br><a href="https://chat.h7ml.cn/">https://chat.h7ml.cn/</a><br><a href="https://chatgpt-flutter.h7ml.cn/">https://chatgpt-flutter.h7ml.cn/</a><br><a href="https://www.aitoolgpt.com/">https://www.aitoolgpt.com/</a><br><a href="https://www.chatsverse.xyz/">https://www.chatsverse.xyz/</a></p><p>在线体验 ChatGPT 的网站集合，UI 界面与官方相似。</p><p>Chat TGBot：<a href="https://chat.tgbot.co/">https://chat.tgbot.co/</a><br>BAI Chat：<a href="https://chat.theb.ai/">https://chat.theb.ai/</a><br>ChatGPT 国产镜像：<a href="https://ai.bo-e.com/">https://ai.bo-e.com/</a><br>ZYT.IM：<a href="https://zyt.im/#/chat/">https://zyt.im/#/chat/</a><br>Fast GPT：<a href="https://fastgpt.app/">https://fastgpt.app/</a><br>Free GPT：<a href="https://freegpt.one/">https://freegpt.one/</a><br>AI EDU：<a href="https://aigcfun.com/%E3%80%81https://chat.forchange.cn/">https://aigcfun.com/、https://chat.forchange.cn/</a><br>Chat LivePo：<a href="https://chat.livepo.top/">https://chat.livepo.top/</a><br>AI 小思：<a href="https://chatgpt-web-production-facc.up.railway.app/">https://chatgpt-web-production-facc.up.railway.app/</a></p><p>chat8:<a href="https://chat.gamejx.cn/#/register?bronk_on=646565">https://chat.gamejx.cn/#/register?bronk_on=646565</a><br>chatgpt:<a href="https://s.wikll.com/">https://s.wikll.com/</a><br>AI网站：<a href="http://www.aitoolist.cn/">www.aitoolist.cn</a><br>AI网站工具：<a href="http://www.futurepedia.io/">www.futurepedia.io</a><br>ai工具网站也可以：<a href="http://www.ainav.cn/">www.ainav.cn</a><br>百度云文生图:<a href="https://ai.baidu.com/creativity/imageeditor">https://ai.baidu.com/creativity/imageeditor</a><br>阿里云文生图<br><a href="https://help.aliyun.com/document_detail/477804.html">https://help.aliyun.com/document_detail/477804.html</a><br>图文生图<br><a href="https://help.aliyun.com/document_detail/477821.html">https://help.aliyun.com/document_detail/477821.html</a><br>文生图、图生图<br><a href="https://www.apispace.com/23329/api/aigc/apiDocument?apiId=11993">https://www.apispace.com/23329/api/aigc/apiDocument?apiId=11993</a><br>腾讯云:<br>文生图<br><a href="https://cloud.tencent.com/document/product/1668/88064">https://cloud.tencent.com/document/product/1668/88064</a><br>图生图<br><a href="https://cloud.tencent.com/document/product/1668/88066">https://cloud.tencent.com/document/product/1668/88066</a></p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="AI工具大合集" scheme="https://zkkget.github.io/categories/AI%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%90%88%E9%9B%86/"/>
    
    
    <category term="AI工具大合集" scheme="https://zkkget.github.io/tags/AI%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%90%88%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>不限次数的AI对标ChatGPT提高生产力无需魔法</title>
    <link href="https://zkkget.github.io/posts/20230510a1.html"/>
    <id>https://zkkget.github.io/posts/20230510a1.html</id>
    <published>2023-05-10T02:37:16.000Z</published>
    <updated>2023-05-10T03:05:16.645Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>由前 OpenAI 副总裁创建的人工智能新项目 “Claude” 来了，我叫它克劳德，与gpt来说，如果gpt的逻辑思维更强，那么Claude就是一个在逻辑上更善于表达的AI，但是coding能力ChatGPT is better</p><p>看起来大部分的测试方面都是GPT完胜，那么为什么还要推荐Claude呢？</p><p>你懂的，因为不需要魔法，或者需要但是只需要一点点，也可以完全不需要。</p><p>免注册使用</p><p>去这里：<a href="https://slack.com/intl/zh-cn/">https://slack.com/intl/zh-cn/</a></p><p>下载slack<br><img src="/posts/20230510a1/9.png" alt="JasperAI"></p><p>2.登录亲测使用手机号+139邮箱完美接入。小声说139邮箱可以加入一个工作区，然后里面竟然接入了gpt，但是对话是公开的<br><img src="/posts/20230510a1/10.png" alt="JasperAI"></p><p>3.创建一个workspace，公司名什么的随便填就可以</p><p>4.添加应用(需要一点点魔法)</p><p>无需魔法，重新在slack中添加claude应用的方法 - 知乎 (zhihu.com)</p><p><a href="https://zhuanlan.zhihu.com/p/625689180">https://zhuanlan.zhihu.com/p/625689180</a></p><p>5.搜索Claude，点击allow</p><p><img src="/posts/20230510a1/11.png" alt="JasperAI"><br>6.<br><img src="/posts/20230510a1/12.png" alt="JasperAI"><br><img src="/posts/20230510a1/13.png" alt="JasperAI"></p><p>接下来就看你的了</p><p>往期精彩内容</p><p>CodeGeeX: 多语言代码生成模型VS Code 和 IntelliJ IDEA安装即用<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486740&amp;idx=1&amp;sn=a8403db2d471b7db2a7b0b1fac4e1e06&amp;chksm=ceb09269f9c71b7f69ef1d5b1ba4bea2e59f841cb6787c269441e72461631a314e329b3314ff&amp;token=2145806419&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486740&amp;idx=1&amp;sn=a8403db2d471b7db2a7b0b1fac4e1e06&amp;chksm=ceb09269f9c71b7f69ef1d5b1ba4bea2e59f841cb6787c269441e72461631a314e329b3314ff&amp;token=2145806419&amp;lang=zh_CN#rd</a></p><p>比Chatgpt还早Jasper的免费10000字的AI<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486683&amp;idx=1&amp;sn=721db5610f1f6e3aea4c6dc8d315165b&amp;chksm=ceb093a6f9c71ab0a90a4b69353987443e083a6c106eb4a01e4c1e944c58af31e34261ba1622&amp;token=2145806419&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486683&amp;idx=1&amp;sn=721db5610f1f6e3aea4c6dc8d315165b&amp;chksm=ceb093a6f9c71ab0a90a4b69353987443e083a6c106eb4a01e4c1e944c58af31e34261ba1622&amp;token=2145806419&amp;lang=zh_CN#rd</a></p><p>Wonder Studio AI 制作属于你自己的CG视频附内测地址<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486668&amp;idx=1&amp;sn=65cb33865793d42de3e96d28e5d400e8&amp;chksm=ceb093b1f9c71aa75f87e3659c0cd5a7cfc3e66c63a58491d8f494c32bf7deb1de7f8137de50&amp;token=2145806419&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486668&amp;idx=1&amp;sn=65cb33865793d42de3e96d28e5d400e8&amp;chksm=ceb093b1f9c71aa75f87e3659c0cd5a7cfc3e66c63a58491d8f494c32bf7deb1de7f8137de50&amp;token=2145806419&amp;lang=zh_CN#rd</a></p><p>文心一言申请通过了，写周报糊弄领导<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486341&amp;idx=1&amp;sn=b9633d93b2e2dbc2291d7b1938af72ba&amp;chksm=ceb094f8f9c71dee394fa42583a4a207ed44fc25b392402bb1714b543375f0fca877552a6a8b&amp;token=2145806419&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486341&amp;idx=1&amp;sn=b9633d93b2e2dbc2291d7b1938af72ba&amp;chksm=ceb094f8f9c71dee394fa42583a4a207ed44fc25b392402bb1714b543375f0fca877552a6a8b&amp;token=2145806419&amp;lang=zh_CN#rd</a></p><p>近期C站频繁更新，导致大多数时间大家进不去，大多数人的模型又都是基础模型，我现在将自己的大模型推荐分享给大家，并标明Lora的模型效果，我自己最常用的几个模型分享。</p><p>所有的AI工具集和大模型已经打包好啦，持续更新内容<del>回复[AI工具]赶紧领取吧</del>限时24小时删除。过期请直接私信。最新包含PPT生成工具，AI大模型，Lora模型，gpt网站，中文AI绘画大模型，大厂绘画网站内测，67万条prompt提示词，免费GPT网站合集等等，别忘了三连呦~</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Springboot正确的停机方式</title>
    <link href="https://zkkget.github.io/posts/20230509a1.html"/>
    <id>https://zkkget.github.io/posts/20230509a1.html</id>
    <published>2023-05-09T07:26:02.000Z</published>
    <updated>2023-05-09T07:26:38.101Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>在Spring Boot应用中,有几种常见的停止方式:</p><ol><li>使用CTRL+C:这是最简单的停止方式,但不推荐在生产环境使用。因为它会立即终止进程,没有机会实现优雅关闭。</li><li>使用SIGTERM信号:发送SIGTERM信号到Spring Boot进程的PID,Spring Boot会注册一个ShutdownHook来优雅关闭应用。这是生产环境推荐的停止方式。</li></ol><p>kill -SIGTERM pid<br>3. 调用Actuator的shutdown接口:Actuator暴露了一个/shutdown的HTTP端点来关闭应用。这也是生产环境推荐的方式之一。</p><p>curl -X POST <a href="http://localhost:8080/actuator/shutdown">http://localhost:8080/actuator/shutdown</a><br>4. 运行应用提供的退出命令:如果在应用中提供了自定义的退出命令,也可以通过运行该命令来关闭应用。<br>比如,在应用的入口类中提供:</p><p>@Component<br>public class ExitCommand implements CommandLineRunner {<br>    @Override<br>    public void run(String… args) throws Exception {<br>        System.exit(0);<br>    }<br>}<br>然后运行命令:</p><p>curl -X POST <a href="http://localhost:8080/exit">http://localhost:8080/exit</a><br>5. 调用ApplicationContext的close方法:通过在程序中直接调用<code>applicationContext.close()</code>方法关闭应用上下文来触发关闭。</p><p>@Autowired<br>private ConfigurableApplicationContext applicationContext;</p><p>public void exit() {<br>    applicationContext.close();<br>}<br>然后通过HTTP请求、JMX等方式调用该<code>exit()</code>方法。<br>总之,在生产环境中推荐使用Actuator接口的方式或发送SIGINT/SIGTERM信号的方式来关闭Spring Boot应用。这些方式能够实现优雅关闭,释放资源。而CTRL+C方式只适合在开发环境使用。<br>正确关闭SpringBoot应用,以释放应用占用的资源,这一点在生产环境尤其重要。我们在开发和运维Spring Boot应用时,需要清楚各种停止方式的区别,选用适合的方式</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>公众号【赵KK日常技术记录】欢迎关注点击</title>
    <link href="https://zkkget.github.io/posts/20230427a1.html"/>
    <id>https://zkkget.github.io/posts/20230427a1.html</id>
    <published>2023-04-27T09:56:45.000Z</published>
    <updated>2023-04-28T01:49:14.470Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/666.png" alt="公众号"></p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="公众号【赵KK日常技术记录】欢迎关注" scheme="https://zkkget.github.io/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%90%E8%B5%B5KK%E6%97%A5%E5%B8%B8%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95%E3%80%91%E6%AC%A2%E8%BF%8E%E5%85%B3%E6%B3%A8/"/>
    
    
    <category term="公众号【赵KK日常技术记录】欢迎关注" scheme="https://zkkget.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%90%E8%B5%B5KK%E6%97%A5%E5%B8%B8%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95%E3%80%91%E6%AC%A2%E8%BF%8E%E5%85%B3%E6%B3%A8/"/>
    
  </entry>
  
  <entry>
    <title>个人公众号赵KK日常技术记录     温馨提示本站所有资料仅供学习交流-严禁用于商业用途-请于24小时内删除</title>
    <link href="https://zkkget.github.io/posts/20230427a1.html"/>
    <id>https://zkkget.github.io/posts/20230427a1.html</id>
    <published>2023-04-27T01:46:24.000Z</published>
    <updated>2023-04-27T08:56:21.194Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><!DOCTYPE html><html><head>  <meta charset="UTF-8">  <title>Markdown标题变红</title>  <style>    .title-red {      color: red;    }  </style>  <script>    var headings = document.getElementsByTagName('h1');    for (var i = 0; i < headings.length; i++) {      headings[i].classList.add("title-red");    }  </script></head><body><h1>个人公众号赵KK日常技术记录     温馨提示本站所有资料仅供学习交流-严禁用于商业用途-请于24小时内删除</h1></body></html></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="AI工具大合集" scheme="https://zkkget.github.io/categories/AI%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%90%88%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>AI工具大合集【不定期更新】</title>
    <link href="https://zkkget.github.io/posts/20230425a1.html"/>
    <id>https://zkkget.github.io/posts/20230425a1.html</id>
    <published>2023-04-25T12:12:52.000Z</published>
    <updated>2023-05-15T01:44:49.688Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h1 id="答案在路上，自由在风里，风吹哪页读哪页，哪页不懂撕哪页"><a href="#答案在路上，自由在风里，风吹哪页读哪页，哪页不懂撕哪页" class="headerlink" title="答案在路上，自由在风里，风吹哪页读哪页，哪页不懂撕哪页"></a>答案在路上，自由在风里，风吹哪页读哪页，哪页不懂撕哪页</h1><h1 id="今天你别想走出这个网页"><a href="#今天你别想走出这个网页" class="headerlink" title="今天你别想走出这个网页"></a>今天你别想走出这个网页</h1><h1 id="温馨提示：本站所有资料仅供学习交流-严禁用于商业用途-请于24小时内删除"><a href="#温馨提示：本站所有资料仅供学习交流-严禁用于商业用途-请于24小时内删除" class="headerlink" title="温馨提示：本站所有资料仅供学习交流,严禁用于商业用途,请于24小时内删除"></a>温馨提示：本站所有资料仅供学习交流,严禁用于商业用途,请于24小时内删除</h1><h1 id="文章底部有文章目录按钮"><a href="#文章底部有文章目录按钮" class="headerlink" title="文章底部有文章目录按钮~~~~~"></a>文章底部有文章目录按钮~~~~~</h1><h1 id="需要什么资料可以在最下方留言-不定期更新"><a href="#需要什么资料可以在最下方留言-不定期更新" class="headerlink" title="需要什么资料可以在最下方留言,不定期更新"></a>需要什么资料可以在最下方留言,不定期更新</h1><h1 id="AI-Gamma一键生成PPT工具直达链接"><a href="#AI-Gamma一键生成PPT工具直达链接" class="headerlink" title="AI Gamma一键生成PPT工具直达链接"></a>AI Gamma一键生成PPT工具直达链接</h1><h2 id="https-gamma-app-signup-r-sqgovd3iif5btr4"><a href="#https-gamma-app-signup-r-sqgovd3iif5btr4" class="headerlink" title="https://gamma.app/signup?r=sqgovd3iif5btr4"></a><a href="https://gamma.app/signup?r=sqgovd3iif5btr4">https://gamma.app/signup?r=sqgovd3iif5btr4</a></h2><p><img src="/posts/20230425a1/640.png" alt="Gamma"><br><img src="/posts/20230425a1/1.png" alt="求关注"><br><img src="/posts/20230425a1/2.png" alt="求点赞"><br><img src="/posts/20230425a1/3.png" alt="求转发"></p><h2 id="导入MindShow-生成PPT先让ChatGPT生成MarkDown代码"><a href="#导入MindShow-生成PPT先让ChatGPT生成MarkDown代码" class="headerlink" title="导入MindShow 生成PPT先让ChatGPT生成MarkDown代码"></a>导入MindShow 生成PPT先让ChatGPT生成MarkDown代码</h2><p><a href="https://www.mindshow.fun/#/login?inviteCode=6597612">https://www.mindshow.fun/#/login?inviteCode=6597612</a><br><img src="/posts/20230425a1/mindshow.png" alt="Gamma"></p><h1 id="听说你有编码命名强迫症？命名困难症？"><a href="#听说你有编码命名强迫症？命名困难症？" class="headerlink" title="听说你有编码命名强迫症？命名困难症？"></a>听说你有编码命名强迫症？命名困难症？</h1><p><a href="https://www.chtml.cn/">https://www.chtml.cn/</a><br><img src="/posts/20230425a1/7.png" alt="编码命名"></p><h1 id="一起薅羊毛啦！我在用小绿鲸读文献，点击链接"><a href="#一起薅羊毛啦！我在用小绿鲸读文献，点击链接" class="headerlink" title="一起薅羊毛啦！我在用小绿鲸读文献，点击链接"></a>一起薅羊毛啦！我在用小绿鲸读文献，点击链接</h1><p><a href="https://www.xljsci.com/?regCode=j28w8w">https://www.xljsci.com?regCode=j28w8w</a><br><img src="/posts/20230425a1/01.png" alt="小绿鲸"><br>并使用邀请码【j28w8w】注册，和我一起得200M网盘容量！(请在浏览器中打开链接)</p><h1 id="AI-PPT-中文绘画大网站直达链接"><a href="#AI-PPT-中文绘画大网站直达链接" class="headerlink" title="AI PPT 中文绘画大网站直达链接"></a>AI PPT 中文绘画大网站直达链接</h1><p><a href="https://aigc.yizhentv.com/invite/register.html?inviteCode=VSLG9JAGJVGHW1">https://aigc.yizhentv.com/invite/register.html?inviteCode=VSLG9JAGJVGHW1</a><br><img src="/posts/20230425a1/6.png" alt="JasperAI"></p><h1 id="免费用字体-我用字由-邀请码68445803"><a href="#免费用字体-我用字由-邀请码68445803" class="headerlink" title="免费用字体  我用字由 邀请码68445803"></a>免费用字体  我用字由 邀请码68445803</h1><p><img src="/posts/20230425a1/%E5%AD%97%E7%94%B1.png" alt="字由"></p><h1 id="点击链接参与粉丝抽奖"><a href="#点击链接参与粉丝抽奖" class="headerlink" title="点击链接参与粉丝抽奖"></a>点击链接参与粉丝抽奖</h1><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486690&amp;idx=1&amp;sn=42eba1d4d2ae9e222194fb87fa432861&amp;chksm=ceb0939ff9c71a898f352370c6eaea127bd5bf9d0dceacab48585b7110119749aca22a280b64&amp;token=1841629559&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486690&amp;idx=1&amp;sn=42eba1d4d2ae9e222194fb87fa432861&amp;chksm=ceb0939ff9c71a898f352370c6eaea127bd5bf9d0dceacab48585b7110119749aca22a280b64&amp;token=1841629559&amp;lang=zh_CN#rd</a></p><h2 id="自媒体分享计划-https-cloud-tencent-com-developer-support-plan-invite-code-32g0nq650b0go"><a href="#自媒体分享计划-https-cloud-tencent-com-developer-support-plan-invite-code-32g0nq650b0go" class="headerlink" title="自媒体分享计划 https://cloud.tencent.com/developer/support-plan?invite_code=32g0nq650b0go"></a>自媒体分享计划 <a href="https://cloud.tencent.com/developer/support-plan?invite_code=32g0nq650b0go">https://cloud.tencent.com/developer/support-plan?invite_code=32g0nq650b0go</a></h2><h2 id="邀请好友加入阿里云开发者大家庭"><a href="#邀请好友加入阿里云开发者大家庭" class="headerlink" title="邀请好友加入阿里云开发者大家庭"></a>邀请好友加入阿里云开发者大家庭</h2><p><a href="https://developer.aliyun.com/mission/invite?taskCode=6660&amp;recordId=da66fefbb1869cb851fd9157a063994a&amp;share_source=copy_link">https://developer.aliyun.com/mission/invite?taskCode=6660&amp;recordId=da66fefbb1869cb851fd9157a063994a&amp;share_source=copy_link</a></p><!DOCTYPE html><html><head>  <meta charset="UTF-8">  <title>Markdown标题变红</title>  <style>    .title-red {      color: green;    }  </style>  <script>    var headings = document.getElementsByTagName('h1');    for (var i = 0; i < headings.length; i++) {    var randomColor = Math.floor(Math.random()*16777215).toString(16);    headings[i].style.color = "#" + randomColor;  }  </script></head><body><h1>温馨提示：本站所有资料仅供学习交流,严禁用于商业用途,请于24小时内删除</h1></body></html><h1 id="AI绘画提示词"><a href="#AI绘画提示词" class="headerlink" title="AI绘画提示词"></a>AI绘画提示词</h1><p>我用夸克网盘分享了「AI绘画提示词.txt」，点击链接即可保存。打开「夸克APP」在线查看，支持多种文档格式转换。<br>链接：<a href="https://pan.quark.cn/s/33511fcf587e">https://pan.quark.cn/s/33511fcf587e</a></p><h1 id="GPT相关新闻"><a href="#GPT相关新闻" class="headerlink" title="GPT相关新闻"></a>GPT相关新闻</h1><p>OpenAl、谷歌、微软 CEO 将在本周四往白宫参会与美国副总统讨论 AI 风险问题。<br>2.本周一，美国好莱坞编剧发起 15 年来首次大罢工。认为AI威胁其生存，要求限制 AI 在编剧领域的使用<br>3.HR GPT 来了: GONEX- IRIS，自动化进行员工满意度和绩效分析、入职流程、薪资核算、政策提供等。<br>美国在线教育公司股价暴跌。Chegg下跌 40%4Pearson 下跌 15%，Duolingo 下跌 10%。<br>5.Twilio Segment报告: 92%的公司采用人工智能技术提供个性化的客户体验，以推动业务增长。<br>6.中国AIGC产业峰会现场，智谱AI CEO: 国有 GPT大语言模型痛点: 成本、人力、算法。<br>7.Moonbeam: <a href="https://moonbeam.network/">https://moonbeam.network/</a> 长文章AI内容创作助手<br>8.MidJourney Prompt Helper: <a href="https://prompt.noonshot.com/midjourney">https://prompt.noonshot.com/midjourney</a> 帮忙写MJ咒语</p><p>1.周鸿讳内部信:360 员工不会被 GPT淘汰<br>2.刘慈欣谈Al:人类若生活在科技的安乐窝里，终将会被“消灭”!<br>3.美国官员也加入chatGPT 热潮:将研究利用AI 保护国土安全<br>4.生成式AI是最大功臣，英伟达市值近4个月增加3290亿美元<br>5.拉勾招聘:25%AIGC算法工程师岗位月薪超68K超4成科技人才在职场应用ChatGPT<br>6.2023年3月，AIGC(意为人工智能生成内容)人才岗位需求量环比增加42%。<br>7.复旦大学开发的国内首个类ChatGPT大模型MOSS开源，其具有160亿参数，在FP16精度下可在单张A100/A800或两张3090显卡上运行。<br>8.钉钉:接入[通义千问] 大模型，智能办公助手。</p><p>Gptrpg:一个基于GPT的代理在RPG类似的环境中的演示<br>“序列猴子”，为个人出门问问内测探索大模型与企业打造专属CoPilot<br>AppGrowing国际版推出AI本地化旁白功能。<br>HealthGPT:使用自然语言查询您的苹果健康数据<br>KeepChatGPT:完美解决chatGPT网络错误，不再频繁地刷新网页<br>Al Story Generator:可让用户轻松利用AI创作自己独特的故事和小说<br>Auto-GPT-ZH:Auto-GPT中文版本，由爱好者组织，同步更新原项目，可用于AI领域创业、自媒体组织、用AI工作学习创作变现等。<br>Vault-ai:使用简单的React前端上传您自己的自定义知识库文件(PDF、txt等)</p><h1 id="PPT模板社区-好工具一定要分享给最好的朋友，ProcessOn助您和好友一起高效办公！"><a href="#PPT模板社区-好工具一定要分享给最好的朋友，ProcessOn助您和好友一起高效办公！" class="headerlink" title="PPT模板社区 好工具一定要分享给最好的朋友，ProcessOn助您和好友一起高效办公！"></a>PPT模板社区 好工具一定要分享给最好的朋友，ProcessOn助您和好友一起高效办公！</h1><p><a href="https://www.processon.com/i/5b961737e4b0bd4db9342c44/?full_name=%E8%B5%B5KK">https://www.processon.com/i/5b961737e4b0bd4db9342c44/?full_name=%E8%B5%B5KK</a></p><h1 id="JasperAI-10000字免费额度试用-https-jasper-ai"><a href="#JasperAI-10000字免费额度试用-https-jasper-ai" class="headerlink" title="JasperAI 10000字免费额度试用 https://jasper.ai"></a>JasperAI 10000字免费额度试用 <a href="https://jasper.ai/">https://jasper.ai</a></h1><p><img src="/posts/20230425a1/4.png" alt="JasperAI"></p><h1 id="这就是公众号说的免费GPT-4-chat-forefront-ai"><a href="#这就是公众号说的免费GPT-4-chat-forefront-ai" class="headerlink" title="这就是公众号说的免费GPT-4 chat.forefront.ai"></a>这就是公众号说的免费GPT-4 chat.forefront.ai</h1><p><img src="/posts/20230425a1/5.png" alt="JasperAI"></p><p>Lumen5是一款在线视频制作平台，可以把文本、图片等内容快速转化成视频，非常适合制作社交媒体广告和短视频。以下是Lumen5的网址和简单教程：<br>网址：<a href="https://lumen5.com/">https://lumen5.com/</a> 教程：<a href="https://lumen5.com/learn">https://lumen5.com/learn</a><br>使用Lumen5制作视频非常简单，只需要将你的文本或网址粘贴到平台上，选择模板并上传图片或视频素材，Lumen5就可以自动为你生成一个视频。<br>除了Lumen5之外，还有很多类似的在线视频制作平台可供选择，例如：<br>Canva：<a href="https://www.canva.com/create/videos/">https://www.canva.com/create/videos/</a><br>Animoto：<a href="https://animoto.com/">https://animoto.com/</a><br>Biteable：<a href="https://biteable.com/">https://biteable.com/</a><br>Powtoon：<a href="https://www.powtoon.com/">https://www.powtoon.com/</a><br>Renderforest：<a href="https://www.renderforest.com/">https://www.renderforest.com/</a></p><h1 id="关注公众号回复SVF获取SVF补帧插件和说明操作手册"><a href="#关注公众号回复SVF获取SVF补帧插件和说明操作手册" class="headerlink" title="关注公众号回复SVF获取SVF补帧插件和说明操作手册"></a>关注公众号回复SVF获取SVF补帧插件和说明操作手册</h1><h1 id="无需魔法的模型插件网站秒下载"><a href="#无需魔法的模型插件网站秒下载" class="headerlink" title="无需魔法的模型插件网站秒下载"></a>无需魔法的模型插件网站秒下载</h1><p><a href="https://www.liblibai.com/#/index/model">https://www.liblibai.com/#/index/model</a></p><h2 id="Stable-Diffusion。Controlnet发布新模型tile，可用于高清图生成"><a href="#Stable-Diffusion。Controlnet发布新模型tile，可用于高清图生成" class="headerlink" title="Stable Diffusion。Controlnet发布新模型tile，可用于高清图生成"></a>Stable Diffusion。Controlnet发布新模型tile，可用于高清图生成</h2><p>模型介绍：<a href="https://github.com/Mikubill/sd-webui-controlnet/issues/1033">https://github.com/Mikubill/sd-webui-controlnet/issues/1033</a><br>插件下载：<a href="https://github.com/Mikubill/sd-webui-controlnet">https://github.com/Mikubill/sd-webui-controlnet</a><br>模型下载：<a href="https://huggingface.co/lllyasviel/ControlNet-v1-1/tree/main">https://huggingface.co/lllyasviel/ControlNet-v1-1/tree/main</a></p><h2 id="Stable-Diffusion-大模型"><a href="#Stable-Diffusion-大模型" class="headerlink" title="Stable Diffusion 大模型"></a>Stable Diffusion 大模型</h2><p>我用夸克网盘分享了「人工智能公司及其产品概述」，点击链接即可保存。打开「夸克APP」，无需下载在线播放视频，畅享原画5倍速，支持电视投屏。<br>链接：<a href="https://pan.quark.cn/s/96c553f93b1e">https://pan.quark.cn/s/96c553f93b1e</a></p><p>我用夸克网盘分享了「154页GPT中文文档」，点击链接即可保存。打开「夸克APP」，无需下载在线播放视频，畅享原画5倍速，支持电视投屏。<br>链接：<a href="https://pan.quark.cn/s/65dffd78335e">https://pan.quark.cn/s/65dffd78335e</a></p><p>我用夸克网盘分享了「免费GPT工具」，点击链接即可保存。打开「夸克APP」，无需下载在线播放视频，畅享原画5倍速，支持电视投屏。<br>链接：<a href="https://pan.quark.cn/s/6c89133a2df0">https://pan.quark.cn/s/6c89133a2df0</a></p><p>我用夸克网盘分享了「Stable Diffusion 大模型」，点击链接即可保存。打开「夸克APP」，无需下载在线播放视频，畅享原画5倍速，支持电视投屏。<br>链接：<a href="https://pan.quark.cn/s/3fd212356810">https://pan.quark.cn/s/3fd212356810</a></p><p>我用夸克网盘分享了「Stable Diffusion  Lora模型」，点击链接即可保存。打开「夸克APP」，无需下载在线播放视频，畅享原画5倍速，支持电视投屏。<br>链接：<a href="https://pan.quark.cn/s/9117425d5332">https://pan.quark.cn/s/9117425d5332</a></p><p>我用夸克网盘分享了「AI绘画提示词.txt」，点击链接即可保存。打开「夸克APP」在线查看，支持多种文档格式转换。<br>链接：<a href="https://pan.quark.cn/s/6fac287f1e60">https://pan.quark.cn/s/6fac287f1e60</a></p><p>我用夸克网盘分享了「PPT超级市场.txt」，点击链接即可保存。打开「夸克APP」在线查看，支持多种文档格式转换。<br>链接：<a href="https://pan.quark.cn/s/fb9e633a8185">https://pan.quark.cn/s/fb9e633a8185</a></p><p>我用夸克网盘分享了「免费GPT网站合集.txt」，点击链接即可保存。打开「夸克APP」在线查看，支持多种文档格式转换。<br>链接：<a href="https://pan.quark.cn/s/dc36c6c502aa">https://pan.quark.cn/s/dc36c6c502aa</a></p><p>我用夸克网盘分享了「timat.png」，点击链接即可保存。打开「夸克APP」，无需下载在线播放视频，畅享原画5倍速，支持电视投屏。<br>链接：<a href="https://pan.quark.cn/s/9dadbfdad0ee">https://pan.quark.cn/s/9dadbfdad0ee</a></p><h2 id="在使用MMOCR制作自己的数据集时，可以使用以下标注工具："><a href="#在使用MMOCR制作自己的数据集时，可以使用以下标注工具：" class="headerlink" title="在使用MMOCR制作自己的数据集时，可以使用以下标注工具："></a>在使用MMOCR制作自己的数据集时，可以使用以下标注工具：</h2><p>1.LabelImg:LabelImg是一款免费的图像标注工具，支持多种标注类型，包括边界框、矩形、多边形、点等。</p><p>2.VGG Image Annotator (VIA):VIA是一款基于Web的图像标注工具，支持多种标注类型，包括边界框、矩形、多边形、点等。</p><p>3.RectLabel:RectLabel是一款专门用于矩形标注的工具，支持多种颜色和字体选择。</p><p>Supervisely:Supervisely是一款在线图像标注工具，支持多种标注类型，包括边界框、矩形、多边形、点等。<br>5.Labelbox:Labelbox是一款云端图像标注平台，支持多种标注类型，包括边界框、矩形、多边形、点等。同时还提供了丰富的API接口和机器学习算法支持。</p><h2 id="图文转视频"><a href="#图文转视频" class="headerlink" title="图文转视频"></a>图文转视频</h2><p>Lumen5是一款在线视频制作平台，可以把文本、图片等内容快速转化成视频，非常适合制作社交媒体广告和短视频。以下是Lumen5的网址和简单教程：<br>网址：<a href="https://lumen5.com/">https://lumen5.com/</a> 教程：<a href="https://lumen5.com/learn">https://lumen5.com/learn</a><br>使用Lumen5制作视频非常简单，只需要将你的文本或网址粘贴到平台上，选择模板并上传图片或视频素材，Lumen5就可以自动为你生成一个视频。<br>除了Lumen5之外，还有很多类似的在线视频制作平台可供选择，例如：<br>Canva：<a href="https://www.canva.com/create/videos/">https://www.canva.com/create/videos/</a><br>Animoto：<a href="https://animoto.com/">https://animoto.com/</a><br>Biteable：<a href="https://biteable.com/">https://biteable.com/</a><br>Powtoon：<a href="https://www.powtoon.com/">https://www.powtoon.com/</a><br>Renderforest：<a href="https://www.renderforest.com/">https://www.renderforest.com/</a></p><h2 id="文字生成视频首先推荐剪映，必剪"><a href="#文字生成视频首先推荐剪映，必剪" class="headerlink" title="文字生成视频首先推荐剪映，必剪"></a>文字生成视频首先推荐剪映，必剪</h2><p>Rephrase.ai<br><a href="https://www.rephrase.ai/">https://www.rephrase.ai/</a></p><p>Synthesia<br><a href="https://www.synthesia.io/?via=ai-bot">https://www.synthesia.io/?via=ai-bot</a><br>它们的功能和操作方式都有所不同，建议你可以试试几个不同的平台，选择最适合自己的一个。</p><h2 id="AI生成ppt"><a href="#AI生成ppt" class="headerlink" title="AI生成ppt"></a>AI生成ppt</h2><p>自动做PPT：beautiful AI<br>Tome：<a href="https://beta.tome.app/">https://beta.tome.app/</a><br>Gamma： <a href="https://gamma.app/signup?r=sqgovd3iif5btr4">https://gamma.app/signup?r=sqgovd3iif5btr4</a><br>chatBA：<a href="https://www.chatba.com/">https://www.chatba.com/</a><br>iA presenter：<a href="https://ia.net/presenter">https://ia.net/presenter</a><br>chronicle：<a href="https://chroniclehq.com/">https://chroniclehq.com/</a><br>beautiful.ai <a href="https://www.beautiful.ai/">https://www.beautiful.ai/</a><br>Mind Show:<a href="https://www.mindshow.fun/#/home">https://www.mindshow.fun/#/home</a> 自动生成PPT根据大纲内容<br>M365 设计器:<a href="https://www.microsoft.com/zh-cn/microsoft-365/premium-templates-with-microsoft-365">https://www.microsoft.com/zh-cn/microsoft-365/premium-templates-with-microsoft-365</a> 丢进文字和图片，自动美化排版PPT<br>Flourish:<a href="https://flourish.studio/">https://flourish.studio/</a> 输入数据表格，自动生成PPT动态可视化图表<br>SlidesGPT：仅需一句话，人工智能就能一键生成PPT的工具<br>Icecream：对电脑性能要求不高的PPT制作工具<br>Wepik：智能AI在几分钟内帮你生成演示文稿的工具<br>SlideHub：商务办公人士都爱使用的 PPT演示工具<br>Ludus：像搭积木一样的块式幻灯片演示工具<br>Decktopus：极短的时间内创建视觉效果惊人的PPT工具<br>Storydoc：可帮你轻松创建交互式演示文稿的工具</p><h1 id="免费下载PPT的网站："><a href="#免费下载PPT的网站：" class="headerlink" title="免费下载PPT的网站："></a>免费下载PPT的网站：</h1><h2 id="以下是10余款AI免费PPT工具网站的推荐："><a href="#以下是10余款AI免费PPT工具网站的推荐：" class="headerlink" title="以下是10余款AI免费PPT工具网站的推荐："></a>以下是10余款AI免费PPT工具网站的推荐：</h2><p>Canva（<a href="https://www.canva.com/%EF%BC%89">https://www.canva.com/）</a><br>Canva是一款非常强大的在线平台，可以用来创建各种视觉元素，包括PPT幻灯片。Canva使用简单，提供了大量的模板、样式和设计元素，并且支持AI技术，可以根据用户的需要自动调整视觉元素。</p><p>Zoho Show（<a href="https://www.zoho.com/show/%EF%BC%89">https://www.zoho.com/show/）</a><br>Zoho Show是一款在线PPT工具，支持AI技术，可以根据用户的要求自动排版和设计幻灯片。Zoho Show提供了许多模板和主题，使得用户可以快速创建出漂亮的PPT。</p><p>Prezi（<a href="https://prezi.com/%EF%BC%89">https://prezi.com/）</a><br>Prezi是一种非线性的演示工具，使用了AI和动画技术，可以使演示更加生动有趣。Prezi提供了许多主题和模板，还可以自由移动和缩放画布上的元素，给用户更大的自由度。</p><p>Visme（<a href="https://www.visme.co/%EF%BC%89">https://www.visme.co/）</a><br>Visme是一款科技感强的PPT工具，支持AI技术，可以根据用户的选择自动生成幻灯片。Visme提供了许多图标、图表等视觉元素，在用户创建演示时会自动进行排版和布局优化</p><p>Slides Carnival:<a href="https://www.slidescarnival.com/">https://www.slidescarnival.com/</a><br>PPT Template:<a href="https://www.ppttemplate.net/">https://www.ppttemplate.net/</a><br>Free PowerPoint Templates:<a href="https://www.free-power-point-templates.com/">https://www.free-power-point-templates.com/</a><br>PoweredTemplate:<a href="https://www.poweredtemplate.com/">https://www.poweredtemplate.com/</a><br>Presentation Magazine:<a href="https://www.presentationmagazine.com/free-powerpoint-templates/">https://www.presentationmagazine.com/free-powerpoint-templates/</a><br>FPPT:<a href="https://www.free-power-point-templates.com/">https://www.free-power-point-templates.com/</a><br>24Slides:<a href="https://24slides.com/free-powerpoint-templates/">https://24slides.com/free-powerpoint-templates/</a><br>Canva:<a href="https://www.canva.com/templates/presentations/">https://www.canva.com/templates/presentations/</a><br>Pikbest:<a href="https://www.pikbest.com/free-powerpoint-templates/">https://www.pikbest.com/free-powerpoint-templates/</a><br>Template.net:<a href="https://www.template.net/business/powerpoint-templates/free">https://www.template.net/business/powerpoint-templates/free</a></p><h2 id="免费GPT网站合集："><a href="#免费GPT网站合集：" class="headerlink" title="免费GPT网站合集："></a>免费GPT网站合集：</h2><p>chat8:<a href="https://chat.gamejx.cn/#/register?bronk_on=646565">https://chat.gamejx.cn/#/register?bronk_on=646565</a><br>chatgpt:<a href="https://s.wikll.com/">https://s.wikll.com/</a><br>AI网站：<a href="http://www.aitoolist.cn/">www.aitoolist.cn</a><br>AI网站工具：<a href="http://www.futurepedia.io/">www.futurepedia.io</a><br>ai工具网站也可以：<a href="http://www.ainav.cn/">www.ainav.cn</a><br>百度云文生图:<a href="https://ai.baidu.com/creativity/imageeditor">https://ai.baidu.com/creativity/imageeditor</a><br>阿里云文生图<br><a href="https://help.aliyun.com/document_detail/477804.html">https://help.aliyun.com/document_detail/477804.html</a><br>图文生图<br><a href="https://help.aliyun.com/document_detail/477821.html">https://help.aliyun.com/document_detail/477821.html</a><br>文生图、图生图<br><a href="https://www.apispace.com/23329/api/aigc/apiDocument?apiId=11993">https://www.apispace.com/23329/api/aigc/apiDocument?apiId=11993</a><br>腾讯云:<br>文生图<br><a href="https://cloud.tencent.com/document/product/1668/88064">https://cloud.tencent.com/document/product/1668/88064</a><br>图生图<br><a href="https://cloud.tencent.com/document/product/1668/88066">https://cloud.tencent.com/document/product/1668/88066</a></p><h2 id="导出PDF转PPT"><a href="#导出PDF转PPT" class="headerlink" title="导出PDF转PPT"></a>导出PDF转PPT</h2><p><a href="https://smallpdf.com/cn/pdf-converter">https://smallpdf.com/cn/pdf-converter</a></p><h2 id="PDF转换器"><a href="#PDF转换器" class="headerlink" title="PDF转换器"></a>PDF转换器</h2><p><a href="https://www.pdf2go.com/zh">https://www.pdf2go.com/zh</a></p><h2 id="chatgpt大合集"><a href="#chatgpt大合集" class="headerlink" title="chatgpt大合集"></a>chatgpt大合集</h2><p><a href="https://chat.huashuyunai.com/#/pages/index/index">https://chat.huashuyunai.com/#/pages/index/index</a></p><p><a href="https://chat.extkj.cn/#/chat/1002">https://chat.extkj.cn/#/chat/1002</a></p><p><a href="https://chat.aidutu.cn/#/chat/1002">https://chat.aidutu.cn/#/chat/1002</a></p><p><a href="https://supremes.pro/">https://supremes.pro/</a></p><p><a href="https://ai-toolbox.codefuture.top/">https://ai-toolbox.codefuture.top/</a></p><p><a href="https://chat.intercat.cn/web/">https://chat.intercat.cn/web/</a></p><p><a href="https://yiyan.baidu.com/welcome">https://yiyan.baidu.com/welcome</a> </p><p><a href="https://effidit.qq.com/">https://effidit.qq.com/</a> </p><p><a href="https://www.giiso.com/#/">https://www.giiso.com/#/</a></p><p><a href="https://chat.lanrenbangong.com/?adaid=14">https://chat.lanrenbangong.com/?adaid=14</a></p><p><a href="https://tryai1.github.io/">https://tryai1.github.io/</a></p><h2 id="GPT镜像"><a href="#GPT镜像" class="headerlink" title="GPT镜像"></a>GPT镜像</h2><p><a href="https://chat.theb.ai/">https://chat.theb.ai/</a><br><a href="https://chatforai.com/">https://chatforai.com/</a><br><a href="https://chatgpt.h7ml.cn/">https://chatgpt.h7ml.cn/</a><br><a href="https://poe.com/">https://poe.com/</a><br><a href="https://chatgpt.poshist.cn/">https://chatgpt.poshist.cn/</a><br><a href="https://gpt.h7ml.cn/">https://gpt.h7ml.cn/</a><br><a href="https://chat.wxredcover.cn/">https://chat.wxredcover.cn/</a><br><a href="https://chat.yqcloud.top/">https://chat.yqcloud.top/</a><br><a href="https://chat.forchange.cn/">https://chat.forchange.cn/</a><br><a href="https://ai.v2less.com/">https://ai.v2less.com/</a> 访问密码：lessismore<br><a href="https://www.aicodehelper.com/">https://www.aicodehelper.com/</a><br><a href="https://ai-toolbox.codefuture.top/">https://ai-toolbox.codefuture.top/</a><br><a href="https://chilloutai.com/">https://chilloutai.com/</a><br><a href="https://harry-potter.openai-lab.com/">https://harry-potter.openai-lab.com</a><br><a href="https://wordstory.streamlit.app/">https://wordstory.streamlit.app/</a><br><a href="https://hotoke.ai/">https://hotoke.ai/</a><br><a href="https://chat.geekr.dev/">https://chat.geekr.dev/</a><br><a href="https://desk.im/">https://desk.im</a><br><a href="https://xc.com/">https://xc.com/</a><br><a href="https://chat.51buygpt.com/">https://chat.51buygpt.com/</a><br><a href="https://freechatgpt.chat/">https://freechatgpt.chat/</a><br><a href="https://askai.ws/">https://askai.ws/</a><br><a href="https://ai.yiios.com/">https://ai.yiios.com/</a><br><a href="http://chat.apigpt.cn/">http://chat.apigpt.cn/</a><br><a href="https://94gpt.com/">https://94gpt.com/</a><br><a href="https://www.teach-anything.com/">https://www.teach-anything.com/</a><br><a href="http://itecheasy.com.cn/">http://itecheasy.com.cn/</a><br><a href="https://trychatgp.com/">https://trychatgp.com/</a><br><a href="https://chatgpt.ddiu.io/">https://chatgpt.ddiu.io/</a><br><a href="https://ai117.com/">https://ai117.com/</a><br><a href="http://chat.livepo.top/">http://chat.livepo.top/</a><br><a href="https://freechatgpt.lol/">https://freechatgpt.lol/</a><br><a href="https://freegpt.cc/">https://freegpt.cc</a><br><a href="https://ai.ls/">https://ai.ls</a><br><a href="https://chat.alpaca-bi.com/">https://chat.alpaca-bi.com/</a><br><a href="https://chat.paoying.net/">https://chat.paoying.net/</a><br><a href="https://chat.eaten.fun/">https://chat.eaten.fun/</a><br><a href="https://www.askopenai.cn/">https://www.askopenai.cn/</a><br><a href="https://chat.h7ml.cn/">https://chat.h7ml.cn/</a><br><a href="https://chatgpt-flutter.h7ml.cn/">https://chatgpt-flutter.h7ml.cn/</a><br><a href="https://www.aitoolgpt.com/">https://www.aitoolgpt.com/</a><br><a href="https://www.chatsverse.xyz/">https://www.chatsverse.xyz/</a><br><a href="http://chat.wikll.com/">http://chat.wikll.com</a></p><h2 id="在线体验-ChatGPT-的网站集合，UI-界面与官方相似。"><a href="#在线体验-ChatGPT-的网站集合，UI-界面与官方相似。" class="headerlink" title="在线体验 ChatGPT 的网站集合，UI 界面与官方相似。"></a>在线体验 ChatGPT 的网站集合，UI 界面与官方相似。</h2><p>Chat TGBot：<a href="https://chat.tgbot.co/">https://chat.tgbot.co/</a><br>BAI Chat：<a href="https://chat.theb.ai/">https://chat.theb.ai/</a><br>ChatGPT 国产镜像：<a href="https://ai.bo-e.com/">https://ai.bo-e.com/</a><br>ZYT.IM：<a href="https://zyt.im/#/chat/">https://zyt.im/#/chat/</a><br>Fast GPT：<a href="https://fastgpt.app/">https://fastgpt.app/</a><br>Free GPT：<a href="https://freegpt.one/">https://freegpt.one/</a><br>AI EDU：<a href="https://aigcfun.com/%E3%80%81https://chat.forchange.cn/">https://aigcfun.com/、https://chat.forchange.cn/</a><br>Chat LivePo：<a href="https://chat.livepo.top/">https://chat.livepo.top/</a><br>AI 小思：<a href="https://chatgpt-web-production-facc.up.railway.app/">https://chatgpt-web-production-facc.up.railway.app/</a></p><p>SlideSalad<br>Beautiful.ai<br>Slidebean<br>Visme<br>Zoho Show<br>Genially<br>Renderforest<br>PowerPoint Designer<br>SlideDog<br>HelloSlide<br><a href="https://flowus.cn/login?code=DCMSHF">https://flowus.cn/login?code=DCMSHF</a><br>PPT模板大市场<br><a href="https://www.pptsupermarket.com/?ref=lovejay.top">https://www.pptsupermarket.com/?ref=lovejay.top</a></p><p>中文写作AI<br><a href="https://xiezuocat.com/">https://xiezuocat.com/</a></p><p>在线markdown教学<br><a href="https://markdown.com.cn/editor/">https://markdown.com.cn/editor/</a></p><p>全球技术新闻<br><a href="https://www.freebuf.com/">https://www.freebuf.com/</a><br>超级好用得浏览器小组件<br><a href="https://go.itab.link/">https://go.itab.link/</a></p><h2 id="免费图片压缩的网站："><a href="#免费图片压缩的网站：" class="headerlink" title="免费图片压缩的网站："></a>免费图片压缩的网站：</h2><p>TinyPNG:<a href="https://tinypng.com/">https://tinypng.com/</a><br>CompressJPEG:<a href="https://compressjpeg.com/">https://compressjpeg.com/</a><br>ImageOptim:<a href="https://imageoptim.com/">https://imageoptim.com/</a><br>Kraken.io:<a href="https://kraken.io/">https://kraken.io/</a><br>ResizeImage.net:<a href="https://www.resizeimage.net/">https://www.resizeimage.net/</a><br>Online-Convert:<a href="https://www.online-convert.com/image/to-jpeg">https://www.online-convert.com/image/to-jpeg</a><br>Imgix:<a href="https://imgix.net/">https://imgix.net/</a><br>Webpizer:<a href="https://webpizer.app/">https://webpizer.app/</a><br>FastStone Image Viewer:<a href="https://www.faststone.org/imageviewer/index.html">https://www.faststone.org/imageviewer/index.html</a><br>GIMP:<a href="https://www.gimp.org/">https://www.gimp.org/</a></p><h2 id="免费的AI绘图网站，以下是其中几个："><a href="#免费的AI绘图网站，以下是其中几个：" class="headerlink" title="免费的AI绘图网站，以下是其中几个："></a>免费的AI绘图网站，以下是其中几个：</h2><p>Deep Dream Generator(深度梦境生成器)：<a href="https://deepdreamgenerator.com/">https://deepdreamgenerator.com/</a><br>NeuralStyler(神经风格化)：<a href="https://neuralstyler.com/">https://neuralstyler.com/</a><br>Artisto(艺术家)：<a href="https://artisto.net/">https://artisto.net/</a><br>AI Painter(AI画家)：<a href="https://aipainter.art/">https://aipainter.art/</a><br>PaintsChainer(画链)：<a href="https://paintschainer.com/">https://paintschainer.com/</a></p><h2 id="10个免费翻译英文PDF文献的网站："><a href="#10个免费翻译英文PDF文献的网站：" class="headerlink" title="10个免费翻译英文PDF文献的网站："></a>10个免费翻译英文PDF文献的网站：</h2><p>Google Translate(<a href="https://translate.google.com/">https://translate.google.com/</a>)<br>DeepL Translator(<a href="https://www.deepl.com/translator">https://www.deepl.com/translator</a>)<br>Bing Translator(<a href="https://www.bing.com/translator">https://www.bing.com/translator</a>)<br>Baidu Translate(<a href="https://fanyi.baidu.com/translate">https://fanyi.baidu.com/translate</a>)<br>FreeTranslation(<a href="https://www.freetranslation.com/">https://www.freetranslation.com/</a>)<br>TextMaster(<a href="https://textmaster.com/translate-pdf">https://textmaster.com/translate-pdf</a>)<br>Online-Translators(<a href="https://www.online-translators.com/">https://www.online-translators.com/</a>)<br>iTranslate(<a href="https://www.itranslate.com/">https://www.itranslate.com/</a>)<br>DocTranslator(<a href="https://doc-translate.com/">https://doc-translate.com/</a>)<br>PDFescape(<a href="https://www.pdfescape.net/tools/online-pdf-">https://www.pdfescape.net/tools/online-pdf-</a> translator)</p><h2 id="将网页转为PDF的网站或浏览器插件："><a href="#将网页转为PDF的网站或浏览器插件：" class="headerlink" title="将网页转为PDF的网站或浏览器插件："></a>将网页转为PDF的网站或浏览器插件：</h2><p>Adobe Acrobat Online:Adobe公司的官方在线PDF编辑器，可以将任何网页转换为PDF文件。</p><p>Smallpdf:一个免费的在线PDF工具，可以将网页、Word文档等转换为PDF格式。</p><p>Zamzar:一个在线文件转换工具，支持将多种文件格式转换为PDF,包括网页。</p><p>Google Docs:Google的在线办公套件，其中包含一个名为“打印”的功能，可以将网页转换为PDF文件。</p><p>Chrome浏览器插件：”Save as PDF”、”PDF Converter”、”Webpage to PDF”等插件都可以将网页转换为PDF文件</p><p>10个将网页转为PDF的免费网站或者免费浏览器插件：</p><p>Smallpdf:<a href="https://smallpdf.com/cn/pdf-converter">https://smallpdf.com/cn/pdf-converter</a><br>Zamzar:<a href="https://www.zamzar.com/convert/web-to-pdf/">https://www.zamzar.com/convert/web-to-pdf/</a><br>PDF Online:<a href="https://www.pdfonline.com/">https://www.pdfonline.com/</a><br>Adobe Acrobat Reader DC:<a href="https://get.adobe.com/reader/">https://get.adobe.com/reader/</a><br>Google Chrome PDF Viewer:<a href="https://chrome.google.com/webstore/detail/pdf-viewer/jnkmfdildnkiilkmekokdddomajhfobje?hl=en">https://chrome.google.com/webstore/detail/pdf-viewer/jnkmfdildnkiilkmekokdddomajhfobje?hl=en</a><br>Firefox PDF Viewer:<a href="https://addons.mozilla.org/en-US/firefox/addon/pdf-viewer/">https://addons.mozilla.org/en-US/firefox/addon/pdf-viewer/</a><br>Print Friendly &amp; PDF Converter:<a href="https://printfriendlypdf.com/">https://printfriendlypdf.com/</a><br>Web2PDF:<a href="https://www.web2pdf.com/">https://www.web2pdf.com/</a><br>ILovePDF:<a href="https://www.ilovepdf.com/">https://www.ilovepdf.com/</a><br>Free PDF Converter:<a href="https://www.freepdfconvert.com/">https://www.freepdfconvert.com/</a></p><h2 id="10个查询论文文献的免费网站和浏览器插件："><a href="#10个查询论文文献的免费网站和浏览器插件：" class="headerlink" title="10个查询论文文献的免费网站和浏览器插件："></a>10个查询论文文献的免费网站和浏览器插件：</h2><p>Google Scholar(谷歌学术)：这是一个免费的搜索引擎，可以搜索学术出版物、学位论文、会议论文等。它还提供了一些有用的功能，如引用计数、作者分析和文献推荐。</p><p>ResearchGate(研究门)：这是一个专门为研究人员设计的社交网络平台，可以帮助你找到同行的研究成果，并与他们交流。它还提供了一个免费的文献数据库，可以搜索各种学科领域的文章。</p><p>Sci-Hub(科学网)：这是一个非常流行的免费获取学术论文的网站，它通过爬取各种在线数据库来提供免费的全文下载服务。但是，由于版权问题，它在某些国家和地区可能无法访问。</p><p>PubMed Central(PubMed中心)：这是一个由美国国立卫生研究院提供的免费数据库，包含了数百万篇医学文献。它还提供了一些高级功能，如文献筛选和引用管理。</p><p>Directory of Open Access Journals(开放获取期刊目录)：这是一个由全球各地的大学和机构提供的免费期刊数据库，包含了各种学科领域的开放获取期刊。</p><p>Mendeley(门德列)：这是一个免费的文献管理和组织工具，可以帮助你整理和管理自己的文献库。它还提供了一些有用的功能，如文献推荐和引用管理。</p><p>Zotero(佐罗)：这是一个免费的开源文献管理工具，可以帮助你收集、整理和引用文献。它支持多种文件格式，包括PDF、Word和HTML。</p><p>ReadCube(阅读立方体)：这是一个免费的文献管理和阅读工具，可以帮助你整理和管理自己的文献库，并提供了一些有用的功能，如文献推荐和引用管理。</p><p>Paperpile(纸堆)：这是一个免费的文献管理和阅读工具，可以帮助你整理和管理自己的文献库，并提供了一些有用的功能，如文献推荐和引用管理。</p><p>Web of Science(科学引文索引)：这是一个由Clarivate Analytics提供的免费数据库，包含了全球范围内的学术出版物和研究报告。它还提供了一些高级功能，如文献筛选和引用管理。</p><h2 id="免费制作视频封面的网站名称"><a href="#免费制作视频封面的网站名称" class="headerlink" title="免费制作视频封面的网站名称"></a>免费制作视频封面的网站名称</h2><p>Canva: <a href="https://www.canva.com/">https://www.canva.com/</a><br>Adobe Spark Video: <a href="https://spark.adobe.com/make/video-cover-maker/">https://spark.adobe.com/make/video-cover-maker/</a><br>Piktochart: <a href="https://piktochart.com/features/vector-graphics/">https://piktochart.com/features/vector-graphics/</a><br>Pixlr: <a href="https://pixlr.com/">https://pixlr.com/</a><br>Fotor: <a href="https://www.fotor.com/create/video-cover/">https://www.fotor.com/create/video-cover/</a><br>Vecteezy: <a href="https://www.vecteezy.com/free-vector-images/video-cover-templates">https://www.vecteezy.com/free-vector-images/video-cover-templates</a><br>Coverr: <a href="https://coverr.co/">https://coverr.co/</a><br>Snappa: <a href="https://snappa.com/video-cover-maker">https://snappa.com/video-cover-maker</a><br>DesignCap: <a href="https://www.designcap.com/video-cover-maker/">https://www.designcap.com/video-cover-maker/</a><br>BeFunky: <a href="https://www.befunky.com/create/video-cover/">https://www.befunky.com/create/video-cover/</a></p><h2 id="免费将doc文件转换为PDF的在线工具："><a href="#免费将doc文件转换为PDF的在线工具：" class="headerlink" title="免费将doc文件转换为PDF的在线工具："></a>免费将doc文件转换为PDF的在线工具：</h2><p>Smallpdf(<a href="https://smallpdf.com/cn/pdf-to-word):Smallpdf">https://smallpdf.com/cn/pdf-to-word):Smallpdf</a> 是一个非常方便的在线PDF转换工具，可以将Word文档、Excel表格和PPT演示文稿等文件转换为PDF格式。只需上传您的doc文件，选择输出格式为PDF,然后点击“转换”按钮即可。</p><p>PDF Converter(<a href="https://www.onlineconvert.com/zht/pdf-to-word):PDF">https://www.onlineconvert.com/zht/pdf-to-word):PDF</a> Converter 是一个功能强大的在线转换工具，支持将多种文件格式(包括doc、docx、xls、xlsx、ppt、pptx等)转换为PDF格式。上传您的doc文件，选择输出格式为PDF,然后点击“转换”按钮即可。</p><p>Zamzar(<a href="https://www.zamzar.com/convert/to/pdf/):Zamzar">https://www.zamzar.com/convert/to/pdf/):Zamzar</a> 是一个提供多种文件格式转换服务的网站，可以将doc文件转换为PDF格式。上传您的doc文件，选择输出格式为PDF,然后等待文件下载完成即可。</p><p>请注意，在使用这些在线工具时，请确保您拥有合法的文件转换权利。同时，由于网络连接速度和服务器负载等因素的影响，文件转换可能需要一定时间。</p><h2 id="免费将PDF翻译为中文的网站："><a href="#免费将PDF翻译为中文的网站：" class="headerlink" title="免费将PDF翻译为中文的网站："></a>免费将PDF翻译为中文的网站：</h2><p>Smallpdf:<a href="https://smallpdf.com/cn/pdf-to-chinese">https://smallpdf.com/cn/pdf-to-chinese</a><br>Zamzar:<a href="https://www.zamzar.com/convert/pdf-to-text/">https://www.zamzar.com/convert/pdf-to-text/</a><br>Online-Convert:<a href="https://www.online-convert.com/zh/pdf-to-text">https://www.online-convert.com/zh/pdf-to-text</a><br>PDF Online:<a href="https://www.pdfonline.com/pdf-to-text/">https://www.pdfonline.com/pdf-to-text/</a><br>Adobe Acrobat:<a href="https://acrobat.adobe.com/us/en/acrobat/online/pdf-to-text.html">https://acrobat.adobe.com/us/en/acrobat/online/pdf-to-text.html</a></p><p>如果您需要高质量的翻译，但又希望它是免费的，您可以尝试以下方法：</p><p>使用在线翻译工具：有一些在线翻译工具，如Google Translate、Bing Translator等，可以将PDF文件上传到它们的网站上进行翻译。虽然这些工具可能无法提供与专业翻译服务或软件相同的质量，但它们通常是免费的，并且可以帮助您快速将PDF文件翻译成中文。</p><p>寻找志愿者翻译者：您可以在一些志愿者翻译平台上发布任务，寻找愿意为您免费翻译PDF文件的志愿者。例如，您可以在FreeTranslation.com、TranslatorsCafé.com等平台上发布任务，并等待志愿者的响应。请注意，由于志愿者通常没有经过专业培训，因此他们的翻译质量可能不如专业翻译服务或软件提供的翻译质量高。</p><p>使用开源翻译软件：有一些开源翻译软件，如OpenOffice Translator、POEditor等，可以将PDF文件导入到软件中进行翻译。虽然这些软件可能不是非常强大，但它们是免费的，并且可以帮助您将PDF文件翻译成中文。</p><h2 id="视频去水印"><a href="#视频去水印" class="headerlink" title="视频去水印"></a>视频去水印</h2><p><a href="https://bgrem.ai/zh/remove-video-bg/?params=start">https://bgrem.ai/zh/remove-video-bg/?params=start</a></p><p>FLIKI<br><a href="https://fliki.ai/">https://fliki.ai/</a></p><h2 id="免费的AI写作网站："><a href="#免费的AI写作网站：" class="headerlink" title="免费的AI写作网站："></a>免费的AI写作网站：</h2><p>1.AI Writer:<a href="https://aiwriter.com/">https://aiwriter.com/</a><br>2.Articoolo:<a href="https://articoolo.com/">https://articoolo.com/</a><br>3.Quillbot:<a href="https://quillbot.com/">https://quillbot.com/</a><br>4.Copyscape-Generator:<a href="https://copyscape-generator.com/">https://copyscape-generator.com/</a><br>5.Grammarly Blog:<a href="https://www.grammarly.com/blog/">https://www.grammarly.com/blog/</a><br>6.Hemingway Editor:<a href="https://hemingwayapp.com/">https://hemingwayapp.com/</a><br>7.Slickwrite:<a href="https://www.slickwrite.com/">https://www.slickwrite.com/</a><br>8.Writefull:<a href="https://www.writefull.com/">https://www.writefull.com/</a><br>9.CoSchedule Headline Analyzer:<a href="https://headlineanalyzer.coschedule.com/">https://headlineanalyzer.coschedule.com/</a><br>10.Yoast SEO Blog:<a href="https://yoastseoblog.com/">https://yoastseoblog.com/</a></p><h2 id="写文案其实并不是一件难事，只要平时不断积累，再擅用工具，就能轻松应对。以下这9款工具能提供素材级创意支持，编辑、排版、寻找热点话题、寻找爆款文章，甚至进行文章原创度检测等功能，让文案创作变得更加高效和有成效。无论是独立创作者还是团队协作，这些工具都是不可或缺的利器。"><a href="#写文案其实并不是一件难事，只要平时不断积累，再擅用工具，就能轻松应对。以下这9款工具能提供素材级创意支持，编辑、排版、寻找热点话题、寻找爆款文章，甚至进行文章原创度检测等功能，让文案创作变得更加高效和有成效。无论是独立创作者还是团队协作，这些工具都是不可或缺的利器。" class="headerlink" title="写文案其实并不是一件难事，只要平时不断积累，再擅用工具，就能轻松应对。以下这9款工具能提供素材级创意支持，编辑、排版、寻找热点话题、寻找爆款文章，甚至进行文章原创度检测等功能，让文案创作变得更加高效和有成效。无论是独立创作者还是团队协作，这些工具都是不可或缺的利器。"></a>写文案其实并不是一件难事，只要平时不断积累，再擅用工具，就能轻松应对。以下这9款工具能提供素材级创意支持，编辑、排版、寻找热点话题、寻找爆款文章，甚至进行文章原创度检测等功能，让文案创作变得更加高效和有成效。无论是独立创作者还是团队协作，这些工具都是不可或缺的利器。</h2><p>阿i妈妈智 能文案(一款提供从图文到视频再到落地页的素材级创意支持，是您营销创意数字资产积累的阵地，更大化提升营销的效率和效果。<br>秘塔写作猫(一款集智 能写作、文本校对、改写润色等功能为一体的网站)<br>GET写作(一款拥有10w+的写作模版，可以键改写和扩写的网站)<br>句子控(一款汇集了很多名人名言，影视经典语录等，超好用的神级app)<br>押韵助手(一款支持在线查询押韵的字、词、诗、歌，支持单押多押，海量词库，文案创作者必备神器。)<br>巨量创意(一款可以定制属于自己的图片、视频脚本、AI配音、智 能配乐等，功能强大。<br>易撰(一款全能型的工具，编辑排版、寻找热点话题、寻找爆款文章，还可以进行文章原创度的检测。 )<br>字语智 能(提供热点整合，丰富写作素材，海量写作模板和AI创新写作。)<br>写文案其实没有想象中那么难，除了平时不断地积累，再就是擅用工具，好好利用以上这9款工具，就再也不愁没有灵感和创意啦~</p><h2 id="完成人物作图后，如果能让人物动起来，那真的可以让人大喊666-这里就要分享一种很简单的方法，就是利用万彩骨骼大师"><a href="#完成人物作图后，如果能让人物动起来，那真的可以让人大喊666-这里就要分享一种很简单的方法，就是利用万彩骨骼大师" class="headerlink" title="完成人物作图后，如果能让人物动起来，那真的可以让人大喊666~这里就要分享一种很简单的方法，就是利用万彩骨骼大师"></a>完成人物作图后，如果能让人物动起来，那真的可以让人大喊666~这里就要分享一种很简单的方法，就是利用万彩骨骼大师</h2><p>（<a href="http://bone.animiz.cn/%EF%BC%89">http://bone.animiz.cn/）</a><br>一款专门制作2D角色的骨骼动画软件，轻松让静态图片转换为动态，实现眨眼、微笑、挥手、移动、跑步、跳跃、旋转等一系列动画动作。</p><h2 id="Upscayl-–-免费开源的-AI-图像放大工具，跨平台"><a href="#Upscayl-–-免费开源的-AI-图像放大工具，跨平台" class="headerlink" title="Upscayl – 免费开源的 AI 图像放大工具，跨平台"></a>Upscayl – 免费开源的 AI 图像放大工具，跨平台</h2><p>使用 Upscayl 需要兼容 Vulkan 的 GPU，主要包括：</p><p>NVIDIA<br>GeForce 600 系列及更新产品<br>Quadro K 系列及更新产品<br>Tesla K/M/X 系列<br>GRID K2/K520<br>AMD<br>Radeon HD 7000 系列及更新产品<br>Radeon R7/R9 200 系列及更新产品<br>Radeon RX 400/500/5000 系列及更新产品<br>FirePro W 系列及更新产品<br>Intel<br>第六代 Core 处理器及更新产品，包括 Haswell、Broadwell、Skylake、Kaby Lake、Coffee Lake 等</p><p>官网：<a href="https://kutt.appinn.com/UwTFTN">https://kutt.appinn.com/UwTFTN</a></p><h2 id="EasyCode-AI-–-集成在-VS-Code-里的-ChatGPT，帮你写代码、改代码"><a href="#EasyCode-AI-–-集成在-VS-Code-里的-ChatGPT，帮你写代码、改代码" class="headerlink" title="EasyCode AI – 集成在 VS Code 里的 ChatGPT，帮你写代码、改代码"></a>EasyCode AI – 集成在 VS Code 里的 ChatGPT，帮你写代码、改代码</h2><p>亲测不太管用，要不你们用一下哈利波特的魔法？</p><h2 id="免费的AI生成PPT网站，以下是其中几个："><a href="#免费的AI生成PPT网站，以下是其中几个：" class="headerlink" title="免费的AI生成PPT网站，以下是其中几个："></a>免费的AI生成PPT网站，以下是其中几个：</h2><p>Slides Carnival:<a href="https://www.slidescarnival.com/">https://www.slidescarnival.com/</a><br>Canva:<a href="https://www.canva.com/templates/presentations/">https://www.canva.com/templates/presentations/</a><br>Prezi:<a href="https://prezi.com/slide-generator/">https://prezi.com/slide-generator/</a><br>Google Slides:<a href="https://www.google.com/slides/about/">https://www.google.com/slides/about/</a><br>Zoho Show:<a href="https://www.zoho.com/slide-show/">https://www.zoho.com/slide-show/</a><br>Visme:<a href="https://www.visme.co/create/presentations/">https://www.visme.co/create/presentations/</a><br>Slidebean:<a href="https://slidebean.com/free-powerpoint-templates/">https://slidebean.com/free-powerpoint-templates/</a><br>SlideSalad:<a href="https://slidesalad.com/free-powerpoint-templates/">https://slidesalad.com/free-powerpoint-templates/</a><br>IA present ：<a href="https://ia.net/presenter">https://ia.net/presenter</a></p><h2 id="prompt提示词"><a href="#prompt提示词" class="headerlink" title="prompt提示词"></a>prompt提示词</h2><p><a href="https://moonvy.com/apps/ops/?utm_source=appinn.com">https://moonvy.com/apps/ops/?utm_source=appinn.com</a><br>AIPRM<br>Prompt Storm<br>novelai：<a href="https://tags-dev.novelai.dev/">https://tags-dev.novelai.dev/</a><br>black lily: <a href="http://heizicao.gitee.io/novelai/#/home">http://heizicao.gitee.io/novelai/#/home</a><br>tag zoo:<a href="http://tag.zoos.life/">http://tag.zoos.life/</a></p><p>😀腾讯-陈鹏《Kubernetes 实践指南》在线阅读（内含离线下载方法）：<br><a href="https://imroc.cc/kubernetes">https://imroc.cc/kubernetes</a></p><p>😀其他K8s阅读材料推荐：<br>《Kubernetes 编程基础知识》<a href="https://cloudnative.to/blog/kubernetes-programming-base/">https://cloudnative.to/blog/kubernetes-programming-base/</a><br>《一文梳理REST API的设计原则》<a href="https://zhuanlan.zhihu.com/p/106724321">https://zhuanlan.zhihu.com/p/106724321</a><br>《在 Kubernetes 上开发》<a href="https://kubernetes.io/zh-cn/blog/2018/05/01/developing-on-kubernetes/">https://kubernetes.io/zh-cn/blog/2018/05/01/developing-on-kubernetes/</a><br>《最新、最全、最详细的 K8S 学习笔记总结（2021最新版）！建议收藏》<br><a href="https://segmentfault.com/a/1190000039844000">https://segmentfault.com/a/1190000039844000</a><br>《一文看懂 Kubelet》<a href="https://zhuanlan.zhihu.com/p/338462784">https://zhuanlan.zhihu.com/p/338462784</a><br>《调度框架》<a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/scheduling-framework/">https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/scheduling-framework/</a></p><p>1Tome: PPT生成Al，输入文案，自动帮你生成PPT，视觉效果超丰富<br>2Prezo: PPT创作Al，输入文案即可为你自动生成PPT<br>3]SlidesAl: 易上手的PPT创作Al，输入文案一键生成PPT<br>4Beautifulai: 效果很好的PPT生成Al，简单输入提示词，自动生成PPT<br>5Motionit ai: 输入文案自动为你创建PPT<br>6STORYD:输入文案数据，为你快速创建PPT擅长图表类的PPT<br>7Present Al: 输入文案可为你快速生成PPT<br>8MagicSlides: 只需三步，输入文案，选择风格，即可生成PPT<br>9MyReport: 输入提示词，快速为你创作PPT<br>https/<a href="http://www.bing.comvcreatol/">www.bing.comvcreatol</a></p><h2 id="AI生产力"><a href="#AI生产力" class="headerlink" title="AI生产力"></a>AI生产力</h2><p>ChatGPT<br>Midjourney<br>Tome<br>AutoDraw<br>Copy.ai<br>Autodraw<br>Remove.bg<br>Fliki<br>FakeYou<br>Jukebox</p><p>chatgpt： <a href="https://chat.openai.com/">https://chat.openai.com/</a><br>Descript： <a href="https://www.descript.com/">https://www.descript.com/</a> 设计软件<br>Midjourney： <a href="https://discord.com/">https://discord.com/</a><br>Notion AI ： <a href="https://www.notion.so/product/ai">https://www.notion.so/product/ai</a><br>Tome ： <a href="https://beta.tome.app/">https://beta.tome.app/</a><br>runway ： <a href="https://runwayml.com/">https://runwayml.com/</a><br>阿里云大模型申请入口：通义千问 (aliyun.com)</p><p>代码工具：<a href="https://copilot.github.com/">https://copilot.github.com/</a><br>文字转语音：<a href="https://azure.microsoft.com/zh-cn/products/cognitive-services/text-to-speech/">https://azure.microsoft.com/zh-cn/products/cognitive-services/text-to-speech/</a><br>语音合成：<a href="https://valle-demo.github.io/">https://valle-demo.github.io/</a><br>开源项目地址：<a href="https://github.com/nvbn/thefuck">https://github.com/nvbn/thefuck</a> 命令行自动改错</p><h1 id="5个AI模型下载地址-100M-S-含Prompt提示词"><a href="#5个AI模型下载地址-100M-S-含Prompt提示词" class="headerlink" title="5个AI模型下载地址 100M/S 含Prompt提示词"></a>5个AI模型下载地址 100M/S 含Prompt提示词</h1><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486788&amp;idx=1&amp;sn=4e5368d55b6f231d1d464346bdc016ed&amp;chksm=ceb09239f9c71b2fa3c2a6998b9125b364d4d89df44743f2de19cdb5b6027a1b3c87a9399b06&amp;token=1149111433&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486788&amp;idx=1&amp;sn=4e5368d55b6f231d1d464346bdc016ed&amp;chksm=ceb09239f9c71b2fa3c2a6998b9125b364d4d89df44743f2de19cdb5b6027a1b3c87a9399b06&amp;token=1149111433&amp;lang=zh_CN#rd</a></p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="AI工具大合集" scheme="https://zkkget.github.io/categories/AI%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%90%88%E9%9B%86/"/>
    
    
    <category term="AI工具大合集" scheme="https://zkkget.github.io/tags/AI%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%90%88%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>每日早报60s</title>
    <link href="https://zkkget.github.io/posts/20230423a1.html"/>
    <id>https://zkkget.github.io/posts/20230423a1.html</id>
    <published>2023-04-23T02:21:18.000Z</published>
    <updated>2023-04-23T02:29:12.479Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p><img src="https://api.03c3.cn/zb/" alt="每日60S"><br><img src="https://v2.alapi.cn/api/zaobao?token=BX2vvKW28gktjrPr&format=image" alt="60s-for-news"></p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="每日早报60s" scheme="https://zkkget.github.io/categories/%E6%AF%8F%E6%97%A5%E6%97%A9%E6%8A%A560s/"/>
    
    
    <category term="每日早报60s" scheme="https://zkkget.github.io/tags/%E6%AF%8F%E6%97%A5%E6%97%A9%E6%8A%A560s/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程专题连载系列</title>
    <link href="https://zkkget.github.io/posts/20230207a1.html"/>
    <id>https://zkkget.github.io/posts/20230207a1.html</id>
    <published>2023-02-07T06:14:39.000Z</published>
    <updated>2023-02-13T05:41:07.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="曾经整理过一个并发专题的连载系列-但由于时间久远-且查阅资料有限-本次尽量按照项目实际应用遇到的问题进行举例。由于时间有限-本文将长时间进行更新…一开始就将一个类设计成是线程安全的-比在后期重新修复它更容易。"><a href="#曾经整理过一个并发专题的连载系列-但由于时间久远-且查阅资料有限-本次尽量按照项目实际应用遇到的问题进行举例。由于时间有限-本文将长时间进行更新…一开始就将一个类设计成是线程安全的-比在后期重新修复它更容易。" class="headerlink" title="曾经整理过一个并发专题的连载系列,但由于时间久远,且查阅资料有限,本次尽量按照项目实际应用遇到的问题进行举例。由于时间有限,本文将长时间进行更新…一开始就将一个类设计成是线程安全的,比在后期重新修复它更容易。"></a>曾经整理过一个并发专题的连载系列,但由于时间久远,且查阅资料有限,本次尽量按照项目实际应用遇到的问题进行举例。由于时间有限,本文将长时间进行更新…一开始就将一个类设计成是线程安全的,比在后期重新修复它更容易。</h2><p>网易云课堂知识大纲<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/1a200f88c7024d5fb7258886178e7165.jpg" alt="知识大纲"><br>相关官方文档：<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html">https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html</a></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。通常，<br>每一个任务称为一个线程（ thread), 它是线程控制的简称。可以同时运行一个以上线程的程<br>序称为多线程程序（multithreaded)。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在java api文档中原文对Thread类解释如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.</span><br><span class="line">Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.</span><br><span class="line"></span><br><span class="line">When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:</span><br><span class="line"></span><br><span class="line">The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.</span><br><span class="line">All threads that are not daemon threads have died, either by returning from t</span><br></pre></td></tr></table></figure><p>译文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程是程序中的执行线程。 Java虚拟机允许应用程序同时运行多个执行线程。</span><br><span class="line">每个线程都有一个优先级。优先级较高的线程优先执行优先级较低的线程。每个线程可能也可能不会标记为守护程序。当在某些线程中运行的代码创建一个新线程时，新线程的优先级最初设置等于创建线程的优先级，并且仅当创建线程是守护程序时，才是守护程序线程。</span><br><span class="line">当Java虚拟机启动时，通常会有一个非daemon线程（通常调用某些指定类的主题的方法）。 Java虚拟机继续执行线程，直到发生以下任何一个：</span><br><span class="line"></span><br><span class="line">已经调用了类运行时的退出方法，安全管理器已允许进行退出操作。</span><br><span class="line">所有不是守护程序线程的线程都死了，要么从T返回</span><br></pre></td></tr></table></figure><p>对于本段话则可以进行提问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是守护线程？</span><br><span class="line">什么是daemon线程？</span><br></pre></td></tr></table></figure><h2 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程"></a>为什么需要多线程</h2><p>1.资源利用,多CPU系统中提高CPU利用率<br>2.提高应用程序响应,程序的运行效率会提高<br>3.编译程序优化指令执行次序，使得缓存能够得到更加合理地利用</p><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>多线程并发执行时,对共享内存中共享对象的属性发生修改时所导致的数据冲突问题,称之为线程安全问题</p><p>即使你的程序没有显式地创建任何线程,框架也可能为你创建了一些线程,这些线程<br>调用的代码必须是线程安全的(thread-safe)。这一点给开发人员的设计和实现赋予了更<br>重要的一份责任,因为开发线程安全的类要比非线程安全的类需要更加仔细,进行更多的<br>分析。</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程可以有如下 6 种状态：<br>•New (新创建）<br>•Runnable (可运行）<br>•Blocked (被阻塞）<br>•Waiting (等待）<br>•Timed waiting (计时等待）<br>•Terminated (被终止）<br>下一节对每一种状态进行解释。<br>要确定一个线程的当前状态， 可调用 getState 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread which has not yet started.</span><br><span class="line">         */</span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line">         * state is executing in the Java virtual machine but it may</span><br><span class="line">         * be waiting for other resources from the operating system</span><br><span class="line">         * such as processor.</span><br><span class="line">         */</span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">         * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line">         * to enter a synchronized block/method or</span><br><span class="line">         * reenter a synchronized block/method after calling</span><br><span class="line">         * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">         */</span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread.</span><br><span class="line">         * A thread is in the waiting state due to calling one of the</span><br><span class="line">         * following methods:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">         * perform a particular action.</span><br><span class="line">         *</span><br><span class="line">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="line">         * on an object is waiting for another thread to call</span><br><span class="line">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="line">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="line">         * is waiting for a specified thread to terminate.</span><br><span class="line">         */</span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">         * A thread is in the timed waiting state due to calling one of</span><br><span class="line">         * the following methods with a specified positive waiting time:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         */</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a terminated thread.</span><br><span class="line">         * The thread has completed execution.</span><br><span class="line">         */</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h2><p>当用 new 操作符创建一个新线程时，如 newThread(r)， 该线程还没有开始运行。这意味<br>着它的状态是 new。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在<br>线程运行之前还有一些基础工作要做。<br>那么所有创建线程的本质都是new Thread()</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123; System.out.printf(<span class="string">&quot;线程%s 正在执行&quot;</span>,Thread.currentThread().getName()); &#125;,<span class="string">&quot;thread-01&quot;</span>).start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;线程%s 是否有存活%s&quot;</span>,Thread.currentThread().getName(),Thread.currentThread().isAlive());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">控制台输出</span><br><span class="line">线程main 是否有存活<span class="keyword">true</span>线程thread-<span class="number">01</span> 正在执行Disconnected from the target VM, address: <span class="string">&#x27;127.0.0.1:53273&#x27;</span>, transport: <span class="string">&#x27;socket&#x27;</span></span><br></pre></td></tr></table></figure></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="并发编程专题" scheme="https://zkkget.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="并发编程专题" scheme="https://zkkget.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动｜字节客户端｜一二三面+hr面（已Offer）</title>
    <link href="https://zkkget.github.io/posts/20221018a1.html"/>
    <id>https://zkkget.github.io/posts/20221018a1.html</id>
    <published>2022-10-18T06:23:27.000Z</published>
    <updated>2022-10-26T07:56:08.412Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="一面｜45min"><a href="#一面｜45min" class="headerlink" title="一面｜45min"></a>一面｜45min</h2><p>1.输入url到页面展示过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入url地址</span><br><span class="line">应用层进行DNS解析</span><br><span class="line">应用层生成HTTP请求报文</span><br><span class="line">传输层建立TCP连接</span><br><span class="line">网络层使用IP协议来选择路线</span><br><span class="line">数据链路层实现网络相邻节点间可靠的数据通信</span><br><span class="line">物理层传输数据</span><br><span class="line">服务器处理反向传输</span><br><span class="line">服务器返回一个 HTTP 响应</span><br><span class="line">浏览器渲染</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/qinian8/article/details/99081105</span><br></pre></td></tr></table></figure><p>2.http和https的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。</span><br><span class="line">HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。</span><br><span class="line"></span><br><span class="line">HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</span><br><span class="line"></span><br><span class="line">HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</span><br><span class="line"></span><br><span class="line">HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</span><br><span class="line">使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</span><br><span class="line">HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</span><br><span class="line">http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</span><br><span class="line">HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/guolin_blog/article/details/104546558</span><br></pre></td></tr></table></figure><p>3.数字证书的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1）概念：</span><br><span class="line">数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。</span><br><span class="line"></span><br><span class="line">认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。</span><br><span class="line"></span><br><span class="line">2）数字证书颁发过程：</span><br><span class="line"></span><br><span class="line">数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。</span><br><span class="line"></span><br><span class="line">3）内容：</span><br><span class="line"></span><br><span class="line">数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：</span><br><span class="line"></span><br><span class="line">1、证书的版本信息；</span><br><span class="line"></span><br><span class="line">2、证书的序列号，每个证书都有一个唯一的证书序列号；</span><br><span class="line"></span><br><span class="line">3、证书所使用的签名算法；</span><br><span class="line"></span><br><span class="line">4、证书的发行机构名称，命名规则一般采用X.500格式；</span><br><span class="line"></span><br><span class="line">5、证书的有效期，通用的证书一般采用UTC时间格式；</span><br><span class="line"></span><br><span class="line">6、证书所有人的名称，命名规则一般采用X.500格式；</span><br><span class="line"></span><br><span class="line">7、证书所有人的公开密钥；</span><br><span class="line"></span><br><span class="line">8、证书发行者对证书的签名。</span><br></pre></td></tr></table></figure><p>4.对称加密和非对称加密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对称加密：加密和解密用的是同一个密码或者同一套逻辑的加密方式。对称加密的致命性缺点就是无法保证秘钥的安全性。</span><br><span class="line">非对称加密:加密和解密用的秘钥不是同一个</span><br></pre></td></tr></table></figure><p>5.https用的是对称加密还是非对称加密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段</span><br></pre></td></tr></table></figure><p>6.http头部有哪些内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">包括通用头，请求头，响应头和实体头</span><br><span class="line">1.通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、 Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理</span><br><span class="line">2.请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If- Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、 Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域,一般将会作为实体头域处理。</span><br><span class="line">3.响应消息的第一行为下面的格式： </span><br><span class="line">HTTP-Version Status-Code Reason-Phrase</span><br><span class="line"></span><br><span class="line">HTTP -Version表示支持的HTTP版本，例如为HTTP/1.1。</span><br><span class="line">Status- Code是一个三个数字的结果代码。</span><br><span class="line">Reason-Phrase给Status-Code提供一个简单的文本描述。</span><br><span class="line">4.请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。</span><br><span class="line"></span><br><span class="line">实体头域包含关于实体的原信息，实体头包括Allow、Content- Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法为接受方识别。</span><br></pre></td></tr></table></figure><p>7.线程和进程的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个进程可以有多个线程,至少有一个线程</span><br><span class="line">根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</span><br></pre></td></tr></table></figure><p>8.进程通信的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 匿名管道通信</span><br><span class="line">2 高级管道通信</span><br><span class="line">3 有名管道通信</span><br><span class="line">4 消息队列通信</span><br><span class="line">5 信号量通信</span><br><span class="line">6 信号</span><br><span class="line">7 共享内存通信</span><br><span class="line">8 套接字通信</span><br></pre></td></tr></table></figure><p>9.线程的状态怎样转移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程主要分为6种状态：初始，可运行，等待，超时等待，阻塞，终止</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>10.封装继承和多态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">封装的意义：</span><br><span class="line">　　封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。</span><br><span class="line">继承主要实现重用代码，节省开发时间。</span><br><span class="line">多态：</span><br><span class="line"></span><br><span class="line">1、“一个接口，多种方法”</span><br><span class="line"></span><br><span class="line">同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</span><br><span class="line"></span><br><span class="line">  多态的三个条件:</span><br><span class="line"> </span><br><span class="line"> a.    继承的存在(继承是多态的基础,没有继承就没有多态).</span><br><span class="line"> b.    子类重写父类的方法(多态下调用子类重写的方法).</span><br><span class="line"> c.    父类引用变量指向子类对象(子类到父类的类型转换).</span><br><span class="line"></span><br><span class="line">重载（overload）和重写（override）是实现多态的两种主要方式。</span><br><span class="line"></span><br><span class="line"> 　２、实现多态：</span><br><span class="line"></span><br><span class="line">接口多态性。</span><br><span class="line">继承多态性。</span><br><span class="line">通过抽象类实现的多态性。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>11.重载和重写的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重写： 在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</span><br><span class="line">重载：在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。</span><br></pre></td></tr></table></figure><p>12.垃圾回收算法了解吗？怎么判断对象需要被回收？GC ROOTS有哪些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">垃圾：已经不再被内存使用到的空间</span><br><span class="line"></span><br><span class="line">1.标记清除</span><br><span class="line">2.标记压缩</span><br><span class="line">3.可达性分析算法</span><br><span class="line">4.GC roots</span><br><span class="line">GC roots</span><br><span class="line">--</span><br><span class="line">1.虚拟机栈中的引用对象</span><br><span class="line">2.方法区中的类静态属性引用对象</span><br><span class="line">3.方法区中常量引用的对象</span><br><span class="line">4.本地方法栈Native方法引用的对象</span><br></pre></td></tr></table></figure><p>算法题一，回型打印二维数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBackPrint &#123;</span><br><span class="line"> </span><br><span class="line">    public static void arrayBackPrint(int[][] nums) &#123;</span><br><span class="line">        if (nums == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;invalid param&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int top = 0;</span><br><span class="line">        int bottom =  nums.length - 1;</span><br><span class="line">        int left =0;</span><br><span class="line">        int right = nums[0].length - 1;</span><br><span class="line">        while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            for (int i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                System.out.print(nums[top][i] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            if (top &gt; bottom || left &gt; right) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = top; i &lt;= bottom; i++) &#123;</span><br><span class="line">                System.out.print(nums[i][right] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            if (top &gt; bottom || left &gt; right) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = right; i &gt;= left; i--) &#123;</span><br><span class="line">                System.out.print(nums[bottom][i] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            if (top &gt; bottom || left &gt; right) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = bottom; i &gt;= top; i--) &#123;</span><br><span class="line">                System.out.print(nums[i][left] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void arrayPrint(int[][] nums) &#123;</span><br><span class="line">        if (nums == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;invalid param&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; nums[0].length; j++) &#123;</span><br><span class="line">                System.out.print(nums[i][j] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void arrayInnit(int[][] nums) &#123;</span><br><span class="line">        if (nums == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;invalid param&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int num = 11;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; nums[0].length; j++) &#123;</span><br><span class="line">                nums[i][j] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        int[][] nums = new int[10][7];</span><br><span class="line">        int[][] nums = new int[10][10];</span><br><span class="line">        arrayInnit(nums);</span><br><span class="line">        arrayPrint(nums);</span><br><span class="line">        arrayBackPrint(nums);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二面｜20min"><a href="#二面｜20min" class="headerlink" title="二面｜20min"></a>二面｜20min</h2><p>1.重载和重写的区别（重复<br>2.静态方法能不能重写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重写的目的在于父类引用可以根据子类对象的运行时实际类型不同而调用不同实现代码，从而表现出多态。并且，静态方法无需创建对象即可使用，而重写的方法发挥作用，需要父类引用，和（不同的）子类对象</span><br></pre></td></tr></table></figure><p>3.只有返回值不同算不算重载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不算,编译都通过不了</span><br></pre></td></tr></table></figure><p>4.类的加载过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加载--验证--准备--解析--初始化--使用--卸载</span><br></pre></td></tr></table></figure><p>算法一，判断A是不是B的子树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    //分为两个函数，一个用于遍历节点当做子树的根节点，另一个用于判断是否是子树（必须要root2先空）</span><br><span class="line">    public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123;</span><br><span class="line">        if(root1==null||root2==null)</span><br><span class="line">            return false;</span><br><span class="line">        //此处用到一个技巧，直接判断isSubtree(root1,root2)，并且采取||的方式确定结果。</span><br><span class="line">        return isSubtree(root1,root2)||HasSubtree(root1.left,root2)||HasSubtree(root1.right,root2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean isSubtree(TreeNode root1,TreeNode root2)&#123;</span><br><span class="line">        if(root2==null)</span><br><span class="line">            return true;</span><br><span class="line">        if(root1==null)</span><br><span class="line">            return false;</span><br><span class="line">        if(root1.val==root2.val)</span><br><span class="line">            return isSubtree(root1.left,root2.left)&amp;&amp;</span><br><span class="line">            isSubtree(root1.right,root2.right);</span><br><span class="line">        else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三面｜50min"><a href="#三面｜50min" class="headerlink" title="三面｜50min"></a>三面｜50min</h2><p>1.问了前两面的表现具体说说<br>算法题一，给一个数n，和一个数组，用数组中的数组成最大的小于n的数，数组中的数可以重复使用（贪心）<br>算法题二，一个数组求max(a[i]-a[j])其中i小于j<br>数学题一：求log2的第10000位（答：会用二分求近似，不会做这个…换了抛硬币，应该是牛顿迭代没学过。。。<br>数学题二：AB轮流抛硬币，A先抛，抛到正面胜利，抛到反面对方接着抛，问A的胜率，等比数列求和，还好还记得等比数列求和公式。。。<br>2.数据库ACID<br>3.缺页中断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。</span><br></pre></td></tr></table></figure><p>4.页面置换算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">未来永远不会再使用的页面 or 未来最长时间不再被访问的页面</span><br></pre></td></tr></table></figure><p>5.http的无状态<br>6.为什么设计成无状态<br>7.你觉得什么样的代码算好的代码（瞎说挖了好多坑。。。<br>SOLLID<br>8.什么叫可拓展性好，举个例子<br>对扩展开放，对修改关闭<br>9.为啥要降低耦合度<br>10.你提到了设计模式，设计模式的七大原则是什么（7挖的坑…不会，设计模式只会单例模式<br>单一职责原则（Single Responsibility Principle）；—-通俗地说，即一个类只负责一项职责<br>开闭原则（Open Closed Principle）；—-开放-关闭原则表示软件实体 (类、模块、函数等等) 应该是可以被扩展的，但是不可被修改<br>里氏替换原则（Liskov Substitution Principle）；—-子类可以扩展父类的功能，但不能改变父类原有的功能<br>迪米特法则（Law of Demeter），又叫“最少知道法则”；—-最少知道原则，它表示一个对象应该对其它对象保持最少的了解。通俗来说就是，只与直接的朋友通信<br>接口隔离原则（Interface Segregation Principle）；—-客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。<br>依赖倒置原则（Dependence Inversion Principle）。—面向接口编程，理解了面向接口编程，也就理解了依赖倒转<br>组合/聚合复用原则 (Composite/Aggregate Reuse Principle)—-在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分; 新的对象通过向这些对象的委派达到复用已有功能的目的。<br>11.你的优势和缺陷<br>三面当天下午收到hr面邀请</p><p>hr面｜20min<br>聊了一些职业规划得问题略</p><p>作者：匿名用户<br>链接：<a href="https://leetcode.cn/circle/discuss/eBN2jJ/">https://leetcode.cn/circle/discuss/eBN2jJ/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面经" scheme="https://zkkget.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://zkkget.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题之817题链表组件</title>
    <link href="https://zkkget.github.io/posts/20221012a1.html"/>
    <id>https://zkkget.github.io/posts/20221012a1.html</id>
    <published>2022-10-12T06:12:47.000Z</published>
    <updated>2022-10-12T07:22:50.037Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><ol start="817"><li>链表组件 中等<br>给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。同时给定列表 nums，该列表是上述链表中整型值的一个子集。</li></ol><p>返回列表 nums 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 nums 中）构成的集合。<br>*</p><ul><li>输入: head = [0,1,2,3], nums = [0,1,3]<br>输出: 2<br>解释: 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 [0, 1] 是 nums 的一个组件，同理 [3] 也是一个组件，故返回 2。</li><li></li><li>输入: head = [0,1,2,3,4], nums = [0,3,1,4]<br>输出: 2<br>解释: 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static int numComponents(ListNode head, int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        int count =0;</span><br><span class="line">        while (p != null)&#123;</span><br><span class="line">            if(set.contains(p.val) &amp;&amp; (p.next == null  || !set.contains(p.next.val))) count++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ListNode head = new ListNode();</span><br><span class="line">        ListNode nextNode;</span><br><span class="line">        nextNode=head;</span><br><span class="line">        int[] nodes = &#123;0,1,2&#125;;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;nodes.length;i++)&#123;</span><br><span class="line">            ListNode node = new ListNode(nodes[i]);</span><br><span class="line">            nextNode.next=node;</span><br><span class="line">            nextNode=nextNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] nums = &#123;0,2&#125;;</span><br><span class="line">        int i = numComponents(head, nums);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/817-2.jpg" alt="817"></p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://zkkget.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://zkkget.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode856括号的分数</title>
    <link href="https://zkkget.github.io/posts/20221009a1.html"/>
    <id>https://zkkget.github.io/posts/20221009a1.html</id>
    <published>2022-10-09T03:19:44.000Z</published>
    <updated>2022-10-09T07:42:16.094Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>给定一个平衡括号字符串S，按下述规则计算该字符串的分数：<br>() 得 1 分。<br>AB 得A + B分，其中 A 和 B 是平衡括号字符串。<br>(A) 得2 * A分，其中 A 是平衡括号字符串。</p><p>示例 1：</p><p>输入： “()”<br>输出： 1<br>示例 2：</p><p>输入： “(())”<br>输出： 2<br>示例3：</p><p>输入： “()()”<br>输出： 2<br>示例4：</p><p>输入： “(()(()))”<br>输出： 6</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/score-of-parentheses">https://leetcode.cn/problems/score-of-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95%E6%8B%AC%E5%8F%B7.png" alt="暴力解法图解"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = S.length();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    n = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    n = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    sum += n;</span><br><span class="line">                &#125;</span><br><span class="line">                n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scoreOfParentheses2</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = S.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(-<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                    Integer pop = stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> (pop != -<span class="number">1</span>) &#123;</span><br><span class="line">                        temp += pop;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (temp == <span class="number">0</span>)</span><br><span class="line">                            stack.push(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            stack.push(temp * <span class="number">2</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            res += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">空间复杂度：O(n)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">scoreOfParentheses3</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; st = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        st.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                st.push(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> v = st.pop();</span><br><span class="line">                <span class="keyword">int</span> top = st.pop() + Math.max(<span class="number">2</span> * v, <span class="number">1</span>);</span><br><span class="line">                st.push(top);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;((((((())))()())))&quot;</span>;</span><br><span class="line">      <span class="comment">/*  System.out.println(scoreOfParentheses(s));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(scoreOfParentheses2(s));*/</span></span><br><span class="line"></span><br><span class="line">        System.out.println(scoreOfParentheses3(s));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%8E%8B%E6%A0%88%E6%8B%AC%E5%8F%B7.png" alt="压栈图解"></p><h2 id="大佬实现：耗时0ms"><a href="#大佬实现：耗时0ms" class="headerlink" title="大佬实现：耗时0ms"></a>大佬实现：耗时0ms</h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题目描述，我们需要对字符串s进行解析，并利用堆栈的特点帮助我们进行计算。以下图为例，s = “(()(()))”，遍历前两个字符都是‘(’，所以我们将‘(’执行入栈操作。遍历到的第三个字符是‘)’，我们要将栈顶元素弹出，发现可以匹配成一个括号，由于题目描述，一个“()”等于1，所以，我们将字符‘1’入栈。此时堆栈中的元素为[‘(‘, ‘1’]。具体操作如下图所示<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/1665287037-XCtbhA-image.png" alt="思路"><br>我们在继续遍历，由于第4和第5个字符都是‘(’，所以我们直接入栈即可。当遍历到第6个字符的时候，由于是‘)’，所以我们再次执行将栈顶元素踢出堆栈的操作，由于题目描述，一个“()”等于1，所以，我们将字符‘1’入栈。此时堆栈中的元素为[‘(‘, ‘1’,’(‘, ‘1’]。具体操作如下图所示：<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/1665287046-XplBvJ-image.png" alt="思路"><br>当遍历到第7个字符的时候，由于是‘)’，所以我们再次执行将栈顶元素踢出堆栈的操作，由于出栈的字符不是‘(’而是‘1’，所以我们继续踢出栈顶元素，此时出栈字符为‘(’，满足匹配题目中描述的(A) 得2 * A分的情况，所以计算出来的结果为 2*1 等于2，我们将字符‘2’入栈。此时堆栈中的元素为[‘(‘, ‘1’,’2’]<br>我们在继续向后遍历，由于第8个字符是‘)’，我们执行栈顶元素出栈操作，由于栈顶和次栈顶元素分别是‘2’和‘1’，都不是‘(’,所以继续执行栈顶出栈操作。然后这次出栈的元素是‘(’，可以匹配成一个括号，同时也满足了题目中描述的 AB 得A + B分 和 (A) 得2 * A分这两种情况。所以，计算结果为：2 * (1 + 2) 等于 6，在将6入栈。此时堆栈中的元素为[‘6’]。那么遍历s字符串完毕之后，我们将堆栈中所有元素值相加就是最终结果。具体操作，如下图所示：<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/1665287052-OhodXC-image.png" alt="思路"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/1665287060-StfKtU-image.png" alt="思路"></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> ArrayDeque();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) deque.addLast(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">char</span> c = deque.removeLast();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    deque.addLast(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((c = deque.removeLast()) != <span class="string">&#x27;(&#x27;</span>)  sum += c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    deque.addLast((<span class="keyword">char</span>) ((sum &lt;&lt; <span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) result += deque.removeLast() - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：muse-77<br>链接：<a href="https://leetcode.cn/problems/score-of-parentheses/solution/zhua-wa-mou-si-by-muse-77-hy72/">https://leetcode.cn/problems/score-of-parentheses/solution/zhua-wa-mou-si-by-muse-77-hy72/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://zkkget.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://zkkget.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode870题田忌赛马</title>
    <link href="https://zkkget.github.io/posts/20221008a1.html"/>
    <id>https://zkkget.github.io/posts/20221008a1.html</id>
    <published>2022-10-08T09:09:46.000Z</published>
    <updated>2022-10-09T09:14:15.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="LeetCode870题"><a href="#LeetCode870题" class="headerlink" title="LeetCode870题"></a>LeetCode870题</h2><p>给定两个大小相等的数组nums1和nums2，nums1相对于 nums2 的优势可以用满足nums1[i] &gt; nums2[i]的索引 i的数目来描述。</p><p>返回 nums1的任意排列，使其相对于 nums2的优势最大化</p><p>示例 1：</p><p>输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]<br>输出：[2,11,7,15]<br>示例 2：</p><p>输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]<br>输出：[24,32,8,12]</p><p>提示：</p><p>1 &lt;= nums1.length &lt;= 105<br>nums2.length == nums1.length<br>0 &lt;= nums1[i], nums2[i] &lt;= 109</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/advantage-shuffle">https://leetcode.cn/problems/advantage-shuffle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/leetcode870.png" alt="LeetCode870题"></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>有数组nums1和数组nums2,先将nums2的元素按着从大到小放入队列,且放入其下标位置<br>将nums1按着从小到大排列<br>依次取出队列中的元素<br>取出数组1的最后一个元素跟队列中的第一个元素比较，如果大于队列的第一个元素则将其放入结果数组的对应下标的位置如果小于队列第1个元素则数组1的最小元素放入其对应的下标</p><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(2).png" alt="思路"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">2</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2 =&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] ints = advantageCount(nums1, nums2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">            System.out.println(anInt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] advantageCount(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2[<span class="number">0</span>] - o1[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//将nums2的元素按从大到小插入到队列中,并记录其下标</span></span><br><span class="line">        <span class="comment">//11,3    10,1    4,2   1,0</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums2[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重排序nums1</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = pq.poll();</span><br><span class="line">            <span class="keyword">if</span> (nums1[hi] &gt; arr[<span class="number">0</span>]) &#123;</span><br><span class="line">                ans[arr[<span class="number">1</span>]] = nums1[hi--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[arr[<span class="number">1</span>]] = nums1[lo++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>拉出一匹马,用我自己的比当前马大的所有马中最小的马去比,比的过则放入结果集，比不过则拉一匹最小的马放入结果集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] advantageCount(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">    <span class="comment">// 给 nums2 降序排序</span></span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; maxpq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (<span class="keyword">int</span>[] pair1, <span class="keyword">int</span>[] pair2) -&gt; &#123; </span><br><span class="line">            <span class="keyword">return</span> pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        maxpq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, nums2[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 nums1 升序排序</span></span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums1[left] 是最小值，nums1[right] 是最大值</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!maxpq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pair = maxpq.poll();</span><br><span class="line">        <span class="comment">// maxval 是 nums2 中的最大值，index 是对应索引</span></span><br><span class="line">        <span class="keyword">int</span> index = pair[<span class="number">0</span>], maxval = pair[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (maxval &lt; nums1[right]) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums1[right] 能胜过 maxval，那就直接上</span></span><br><span class="line">            res[index] = nums1[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 战胜不过，就用最小值去送</span></span><br><span class="line">            res[index] = nums1[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="官网解法"><a href="#官网解法" class="headerlink" title="官网解法"></a>官网解法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] advantageCount(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int n = nums1.length;</span><br><span class="line">        Integer[] idx1 = new Integer[n];</span><br><span class="line">        Integer[] idx2 = new Integer[n];</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            idx1[i] = i;</span><br><span class="line">            idx2[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(idx1, (i, j) -&gt; nums1[i] - nums1[j]);</span><br><span class="line">        Arrays.sort(idx2, (i, j) -&gt; nums2[i] - nums2[j]);</span><br><span class="line"></span><br><span class="line">        int[] ans = new int[n];</span><br><span class="line">        int left = 0, right = n - 1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums1[idx1[i]] &gt; nums2[idx2[left]]) &#123;</span><br><span class="line">                ans[idx2[left]] = nums1[idx1[i]];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans[idx2[right]] = nums1[idx1[i]];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/advantage-shuffle/solution/you-shi-xi-pai-by-leetcode-solution-sqsf/">https://leetcode.cn/problems/advantage-shuffle/solution/you-shi-xi-pai-by-leetcode-solution-sqsf/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://zkkget.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://zkkget.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Nacos源码解析</title>
    <link href="https://zkkget.github.io/posts/20220916a1.html"/>
    <id>https://zkkget.github.io/posts/20220916a1.html</id>
    <published>2022-09-16T02:24:22.000Z</published>
    <updated>2023-02-13T07:22:56.272Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="官网：https-nacos-io-zh-cn-docs-architecture-html"><a href="#官网：https-nacos-io-zh-cn-docs-architecture-html" class="headerlink" title="官网：https://nacos.io/zh-cn/docs/architecture.html"></a>官网：<a href="https://nacos.io/zh-cn/docs/architecture.html">https://nacos.io/zh-cn/docs/architecture.html</a></h2><h2 id="官方架构原理文档：https-developer-aliyun-com-ebook-36-10664-spm-a2c6h-26392459-ebook-detail-4-31b934e2j9LrWh"><a href="#官方架构原理文档：https-developer-aliyun-com-ebook-36-10664-spm-a2c6h-26392459-ebook-detail-4-31b934e2j9LrWh" class="headerlink" title="官方架构原理文档：https://developer.aliyun.com/ebook/36/10664?spm=a2c6h.26392459.ebook-detail.4.31b934e2j9LrWh"></a>官方架构原理文档：<a href="https://developer.aliyun.com/ebook/36/10664?spm=a2c6h.26392459.ebook-detail.4.31b934e2j9LrWh">https://developer.aliyun.com/ebook/36/10664?spm=a2c6h.26392459.ebook-detail.4.31b934e2j9LrWh</a></h2><h2 id="官网架构"><a href="#官网架构" class="headerlink" title="官网架构"></a>官网架构</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/nacos%E6%9E%B6%E6%9E%84.jpg" alt="架构"></p><h2 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/nacos.webp" alt="流程"></p><h2 id="官方文档中并未着重介绍动态刷新的原理-结合-RefreshScope和ContextRefresher来引出HostReactor"><a href="#官方文档中并未着重介绍动态刷新的原理-结合-RefreshScope和ContextRefresher来引出HostReactor" class="headerlink" title="官方文档中并未着重介绍动态刷新的原理,结合@RefreshScope和ContextRefresher来引出HostReactor"></a>官方文档中并未着重介绍动态刷新的原理,结合@RefreshScope和ContextRefresher来引出HostReactor</h2><h2 id="为何要看源码"><a href="#为何要看源码" class="headerlink" title="为何要看源码"></a>为何要看源码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提升技术功底：学习源码里的优秀设计思想,比如一些疑难问题的解决思路,还有一些优秀的设计模式,整体提升自己的技术功底</span><br><span class="line">深度掌握技术框架：源码看多了,对于一个新技术或框架的掌握速度会有大幅提升,看下框架demo大致就能知道底层的实现,技术框架更新再快也不怕</span><br><span class="line">快速定位线上问题：遇到线上问题,特别是框架源码里的问题(比如bug),能够快速定位,这就是相比其他没看过源码的人的优势</span><br><span class="line">对面试大有裨益：面试一线互联网公司对于框架技术一般都会问到源码级别的实现</span><br><span class="line">知其然知其所以然：对技术有追求的人必做之事,使用了一个好的框架,很想知道底层是如何实现的</span><br><span class="line">拥抱开源社区：参与到开源项目的研发,结识更多大牛,积累更多优质人脉</span><br></pre></td></tr></table></figure><h2 id="一、入口分析"><a href="#一、入口分析" class="headerlink" title="一、入口分析"></a>一、入口分析</h2><p>服务注册与发现@EnableDiscoveryClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(EnableDiscoveryClientImportSelector.class)</span><span class="comment">//@Import注解用来帮助我们把一些需要定义为Bean的类导入到IOC容器里面</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDiscoveryClient &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If true, the ServiceRegistry will automatically register the local server.默认为true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">autoRegister</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用autoRegister()方法时默认返回true,在本接口中还引入了ImportSelector类即@Import(EnableDiscoveryClientImportSelector.class),其中selectImports调用如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">public String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">String[] imports <span class="operator">=</span> super.selectImports(metadata);</span><br><span class="line"></span><br><span class="line">AnnotationAttributes attributes <span class="operator">=</span> AnnotationAttributes.fromMap(</span><br><span class="line">metadata.getAnnotationAttributes(getAnnotationClass().getName(), <span class="literal">true</span>));</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>获取本类的autoRegister属性</span><br><span class="line"><span class="type">boolean</span> autoRegister <span class="operator">=</span> attributes.getBoolean(&quot;autoRegister&quot;);</span><br><span class="line"></span><br><span class="line">if (autoRegister) &#123;</span><br><span class="line">List<span class="operator">&lt;</span>String<span class="operator">&gt;</span> importsList <span class="operator">=</span> <span class="keyword">new</span> ArrayList<span class="operator">&lt;&gt;</span>(Arrays.asList(imports));</span><br><span class="line">importsList.add(&quot;org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationConfiguration&quot;);</span><br><span class="line">imports <span class="operator">=</span> importsList.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Environment env <span class="operator">=</span> getEnvironment();</span><br><span class="line">if(ConfigurableEnvironment.class.isInstance(env)) &#123;</span><br><span class="line">ConfigurableEnvironment configEnv <span class="operator">=</span> (ConfigurableEnvironment)env;</span><br><span class="line">LinkedHashMap<span class="operator">&lt;</span>String, Object<span class="operator">&gt;</span> map <span class="operator">=</span> <span class="keyword">new</span> LinkedHashMap<span class="operator">&lt;&gt;</span>();</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>注入yml文件属性</span><br><span class="line">map.put(&quot;spring.cloud.service-registry.auto-registration.enabled&quot;, <span class="literal">false</span>);</span><br><span class="line">MapPropertySource propertySource <span class="operator">=</span> <span class="keyword">new</span> MapPropertySource(</span><br><span class="line">&quot;springCloudDiscoveryClient&quot;, map);</span><br><span class="line">configEnv.getPropertySources().addLast(propertySource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> imports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、META-INF-spring-factories"><a href="#二、META-INF-spring-factories" class="headerlink" title="二、META-INF/spring.factories"></a>二、META-INF/spring.factories</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.NacosDiscoveryAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.endpoint.NacosDiscoveryEndpointAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.registry.NacosServiceRegistryAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.NacosDiscoveryClientConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.reactive.NacosReactiveDiscoveryClientConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.configclient.NacosConfigServerAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.loadbalancer.LoadBalancerNacosAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.NacosServiceAutoConfiguration</span><br><span class="line">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.configclient.NacosDiscoveryClientConfigServiceBootstrapConfiguration</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.logging.NacosLoggingListener</span><br></pre></td></tr></table></figure><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/nacosdiscovery.jpg" alt="流程"><br>NacosDiscoveryAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnDiscoveryEnabled</span></span><br><span class="line"><span class="meta">@ConditionalOnNacosDiscoveryEnabled</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosDiscoveryAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NacosDiscoveryProperties <span class="title">nacosProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NacosDiscoveryProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NacosServiceDiscovery <span class="title">nacosServiceDiscovery</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">NacosDiscoveryProperties discoveryProperties,</span></span></span><br><span class="line"><span class="params"><span class="function">NacosServiceManager nacosServiceManager)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NacosServiceDiscovery(discoveryProperties, nacosServiceManager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、服务自动注册"><a href="#三、服务自动注册" class="headerlink" title="三、服务自动注册"></a>三、服务自动注册</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/SpringCloudCommons.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/serviceregistry.jpg" alt="流程"><br>Spring Cloud 有 Euerka、ZK、Nacos 等多种注册中心的实现,想要达到实现统一必须有一套规范,而Spring Cloud Commons 就是定义了这一规范。<br>Spring Cloud Commons里面的org.springframework.cloud.client.serviceregistry包下面有 AutoServiceRegistration、Registration、ServiceRegistry这三个接口,这是服务注册的核心接口<br>其中Registration继承了ServiceInstance,在ServiceInstance中规范了一个服务实例属性<br>1、AutoServiceRegistration用于服务自动注册。自动注册的意思就是,服务启动后自动把服务信息注册到注册中心。它的存在就是要规范实现必须要有自动注册.</p><p>2、Registration存储服务信息,用于规范将什么信息注册到注册中心,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Registration</span> <span class="keyword">extends</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The unique instance ID as registered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//注册的唯一ID</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> String <span class="title">getInstanceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The service ID as registered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getServiceId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The hostname of the registered service instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getHost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The port of the registered service instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Whether the port of the registered service instance uses HTTPS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">是否使用<span class="function">HTTPS</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The service URI address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">URI <span class="title">getUri</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The key / value pair metadata associated with the service instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Map&lt;String, String&gt; <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The scheme of the service instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">注册服务的约束</span><br><span class="line"><span class="function"><span class="keyword">default</span> String <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、ServiceRegistry用来注册或者注销服务,下线服务以及心跳检测等都可在此循迹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span>&lt;<span class="title">R</span> <span class="keyword">extends</span> <span class="title">Registration</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers the registration. A registration typically has information about an</span></span><br><span class="line"><span class="comment"> * instance, such as its hostname and port.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registration registration meta data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(R registration)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Deregisters the registration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registration registration meta data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(R registration)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Closes the ServiceRegistry. This is a lifecycle method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the status of the registration. The status values are determined by the</span></span><br><span class="line"><span class="comment"> * individual implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registration The registration to update.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> status The status to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.cloud.client.serviceregistry.endpoint.ServiceRegistryEndpoint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(R registration, String status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the status of a particular registration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registration The registration to query.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; The type of the status.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The status of the registration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.cloud.client.serviceregistry.endpoint.ServiceRegistryEndpoint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getStatus</span><span class="params">(R registration)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、Nacos实现"><a href="#三、Nacos实现" class="headerlink" title="三、Nacos实现"></a>三、Nacos实现</h2><h2 id="NacosRegistration"><a href="#NacosRegistration" class="headerlink" title="NacosRegistration"></a>NacosRegistration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosRegistration</span> <span class="keyword">implements</span> <span class="title">Registration</span>, <span class="title">ServiceInstance</span> </span></span><br></pre></td></tr></table></figure><h2 id="NacosServiceRegistry"><a href="#NacosServiceRegistry" class="headerlink" title="NacosServiceRegistry"></a>NacosServiceRegistry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceRegistry</span> <span class="keyword">implements</span> <span class="title">ServiceRegistry</span>&lt;<span class="title">Registration</span>&gt; </span></span><br></pre></td></tr></table></figure><p>将配置文件封装为Instance实例,调用namingService.registerInstance(serviceId, instance)方法将服务注册到注册中心,在2.1.1当中则是通过NacosServiceManager来管理NameService的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Properties nacosProperties = nacosDiscoveryProperties.getNacosProperties();</span><br><span class="line">nacosServiceManager.getNamingMaintainService(nacosProperties).updateInstance(</span><br><span class="line">serviceId, nacosDiscoveryProperties.getGroup(), instance);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;update nacos instance status fail&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NacosAutoServiceRegistration"><a href="#NacosAutoServiceRegistration" class="headerlink" title="NacosAutoServiceRegistration"></a>NacosAutoServiceRegistration</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class NacosAutoServiceRegistration extends AbstractAutoServiceRegistration&lt;Registration&gt; </span><br><span class="line">  -&gt; public abstract class AbstractAutoServiceRegistration&lt;R extends Registration&gt;implements AutoServiceRegistration, ApplicationContextAware, ApplicationListener&lt;WebServerInitializedEvent&gt; &#123;</span><br></pre></td></tr></table></figure><p>通过间接实现ApplicationListener在服务启动时调用onApplicationEvent将服务注册到服务中心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; ApplicationListener&lt;PayloadApplicationEvent&lt;T&gt;&gt; forPayload(Consumer&lt;T&gt; consumer) &#123;</span><br><span class="line">        <span class="keyword">return</span> (event) -&gt; &#123;</span><br><span class="line">            consumer.accept(event.getPayload());</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(WebServerInitializedEvent event)</span> </span>&#123;</span><br><span class="line">bind(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(WebServerInitializedEvent event)</span> </span>&#123;</span><br><span class="line">ApplicationContext context = event.getApplicationContext();</span><br><span class="line"><span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableWebServerApplicationContext) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;management&quot;</span>.equals(((ConfigurableWebServerApplicationContext) context).getServerNamespace())) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.port.compareAndSet(<span class="number">0</span>, event.getWebServer().getPort());</span><br><span class="line"><span class="keyword">this</span>.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Discovery Lifecycle disabled. Not starting&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only initialize if nonSecurePort is greater than 0 and it isn&#x27;t already running</span></span><br><span class="line"><span class="comment">// because of containerPortInitializer below</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.running.get()) &#123;</span><br><span class="line"><span class="keyword">this</span>.context.publishEvent(<span class="keyword">new</span> InstancePreRegisteredEvent(<span class="keyword">this</span>, getRegistration()));</span><br><span class="line">register();</span><br><span class="line"><span class="keyword">if</span> (shouldRegisterManagement()) &#123;</span><br><span class="line">registerManagement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.context.publishEvent(<span class="keyword">new</span> InstanceRegisteredEvent&lt;&gt;(<span class="keyword">this</span>, getConfiguration()));</span><br><span class="line"><span class="keyword">this</span>.running.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>publishiEvent则是在AbstractApplicationContext中调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">监听器在消息源之后初始化,以便能够以在监听器实现中访问它。因此消息源实现不能发布事件。</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端如何向服务端注册"><a href="#客户端如何向服务端注册" class="headerlink" title="客户端如何向服务端注册"></a>客户端如何向服务端注册</h2><p>com.alibaba.cloud.nacos.registry.NacosServiceRegistry#register</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Registration registration)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;No service to register for nacos client...&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NamingService namingService = namingService();</span><br><span class="line">String serviceId = registration.getServiceId();</span><br><span class="line">String group = nacosDiscoveryProperties.getGroup();</span><br><span class="line"></span><br><span class="line">Instance instance = getNacosInstanceFromRegistration(registration);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">namingService.registerInstance(serviceId, group, instance);</span><br><span class="line">log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, group, serviceId,</span><br><span class="line">instance.getIp(), instance.getPort());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (nacosDiscoveryProperties.isFailFast()) &#123;</span><br><span class="line">log.error(<span class="string">&quot;nacos registry, &#123;&#125; register failed...&#123;&#125;,&quot;</span>, serviceId,</span><br><span class="line">registration.toString(), e);</span><br><span class="line">rethrowRuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">log.warn(<span class="string">&quot;Failfast is false. &#123;&#125; register failed...&#123;&#125;,&quot;</span>, serviceId,</span><br><span class="line">registration.toString(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">        String groupedServiceName = NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            BeatInfo beatInfo = beatReactor.buildBeatInfo(groupedServiceName, instance);</span><br><span class="line">            beatReactor.addBeatInfo(groupedServiceName, beatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        serverProxy.registerService(groupedServiceName, groupName, instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;[REGISTER-SERVICE] &#123;&#125; registering service &#123;&#125; with instance: &#123;&#125;&quot;</span>, namespaceId, serviceName,</span><br><span class="line">                instance);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">16</span>);</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, serviceName);</span><br><span class="line">        params.put(CommonParams.GROUP_NAME, groupName);</span><br><span class="line">        params.put(CommonParams.CLUSTER_NAME, instance.getClusterName());</span><br><span class="line">        params.put(<span class="string">&quot;ip&quot;</span>, instance.getIp());</span><br><span class="line">        params.put(<span class="string">&quot;port&quot;</span>, String.valueOf(instance.getPort()));</span><br><span class="line">        params.put(<span class="string">&quot;weight&quot;</span>, String.valueOf(instance.getWeight()));</span><br><span class="line">        params.put(<span class="string">&quot;enable&quot;</span>, String.valueOf(instance.isEnabled()));</span><br><span class="line">        params.put(<span class="string">&quot;healthy&quot;</span>, String.valueOf(instance.isHealthy()));</span><br><span class="line">        params.put(<span class="string">&quot;ephemeral&quot;</span>, String.valueOf(instance.isEphemeral()));</span><br><span class="line">        params.put(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.toJson(instance.getMetadata()));</span><br><span class="line">        </span><br><span class="line">        reqApi(UtilAndComs.nacosUrlInstance, params, HttpMethod.POST);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">reqApi</span><span class="params">(String api, Map&lt;String, String&gt; params, Map&lt;String, String&gt; body, List&lt;String&gt; servers,</span></span></span><br><span class="line"><span class="params"><span class="function">            String method)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, getNamespaceId());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(servers) &amp;&amp; StringUtils.isBlank(nacosDomain)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.INVALID_PARAM, <span class="string">&quot;no server available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NacosException exception = <span class="keyword">new</span> NacosException();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(nacosDomain)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxRetry; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> callServer(api, params, body, nacosDomain, method);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, nacosDomain, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">int</span> index = random.nextInt(servers.size());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; servers.size(); i++) &#123;</span><br><span class="line">                String server = servers.get(index);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> callServer(api, params, body, server, method);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, server, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                index = (index + <span class="number">1</span>) % servers.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.error(<span class="string">&quot;request: &#123;&#125; failed, servers: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>, api, servers, exception.getErrCode(),</span><br><span class="line">                exception.getErrMsg());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(exception.getErrCode(),</span><br><span class="line">                <span class="string">&quot;failed to req API:&quot;</span> + api + <span class="string">&quot; after all servers(&quot;</span> + servers + <span class="string">&quot;) tried: &quot;</span> + exception.getMessage());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HttpRestResult&lt;String&gt; restResult = nacosRestTemplate</span><br><span class="line">                    .exchangeForm(url, header, Query.newInstance().initParams(params), body, method, String.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@CanDistro</span><span class="comment">//在Distro协议中加以判断是否处理本服务。</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@Secured(action = ActionTypes.WRITE)</span> <span class="comment">//com.alibaba.nacos.auth.annotation.Secured权限控制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> String namespaceId = WebUtils</span><br><span class="line">                .optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">        <span class="keyword">final</span> String serviceName = WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">        NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Instance instance = HttpRequestInstanceBuilder.newBuilder()</span><br><span class="line">                .setDefaultInstanceEphemeral(switchDomain.isDefaultInstanceEphemeral()).setRequest(request).build();</span><br><span class="line">        </span><br><span class="line">        getInstanceOperator().registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">        NotifyCenter.publishEvent(<span class="keyword">new</span> RegisterInstanceTraceEvent(System.currentTimeMillis(), <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="keyword">false</span>, namespaceId, NamingUtils.getGroupName(serviceName), NamingUtils.getServiceName(serviceName),</span><br><span class="line">                instance.getIp(), instance.getPort()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> ephemeral = instance.isEphemeral();</span><br><span class="line">        String clientId = IpPortBasedClient.getClientId(instance.toInetAddr(), ephemeral);</span><br><span class="line">        createIpPortClientIfAbsent(clientId);</span><br><span class="line">        Service service = getService(namespaceId, serviceName, ephemeral);</span><br><span class="line">        clientOperationService.registerInstance(service, instance, clientId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在NacosServiceRegistry实例化的时候实例化nacosServiceManager,然后调用nacosServiceManager的getNamingService方法,构造实例化参数后<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/NacosServiceRegistry.jpg" alt="流程"></p><p>把服务放入serviceMap服务注册表中</p><p>初始化服务,创建一个健康检查的任务（主线–健康检查代码）</p><p>向一个队列中添加一个监听器（RecordListener类型）当监听到某些事件时会执行里面的onChange方法,Nacos大量运用了观察者设计模式,比如实例的注册、剔除等会被抽象成一个个的任务放到一个阻塞队列中,当监听到有任务时进来时,监听器会处理这些任务,执行onChange方法</p><p>com.alibaba.nacos.naming.consistency.RecordListener#onChange</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(String key, Service service)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Loggers.SRV_LOG.warn(<span class="string">&quot;received empty push from raft, key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(service.getNamespaceId())) &#123;</span><br><span class="line">                service.setNamespaceId(Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Loggers.RAFT.info(<span class="string">&quot;[RAFT-NOTIFIER] datum is changed, key: &#123;&#125;, value: &#123;&#125;&quot;</span>, key, service);</span><br><span class="line">            </span><br><span class="line">            Service oldDom = getService(service.getNamespaceId(), service.getName());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (oldDom != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldDom.update(service);</span><br><span class="line">                <span class="comment">// re-listen to handle the situation when the underlying listener is removed:</span></span><br><span class="line">                consistencyService</span><br><span class="line">                        .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">true</span>),</span><br><span class="line">                                oldDom);</span><br><span class="line">                consistencyService</span><br><span class="line">                        .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">false</span>),</span><br><span class="line">                                oldDom);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                putServiceAndInit(service);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Loggers.SRV_LOG.error(<span class="string">&quot;[NACOS-SERVICE] error while processing service update&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="addInstance"><a href="#addInstance" class="headerlink" title="addInstance"></a>addInstance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="keyword">boolean</span> ephemeral, Instance... ips)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">       </span><br><span class="line">       String key = KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line">       </span><br><span class="line">       Service service = getService(namespaceId, serviceName);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">           List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line">           </span><br><span class="line">           Instances instances = <span class="keyword">new</span> Instances();</span><br><span class="line">           instances.setInstanceList(instanceList);</span><br><span class="line">           </span><br><span class="line">           consistencyService.put(key, instances);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="consistencyService"><a href="#consistencyService" class="headerlink" title="consistencyService"></a>consistencyService</h2><h3 id="AP"><a href="#AP" class="headerlink" title="AP"></a>AP</h3><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/ConsistencyService.jpg" alt="流程"><br>clientOperationService.registerInstance(service, instance, clientId)中调用了ServiceManager</p><h3 id="CP"><a href="#CP" class="headerlink" title="CP"></a>CP</h3><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/PersistentConsistencyServiceDelegateImpl.png" alt="流程"></p><p>Service:主要关心实例的变动</p><p>ServiceManager:主要关心服务的变动</p><p>SwitchManager:主要关心AP模型、CP模型的切换</p><h2 id="重要切换AP-CP命令"><a href="#重要切换AP-CP命令" class="headerlink" title="重要切换AP,CP命令"></a>重要切换AP,CP命令</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">&#x27;$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Nacos-2-0源码分析-健康检查机制"><a href="#Nacos-2-0源码分析-健康检查机制" class="headerlink" title="Nacos 2.0源码分析-健康检查机制"></a>Nacos 2.0源码分析-健康检查机制</h2><p><font color="green">Nacos支持众多健康检查类型,心跳、HTTP、TCP、MySQL等类型</font><br>验证来自com.alibaba.nacos.api.naming.pojo.healthcheck.HealthCheckType</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * TCP type.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   TCP(Tcp.class),</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * HTTP type.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   HTTP(Http.class),</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * MySQL type.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   MYSQL(Mysql.class),</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * No check.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   NONE(AbstractHealthChecker.None.class);</span><br></pre></td></tr></table></figure><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.jpg" alt="流程"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      BeatInfo beatInfo;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">BeatTask</span><span class="params">(BeatInfo beatInfo)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.beatInfo = beatInfo;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (beatInfo.isStopped()) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">long</span> nextTime = beatInfo.getPeriod();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//发送心跳续约</span></span><br><span class="line">          <span class="comment">//lightBeatEnabled默认值为false</span></span><br><span class="line">              JsonNode result = serverProxy.sendBeat(beatInfo, BeatReactor.<span class="keyword">this</span>.lightBeatEnabled);</span><br><span class="line">              <span class="keyword">long</span> interval = result.get(CLIENT_BEAT_INTERVAL_FIELD).asLong();</span><br><span class="line">              <span class="keyword">boolean</span> lightBeatEnabled = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">if</span> (result.has(CommonParams.LIGHT_BEAT_ENABLED)) &#123;</span><br><span class="line">                  lightBeatEnabled = result.get(CommonParams.LIGHT_BEAT_ENABLED).asBoolean();</span><br><span class="line">              &#125;</span><br><span class="line">              BeatReactor.<span class="keyword">this</span>.lightBeatEnabled = lightBeatEnabled;</span><br><span class="line">              <span class="keyword">if</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  nextTime = interval;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">int</span> code = NamingResponseCode.OK;</span><br><span class="line">              <span class="keyword">if</span> (result.has(CommonParams.CODE)) &#123;</span><br><span class="line">                  code = result.get(CommonParams.CODE).asInt();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (code == NamingResponseCode.RESOURCE_NOT_FOUND) &#123;</span><br><span class="line">                  Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">                  instance.setPort(beatInfo.getPort());</span><br><span class="line">                  instance.setIp(beatInfo.getIp());</span><br><span class="line">                  instance.setWeight(beatInfo.getWeight());</span><br><span class="line">                  instance.setMetadata(beatInfo.getMetadata());</span><br><span class="line">                  instance.setClusterName(beatInfo.getCluster());</span><br><span class="line">                  instance.setServiceName(beatInfo.getServiceName());</span><br><span class="line">                  instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">                  instance.setEphemeral(<span class="keyword">true</span>);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      serverProxy.registerService(beatInfo.getServiceName(),</span><br><span class="line">                              NamingUtils.getGroupName(beatInfo.getServiceName()), instance);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (NacosException ex) &#123;</span><br><span class="line">              NAMING_LOGGER.error(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                      JacksonUtils.toJson(beatInfo), ex.getErrCode(), ex.getErrMsg());</span><br><span class="line">  </span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception unknownEx) &#123;</span><br><span class="line">              NAMING_LOGGER.error(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, unknown exception msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                      JacksonUtils.toJson(beatInfo), unknownEx.getMessage(), unknownEx);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              executorService.schedule(<span class="keyword">new</span> BeatTask(beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JsonNode <span class="title">sendBeat</span><span class="params">(BeatInfo beatInfo, <span class="keyword">boolean</span> lightBeatEnabled)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">          NAMING_LOGGER.debug(<span class="string">&quot;[BEAT] &#123;&#125; sending beat to server: &#123;&#125;&quot;</span>, namespaceId, beatInfo.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">      Map&lt;String, String&gt; bodyMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (!lightBeatEnabled) &#123;</span><br><span class="line">          bodyMap.put(<span class="string">&quot;beat&quot;</span>, JacksonUtils.toJson(beatInfo));</span><br><span class="line">      &#125;</span><br><span class="line">      params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">      params.put(CommonParams.SERVICE_NAME, beatInfo.getServiceName());</span><br><span class="line">      params.put(CommonParams.CLUSTER_NAME, beatInfo.getCluster());</span><br><span class="line">      params.put(IP_PARAM, beatInfo.getIp());</span><br><span class="line">      params.put(PORT_PARAM, String.valueOf(beatInfo.getPort()));</span><br><span class="line">      String result = reqApi(UtilAndComs.nacosUrlBase + <span class="string">&quot;/instance/beat&quot;</span>, params, bodyMap, HttpMethod.PUT);</span><br><span class="line">      <span class="keyword">return</span> JacksonUtils.toObj(result);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="服务端处理心跳续约"><a href="#服务端处理心跳续约" class="headerlink" title="服务端处理心跳续约"></a>服务端处理心跳续约</h2><p>com.alibaba.nacos.naming.controllers.InstanceController#beat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ObjectNode <span class="title">beat</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       </span><br><span class="line">       ObjectNode result = JacksonUtils.createEmptyJsonNode();</span><br><span class="line">       result.put(SwitchEntry.CLIENT_BEAT_INTERVAL, switchDomain.getClientBeatInterval());</span><br><span class="line">       </span><br><span class="line">       String beat = WebUtils.optional(request, <span class="string">&quot;beat&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">       RsInfo clientBeat = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isNotBlank(beat)) &#123;</span><br><span class="line">           clientBeat = JacksonUtils.toObj(beat, RsInfo.class);</span><br><span class="line">       &#125;</span><br><span class="line">       String clusterName = WebUtils</span><br><span class="line">               .optional(request, CommonParams.CLUSTER_NAME, UtilsAndCommons.DEFAULT_CLUSTER_NAME);</span><br><span class="line">       String ip = WebUtils.optional(request, <span class="string">&quot;ip&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">       <span class="keyword">int</span> port = Integer.parseInt(WebUtils.optional(request, <span class="string">&quot;port&quot;</span>, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">       <span class="keyword">if</span> (clientBeat != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isNotBlank(clientBeat.getCluster())) &#123;</span><br><span class="line">               clusterName = clientBeat.getCluster();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// fix #2533</span></span><br><span class="line">               clientBeat.setCluster(clusterName);</span><br><span class="line">           &#125;</span><br><span class="line">           ip = clientBeat.getIp();</span><br><span class="line">           port = clientBeat.getPort();</span><br><span class="line">       &#125;</span><br><span class="line">       String namespaceId = WebUtils.optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">       String serviceName = WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">       <span class="comment">//校验服务名格式</span></span><br><span class="line">       NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">       Loggers.SRV_LOG.debug(<span class="string">&quot;[CLIENT-BEAT] full arguments: beat: &#123;&#125;, serviceName: &#123;&#125;, namespaceId: &#123;&#125;&quot;</span>, clientBeat,</span><br><span class="line">               serviceName, namespaceId);</span><br><span class="line">       BeatInfoInstanceBuilder builder = BeatInfoInstanceBuilder.newBuilder();</span><br><span class="line">       builder.setRequest(request);</span><br><span class="line">       <span class="comment">//获取实例信息</span></span><br><span class="line">       <span class="keyword">int</span> resultCode = getInstanceOperator()</span><br><span class="line">               .handleBeat(namespaceId, serviceName, ip, port, clusterName, clientBeat, builder);</span><br><span class="line">       result.put(CommonParams.CODE, resultCode);</span><br><span class="line">       result.put(SwitchEntry.CLIENT_BEAT_INTERVAL,</span><br><span class="line">               getInstanceOperator().getHeartBeatInterval(namespaceId, serviceName, ip, port, clusterName));</span><br><span class="line">       result.put(SwitchEntry.LIGHT_BEAT_ENABLED, switchDomain.isLightBeatEnabled());</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在2.1.1当中getInstanceOperator().handleBeat(namespaceId, serviceName, ip, port, clusterName, clientBeat, builder);封装了对Service的处理包含开启续约,更新客户端心跳时间<br>分为客户端和服务端<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/handleBeat.png" alt="流程"><br>对于服务端我们看下service#handleBeat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">handleBeat</span><span class="params">(String namespaceId, String serviceName, String ip, <span class="keyword">int</span> port, String cluster,</span></span></span><br><span class="line"><span class="params"><span class="function">            RsInfo clientBeat, BeatInfoInstanceBuilder builder)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        com.alibaba.nacos.naming.core.Instance instance = serviceManager</span><br><span class="line">                .getInstance(namespaceId, serviceName, cluster, ip, port);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clientBeat == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> NamingResponseCode.RESOURCE_NOT_FOUND;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Loggers.SRV_LOG.warn(<span class="string">&quot;[CLIENT-BEAT] The instance has been removed for health mechanism, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;perform data compensation operations, beat: &#123;&#125;, serviceName: &#123;&#125;&quot;</span>, clientBeat, serviceName);</span><br><span class="line">            instance = parseInstance(builder.setBeatInfo(clientBeat).setServiceName(serviceName).build());</span><br><span class="line">            serviceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取服务实例</span></span><br><span class="line">        Service service = serviceManager.getService(namespaceId, serviceName);</span><br><span class="line">        <span class="comment">//检查服务是否为空</span></span><br><span class="line">        serviceManager.checkServiceIsNull(service, namespaceId, serviceName);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (clientBeat == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clientBeat = <span class="keyword">new</span> RsInfo();</span><br><span class="line">            clientBeat.setIp(ip);</span><br><span class="line">            clientBeat.setPort(port);</span><br><span class="line">            clientBeat.setCluster(cluster);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//服务续约</span></span><br><span class="line">        service.processClientBeat(clientBeat);</span><br><span class="line">        <span class="keyword">return</span> NamingResponseCode.OK;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedule client beat check task without a delay.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task health check task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> scheduled future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledFuture&lt;?&gt; scheduleNow(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">return</span> GlobalExecutor.scheduleNamingHealth(task, <span class="number">0</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    将心跳时间设置为当前时间</span><br></pre></td></tr></table></figure><h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>com.alibaba.nacos.naming.core.ServiceManager#putServiceAndInit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putServiceAndInit</span><span class="params">(Service service)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        putService(service);</span><br><span class="line">        service = getService(service.getNamespaceId(), service.getName());</span><br><span class="line">        service.init();</span><br><span class="line">        consistencyService</span><br><span class="line">                .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">true</span>), service);</span><br><span class="line">        consistencyService</span><br><span class="line">                .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">false</span>), service);</span><br><span class="line">        Loggers.SRV_LOG.info(<span class="string">&quot;[NEW-SERVICE] &#123;&#125;&quot;</span>, service.toJson());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Init service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HealthCheckReactor.scheduleCheck(clientBeatCheckTask);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Cluster&gt; entry : clusterMap.entrySet()) &#123;</span><br><span class="line">            entry.getValue().setService(<span class="keyword">this</span>);</span><br><span class="line">            entry.getValue().init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="健康检查任务"><a href="#健康检查任务" class="headerlink" title="健康检查任务"></a>健康检查任务</h2><h3 id="ClientBeatCheckTask"><a href="#ClientBeatCheckTask" class="headerlink" title="ClientBeatCheckTask"></a>ClientBeatCheckTask</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getInstanceHeartBeatTimeOut()) </span><br><span class="line">getInstanceHeartBeatTimeOut</span><br><span class="line">15秒</span><br><span class="line"></span><br><span class="line">public static final long DEFAULT_HEART_BEAT_TIMEOUT = TimeUnit.SECONDS.toMillis(15);</span><br><span class="line">    </span><br><span class="line">public static final long DEFAULT_IP_DELETE_TIMEOUT = TimeUnit.SECONDS.toMillis(30);</span><br><span class="line">    </span><br><span class="line">public static final long DEFAULT_HEART_BEAT_INTERVAL = TimeUnit.SECONDS.toMillis(5);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// If upgrade to 2.0.X stop health check with v1</span></span><br><span class="line">            <span class="keyword">if</span> (ApplicationUtils.getBean(UpgradeJudgement.class).isUseGrpcFeatures()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!getDistroMapper().responsible(service.getName())) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!getSwitchDomain().isHealthCheckEnabled()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            List&lt;Instance&gt; instances = service.allIPs(<span class="keyword">true</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// first set health status of instances:</span></span><br><span class="line">            <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getInstanceHeartBeatTimeOut()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!instance.isMarked()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (instance.isHealthy()) &#123;</span><br><span class="line">                            instance.setHealthy(<span class="keyword">false</span>);</span><br><span class="line">                            Loggers.EVT_LOG</span><br><span class="line">                                    .info(<span class="string">&quot;&#123;POS&#125; &#123;IP-DISABLED&#125; valid: &#123;&#125;:&#123;&#125;@&#123;&#125;@&#123;&#125;, region: &#123;&#125;, msg: client timeout after &#123;&#125;, last beat: &#123;&#125;&quot;</span>,</span><br><span class="line">                                            instance.getIp(), instance.getPort(), instance.getClusterName(),</span><br><span class="line">                                            service.getName(), UtilsAndCommons.LOCALHOST_SITE,</span><br><span class="line">                                            instance.getInstanceHeartBeatTimeOut(), instance.getLastBeat());</span><br><span class="line">                            getPushService().serviceChanged(service);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!getGlobalConfig().isExpireInstance()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// then remove obsolete instances:</span></span><br><span class="line">            <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (instance.isMarked()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当超过30秒无响应则删除</span></span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getIpDeleteTimeout()) &#123;</span><br><span class="line">                    <span class="comment">// delete instance</span></span><br><span class="line">                    Loggers.SRV_LOG.info(<span class="string">&quot;[AUTO-DELETE-IP] service: &#123;&#125;, ip: &#123;&#125;&quot;</span>, service.getName(),</span><br><span class="line">                            JacksonUtils.toJson(instance));</span><br><span class="line">                    deleteIp(instance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.SRV_LOG.warn(<span class="string">&quot;Exception while processing client beat time out.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：Zookeeper中在进行服务注册的时候,发起一个长连接,比如用Nio或者Netty,会一直占用管道,而Nacos只是发起一个http请求,发起请求后就结束了,Nacos在1.4.x版本中是典型的短链接（当然2.0后改用gRpc长连接）,而Zk采用长连接方式建立通道,如果在客户端服务器非常非常多,会比较耗性能的,Nacos相比会轻量不少哦,Zk为了保证服务变动的一致性,监听回调机制就会立刻通知到客户端,响应是很及时的,所以Zk保证了Cp,Nacos有两块保证了心跳,一块是客户端的定时拉取,一块是udp反向推送,即便udp丢失了,也有定时任务兜底。</p><h2 id="TcpHealthCheckProcessor"><a href="#TcpHealthCheckProcessor" class="headerlink" title="TcpHealthCheckProcessor"></a>TcpHealthCheckProcessor</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/HealthCheckProcess.png" alt="HealthCheckProcess"><br>com.alibaba.nacos.naming.healthcheck.v2.processor.TcpHealthCheckProcessor </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpSuperSenseProcessor</span> <span class="keyword">implements</span> <span class="title">HealthCheckProcessor</span>, <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE = <span class="string">&quot;TCP&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HealthCheckCommon healthCheckCommon;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SwitchDomain switchDomain;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了定义类型之外都会有的共同属性healthCheckCommon和switchDomain,其实现实在内部类的Beat.finishCheck方法中<br>判断是否健康</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHealthy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis() - startTime &lt; TimeUnit.SECONDS.toMillis(<span class="number">30L</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里checkok的方法也是调用Distro协议来判断当前ip在集群中的服务是否需要处理,当需要时返回true,此时就会将ip设置为健康,并将服务的最后一次修改时间设置为当前时间,服务监听器推送当前服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NotifyCenter.publishEvent(<span class="keyword">new</span> HealthStateChangeTraceEvent(System.currentTimeMillis(),</span><br><span class="line">                                service.getNamespaceId(), service.getGroupName(), service.getName(), ip.getIp(), ip.getPort(),</span><br><span class="line">                                <span class="keyword">true</span>, msg));</span><br></pre></td></tr></table></figure><h1 id="Nacos一致性协议"><a href="#Nacos一致性协议" class="headerlink" title="Nacos一致性协议"></a>Nacos一致性协议</h1><p><font color="red">分布式一致性协议有很多,例如Paxos协议,Zab协议,Raft协议,而Nacos采用的是Distro协议和Raft协议。对于非临时数据,Nacos采用的是Raft协议,而临时数据Nacos采用的是Distro协议。简单说一下Distro,Distro协议被定位为临时数据的一致性协议：该类型协议不需要把数据存储到磁盘或者数据库,因为临时数据通常和服务器保持一个session会话,该会话只要存在,数据就不会丢失</font></p><h2 id="Distro协议"><a href="#Distro协议" class="headerlink" title="Distro协议"></a>Distro协议</h2><p>Distro 协议是 Nacos 对于临时实例数据开发的一致性协议。其数据存储在缓存中,并且会在启动时进行全量数据同步,并定期进行数据校验。</p><p>在 Distro 协议的设计思想下,每个 Distro 节点都可以接收到读写请求。所有的 Distro 协议的请求场景主要分为三种情况：</p><p>1、当该节点接收到属于该节点负责的实例的写请求时,直接写入。</p><p>2、当该节点接收到不属于该节点负责的实例的写请求时,将在集群内部路由,转发给对应的节点,从而完成读写。</p><p>3、当该节点接收到任何读请求时,都直接在本机查询并返回（因为所有实例都被同步到了每台机器上）。</p><p>Distro 协议作为 Nacos 的内嵌临时实例一致性协议,保证了在分布式环境下每个节点上面的服务信息的状态都能够及时地通知其他节点,可以维持数十万量级服务实例的存储和一致性。</p><p>Nacos中有CP和AP两种模式,而这两种模式在实现数据一致性方案上面是完全不一样的,对于CP模式而言,使用的是raft这种强一致性协议,对于AP模式而言,则是使用阿里自创的Distro协议<br>在上文中对服务的注册中,调用instanceController当中的register方法时实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanDistro</span><span class="comment">//在Distro协议中加以判断是否处理本服务。</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@Secured(action = ActionTypes.WRITE)</span><span class="comment">//com.alibaba.nacos.auth.annotation.Secured权限控制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> String namespaceId = WebUtils</span><br><span class="line">            .optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">    <span class="keyword">final</span> String serviceName = WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">    <span class="comment">//服务名中不能带有@@,服务名不能为空</span></span><br><span class="line">    NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Instance instance = HttpRequestInstanceBuilder.newBuilder()</span><br><span class="line">            .setDefaultInstanceEphemeral(switchDomain.isDefaultInstanceEphemeral()).setRequest(request).build();</span><br><span class="line">    </span><br><span class="line">    getInstanceOperator().registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">    NotifyCenter.publishEvent(<span class="keyword">new</span> RegisterInstanceTraceEvent(System.currentTimeMillis(), <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="keyword">false</span>, namespaceId, NamingUtils.getGroupName(serviceName), NamingUtils.getServiceName(serviceName),</span><br><span class="line">            instance.getIp(), instance.getPort()));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> ephemeral = instance.isEphemeral();</span><br><span class="line">    String clientId = IpPortBasedClient.getClientId(instance.toInetAddr(), ephemeral);</span><br><span class="line">    createIpPortClientIfAbsent(clientId);</span><br><span class="line">    Service service = getService(namespaceId, serviceName, ephemeral);</span><br><span class="line">    clientOperationService.registerInstance(service, instance, clientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中CanDistro则是跟Distro协议有关<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/DistroFilter.jpg" alt="DistroFilter"><br>来自nacos2.1.1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">       ReuseHttpServletRequest req = <span class="keyword">new</span> ReuseHttpServletRequest((HttpServletRequest) servletRequest);</span><br><span class="line">       HttpServletResponse resp = (HttpServletResponse) servletResponse;</span><br><span class="line">       </span><br><span class="line">       String urlString = req.getRequestURI();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isNotBlank(req.getQueryString())) &#123;</span><br><span class="line">           urlString += <span class="string">&quot;?&quot;</span> + req.getQueryString();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//获取方法</span></span><br><span class="line">           Method method = controllerMethodsCache.getMethod(req);</span><br><span class="line">           </span><br><span class="line">           String path = <span class="keyword">new</span> URI(req.getRequestURI()).getPath();</span><br><span class="line">           <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(req.getMethod() + <span class="string">&quot; &quot;</span> + path);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//是否有CanDistro注解</span></span><br><span class="line">           <span class="keyword">if</span> (!method.isAnnotationPresent(CanDistro.class)) &#123;</span><br><span class="line">               filterChain.doFilter(req, resp);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           String distroTag = distroTagGenerator.getResponsibleTag(req);</span><br><span class="line">           <span class="comment">//判断是否处理这个请求,需要处理则直接放行</span></span><br><span class="line">           <span class="keyword">if</span> (distroMapper.responsible(distroTag)) &#123;</span><br><span class="line">               filterChain.doFilter(req, resp);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// proxy request to other server if necessary:</span></span><br><span class="line">           String userAgent = req.getHeader(HttpHeaderConsts.USER_AGENT_HEADER);</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isNotBlank(userAgent) &amp;&amp; userAgent.contains(UtilsAndCommons.NACOS_SERVER_HEADER)) &#123;</span><br><span class="line">               <span class="comment">// This request is sent from peer server, should not be redirected again:</span></span><br><span class="line">               Loggers.SRV_LOG.error(<span class="string">&quot;receive invalid redirect request from peer &#123;&#125;&quot;</span>, req.getRemoteAddr());</span><br><span class="line">               resp.sendError(HttpServletResponse.SC_BAD_REQUEST,</span><br><span class="line">                       <span class="string">&quot;receive invalid redirect request from peer &quot;</span> + req.getRemoteAddr());</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">final</span> String targetServer = distroMapper.mapSrv(distroTag);</span><br><span class="line">           </span><br><span class="line">           List&lt;String&gt; headerList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">           Enumeration&lt;String&gt; headers = req.getHeaderNames();</span><br><span class="line">           <span class="keyword">while</span> (headers.hasMoreElements()) &#123;</span><br><span class="line">               String headerName = headers.nextElement();</span><br><span class="line">               headerList.add(headerName);</span><br><span class="line">               headerList.add(req.getHeader(headerName));</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">final</span> String body = IoUtils.toString(req.getInputStream(), StandardCharsets.UTF_8.name());</span><br><span class="line">           <span class="keyword">final</span> Map&lt;String, String&gt; paramsValue = HttpClient.translateParameterMap(req.getParameterMap());</span><br><span class="line">           </span><br><span class="line">           RestResult&lt;String&gt; result = HttpClient</span><br><span class="line">                   .request(HTTP_PREFIX + targetServer + req.getRequestURI(), headerList, paramsValue, body,</span><br><span class="line">                           PROXY_CONNECT_TIMEOUT, PROXY_READ_TIMEOUT, StandardCharsets.UTF_8.name(), req.getMethod());</span><br><span class="line">           String data = result.ok() ? result.getData() : result.getMessage();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               WebUtils.response(resp, data, result.getCode());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">               Loggers.SRV_LOG.warn(<span class="string">&quot;[DISTRO-FILTER] request failed: &quot;</span> + distroMapper.mapSrv(distroTag) + urlString);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (AccessControlException e) &#123;</span><br><span class="line">           resp.sendError(HttpServletResponse.SC_FORBIDDEN, <span class="string">&quot;access denied: &quot;</span> + ExceptionUtil.getAllExceptionMsg(e));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">           resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED,</span><br><span class="line">                   <span class="string">&quot;no such api:&quot;</span> + req.getMethod() + <span class="string">&quot;:&quot;</span> + req.getRequestURI());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Loggers.SRV_LOG.warn(<span class="string">&quot;[DISTRO-FILTER] Server failed: &quot;</span>, e);</span><br><span class="line">           resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,</span><br><span class="line">                   <span class="string">&quot;Server failed, &quot;</span> + ExceptionUtil.getAllExceptionMsg(e));</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DistroFilter这个类是实现了Filter接口,所以表明了它是一个过滤器,在请求来的时候,会经过doFilter方法,在doFilter方法中大概有下面4个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>根据请求路径从controllerMethodsCache中获取到对应的controller方法</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>判断这个controller方法是否有<span class="meta">@CanDistro</span>注解,如果有的话再调用distroMapper.responsible()方法去判断当前nacos节点是否需要处理这个请求</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>如果controller方法没有<span class="meta">@CanDistro</span>注解,或者有<span class="meta">@CanDistro</span>注解并且当前nacos节点需要处理这个请求,那么就直接放行这个请求到controller端</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>反之如果controller方法有<span class="meta">@CanDistro</span>注解并且当前nacos节点不需要处理这个请求,那么就会把这个请求转发到对应的其他节点去处理</span><br></pre></td></tr></table></figure><p>其中第一点中从controllerMethodsCache中获取对应的controller方法,那么是怎么获取的呢？所以我们要看下ControllerMethodsCache中的getMethod方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static final Logger LOGGER = LoggerFactory.getLogger(ControllerMethodsCache.<span class="keyword">class</span>);</span><br><span class="line">    </span><br><span class="line">    private ConcurrentMap&lt;RequestMappingInfo, Method&gt; methods = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    private final ConcurrentMap&lt;String, <span class="type">List</span>&lt;RequestMappingInfo&gt;&gt; urlLookup = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public Method getMethod(HttpServletRequest request) &#123;</span><br><span class="line">        String path = getPath(request);</span><br><span class="line">        String httpMethod = request.getMethod();</span><br><span class="line">        String urlKey = httpMethod + REQUEST_PATH_SEPARATOR + path.replaceFirst(EnvUtil.getContextPath(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">List</span>&lt;RequestMappingInfo&gt; requestMappingInfos = urlLookup.get(urlKey);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(requestMappingInfos)) &#123;</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">List</span>&lt;RequestMappingInfo&gt; matchedInfo = findMatchedInfo(requestMappingInfos, request);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(matchedInfo)) &#123;</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        RequestMappingInfo bestMatch = matchedInfo.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (matchedInfo.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            RequestMappingInfoComparator comparator = new RequestMappingInfoComparator();</span><br><span class="line">            matchedInfo.sort(comparator);</span><br><span class="line">            bestMatch = matchedInfo.get(<span class="number">0</span>);</span><br><span class="line">            RequestMappingInfo secondBestMatch = matchedInfo.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">                throw new IllegalStateException(</span><br><span class="line">                        <span class="string">&quot;Ambiguous methods mapped for &#x27;&quot;</span> + request.getRequestURI() + <span class="string">&quot;&#x27;: &#123;&quot;</span> + bestMatch + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + secondBestMatch + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methods.get(bestMatch);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用链如下<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/ConsoleConfig.jpg" alt="ConsoleConfig"><br>可以看到源头是在一个叫ConsoleConfig的类的init方法开始的,并且这个init方法加了@PostConstruct注解,表示在spring容器启动的时候就能够被调用该方法,在init方法中,调用了4次ControllerMethodsCache的initClassMethod方法,分别传了不同的包名,在initClassMethod方法中会根据传入的包名然后找到加了@RequestMapping注解的类,然后寻找每一个类中加了@RequestMapping注解的方法,然后构造出一个RequestMappingInfo对象,其中给这个RequestMappingInfo对象设置两个校验,一个是请求路径的校验,一个是请求参数的校验,然后把urlKey和RequestMappingInfo对象放到urlLookup这个map中,再把RequestMappingInfo对象和controller方法放到methods这个map中。所以经过上面的分析,我们可以做一个小总结,在spring容器启动的时候,nacos就会在指定的几个包名下找到所有加了@RequestMapping注解的controller类,然后再找到这些类下面加了@RequestMapping注解的方法,再构造出一个RequestMappingInfo校验对象用来对请求路径和请求参数进行校验匹配,而请求路径的检验是根据@RequestMapping注解指定的请求方式以及请求路径去构造出一个urlKey作为校验匹配的条件,请求参数校验则是根据@RequestMapping注解中的params属性作为检验匹配的条件,最终就会把这个RequestMappingInfo校验对象和对应的controller方法放到methods这个map中了。所以当有请求过来的时候,DistroFilter会进行拦截,首先会根据请求路径构造出urlKey,再根据urlKey找到对应的RequestMappingInfo检验对象,然后使用这个RequestMappingInfo校验对象对这个请求参数进行校验,如果校验不通过则返回null,校验通过则再根据这个RequestMappingInfo对象找到对应的controller方法</p><h2 id="Distro弱一致性协议实现原理"><a href="#Distro弱一致性协议实现原理" class="headerlink" title="Distro弱一致性协议实现原理"></a>Distro弱一致性协议实现原理</h2><p>String distroTag = distroTagGenerator.getResponsibleTag(req);<br>通过上面我们知道在DistroFilter中会根据请求找到对应的controller方法,然后会去判断这个controller方法上是否有@CanDistro注解,如果有的话会再判断当前的nacos节点是否需要对这个请求进行处理,而这个判断就是通过distroMapper.responsible()这个方法去判断的,那么这个方法具体是干什么的呢？其实这个方法就是实现distro弱一致性协议的核心,我们看下这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">responsible</span><span class="params">(String responsibleTag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; servers = healthyList;</span><br><span class="line">        <span class="comment">// 条件成立：没有开启distro协议,或者是nacos服务是单机模式</span></span><br><span class="line">        <span class="keyword">if</span> (!switchDomain.isDistroEnabled() || EnvUtil.getStandaloneMode()) &#123;</span><br><span class="line">        <span class="comment">// 返回true表示需要响应处理这个service</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(servers)) &#123;</span><br><span class="line">            <span class="comment">// means distro config is not ready yet</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取到当前nacos服务在集群中的位置索引</span></span><br><span class="line">    <span class="comment">// index和lastIndex通常都会相等</span></span><br><span class="line">        String localAddress = EnvUtil.getLocalAddress();</span><br><span class="line">        <span class="keyword">int</span> index = servers.indexOf(localAddress);</span><br><span class="line">        <span class="keyword">int</span> lastIndex = servers.lastIndexOf(localAddress);</span><br><span class="line">        <span class="keyword">if</span> (lastIndex &lt; <span class="number">0</span> || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> target = distroHash(responsibleTag) % servers.size();</span><br><span class="line">        <span class="keyword">return</span> target &gt;= index &amp;&amp; target &lt;= lastIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先这个方法的作用是判断当前nacos节点是否需要负责处理指定的服务,如果不负责处理就返回true,反之就返回false。在开始的时候会去判断当前是否开启了distro协议,如果没有开启就返回true,以及会去判断这个nacos节点是否是单机模式,如果是单机模式就返回true,也就是说在单机模式下,distro协议是不起作用的,很好理解,因为distro协议就是解决了集群之间数据同步一致性的一种方案,而单机模式也没有所谓的数据同步,自然distro协议是不需要的。然后就是会去获取到当前nacos节点在整个nacos集群中的索引位置,并且对指定的服务名通过distroHash方法获取到一个值,把这个值与整个nacos集群节点数进行取模得到一个target值,如果这个target值是等于当前nacos节点所在集群的索引位置值,那么就返回true,反之就返回false。所以对于每一个服务,它都会通过上面这种方式分配到具体的nacos节点,也就是说每一个nacos节点都会负责一部分的服务,那么这这难道nacos集群是分布式集群吗 ？很显然不是的,虽然说每一个nacos节点只会负责一部分的服务请求,但是nacos之间会进行数据的同步,也就是nacos集群的每一个节点数据是最终一致性的,所以这也就是什么说distro协议是一个弱一致性的协议了。而如果这个服务请求根据distro协议的规则判断之后发现不归当前这个nacos节点负责处理怎么办呢？这时候就需要对这个服务请求进行转发了,此时会通过distro协议的规则重新计算找出负责处理这个服务请求的nacos节点,然后当前nacos节点就把这个请求重转发到指定的nacos节点,这样整个distro协议的实现流程就完成了</p><h1 id="Nacos集群选举"><a href="#Nacos集群选举" class="headerlink" title="Nacos集群选举"></a>Nacos集群选举</h1><p>Raft协议演示地址：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><h2 id="Raft一致性协议"><a href="#Raft一致性协议" class="headerlink" title="Raft一致性协议"></a>Raft一致性协议</h2><p>Nacos支持集群模式,很显然。 而一旦涉及到集群,就涉及到主从,那么nacos是一种什么样的机制来实现的集群呢？</p><p>nacos的集群类似于zookeeper,它分为leader角色和follower角色,那么从这个角色的名字可以看出来,这个集群存在选举的机制。 因为如果自己不具备选举功能,角色的命名可能就是master/slave了,当然这只是我基于这么多组件的命名的一个猜测。</p><p>Raft协议是一种强一致性、去中心化、高可用的分布式协议,它是用来解决分布式一致性问题的,相对于大名鼎鼎的Paxos协议,Raft协议更容易理解,并且在性能、可靠性、可用性方面是不输于Paxos协议的。许多中间件都是利用Raft协议来保证分布式一致性的,例如Redis的sentinel,CP模式的Nacos的leader选举都是通过Raft协议来实现的。因为Nacos的一致性协议是采用的Raft协议。</p><p>在Raft中,节点有三种角色：</p><p>Leader：负责接收客户端的请求<br>Candidate：用于选举Leader的一种角色<br>Follower：负责响应来自Leader或者Candidate的请求<br>选举分为两个时间点:</p><p>服务启动的时候<br>leader挂了的时候<br>所有节点启动的时候,都是follower状态。 如果在一段时间内如果没有收到leader的心跳（可能是没有 leader,也可能是leader挂了）,那么follower会变成Candidate。然后发起选举,选举之前,会增加 term,这个term和zookeeper中的epoch的道理是一样的。</p><p>follower会投自己一票,并且给其他节点发送票据vote,等到其他节点回复</p><p>在这个过程中,可能出现几种情况</p><p>收到过半的票数通过,则成为leader<br>被告知其他节点已经成为leader,则自己切换为follower<br>一段时间内没有收到过半的投票,则重新发起选举<br>选举的几种情况:</p><p>第一种情况,赢得选举之后,leader会给所有节点发送消息,避免其他节点触发新的选举<br>第二种情况,比如有三个节点A B C。A B同时发起选举,而A的选举消息先到达C,C给A投了一 票,当B的消息到达C时,已经不能满足上面提到的第一个约束,即C不会给B投票,而A和B显然都不会给对方投票。A胜出之后,会给B,C发心跳消息,节点B发现节点A的term不低于自己的term,知道有已经有Leader了,于是转换成follower。<br>第三种情况,没有任何节点获得majority(超过半数的)投票,可能是平票的情况。加入总共有四个节点 （A/B/C/D）,Node C、Node D同时成为了candidate,但Node A投了NodeD一票,NodeB投 了Node C一票,这就出现了平票 split vote的情况。这个时候大家都在等啊等,直到超时后重新发 起选举。如果出现平票的情况,那么就延长了系统不可用的时间,因此raft引入了randomized election timeouts来尽量避免平票情况.</p><h2 id="RaftCore初始化"><a href="#RaftCore初始化" class="headerlink" title="RaftCore初始化"></a>RaftCore初始化</h2><p>这里有几个核心概念或组件：</p><p>1.peer：代表每台nocas机器,记录着一台server的投票相关的元数据信息,比如本机的ip,投票给谁（votefor）,AtomicLong类型的term,记录本地服务第几次发起的投票,状体（leader/follower）,leader选举间隔时间等。</p><p>2.peers:是个RaftPeerSet类型,实际上记录了整个集群所有peer的信息。</p><p>3.notifier：一个线程,用作事件通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DependsOn(&quot;ProtocolManager&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RaftCore</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建一个单线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor = ExecutorFactory.Managed</span><br><span class="line">            .newSingleScheduledExecutorService(ClassUtils.getCanonicalName(NamingApp.class),</span><br><span class="line">                    <span class="keyword">new</span> NameThreadFactory(<span class="string">&quot;com.alibaba.nacos.naming.raft.notifier&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Loggers.RAFT.info(<span class="string">&quot;initializing Raft sub-system&quot;</span>);</span><br><span class="line"><span class="comment">//开启一个notifier监听,这个线程中会遍历listeners,根据ApplyAction执行相应的逻辑</span></span><br><span class="line">        </span><br><span class="line">        executor.submit(notifier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//启动的时候先加载本地日志</span></span><br><span class="line">        <span class="comment">//遍历/nacos/data/naming/data/文件件,也就是从磁盘中加载Datum到内存,用来做数据恢复。(数据同步采用2pc协议,leader收到请求会写写入到磁盘日志,然后再进行数据同步)</span></span><br><span class="line">        <span class="comment">//Datum：kv对</span></span><br><span class="line">        <span class="comment">//datums：ConcurrentMap&lt;String, Datum&gt;内存数据存储</span></span><br><span class="line">        raftStore.loadDatums(notifier, datums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置term值,从/nacos/data/naming/meta.properties本地磁盘中读取term的值,如果为null,默认为0</span></span><br><span class="line">        setTerm(NumberUtils.toLong(raftStore.loadMeta().getProperty(<span class="string">&quot;term&quot;</span>), <span class="number">0L</span>));</span><br><span class="line"></span><br><span class="line">        Loggers.RAFT.info(<span class="string">&quot;cache loaded, datum count: &#123;&#125;, current term: &#123;&#125;&quot;</span>, datums.size(), peers.getTerm());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (notifier.tasks.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Loggers.RAFT.info(<span class="string">&quot;finish to load data from disk, cost: &#123;&#125; ms.&quot;</span>, (System.currentTimeMillis() - start));</span><br><span class="line"><span class="comment">//开启定时任务,每500ms执行一次,用来判断是否需要发起leader选举</span></span><br><span class="line">        GlobalExecutor.registerMasterElection(<span class="keyword">new</span> MasterElection());</span><br><span class="line">        <span class="comment">//每500ms发起一次心跳</span></span><br><span class="line">        GlobalExecutor.registerHeartbeat(<span class="keyword">new</span> HeartBeat());</span><br><span class="line"></span><br><span class="line">        Loggers.RAFT.info(<span class="string">&quot;timer started: leader timeout ms: &#123;&#125;, heart-beat timeout ms: &#123;&#125;&quot;</span>,</span><br><span class="line">                          GlobalExecutor.LEADER_TIMEOUT_MS, GlobalExecutor.HEARTBEAT_INTERVAL_MS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="RaftCore-MasterElection"><a href="#RaftCore-MasterElection" class="headerlink" title="RaftCore.MasterElection"></a>RaftCore.MasterElection</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterElection</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果还没有初始化完成</span></span><br><span class="line">            <span class="keyword">if</span> (!peers.isReady()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//获取当前机器上跑的这个peer节点信息</span></span><br><span class="line">            RaftPeer local = peers.local();</span><br><span class="line">            <span class="comment">//leader选举触发间隔时间,第一次进来,会生成（0~15000毫秒）之间的一个随机数-500.</span></span><br><span class="line"><span class="comment">//后面由于500ms调度一次,所以每次该线程被调起,会将该leaderDueMs减去TICK_PERIOD_MS(500ms),直到小于0的时候会触发选举</span></span><br><span class="line"><span class="comment">//后面每次收到一次leader的心跳就会重置leaderDueMs = 15s+（随机0-5s）</span></span><br><span class="line">            local.leaderDueMs -= GlobalExecutor.TICK_PERIOD_MS;</span><br><span class="line"><span class="comment">//当间隔时间&gt;0,直接返回,等到下一次500ms后再调用</span></span><br><span class="line">            <span class="keyword">if</span> (local.leaderDueMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reset timeout</span></span><br><span class="line">            <span class="comment">//重置选举间隔时间</span></span><br><span class="line">            local.resetLeaderDue();</span><br><span class="line">            <span class="comment">//重置心跳间隔时间</span></span><br><span class="line">            local.resetHeartbeatDue();</span><br><span class="line"><span class="comment">//将本地选举投票通过http发送其他几台服务器</span></span><br><span class="line">            sendVote();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.RAFT.warn(<span class="string">&quot;[RAFT] error while master election &#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendVote</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取本机的节点信息</span></span><br><span class="line">        RaftPeer local = peers.get(NetUtils.localServer());</span><br><span class="line">        Loggers.RAFT.info(<span class="string">&quot;leader timeout, start voting,leader: &#123;&#125;, term: &#123;&#125;&quot;</span>, JacksonUtils.toJson(getLeader()),</span><br><span class="line">                          local.term);</span><br><span class="line"><span class="comment">//重置peers,各个peer的voteFor与leader设为null</span></span><br><span class="line">        peers.reset();</span><br><span class="line"><span class="comment">//每一次投票,都累加一次term,表示当前投票的轮数,选举计数器,记录本地发起的是第几轮选举</span></span><br><span class="line">        local.term.incrementAndGet();</span><br><span class="line">        <span class="comment">//投票选自己,此时peers中有一个votefor就是自己</span></span><br><span class="line">        local.voteFor = local.ip;</span><br><span class="line">        <span class="comment">//本地server状态设置为CANDIDATE竞选状态</span></span><br><span class="line">        local.state = RaftPeer.State.CANDIDATE;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        params.put(<span class="string">&quot;vote&quot;</span>, JacksonUtils.toJson(local));<span class="comment">//设置本机请求参数</span></span><br><span class="line">        <span class="comment">//遍历除了本机ip之外的其他节点,把自己的票据发送给所有节点,将选自己的投票发送给其他servers,获取其他机器的选票信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> String server : peers.allServersWithoutMySelf()) &#123;</span><br><span class="line">            <span class="comment">//API_VOTE:  /raft/vote</span></span><br><span class="line">            <span class="keyword">final</span> String url = buildUrl(server, API_VOTE);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//发起投票</span></span><br><span class="line">                HttpClient.asyncHttpPost(url, <span class="keyword">null</span>, params, <span class="keyword">new</span> AsyncCompletionHandler&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">onCompleted</span><span class="params">(Response response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (response.getStatusCode() != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                            Loggers.RAFT</span><br><span class="line">                                .error(<span class="string">&quot;NACOS-RAFT vote failed: &#123;&#125;, url: &#123;&#125;&quot;</span>, response.getResponseBody(), url);</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"><span class="comment">//获取其他server的响应</span></span><br><span class="line">                        RaftPeer peer = JacksonUtils.toObj(response.getResponseBody(), RaftPeer.class);</span><br><span class="line"></span><br><span class="line">                        Loggers.RAFT.info(<span class="string">&quot;received approve from peer: &#123;&#125;&quot;</span>, JacksonUtils.toJson(peer));</span><br><span class="line"><span class="comment">//计算leader</span></span><br><span class="line">                        peers.decideLeader(peer);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Loggers.RAFT.warn(<span class="string">&quot;error while sending vote to server: &#123;&#125;&quot;</span>, server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="RaftController-vote"><a href="#RaftController-vote" class="headerlink" title="RaftController.vote"></a>RaftController.vote</h2><p>收到投票的票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/vote&quot;)</span><br><span class="line">public JsonNode vote(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    RaftPeer peer = raftCore.receivedVote(JacksonUtils.toObj(WebUtils.required(request, &quot;vote&quot;), RaftPeer.class));</span><br><span class="line"></span><br><span class="line">    return JacksonUtils.transferToJsonNode(peer);</span><br></pre></td></tr></table></figure><h2 id="RaftCore-receivedVote"><a href="#RaftCore-receivedVote" class="headerlink" title="RaftCore.receivedVote"></a>RaftCore.receivedVote</h2><p>这个方法主要就是处理自己的选票的,当收到其他机器拉票的请求的时候,会比较term,如果自身的term大于全程请求机器的term,并且自己的选票没有还没投出去的时候,就把选票投给自己。<br>否则将选票投给远程请求的机器,并且把自己的状态设置为follower,并且把信息返回出去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public synchronized RaftPeer receivedVote(RaftPeer remote) &#123;</span><br><span class="line">    if (!peers.contains(remote)) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;can not find peer: &quot; + remote.ip);</span><br><span class="line">    &#125;</span><br><span class="line">//获取本机的节点信息</span><br><span class="line">    RaftPeer local = peers.get(NetUtils.localServer());</span><br><span class="line">    //如果请求的任期小于自己的任期并且还没有投出选票,那么将票投给自己</span><br><span class="line">    if (remote.term.get() &lt;= local.term.get()) &#123;</span><br><span class="line">        String msg = &quot;received illegitimate vote&quot; + &quot;, voter-term:&quot; + remote.term + &quot;, votee-term:&quot; + local.term;</span><br><span class="line"></span><br><span class="line">        Loggers.RAFT.info(msg);</span><br><span class="line">        //如果voteFor为空,表示在此之前没有收到其他节点的票据。则把remote节点的票据设置到自己的节点上</span><br><span class="line">        if (StringUtils.isEmpty(local.voteFor)) &#123;</span><br><span class="line">            local.voteFor = local.ip;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return local;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果上面if不成立,说明请求的任期&gt;本地的任期 ,remote机器率先发起的投票,那么就认同他的投票</span><br><span class="line">    local.resetLeaderDue(); //重置本地机器的选举间隔时间</span><br><span class="line"></span><br><span class="line">    local.state = RaftPeer.State.FOLLOWER; //设置本机机器为follower,并且为请求过来的机器投票</span><br><span class="line">    local.voteFor = remote.ip;//本地机器投票给remote的机器</span><br><span class="line">    local.term.set(remote.term.get());;//同步remote的term</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Loggers.RAFT.info(&quot;vote &#123;&#125; as leader, term: &#123;&#125;&quot;, remote.ip, remote.term);</span><br><span class="line"></span><br><span class="line">    return local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="decideLeader"><a href="#decideLeader" class="headerlink" title="decideLeader"></a>decideLeader</h2><p>decideLeader,表示用来决策谁能成为leader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RaftPeer <span class="title">decideLeader</span><span class="params">(RaftPeer candidate)</span> </span>&#123;</span><br><span class="line">    peers.put(candidate.ip, candidate);</span><br><span class="line"></span><br><span class="line">    SortedBag ips = <span class="keyword">new</span> TreeBag();</span><br><span class="line">    <span class="comment">//选票最多的票数</span></span><br><span class="line">    <span class="keyword">int</span> maxApproveCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//选票最多的ip</span></span><br><span class="line">    String maxApprovePeer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 假设3个节点：A,B,C</span></span><br><span class="line"><span class="comment">* local节点为A,假设A,B,C第一轮同时发起选举请求</span></span><br><span class="line"><span class="comment">* 第一轮投票结果：</span></span><br><span class="line"><span class="comment">    * 第一次for循环是A自己的投票(投票给自己)：maxApproveCount = 1,maxApprovePeer = A</span></span><br><span class="line"><span class="comment">* 第二次for循环是B服务器返回的投票,该投票投向B：</span></span><br><span class="line"><span class="comment">* 此时 if (ips.getCount(peer.voteFor) &gt; maxApproveCount) 条件不成立,maxApproveCount = 1,maxApprovePeer = A</span></span><br><span class="line"><span class="comment">* 第三次for循环是C服务器返回的投票,该投票投向C</span></span><br><span class="line"><span class="comment">* 此时 if (ips.getCount(peer.voteFor) &gt; maxApproveCount) 条件不成立,maxApproveCount = 1,maxApprovePeer = A</span></span><br><span class="line"><span class="comment">* 第二轮投票结果：</span></span><br><span class="line"><span class="comment">    * 第一次for循环是A自己的投票(投票给自己)：maxApproveCount = 1,maxApprovePeer = A</span></span><br><span class="line"><span class="comment">* 第二次for循环是B服务器返回的投票,该投票投向A：</span></span><br><span class="line"><span class="comment">* 此时 if (ips.getCount(peer.voteFor) &gt; maxApproveCount) 条件成立,maxApproveCount = 2,maxApprovePeer = A</span></span><br><span class="line"><span class="comment">* 第三次for循环是C服务器返回的投票,该投票投向C</span></span><br><span class="line"><span class="comment">* 此时 if (ips.getCount(peer.voteFor) &gt; maxApproveCount) 条件不成立,maxApproveCount = 1,maxApprovePeer = A</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span> (RaftPeer peer : peers.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(peer.voteFor)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//收集选票</span></span><br><span class="line">        ips.add(peer.voteFor);</span><br><span class="line">        <span class="keyword">if</span> (ips.getCount(peer.voteFor) &gt; maxApproveCount) &#123;</span><br><span class="line">            maxApproveCount = ips.getCount(peer.voteFor);</span><br><span class="line">            maxApprovePeer = peer.voteFor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//majorityCount()过半节点数：2（假设3个节点）</span></span><br><span class="line"><span class="comment">//第一轮：maxApproveCount = 1 if条件不成立,返回leader,此时leader为null,没有选举成功</span></span><br><span class="line"><span class="comment">//第二轮：maxApproveCount = 2 if条件成立,返回leader,此时leader为A,没有选举成功</span></span><br><span class="line">    <span class="keyword">if</span> (maxApproveCount &gt;= majorityCount()) &#123;</span><br><span class="line">        RaftPeer peer = peers.get(maxApprovePeer);</span><br><span class="line">        peer.state = RaftPeer.State.LEADER;<span class="comment">//成为Leader</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(leader, peer)) &#123;</span><br><span class="line">            leader = peer;</span><br><span class="line">            <span class="comment">// 如果当前leader和选举出来的leader不是同一个,那么将选举的leader重置并且发布一个leader选举完成的事件</span></span><br><span class="line">            ApplicationUtils.publishEvent(<span class="keyword">new</span> LeaderElectFinishedEvent(<span class="keyword">this</span>, leader, local()));</span><br><span class="line">            Loggers.RAFT.info(<span class="string">&quot;&#123;&#125; has become the LEADER&quot;</span>, leader.ip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回Leader</span></span><br><span class="line">    <span class="keyword">return</span> leader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据同步</p><h2 id="addInstance-1"><a href="#addInstance-1" class="headerlink" title="addInstance"></a>addInstance</h2><p>比如我们在注册服务时,调用addInstance之后,最后会调用 consistencyService.put(key, instances); 这个方法,来实现数据一致性的同步。</p><p>InstanceController.register—-&gt;registerInstance—–&gt;addInstance——&gt;consistencyService.put(key, instances);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="keyword">boolean</span> ephemeral, Instance... ips)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String key = KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line"></span><br><span class="line">    Service service = getService(namespaceId, serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">        List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line"></span><br><span class="line">        Instances instances = <span class="keyword">new</span> Instances();</span><br><span class="line">        instances.setInstanceList(instanceList);</span><br><span class="line"><span class="comment">//数据同步</span></span><br><span class="line">        consistencyService.put(key, instances);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RaftConsistencyServiceImpl-put"><a href="#RaftConsistencyServiceImpl-put" class="headerlink" title="RaftConsistencyServiceImpl.put"></a>RaftConsistencyServiceImpl.put</h2><p>调用 consistencyService.put 用来发布类容,也就是实现数据的一致性同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raftCore.signalPublish(key, value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Loggers.RAFT.error(<span class="string">&quot;Raft put failed.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.SERVER_ERROR, <span class="string">&quot;Raft put failed, key:&quot;</span> + key + <span class="string">&quot;, value:&quot;</span> + value,</span><br><span class="line">                                 e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RaftCore-signalPublish"><a href="#RaftCore-signalPublish" class="headerlink" title="RaftCore.signalPublish"></a>RaftCore.signalPublish</h2><p>public static final Lock OPERATE_LOCK = new ReentrantLock();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalPublish</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//如果接受的节点不是Leader节点</span></span><br><span class="line">    <span class="keyword">if</span> (!isLeader()) &#123;</span><br><span class="line">        ObjectNode params = JacksonUtils.createEmptyJsonNode();</span><br><span class="line">        params.put(<span class="string">&quot;key&quot;</span>, key);</span><br><span class="line">        params.replace(<span class="string">&quot;value&quot;</span>, JacksonUtils.transferToJsonNode(value));</span><br><span class="line">        Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        parameters.put(<span class="string">&quot;key&quot;</span>, key);</span><br><span class="line"><span class="comment">//获取Leader节点</span></span><br><span class="line">        <span class="keyword">final</span> RaftPeer leader = getLeader();</span><br><span class="line">        <span class="comment">//转发到Leader节点</span></span><br><span class="line">        raftProxy.proxyPostLarge(leader.ip, API_PUB, params.toString(), parameters);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果自己是leader,则向所有节点发送onPublish请求。这个所有节点包含自己</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        OPERATE_LOCK.lock();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> Datum datum = <span class="keyword">new</span> Datum();</span><br><span class="line">        datum.key = key;</span><br><span class="line">        datum.value = value;</span><br><span class="line">        <span class="keyword">if</span> (getDatum(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            datum.timestamp.set(<span class="number">1L</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            datum.timestamp.set(getDatum(key).timestamp.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectNode json = JacksonUtils.createEmptyJsonNode();</span><br><span class="line">        json.replace(<span class="string">&quot;datum&quot;</span>, JacksonUtils.transferToJsonNode(datum));</span><br><span class="line">        json.replace(<span class="string">&quot;source&quot;</span>, JacksonUtils.transferToJsonNode(peers.local()));</span><br><span class="line"><span class="comment">//onPublish可以当做是一次心跳了,更新选举检查时间,然后一个重点就是term增加100了。</span></span><br><span class="line"><span class="comment">//当然还是就是更新内容了,先写文件,再更新内存缓存。(也就是先记录本地日志)</span></span><br><span class="line">        onPublish(datum, peers.local()); <span class="comment">//发送数据到所有节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String content = json.toString();</span><br><span class="line"> <span class="comment">//CountDownLatch 用于控制过半提交</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(peers.majorityCount());</span><br><span class="line">        <span class="comment">//遍历所有节点,发送事务提交请求,把记录在本地日志中的数据进行提交</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> String server : peers.allServersIncludeMyself()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeader(server)) &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//API_ON_PUB: /raft/datum/commit  采用的是二阶段提交</span></span><br><span class="line">            <span class="keyword">final</span> String url = buildUrl(server, API_ON_PUB);</span><br><span class="line">            HttpClient.asyncHttpPostLarge(url, Arrays.asList(<span class="string">&quot;key=&quot;</span> + key), content,</span><br><span class="line">                                          <span class="keyword">new</span> AsyncCompletionHandler&lt;Integer&gt;() &#123;</span><br><span class="line">                                              <span class="meta">@Override</span></span><br><span class="line">                                              <span class="function"><span class="keyword">public</span> Integer <span class="title">onCompleted</span><span class="params">(Response response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                                  <span class="keyword">if</span> (response.getStatusCode() != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                                                      Loggers.RAFT</span><br><span class="line">                                                          .warn(<span class="string">&quot;[RAFT] failed to publish data to peer, datumId=&#123;&#125;, peer=&#123;&#125;, http code=&#123;&#125;&quot;</span>,</span><br><span class="line">                                                                datum.key, server, response.getStatusCode());</span><br><span class="line">                                                      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                                                  &#125;</span><br><span class="line">                                                  latch.countDown();</span><br><span class="line">                                                  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                                              &#125;</span><br><span class="line"></span><br><span class="line">                                              <span class="meta">@Override</span></span><br><span class="line">                                              <span class="function"><span class="keyword">public</span> STATE <span class="title">onContentWriteCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                                  <span class="keyword">return</span> STATE.CONTINUE;</span><br><span class="line">                                              &#125;</span><br><span class="line">                                          &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!latch.await(UtilsAndCommons.RAFT_PUBLISH_TIMEOUT, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            <span class="comment">// only majority servers return success can we consider this update success</span></span><br><span class="line">            Loggers.RAFT.error(<span class="string">&quot;data publish failed, caused failed to notify majority, key=&#123;&#125;&quot;</span>, key);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;data publish failed, caused failed to notify majority, key=&quot;</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        Loggers.RAFT.info(<span class="string">&quot;signalPublish cost &#123;&#125; ms, key: &#123;&#125;&quot;</span>, (end - start), key);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        OPERATE_LOCK.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="onPublish"><a href="#onPublish" class="headerlink" title="onPublish"></a>onPublish</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ConcurrentMap&lt;String, Datum&gt; datums = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPublish</span><span class="params">(Datum datum, RaftPeer source)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    RaftPeer local = peers.local();</span><br><span class="line">    <span class="keyword">if</span> (datum.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Loggers.RAFT.warn(<span class="string">&quot;received empty datum&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;received empty datum&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!peers.isLeader(source.ip)) &#123;</span><br><span class="line">        Loggers.RAFT</span><br><span class="line">            .warn(<span class="string">&quot;peer &#123;&#125; tried to publish data but wasn&#x27;t leader, leader: &#123;&#125;&quot;</span>, JacksonUtils.toJson(source),</span><br><span class="line">                  JacksonUtils.toJson(getLeader()));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;peer(&quot;</span> + source.ip + <span class="string">&quot;) tried to publish &quot;</span> + <span class="string">&quot;data but wasn&#x27;t leader&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (source.term.get() &lt; local.term.get()) &#123;</span><br><span class="line">        Loggers.RAFT.warn(<span class="string">&quot;out of date publish, pub-term: &#123;&#125;, cur-term: &#123;&#125;&quot;</span>, JacksonUtils.toJson(source),</span><br><span class="line">                          JacksonUtils.toJson(local));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;out of date publish, pub-term:&quot;</span> + source.term.get() + <span class="string">&quot;, cur-term: &quot;</span> + local.term.get());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//重置选举间隔时间</span></span><br><span class="line">    local.resetLeaderDue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if data should be persisted, usually this is true:</span></span><br><span class="line">    <span class="keyword">if</span> (KeyBuilder.matchPersistentKey(datum.key)) &#123;</span><br><span class="line">        <span class="comment">//存储到本地磁盘中</span></span><br><span class="line">        raftStore.write(datum);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//并且存储到内存中</span></span><br><span class="line">    datums.put(datum.key, datum);</span><br><span class="line"><span class="comment">//如果是leader,term增加100</span></span><br><span class="line">    <span class="keyword">if</span> (isLeader()) &#123;</span><br><span class="line">        local.term.addAndGet(PUBLISH_TERM_INCREASE_COUNT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (local.term.get() + PUBLISH_TERM_INCREASE_COUNT &gt; source.term.get()) &#123;</span><br><span class="line">            <span class="comment">//set leader term:</span></span><br><span class="line">            getLeader().term.set(source.term.get());</span><br><span class="line">            local.term.set(getLeader().term.get());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            local.term.addAndGet(PUBLISH_TERM_INCREASE_COUNT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新本地磁盘文件meta.properties下的term值</span></span><br><span class="line">    raftStore.updateTerm(local.term.get());</span><br><span class="line">    </span><br><span class="line">    notifier.addTask(datum.key, ApplyAction.CHANGE);</span><br><span class="line"></span><br><span class="line">    Loggers.RAFT.info(<span class="string">&quot;data added/updated, key=&#123;&#125;, term=&#123;&#125;&quot;</span>, datum.key, local.term);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看其他节点在接受到leader请求时是如何处理的,我们查看/v1/ns/raft/datum/commit接口的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/datum/commit&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">onPublish</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    response.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=&quot;</span> + getAcceptEncoding(request));</span><br><span class="line">    response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Content-Encode&quot;</span>, <span class="string">&quot;gzip&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String entity = IoUtils.toString(request.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    String value = URLDecoder.decode(entity, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    JsonNode jsonObject = JacksonUtils.toObj(value);</span><br><span class="line">    String key = <span class="string">&quot;key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    RaftPeer source = JacksonUtils.toObj(jsonObject.get(<span class="string">&quot;source&quot;</span>).toString(), RaftPeer.class);</span><br><span class="line">    JsonNode datumJson = jsonObject.get(<span class="string">&quot;datum&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Datum datum = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//根据不同数据类型进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (KeyBuilder.matchInstanceListKey(datumJson.get(key).asText())) &#123;</span><br><span class="line">        datum = JacksonUtils.toObj(jsonObject.get(<span class="string">&quot;datum&quot;</span>).toString(), <span class="keyword">new</span> TypeReference&lt;Datum&lt;Instances&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (KeyBuilder.matchSwitchKey(datumJson.get(key).asText())) &#123;</span><br><span class="line">        datum = JacksonUtils.toObj(jsonObject.get(<span class="string">&quot;datum&quot;</span>).toString(), <span class="keyword">new</span> TypeReference&lt;Datum&lt;SwitchDomain&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (KeyBuilder.matchServiceMetaKey(datumJson.get(key).asText())) &#123;</span><br><span class="line">        datum = JacksonUtils.toObj(jsonObject.get(<span class="string">&quot;datum&quot;</span>).toString(), <span class="keyword">new</span> TypeReference&lt;Datum&lt;Service&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raftConsistencyService.onPut(datum, source);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的核心在于 raftConsistencyService.onPut(datum, source);我们进入到该方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPut</span><span class="params">(Datum datum, RaftPeer source)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//在本地写入数据</span></span><br><span class="line">        raftCore.onPublish(datum, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Loggers.RAFT.error(<span class="string">&quot;Raft onPut failed.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.SERVER_ERROR,</span><br><span class="line">                                 <span class="string">&quot;Raft onPut failed, datum:&quot;</span> + datum + <span class="string">&quot;, source: &quot;</span> + source, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/raft.jpg" alt="raft"></p><h2 id="SpringcloudConfigServer"><a href="#SpringcloudConfigServer" class="headerlink" title="SpringcloudConfigServer"></a>SpringcloudConfigServer</h2><p>SpringCloudConfigServer为外部配置（名称-值对或等效的YAML内容）提供了基于HTTP的API。通过使用@EnableConfigServer注释，服务器可以嵌入到Spring Boot应用程序中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring Cloud Config Server provides an HTTP resource-based API for external configuration (name-value pairs or equivalent YAML content). The server is embeddable in a Spring Boot application, by using the @EnableConfigServer annotation. Consequently, the following application is a config server:</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ConfigServer.java</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ConfigServer.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Cloud-Config-Client"><a href="#Spring-Cloud-Config-Client" class="headerlink" title="Spring Cloud Config Client"></a>Spring Cloud Config Client</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A Spring Boot application can take immediate advantage of the Spring Config Server (or other external property sources provided by the application developer). It also picks up some additional useful features related to Environment change events.</span><br></pre></td></tr></table></figure><h3 id="RefreshScope和ContextRefresher"><a href="#RefreshScope和ContextRefresher" class="headerlink" title="@RefreshScope和ContextRefresher"></a>@RefreshScope和ContextRefresher</h3><p>通过外部化配置（.properties）的刷新，在应用不需要重启的情况下热加载新的外部化配置的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">通过 Spring Cloud 原生注解 @RefreshScope 实现配置自动更新：</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/config&quot;)</span><br><span class="line">@RefreshScope</span><br><span class="line">public class ConfigController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;useLocalCache:false&#125;&quot;)</span><br><span class="line">    private boolean useLocalCache;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/get&quot;)</span><br><span class="line">    public boolean get() &#123;</span><br><span class="line">        return useLocalCache;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单独管理Bean生命周期<br>创建Bean的时候如果是RefreshScope就缓存在一个专门管理的ScopeMap中，这样就可以管理Scope是Refresh的Bean的生命周期了（所以含RefreshScope的其实一共创建了两个bean）。<br>重新创建Bean<br>外部化配置刷新之后，会触发一个动作，这个动作将上面的ScopeMap中的Bean清空，这样这些Bean就会重新被IOC容器创建一次，使用最新的外部化配置的值注入类中，达到热加载新值的效果。</p><p>在SpringIOC中，BeanScope（Bean的作用域）影响了Bean的管理方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ManagedResource</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefreshScope</span> <span class="keyword">extends</span> <span class="title">GenericScope</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">Ordered</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">enum</span> <span class="title">ScopedProxyMode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default typically equals &#123;<span class="doctag">@link</span> #NO&#125;, unless a different default</span></span><br><span class="line"><span class="comment"> * has been configured at the component-scan instruction level.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DEFAULT,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Do not create a scoped proxy.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This proxy-mode is not typically useful when used with a</span></span><br><span class="line"><span class="comment"> * non-singleton scoped instance, which should favor the use of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #INTERFACES&#125; or &#123;<span class="doctag">@link</span> #TARGET_CLASS&#125; proxy-modes instead if it</span></span><br><span class="line"><span class="comment"> * is to be used as a dependency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NO,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a JDK dynamic proxy implementing &lt;i&gt;all&lt;/i&gt; interfaces exposed by</span></span><br><span class="line"><span class="comment"> * the class of the target object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">INTERFACES,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a class-based proxy (uses CGLIB).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TARGET_CLASS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">作用域</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">singleton（单例）</td><td align="left"><font color="blue">每一个Spring IoC容器都拥有唯一的一个实例对象（默认作用域）</font> 。</td></tr><tr><td align="left">prototype（原型）</td><td align="left"><font color="blue">一个Bean定义，任意多个对象</font></td></tr><tr><td align="left">request（请求）</td><td align="left"><font color="blue">每一个HTTP请求都有自己的Bean实例（只在基于web的Spring ApplicationContext中可用）</font></td></tr><tr><td align="left">session（会话）</td><td align="left"><font color="blue">一个Bean的作用域为HTTPsession的生命周期（只有基于web的Spring ApplicationContext才能使用） </font></td></tr><tr><td align="left">global session（全局会话）</td><td align="left"><font color="blue">一个Bean的作用域为全局HTTPSession的生命周期。通常用于门户网站场景（只有基于web的Spring ApplicationContext才能使用）</font>。</td></tr></tbody></table><h2 id="Nacos动态更新地址原理"><a href="#Nacos动态更新地址原理" class="headerlink" title="Nacos动态更新地址原理"></a>Nacos动态更新地址原理</h2><p>Nacos客户端中有一个HostReactor类，它的功能是实现服务的动态更新，基本原理是：</p><p>客户端发起时间订阅后，在HostReactor中有一个UpdateTask线程，每10s发送一次Pull请求，获得服务端最新的地址列表<br>对于服务端，它和服务提供者的实例之间维持了心跳检测，一旦服务提供者出现异常，则会发送一个Push消息给Nacos客户端，也就是服务端消费者<br>服务消费者收到请求之后，使用HostReactor中提供的processServiceJSON解析消息，并更新本地服务地址列表</p><ol><li>@RefreshScope使用注意事项<br>@RefreshScope作用的类，不能是final类，否则启动时会报错。<br>@RefreshScope不能单独使用，需要和其他其他bean注解结合使用，如：@Controller、@Service、@Component、@Repository、@Configuration等。<br>@RefreshScope 最好不要修饰在 @Scheduled、listener、Timmer等类中,因为配置的刷新会导致原来的对象被清除，需要重新使用对象才能出发生成新对象（但因为对象没了，又没法重新使用对象，死循环）</li><li>@RefreshScope动态刷新失效<br>考虑使用的bean是否是@RefreshScope生成的那个scopedTarget.beanName的 bean<br>springboot某些低版本貌似有问题，在Controller类上使用不会生效（网上有这么说的，没具体研究）<br>解决方法1：注解上加属性@RefreshScope(proxyMode = ScopedProxyMode.DEFAULT)<br>解决方法2：直接使用其他类单独封装配置参数，使用@RefreshScope+@Value方式<br>解决方法3：直接使用@ConfigurationProperties</li><li>不使用@RefreshScope也能实现动态刷新<br>直接使用@ConfigurationProperties，并不需要加@RefreshScope就能实现动态更新。</li></ol><p>@ConfigurationProperties实现动态刷新的原理：<br>@ConfigurationProperties有ConfigurationPropertiesRebinder这个监听器，监听着EnvironmentChangeEvent事件。当发生EnvironmentChange事件后，会重新构造原来的加了@ConfigurationProperties注解的Bean对象。这个是Spring Cloud的默认实现。</p><p>@Autowired方式注入的是代理对象<br>beanName的得到的是代理对象<br>scopedTarget.beanName的得到的@RefreshScope生成的那个原类对象<br>代理对象不会随着配置刷新而更新<br>@RefreshScope生成的那个原类对象会随着配置的刷新而更新（属性时清除原来的，使用时才生成新的）</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SpringCloud Nacos" scheme="https://zkkget.github.io/categories/SpringCloud-Nacos/"/>
    
    
    <category term="SpringCloud Nacos" scheme="https://zkkget.github.io/tags/SpringCloud-Nacos/"/>
    
  </entry>
  
  <entry>
    <title>Mysql保留关键字</title>
    <link href="https://zkkget.github.io/posts/20220830a1.html"/>
    <id>https://zkkget.github.io/posts/20220830a1.html</id>
    <published>2022-08-30T06:53:46.000Z</published>
    <updated>2022-08-30T06:54:11.240Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>MySQL关键字（保留字）列表<br>在使用MySQL的时候，一般尽量避免用关键字作为表名，如使用关键字做表名，需要按标准写法给SQL语句加<a href="%E6%88%96%E6%98%AF%E2%80%9C"></a>区分字段名和表名。</p><p>下面列出MySQL所有关键字，希望给使用MySQL的朋友提供一些参考帮助。</p><p>ADD    ALL    ALTER<br>ANALYZE    AND    AS<br>ASC    ASENSITIVE    BEFORE<br>BETWEEN    BIGINT    BINARY<br>BLOB    BOTH    BY<br>CALL    CASCADE    CASE<br>CHANGE    CHAR    CHARACTER<br>CHECK    COLLATE    COLUMN<br>CONDITION    CONNECTION    CONSTRAINT<br>CONTINUE    CONVERT    CREATE<br>CROSS    CURRENT_DATE    CURRENT_TIME<br>CURRENT_TIMESTAMP    CURRENT_USER    CURSOR<br>DATABASE    DATABASES    DAY_HOUR<br>DAY_MICROSECOND    DAY_MINUTE    DAY_SECOND<br>DEC    DECIMAL    DECLARE<br>DEFAULT    DELAYED    DELETE<br>DESC    DESCRIBE    DETERMINISTIC<br>DISTINCT    DISTINCTROW    DIV<br>DOUBLE    DROP    DUAL<br>EACH    ELSE    ELSEIF<br>ENCLOSED    ESCAPED    EXISTS<br>EXIT    EXPLAIN    FALSE<br>FETCH    FLOAT    FLOAT4<br>FLOAT8    FOR    FORCE<br>FOREIGN    FROM    FULLTEXT<br>GOTO    GRANT    GROUP<br>HAVING    HIGH_PRIORITY    HOUR_MICROSECOND<br>HOUR_MINUTE    HOUR_SECOND    IF<br>IGNORE    IN    INDEX<br>INFILE    INNER    INOUT<br>INSENSITIVE    INSERT    INT<br>INT1    INT2    INT3<br>INT4    INT8    INTEGER<br>INTERVAL    INTO    IS<br>ITERATE    JOIN    KEY<br>KEYS    KILL    LABEL<br>LEADING    LEAVE    LEFT<br>LIKE    LIMIT    LINEAR<br>LINES    LOAD    LOCALTIME<br>LOCALTIMESTAMP    LOCK    LONG<br>LONGBLOB    LONGTEXT    LOOP<br>LOW_PRIORITY    MATCH    MEDIUMBLOB<br>MEDIUMINT    MEDIUMTEXT    MIDDLEINT<br>MINUTE_MICROSECOND    MINUTE_SECOND    MOD<br>MODIFIES    NATURAL    NOT<br>NO_WRITE_TO_BINLOG    NULL    NUMERIC<br>ON    OPTIMIZE    OPTION<br>OPTIONALLY    OR    ORDER<br>OUT    OUTER    OUTFILE<br>PRECISION    PRIMARY    PROCEDURE<br>PURGE    RAID0    RANGE<br>READ    READS    REAL<br>REFERENCES    REGEXP    RELEASE<br>RENAME    REPEAT    REPLACE<br>REQUIRE    RESTRICT    RETURN<br>REVOKE    RIGHT    RLIKE<br>SCHEMA    SCHEMAS    SECOND_MICROSECOND<br>SELECT    SENSITIVE    SEPARATOR<br>SET    SHOW    SMALLINT<br>SPATIAL    SPECIFIC    SQL<br>SQLEXCEPTION    SQLSTATE    SQLWARNING<br>SQL_BIG_RESULT    SQL_CALC_FOUND_ROWS    SQL_SMALL_RESULT<br>SSL    STARTING    STRAIGHT_JOIN<br>TABLE    TERMINATED    THEN<br>TINYBLOB    TINYINT    TINYTEXT<br>TO    TRAILING    TRIGGER<br>TRUE    UNDO    UNION<br>UNIQUE    UNLOCK    UNSIGNED<br>UPDATE    USAGE    USE<br>USING    UTC_DATE    UTC_TIME<br>UTC_TIMESTAMP    VALUES    VARBINARY<br>VARCHAR    VARCHARACTER    VARYING<br>WHEN    WHERE    WHILE<br>WITH    WRITE    X509<br>XOR    YEAR_MONTH    ZEROFILL</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Mysql" scheme="https://zkkget.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>1000万数据对比ContainsAll实测</title>
    <link href="https://zkkget.github.io/posts/20220812clho7wpj20001youj2bmlgv58.html"/>
    <id>https://zkkget.github.io/posts/20220812clho7wpj20001youj2bmlgv58.html</id>
    <published>2022-08-12T08:24:06.000Z</published>
    <updated>2022-08-12T08:25:08.475Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutReminder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            list.add(getRandomString(random.nextInt(<span class="number">100</span>)));</span><br><span class="line">            list2.add(getRandomString(random.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        list.containsAll(list2);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(stopWatch.getTotalTimeSeconds());</span><br><span class="line">        StopWatch stopWatch2 = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch2.start();</span><br><span class="line">        CollectionUtils.containsAll(list, list2);</span><br><span class="line">        stopWatch2.stop();</span><br><span class="line">        System.out.println(stopWatch2.getTotalTimeSeconds());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">0.571</span></span><br><span class="line"><span class="number">17.27</span></span><br><span class="line"></span><br><span class="line">源码 java.util.List#<span class="function">containsAll</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = es.length;</span><br><span class="line">        <span class="keyword">for</span> (Object e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexOfRange(e, es, <span class="number">0</span>, len) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOfRange</span><span class="params">(Object o, Object[] es, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt; to; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt; to; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">源码org.apache.commons.collections4.CollectionUtils#containsAll</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;code&gt;true&lt;/code&gt; iff all elements of &#123;<span class="doctag">@code</span> coll2&#125; are also contained</span></span><br><span class="line"><span class="comment">     * in &#123;<span class="doctag">@code</span> coll1&#125;. The cardinality of values in &#123;<span class="doctag">@code</span> coll2&#125; is not taken into account,</span></span><br><span class="line"><span class="comment">     * which is the same behavior as &#123;<span class="doctag">@link</span> Collection#containsAll(Collection)&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * In other words, this method returns &lt;code&gt;true&lt;/code&gt; iff the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #intersection&#125; of &lt;i&gt;coll1&lt;/i&gt; and &lt;i&gt;coll2&lt;/i&gt; has the same cardinality as</span></span><br><span class="line"><span class="comment">     * the set of unique values from &#123;<span class="doctag">@code</span> coll2&#125;. In case &#123;<span class="doctag">@code</span> coll2&#125; is empty, &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * will be returned.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method is intended as a replacement for &#123;<span class="doctag">@link</span> Collection#containsAll(Collection)&#125;</span></span><br><span class="line"><span class="comment">     * with a guaranteed runtime complexity of &#123;<span class="doctag">@code</span> O(n + m)&#125;. Depending on the type of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Collection&#125; provided, this method will be much faster than calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Collection#containsAll(Collection)&#125; instead, though this will come at the</span></span><br><span class="line"><span class="comment">     * cost of an additional space complexity O(n).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coll1  the first collection, must not be null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coll2  the second collection, must not be null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;code&gt;true&lt;/code&gt; iff the intersection of the collections has the same cardinality</span></span><br><span class="line"><span class="comment">     *   as the set of unique elements from the second collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(<span class="keyword">final</span> Collection&lt;?&gt; coll1, <span class="keyword">final</span> Collection&lt;?&gt; coll2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coll2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Iterator&lt;?&gt; it = coll1.iterator();</span><br><span class="line">            <span class="keyword">final</span> Set&lt;Object&gt; elementsAlreadySeen = <span class="keyword">new</span> HashSet&lt;Object&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> Object nextElement : coll2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (elementsAlreadySeen.contains(nextElement)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> foundCurrentElement = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Object p = it.next();</span><br><span class="line">                    elementsAlreadySeen.add(p);</span><br><span class="line">                    <span class="keyword">if</span> (nextElement == <span class="keyword">null</span> ? p == <span class="keyword">null</span> : nextElement.equals(p)) &#123;</span><br><span class="line">                        foundCurrentElement = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (foundCurrentElement) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="ContainsAll" scheme="https://zkkget.github.io/tags/ContainsAll/"/>
    
  </entry>
  
  <entry>
    <title>面向面试编程</title>
    <link href="https://zkkget.github.io/posts/20220802clho7wpkq002wyoujgnui1nsi.html"/>
    <id>https://zkkget.github.io/posts/20220802clho7wpkq002wyoujgnui1nsi.html</id>
    <published>2022-08-02T03:35:12.000Z</published>
    <updated>2023-02-07T06:14:38.861Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="2023年2月2日09-58-57更新"><a href="#2023年2月2日09-58-57更新" class="headerlink" title="2023年2月2日09:58:57更新"></a>2023年2月2日09:58:57更新</h2><p>提问：请问什么是java中函数式接口？<br>回答：只定义了一个抽象方法的接口。(如果你也是这个回答，很遗憾肯定是不及格的)</p><p>原答案中对于此回答不是很认可，我不知道是处于语法的严谨还是个人角度理解的不同，在官方文档中如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Package java.util.function Description</span><br><span class="line">Functional interfaces provide target types for lambda expressions and method references. Each functional interface has a single abstract method, called the functional method for that functional interface, to which the lambda expression&#x27;s parameter and return types are matched or adapted. Functional interfaces can provide a target type in multiple contexts, such as assignment context, method invocation, or cast context:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>译文如下：<br>函数接口为 lambda 表达式和方法引用提供目标类型。每个函数接口都有一个抽象方法，称为该函数接口的函数方法，lambda 表达式的参数和返回类型与该方法匹配或调整。函数接口可以在多个上下文中提供目标类型，例如赋值上下文、方法调用或强制转换上下文</p><h2 id="jdk哪个方法是用堆实现的"><a href="#jdk哪个方法是用堆实现的" class="headerlink" title="jdk哪个方法是用堆实现的"></a>jdk哪个方法是用堆实现的</h2><p>PriorityQueue</p><h2 id="函数式编程的本质是什么？"><a href="#函数式编程的本质是什么？" class="headerlink" title="函数式编程的本质是什么？"></a>函数式编程的本质是什么？</h2><p>函数式编程的本质是：把函数看作是数据。</p><h2 id="Stream-foreach中类型是什么"><a href="#Stream-foreach中类型是什么" class="headerlink" title="Stream.foreach中类型是什么?"></a>Stream.foreach中类型是什么?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1-请介绍下java中基本数据类型以及它们的使用场景"><a href="#1-请介绍下java中基本数据类型以及它们的使用场景" class="headerlink" title="1.请介绍下java中基本数据类型以及它们的使用场景"></a>1.请介绍下java中基本数据类型以及它们的使用场景</h2><p>Java八大数据类型：<br>（1）整数类型：byte、short、int、long<br>（2）小数类型：float、double<br>（3）字符类型：char<br>（4）布尔类型：boolean<br>引用数据类型<br>String</p><h2 id="2-为什么定义了这些基本数据类型后还要定义包装类？"><a href="#2-为什么定义了这些基本数据类型后还要定义包装类？" class="headerlink" title="2.为什么定义了这些基本数据类型后还要定义包装类？"></a>2.为什么定义了这些基本数据类型后还要定义包装类？</h2><p>之所以需要包装类型，就是因为java是一个面向对象的语言，然而基本数据类型不具备面向对象的特性，当我们把基本数据类型包装成包装类型之后，它就具有了面向对象的特性。而且，在往ArrayList、HashMap这些容器传数据的时候，基本类型int和double是传输不进去的，因为容器都是装object类型的，所以需要转为包装类型进行传输。每一个基本数据类型都有对应的包装类型.</p><h2 id="3-包装类和String类有什么相同点吗？"><a href="#3-包装类和String类有什么相同点吗？" class="headerlink" title="3.包装类和String类有什么相同点吗？"></a>3.包装类和String类有什么相同点吗？</h2><p>都允许为null或空,<br>包装类除Float,Double并没有实现常量池技术,其他的和String类都存放在常量池中。</p><h2 id="4-包装类是否重写了equals方法，为什么？"><a href="#4-包装类是否重写了equals方法，为什么？" class="headerlink" title="4.包装类是否重写了equals方法，为什么？"></a>4.包装类是否重写了equals方法，为什么？</h2><p>是的,先看他是否内存相等,如果不相等</p><h2 id="5-请问我使用Integer定义两个数字，它们值都等于100，使用-和equals方式分别比较它们是否相等？"><a href="#5-请问我使用Integer定义两个数字，它们值都等于100，使用-和equals方式分别比较它们是否相等？" class="headerlink" title="5.请问我使用Integer定义两个数字，它们值都等于100，使用 == 和equals方式分别比较它们是否相等？"></a>5.请问我使用Integer定义两个数字，它们值都等于100，使用 == 和equals方式分别比较它们是否相等？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">都是<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">Integer a =<span class="number">100</span>;</span><br><span class="line">Integer b =<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(a.equals(b));</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">-------</span><br><span class="line">Integer a =<span class="number">200</span>;</span><br><span class="line">Integer b =<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(a.equals(b));</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><h2 id="6-导致上面结果原因是什么？如果我把值都改成200呢，结果会发生什么改变？"><a href="#6-导致上面结果原因是什么？如果我把值都改成200呢，结果会发生什么改变？" class="headerlink" title="6.导致上面结果原因是什么？如果我把值都改成200呢，结果会发生什么改变？"></a>6.导致上面结果原因是什么？如果我把值都改成200呢，结果会发生什么改变？</h2><p>在内存中的缓存值是相等的。优先比较内存，200超过127的大小范围==是不相等的</p><h2 id="7-我如何验证上述结果原因？"><a href="#7-我如何验证上述结果原因？" class="headerlink" title="7.我如何验证上述结果原因？"></a>7.我如何验证上述结果原因？</h2><p>Integer的缓存机制：为了节省内存和提高性能，Integer类在内部通过使用相同的对象引用实现缓存和重用，Integer类默认在-128 ~ 127 之间，可以通过 -XX:AutoBoxCacheMax进行修改，且这种机制仅在自动装箱的时候有用，在使用构造器创建Integer对象时无用。</p><h2 id="8-哪些包装类是带缓存的？默认值是多少？"><a href="#8-哪些包装类是带缓存的？默认值是多少？" class="headerlink" title="8.哪些包装类是带缓存的？默认值是多少？"></a>8.哪些包装类是带缓存的？默认值是多少？</h2><p>Integer 、Byte 、Short 、Long 、Character 五大包装类都有缓冲机制，且缓冲的默认值范围都是-128~127</p><p>而Float,Double,Boolean 三大包装类并没有缓冲机制。</p><h2 id="9-我是否可以改变缓存值区间？怎么做？"><a href="#9-我是否可以改变缓存值区间？怎么做？" class="headerlink" title="9.我是否可以改变缓存值区间？怎么做？"></a>9.我是否可以改变缓存值区间？怎么做？</h2><p>可以通过 -XX:AutoBoxCacheMax进行修改，且这种机制仅在自动装箱的时候有用，在使用构造器创建Integer对象时无用。</p><h2 id="1-请简单说下mysql常用索引类型"><a href="#1-请简单说下mysql常用索引类型" class="headerlink" title="1.请简单说下mysql常用索引类型"></a>1.请简单说下mysql常用索引类型</h2><p>主键索引、唯一索引、普通索引、全文索引、组合索引（联合索引，多列索引）</p><h2 id="2-组合索引使用时有什么需要特别注意的？"><a href="#2-组合索引使用时有什么需要特别注意的？" class="headerlink" title="2.组合索引使用时有什么需要特别注意的？"></a>2.组合索引使用时有什么需要特别注意的？</h2><p>1、对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高;     select * from table1 where col1=A AND col2=B AND col3=D     如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引<br>2、何时是用复合索引     根据where条件建索引是极其重要的一个原则;     注意不要过多用索引,否则对表更新的效率有很大的影响,因为在操作表的时候要化大量时间花在创建索引中<br>3、复合索引会替代单一索引么     如果索引满足窄索引的情况下可以建立复合索引,这样可以节约空间和时间</p><h2 id="3-为哪个表哪个字段需要添加索引有什么依据吗？"><a href="#3-为哪个表哪个字段需要添加索引有什么依据吗？" class="headerlink" title="3.为哪个表哪个字段需要添加索引有什么依据吗？"></a>3.为哪个表哪个字段需要添加索引有什么依据吗？</h2><p>1、表的主键、外键必须有索引；<br>2、数据量超过300的表应该有索引；<br>3、经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>5、索引应该建在选择性高的字段上；<br>6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；<br>7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：<br>A、正确选择复合索引中的主列字段，一般是选择性较好的字段；<br>B、复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；<br>C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；<br>D、如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；<br>E、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；<br>8、频繁进行数据操作的表，不要建立太多的索引；<br>9、删除无用的索引，避免对执行计划造成负面影响；<br>以上是一些普遍的建立索引时的判断依据。一言以蔽之，索引的建立必须慎重，对每个索引的必要性都应该经过仔细分析，要有建立的依据。因为太多的索引与不充分、不正确的索引对性能都毫无益处：在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大</p><h2 id="4-能为较长的varchar类型字段建立索引吗？建立哪种索引？"><a href="#4-能为较长的varchar类型字段建立索引吗？建立哪种索引？" class="headerlink" title="4.能为较长的varchar类型字段建立索引吗？建立哪种索引？"></a>4.能为较长的varchar类型字段建立索引吗？建立哪种索引？</h2><p>其中M指的是可存储的字符长度(或字符数)，而MySQL实际是按字节存储的，在不同的字符集下一个字符的字节长不同，因此这个M最大值在不同的字符集下值不同：</p><p>对于latin字符集下，因为一个字符占一个字节，所以M的最大值为65535(但实际只有65532)；对于gbk字符集，因为一个字符占两个字节，所以M的最大值为32767；对于utf8字符集，因为一个字符占两到三个字节，所以M的最大值为21845。</p><p>此外，mysql官方文档中定义的65535长度是指同一行的所有varchar列的长度总和。如果列的长度总和超出这个长度，依然无法创建。</p><p>1、MySQL5.6的限制方式：</p><p>在MySQL5.6版本中，当某个列的varchar长度定义超过相应字符集下的最大长度时，会自动将该列转存为mediumtext类型。例如，在utf8字符集下，定义ecs_payment表test2字段长度为21846：</p><p>假如再存储一个字段test3，定义varchar长度为21845，这时没有超过最大长度限制，但在存储test3 varchar(21845)列时，发现该表上所有varchar行的总长度将会超过65535字节，因此会发生如下报错：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> ecs_payment <span class="keyword">add</span> test3 <span class="type">varchar</span>(<span class="number">21845</span>);</span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): <span class="type">Row</span> size too large. The maximum <span class="type">row</span> size <span class="keyword">for</span> the used <span class="keyword">table</span> type, <span class="keyword">not</span> counting BLOBs, <span class="keyword">is</span> <span class="number">65535.</span> This includes storage overhead, <span class="keyword">check</span> the manual. You have <span class="keyword">to</span> change <span class="keyword">some</span> columns <span class="keyword">to</span> TEXT <span class="keyword">or</span> BLOBs</span><br></pre></td></tr></table></figure><p>2、MySQL5.7的限制方式：</p><p>在MySQL5.7版本下，只要列的varchar长度超过相应字符集下的最大限制，或者表上所有varchar列总长度将会超过65535字节时，MySQL都会抛出错误提示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> c1 <span class="type">varchar</span>(<span class="number">21846</span>);</span><br><span class="line">ERROR <span class="number">1074</span> (<span class="number">42000</span>): <span class="keyword">Column</span> length too big <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;c1&#x27;</span> (max <span class="operator">=</span> <span class="number">21845</span>); use <span class="type">BLOB</span> <span class="keyword">or</span> TEXT instead</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> c1 <span class="type">varchar</span>(<span class="number">21844</span>);</span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): <span class="type">Row</span> size too large. The maximum <span class="type">row</span> size <span class="keyword">for</span> the used <span class="keyword">table</span> type, <span class="keyword">not</span> counting BLOBs, <span class="keyword">is</span> <span class="number">65535.</span> This includes storage overhead, <span class="keyword">check</span> the manual. You have <span class="keyword">to</span> change <span class="keyword">some</span> columns <span class="keyword">to</span> TEXT <span class="keyword">or</span> BLOBs</span><br></pre></td></tr></table></figure><p>二、创建索引的限制<br>对于varchar列，当varchar长度过长时，会对索引的创建有限制，在MySQL5.6和5.7下的限制行为的表现形式不同。</p><p>1、MySQL5.6的限制</p><p>在MySQL5.6中，对ecs_payment表的test varchar(1024)列创建索引，并查看创建后的情况：</p><p>可以看到test列上建立了一个前缀索引，前缀长度为255字节。在MySQL5.6下，varchar长度超过255字节时是不适合建立索引的，MySQL会自动只建立255字节长的前缀索引，而不是抛出错误。</p><p>2、MySQL5.7的限制</p><p>在MySQL5.7版本下，varchar列上可建索引的最大长度是3072字节，超过此长度在建索引时会报错：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">column</span> c4 <span class="type">varchar</span>(<span class="number">1025</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.04</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> index i_2 <span class="keyword">on</span> t1(c4);</span><br><span class="line">ERROR <span class="number">1071</span> (<span class="number">42000</span>): Specified key was too long; max key length <span class="keyword">is</span> <span class="number">3072</span> bytes</span><br></pre></td></tr></table></figure><p>表t1是utf8字符集。</p><h2 id="5-在你之前开发经验中，你还有哪些索引使用规范？"><a href="#5-在你之前开发经验中，你还有哪些索引使用规范？" class="headerlink" title="5.在你之前开发经验中，你还有哪些索引使用规范？"></a>5.在你之前开发经验中，你还有哪些索引使用规范？</h2><p>1、 只为用于搜索、排序或分组的列创建索引。<br>重点关注 where 语句后边的情况</p><p>2、 当列中不重复值的个数在总记录条数中的占比很大时，才为列建立索引。<br>例如手机号、用户 ID、班级等，但是比如一张全校学生表，每条记录是一名学生，where 语句是查询所有’某学校‘的学生，那么其实也不会提高性能。</p><p>3、 索引列的类型尽量小。<br>无论是主键还是索引列都尽量选择小的，如果很大则会占据很大的索引空间。</p><p>4、 可以只为索引列前缀创建索引，减少索引占用的存储空间。<br>alter table single_table add index idx_key1(key1(10))<br>5、 尽量使用覆盖索引进行查询，以避免回表操作带来的性能损耗。<br>select key1 from single_table order by key1</p><p>6、 为了尽可能的少的让聚簇索引发生页面分裂的情况，建议让主键自增。<br>7、 定位并删除表中的冗余和重复索引。</p><p>冗余索引： 指的是不同的联合索引组合，某一列或者几列字段被多组索引覆盖，一般称这些列存在冗余索引</p><p>查询冗余索引SQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.TABLE_SCHEMA, a.TABLE_NAME, a.COLUMN_NAME, </span><br><span class="line">a.INDEX_NAME AS &#x27;index1&#x27;, b.INDEX_NAME AS &#x27;index2&#x27;</span><br><span class="line">FROM information_schema.STATISTICS a </span><br><span class="line">JOIN information_schema.STATISTICS b </span><br><span class="line">ON a.TABLE_SCHEMA = b.TABLE_SCHEMA    </span><br><span class="line">AND a.TABLE_NAME = b.TABLE_NAME </span><br><span class="line">AND a.SEQ_IN_INDEX = b.SEQ_IN_INDEX   </span><br><span class="line">AND a.COLUMN_NAME = b.COLUMN_NAME </span><br><span class="line">WHERE a.SEQ_IN_INDEX = 1 AND a.INDEX_NAME &lt;&gt; b.INDEX_NAME</span><br></pre></td></tr></table></figure><p>单列索引：（字段 1）</p><p>联合索引：（字段 1 字段 2）</p><p>重复索引：在一个字段上添加了普通索引、唯一索引、主键等多个索引</p><h2 id="6-一般我们是如何查看一条sql语句索引有没有起作用的？"><a href="#6-一般我们是如何查看一条sql语句索引有没有起作用的？" class="headerlink" title="6.一般我们是如何查看一条sql语句索引有没有起作用的？"></a>6.一般我们是如何查看一条sql语句索引有没有起作用的？</h2><p>explain执行分析计划<br>我们只需要注意一个最重要的type 的信息很明显的提现是否用到索引：</p><p>type结果值从好到坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。</p><p>possible_keys：sql所用到的索引</p><p>key：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL</p><p>rows: 显示MySQL认为它执行查询时必须检查的行数</p><p>3、profiling分析<br>想要优化一条query sql ，就要清楚这条query的性能瓶颈在哪里，mysql的profiler是一个非常方便的查询诊断分析工具，通过该工具可以获取一条查询在整个执行过程中多种资源的消耗情况，例如内存消耗、I/O消耗和CPU消耗<br>profile的语法结构：<br>show profile [type [,type] …]<br>[for query n]<br>[limit row_count [offset offset]]<br>其中type参数可选含义如下：<br>all：显示所有信息<br>block io：显示输入输出操作阻塞的数量<br>context switches：显示自动或非自动context switches的数量<br>cpu：显示系统和用户CPU使用的时间<br>ipc：显示信息发送和接受的数量<br>memory：内存的信息<br>page faults：显示主要的page faults数量<br>source：显示函数的名称，并且是那些函数所在文件的名字和行数<br>swaps：显示swap数量</p><p>开启profile<br>set profiling = 1;</p><p>开启query profiler功能之后，MySQL就会自动记录所有执行的query的profile信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> customers1;</span><br></pre></td></tr></table></figure><p>通过执行show profiles 命令获取当前系统中保存的多个query的profile的概要信息</p><p>针对单个query获取详细的profile信息（根据概要信息中的query_id来获取）<br>show profile for query 5;</p><h2 id="7-有没有了解过为什么添加索引可以加快查询速度？-数据结构B树和B-树"><a href="#7-有没有了解过为什么添加索引可以加快查询速度？-数据结构B树和B-树" class="headerlink" title="7.有没有了解过为什么添加索引可以加快查询速度？(数据结构B树和B+树)"></a>7.有没有了解过为什么添加索引可以加快查询速度？(数据结构B树和B+树)</h2><p>首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。<br>MySQL官方对于索引的定义为：索引是帮助MySQL高效获取数据的数据结构。即可以理解为：索引是数据结构。</p><p>我们知道，数据库查询是数据库最主要的功能之一，我们都希望查询数据的速度尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找，当然这种时间复杂度为O(n)的算法在数据量很大时显然是糟糕的，于是有了二分查找、二叉树查找等。但是二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树，但是数据本身的组织结构不可能完全满足各种数据结构。所以，在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。<br>数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）</p><h2 id="8-二者有什么区别？-可以给一个例子让其画出来"><a href="#8-二者有什么区别？-可以给一个例子让其画出来" class="headerlink" title="8.二者有什么区别？(可以给一个例子让其画出来)"></a>8.二者有什么区别？(可以给一个例子让其画出来)</h2><p>缺页查询，减少io</p><h2 id="9-结合树的特点说说，为什么推荐使用自增ID来做索引？为什么不使用红黑树、hash树？"><a href="#9-结合树的特点说说，为什么推荐使用自增ID来做索引？为什么不使用红黑树、hash树？" class="headerlink" title="9.结合树的特点说说，为什么推荐使用自增ID来做索引？为什么不使用红黑树、hash树？"></a>9.结合树的特点说说，为什么推荐使用自增ID来做索引？为什么不使用红黑树、hash树？</h2><p>自增主键的插入数据模式，正符合了递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。<br>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p><h2 id="Service-和-Component-注解的差别？"><a href="#Service-和-Component-注解的差别？" class="headerlink" title="@Service 和@Component 注解的差别？"></a>@Service 和@Component 注解的差别？</h2><p>@Component spring基础的注解,被spring管理的组件或bean,用于将对象实例化到Spring容器中<br>而@Service源码中是包含@Component注解的,也就是说service实现component的功能,但service用于服务层,处理业务逻辑</p><h2 id="各种-Restful-请求格式以及各种-http-请求返回码。"><a href="#各种-Restful-请求格式以及各种-http-请求返回码。" class="headerlink" title="各种 Restful 请求格式以及各种 http 请求返回码。"></a>各种 Restful 请求格式以及各种 http 请求返回码。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">API,英文全称Application Programming Interface,翻译为“应用程序编程接口”。就是将一些功能（逻辑）封装成组件,目的是提供一个应用程序接口给其它程序与开发人员访问,而这些访问人员不需要访问源码以及理解内部工作原理就可以直接使用</span><br><span class="line">RESTFUL是一种网络应用程序的设计风格和开发方式,基于HTTP,可以使用 XML 格式定义或 JSON 格式定义。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取,所以,使用JSON格式的REST风格的API具有简单、易读、易用的特点。</span><br><span class="line">而http返回状态码常见200.400.500等</span><br></pre></td></tr></table></figure><h2 id="1-请说下Springboot相比较Spring来说，你认为的最重要的三个特点是什么？"><a href="#1-请说下Springboot相比较Spring来说，你认为的最重要的三个特点是什么？" class="headerlink" title="1.请说下Springboot相比较Spring来说，你认为的最重要的三个特点是什么？"></a>1.请说下Springboot相比较Spring来说，你认为的最重要的三个特点是什么？</h2><p>自动化装配（以规约大于配置思想，做到了很多功能模块的自动化装配）、内嵌容器化（可以独立以jar包方式运行无需外部web容器支持）、开发运维化（基于一些devops思想做了一些endpoint来支持监控管理化）</p><h2 id="2-请问springboot的自动化装配技术，哪些技术来源与spring体系，哪些是自己新增的？"><a href="#2-请问springboot的自动化装配技术，哪些技术来源与spring体系，哪些是自己新增的？" class="headerlink" title="2.请问springboot的自动化装配技术，哪些技术来源与spring体系，哪些是自己新增的？"></a>2.请问springboot的自动化装配技术，哪些技术来源与spring体系，哪些是自己新增的？</h2><p>SpringBoot中的一些特征：</p><p>1、创建独立的 Spring应用。</p><p>2、嵌入式 Tomcat、 Jetty、 Undertow容器（无需部署war文件）。</p><p>3、提供的 starters 简化构建配置</p><p>4、尽可能自动配置 spring应用。 5、提供生产指标,例如指标、健壮检查和外部化配置</p><p>6、完全没有代码生成和 XML配置要求</p><h2 id="3-N：对上文的模式注解、模块装配、条件装配知识点进行具体有层次的提问"><a href="#3-N：对上文的模式注解、模块装配、条件装配知识点进行具体有层次的提问" class="headerlink" title="3-N：对上文的模式注解、模块装配、条件装配知识点进行具体有层次的提问"></a>3-N：对上文的模式注解、模块装配、条件装配知识点进行具体有层次的提问</h2><p>Spirng模式注解装配<br>@Component作为一种由Spirng容器托管的通用模式组件,任何被@Component标准的组件均为组件扫描的候选对象.类似的,凡是被@Component原标注的注解,如@Service,任何组件标注它时,也将被是做组件扫描的候选对象.</p><p>Spring @Enable模块装配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableFeignClients(basePackages = &#123;&quot;&quot;&#125;)</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">@SpringBootApplication(scanBasePackages = &#123;&quot;&quot;&#125;)</span><br><span class="line">@EnableScheduling</span><br><span class="line">@ServletComponentScan</span><br><span class="line">@EnableAsync(proxyTargetClass = true)</span><br></pre></td></tr></table></figure><p>Spirng条件装配 </p><h2 id="Spring-Boot-提供的条件注解"><a href="#Spring-Boot-提供的条件注解" class="headerlink" title="Spring Boot 提供的条件注解"></a>Spring Boot 提供的条件注解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ConditionalOnBean：当容器里有指定 Bean 的条件下</span><br><span class="line">@ConditionalOnMissingBean：当容器里没有指定 Bean 的情况下</span><br><span class="line">@ConditionalOnSingleCandidate：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</span><br><span class="line">@ConditionalOnClass：当类路径下有指定类的条件下</span><br><span class="line">@ConditionalOnMissingClass：当类路径下没有指定类的条件下</span><br><span class="line">@ConditionalOnProperty：指定的属性是否有指定的值</span><br><span class="line">@ConditionalOnResource：类路径是否有指定的值</span><br><span class="line">@ConditionalOnExpression：基于 SpEL 表达式作为判断条件</span><br><span class="line">@ConditionalOnJava：基于 Java 版本作为判断条件</span><br><span class="line">@ConditionalOnJndi：在 JNDI 存在的条件下差在指定的位置</span><br><span class="line">@ConditionalOnNotWebApplication：当前项目不是 Web 项目的条件下</span><br><span class="line">@ConditionalOnWebApplication：当前项目是 Web 项 目的条件下</span><br></pre></td></tr></table></figure><h2 id="拿模块装配为例子可以继续提问：自定义的模块装配有几种实现方式？-自动化注解方式和selector接口编程的方式这两种比较各有什么特点？我们如何选择？-可以各举个spring中实际实现的例子吗？"><a href="#拿模块装配为例子可以继续提问：自定义的模块装配有几种实现方式？-自动化注解方式和selector接口编程的方式这两种比较各有什么特点？我们如何选择？-可以各举个spring中实际实现的例子吗？" class="headerlink" title="拿模块装配为例子可以继续提问：自定义的模块装配有几种实现方式？ 自动化注解方式和selector接口编程的方式这两种比较各有什么特点？我们如何选择？ 可以各举个spring中实际实现的例子吗？"></a>拿模块装配为例子可以继续提问：自定义的模块装配有几种实现方式？ 自动化注解方式和selector接口编程的方式这两种比较各有什么特点？我们如何选择？ 可以各举个spring中实际实现的例子吗？</h2><p>关于Java的Selector，其实也没什么好说的。说高级点就是就是多路复用。而多路复用是由于操作系统的支持，才能得以实现。适合实时性要求高的场景<br>而对于自动化注解则是常用的驱动方式，适合方面是编码以及优化方面的</p><h2 id="Transactional-事务里的事务隔离级别和事务传播机制概念。"><a href="#Transactional-事务里的事务隔离级别和事务传播机制概念。" class="headerlink" title="@Transactional 事务里的事务隔离级别和事务传播机制概念。"></a>@Transactional 事务里的事务隔离级别和事务传播机制概念。</h2><p>定义一个事务受其他并发事务影响程度。事务并发引发的问题。</p><p>脏读：一个事务读取到另一个事务修改但还未提交的数据<br>不可重复读：一个事务读取数据之后,该数据被其他事务修改,此时第一个事务读取到的事务就是错误的（强调修改）<br>幻读：一个事务读取了某些数据,没提交再读取时数据多了或者少了,类似幻觉（强调增删）<br>丢失修改：两个事务都读取了数据,其中一个事务修改之后,另一个事务也做了修改,前者的修改丢失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以放在 类上 或者 方法上。 </span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 区别于 transactionManager属性</span></span><br><span class="line"><span class="comment"> * 查看 transactionManager</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选定特定的 事务管理器 SpringBoot中默认不用配置 可以是beanName或者特定的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置传播级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置事务隔离级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务只读 默认是可以修改的 如果设置为true只能执行查询相关</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定错误回滚 当未抛出该类型的错误或者其子类的错误时 不会回滚 默认是任何错误（异常）都会回滚</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 略 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果配置这个 如果抛出此异常将不会回滚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 略 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Isolation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认的隔离级别</span></span><br><span class="line"><span class="comment"> * 所有其他级别对应于JDBC隔离级别</span></span><br><span class="line"><span class="comment"> * 具体隔离级别 查看 java.sql.Connection</span></span><br><span class="line"><span class="comment"> * Mysql 默认 RR(REPEATABLE_READ)</span></span><br><span class="line"><span class="comment"> * Oracle 默认 RC(READ_COMMITTED)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未提交读 什么问题都不解决</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_READ_UNCOMMITTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交读 解决脏读</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_READ_COMMITTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重复读 解决脏读和不可重复读 不解决幻读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 串行读 解决所有的事务隔离问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Isolation(<span class="keyword">int</span> value) &#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Support a current transaction, create a new one if none exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is the default setting of a transaction annotation.</span></span><br><span class="line"><span class="comment"> * 外围有事务则加入形成同一个事务,外围无事务则新开启,内部事务之间相互独立</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Support a current transaction, execute non-transactionally if none exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: For transaction managers with transaction synchronization,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> SUPPORTS&#125; is slightly different from no transaction at all,</span></span><br><span class="line"><span class="comment"> * as it defines a transaction scope that synchronization will apply for.</span></span><br><span class="line"><span class="comment"> * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc)</span></span><br><span class="line"><span class="comment"> * will be shared for the entire specified scope. Note that this depends on</span></span><br><span class="line"><span class="comment"> * the actual synchronization configuration of the transaction manager.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization</span></span><br><span class="line"><span class="comment"> * 若外围没有事务则非事务执行,有事务则同 REQUIRED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Support a current transaction, throw an exception if none exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * 使用外围事务,若外围无事务则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new transaction, and suspend the current transaction if one exists.</span></span><br><span class="line"><span class="comment"> * Analogous to the EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span></span><br><span class="line"><span class="comment"> * on all transaction managers. This in particular applies to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span></span><br><span class="line"><span class="comment"> * which requires the &#123;<span class="doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span></span><br><span class="line"><span class="comment"> * made available to it (which is server-specific in standard Java EE).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span></span><br><span class="line"><span class="comment"> * 外围有无事务都开启新事务,相互独立,且与外围事务相互独立开 如果当前有事务,就把当前的事务挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute non-transactionally, suspend the current transaction if one exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span></span><br><span class="line"><span class="comment"> * on all transaction managers. This in particular applies to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span></span><br><span class="line"><span class="comment"> * which requires the &#123;<span class="doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span></span><br><span class="line"><span class="comment"> * made available to it (which is server-specific in standard Java EE).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span></span><br><span class="line"><span class="comment"> * 非事务执行,若外围存在事务则挂起该事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute non-transactionally, throw an exception if a transaction exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * 非事务执行,当外围有事务则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute within a nested transaction if a current transaction exists,</span></span><br><span class="line"><span class="comment"> * behave like &#123;<span class="doctag">@code</span> REQUIRED&#125; otherwise. There is no analogous feature in EJB.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific</span></span><br><span class="line"><span class="comment"> * transaction managers. Out of the box, this only applies to the JDBC</span></span><br><span class="line"><span class="comment"> * DataSourceTransactionManager. Some JTA providers might support nested</span></span><br><span class="line"><span class="comment"> * transactions as well.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.jdbc.datasource.DataSourceTransactionManager</span></span><br><span class="line"><span class="comment"> * 外围无事务,则同 REQUIRED 内部开启新事务相互独立。外围有事务,则内部事务是其子事务,主事务回滚则子事务全部回滚,子事务回滚不影响其他子事务和主事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Propagation(<span class="keyword">int</span> value) &#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Spring-依赖注入概念和-Autowired-的用法。"><a href="#Spring-依赖注入概念和-Autowired-的用法。" class="headerlink" title="Spring 依赖注入概念和@Autowired 的用法。"></a>Spring 依赖注入概念和@Autowired 的用法。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">概念：实例不再由程序员实例化,而是通过spring容器帮我们<span class="keyword">new</span>指定实例并且将实例注入到需要该对象的类。</span><br><span class="line">依赖注入能够让相互协作的软件组件保持松散耦合</span><br><span class="line"><span class="meta">@Autowired</span> 注释,它可以对类成员变量、方法及构造函数进行标注,完成自动装配的工作。 通过 <span class="meta">@Autowired</span>的使用来消除 set ,get方法。也可作用与集合上</span><br><span class="line">这里授权服务配置类是继承了AuthorizationServerConfigurerAdapter,而AuthorizationServerConfigurerAdapter又实现了AuthorizationServerConfigurer接口！</span><br><span class="line">源码AuthorizationServerConfigurer</span><br><span class="line"><span class="meta">@Autowired</span>对List自动注入</span><br><span class="line"><span class="comment">//@Autowired注解用在接口的集合上面,所有实现该接口的实现类都会在该集合中</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;IAsynTask&gt; tasks = Collections.emptyList();</span><br></pre></td></tr></table></figure><h2 id="Spring-Bean-的生命周期。"><a href="#Spring-Bean-的生命周期。" class="headerlink" title="Spring Bean 的生命周期。"></a>Spring Bean 的生命周期。</h2><p>Bean 的生命周期概括起来就是 4 个阶段：</p><p>实例化（Instantiation）<br>属性赋值（Populate）<br>初始化（Initialization）<br>销毁（Destruction）<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/374544735d0dd4104601ef98749c7f89.jpg" alt="流程"></p><h2 id="Spring-Boot-启动流程以及底层源码"><a href="#Spring-Boot-启动流程以及底层源码" class="headerlink" title="Spring Boot 启动流程以及底层源码"></a>Spring Boot 启动流程以及底层源码</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/05-305138350.jpg" alt="流程"></p><h2 id="索引的数据结构（比如-B-树）"><a href="#索引的数据结构（比如-B-树）" class="headerlink" title="索引的数据结构（比如 B+树）"></a>索引的数据结构（比如 B+树）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">B+Tree</span><br><span class="line">B+Tree相对于B-Tree有几点不同：</span><br><span class="line">非叶子节点只存储键值信息。</span><br><span class="line">所有叶子节点之间都有一个链指针。</span><br><span class="line">数据记录都存放在叶子节点中。</span><br><span class="line">查询速度快,但是占用空间</span><br><span class="line">索引结构：B-Tree B+Tree B：balance</span><br><span class="line">B-Tree：平衡二叉树</span><br><span class="line">特点：</span><br><span class="line"><span class="number">1.</span>具有数据节点</span><br><span class="line"><span class="number">2.</span>指向下层指针</span><br><span class="line"><span class="number">3.</span>指向数据指针</span><br><span class="line">缺页查询,产生IO</span><br><span class="line">B+Tree：</span><br><span class="line">特点:</span><br><span class="line"><span class="number">1.</span>具有数据节点</span><br><span class="line"><span class="number">2.</span>指向下层指针</span><br><span class="line">命中数据<span class="number">3</span>层查找后查询数据指针</span><br><span class="line">加载更快,产生更少IO</span><br><span class="line">效率：BTree更高,但从IO角度,Mysql选择B+Tree</span><br><span class="line"></span><br><span class="line">Hash 索引的特点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hash 索引只能够用于使用 = 或者 &lt;=&gt; 运算符的相等比较(但是速度更快)。Hash 索引不能够用于诸如 &lt; 等</span><br><span class="line">用于查找一个范围值的比较运算符。依赖于这种单值查找的系统被称为 “键-值存储”；对于这种系统,尽可能地使用 hash 索引。</span><br><span class="line">优化器不能够使用 hash 索引来加速 ORDER BY 操作。这种类型的索引不能够用于按照顺序查找下一个条目。</span><br><span class="line">MySql 无法使用 hash 索引估计两个值之间有多少行(这种情况由范围优化器来决定使用哪个索引)。如果你将一张 MyISAM 或 InnoDB 表转换成一个 hash 索引的内存表时,一些查询可能会受此影响。</span><br><span class="line">查找某行记录必须进行全键匹配。而 B-tree 索引,任何该键的左前缀都可用以查找记录</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font color="red">索引是为了加速对表中数据行的检索而创建的一种分散的存储结构</font><br>建索引的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_xxx <span class="keyword">USING</span> BTREE <span class="keyword">ON</span> tablename (字段,字段,字段);</span><br></pre></td></tr></table></figure><p>索引的种类尤其是复合索引以及对应的回表和最左匹配原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">普通索引：最基本的索引,没有任何约束限制。</span><br><span class="line">唯一索引：和普通索引类似,但是具有唯一性约束,可以有 <span class="keyword">null</span></span><br><span class="line">主键索引：特殊的唯一索引,不允许有 <span class="keyword">null</span>,一张表最多一个主键索引</span><br><span class="line">组合索引：多列值组成一个索引,用于组合搜索,效率大于索引合并</span><br><span class="line">全文索引：对文本的内容进行分词、搜索</span><br><span class="line">覆盖索引：查询列要被所建的索引覆盖,不必读取数据行</span><br><span class="line"><span class="number">1</span>、复合索引绑定的第一个列,没有出现在查询条件中;</span><br><span class="line">举例说明：为emp表插入索引idx_age_deptid_name(age,deptid,name),但是在查询条件中未使用age,导致复合索引全部失效。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、复合索引绑定的多个列是有顺序的,某一个列没有出现在查询条件中,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里没有deptid列,会导致复合索引中的deptid及其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>查询条件中出现某个列是范围查询的,存储引擎不能使用复合索引中该列其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里deptid列使用到了范围查询,会导致复合索引中的deptid其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>查询条件中某列使用否定条件的（!= &lt;&gt; IS NOT NULL）,存储引擎不能使用索引中该列其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里deptid列使用到了否定条件,会导致复合索引中的deptid其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>查询条件中某列使用LIKE条件后的字段是以%开头的（如：’%ABC’）,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里name列使用到了like ‘%a’,会导致复合索引中的name及其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>查询条件中某列使用函数的,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里name列使用到了like ‘%a’,会导致复合索引中的name及其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>查询条件中某列使用类型转换的（包括显示的和隐示的）,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">如：字符串类型的列NAME=<span class="number">3</span>,就是隐示的类型转换,将INT型转换为字符串类型。如果写为NAME=’<span class="number">3</span>’,就不是类型转换。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件name=<span class="number">3</span>,会导致复合索引中的name及其后的索引失效。条件写成name=‘<span class="number">3</span>’,索引就不会失效。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>如果索引的列在 select 所需获得的列中（因为在 mysql 中索引是根据索引列的值进行排序的,所以索引节点中存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表,如果 select 所需获得列中有大量的非索引列,索引就需要到表中找到相应的列的信息,这就叫回表。<br>使用聚集索引（主键或第一个唯一索引）就不会回表,普通索引就会回表</p><h2 id="索引下推优化"><a href="#索引下推优化" class="headerlink" title="索引下推优化,"></a>索引下推优化,</h2><p>可以在索引遍历过程中,对索引中包含的字段先做判断,过滤掉不符合条件的记录,减少回表字数。<br>最左匹配原则<br>带头大哥不能死,中间兄弟不能断</p><h2 id="Spring-AOP-底层原理"><a href="#Spring-AOP-底层原理" class="headerlink" title="Spring AOP 底层原理"></a>Spring AOP 底层原理</h2><p>AOP 底层是采用动态代理机制实现的：接口+实现类</p><h2 id="如果要代理的对象-实现了某个接口-那么-Spring-AOP-会使用-JDK-Proxy-去创建代"><a href="#如果要代理的对象-实现了某个接口-那么-Spring-AOP-会使用-JDK-Proxy-去创建代" class="headerlink" title="如果要代理的对象,实现了某个接口,那么 Spring AOP 会使用 JDK Proxy,去创建代"></a>如果要代理的对象,实现了某个接口,那么 Spring AOP 会使用 JDK Proxy,去创建代</h2><p>理对象。</p><h2 id="没有实现接口的对象-就无法使用-JDK-Proxy-去进行代理了-这时候-Spring-AOP-会使用"><a href="#没有实现接口的对象-就无法使用-JDK-Proxy-去进行代理了-这时候-Spring-AOP-会使用" class="headerlink" title="没有实现接口的对象,就无法使用 JDK Proxy 去进行代理了,这时候 Spring AOP 会使用"></a>没有实现接口的对象,就无法使用 JDK Proxy 去进行代理了,这时候 Spring AOP 会使用</h2><p>Cglib 生成一个被代理对象的子类来作为代理。<br>就是由代理创建出一个和 impl 实现类平级的一个对象,但是这个对象不是一个真正的对象,<br>只是一个代理对象,但它可以实现和 impl 相同的功能,这个就是 aop 的横向机制原理,这<br>样就不需要修改源代码。</p><h2 id><a href="#" class="headerlink" title></a></h2><p>HashMap在java1.7之前底层数据结构是数组+链表,1.8之后是数组+链表+红黑树,<br>在1.7以前的put方法采用的是头插法,当hash碰撞次数到达8,且桶内元素到达64个的时候形成链表,但是在极端情况下会造成链表过长,效率变低,并且在rehash的时候,头插法会造成回环链首尾相连,形成死锁,在java1.8以后采用红黑树,除了添加效率都高,是线程不安全的,不安全示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class HashMapTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMapThread thread0 = new HashMapThread();</span><br><span class="line">        HashMapThread thread1 = new HashMapThread();</span><br><span class="line">        HashMapThread thread2 = new HashMapThread();</span><br><span class="line">        HashMapThread thread3 = new HashMapThread();</span><br><span class="line">        HashMapThread thread4 = new HashMapThread();</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HashMapThread extends Thread &#123;</span><br><span class="line">    private static AtomicInteger ai = new AtomicInteger();</span><br><span class="line">    private static Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (ai.get() &lt; 1000000) &#123;</span><br><span class="line">            map.put(ai.get(), ai.get());</span><br><span class="line">            ai.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h2><p>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。 ## HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值,然后通过 (n -</p><ol><li>&amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度）,如果当前位置存在<br>元素的话,就判断该元素与要存入的元素的 hash 值以及 key 是否相同,如果相同的话,<br>直接覆盖,不相同就通过拉链法解决冲突。<br>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了<br>防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。<h2 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h2>当链表长度大于阈值（默认为 8）时,会首先调用 treeifyBin()方法。这个方法会根据<br>HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下,才会<br>执行转换红黑树操作,以减少搜索时间。否则,就是只是执行 resize() 方法对数组扩容。</li></ol><p>1.通常代替HashMap的安全由HashTable代替,但是多线程下他的put.get方法都是synchronized,效率太低,<br>2.Collections.synchronizedMap(),底层仍是synchronized<br>3.java9实现Collections.of()<br>ConcurrentHashMap 与 ConcurrentSkipListMap<br>ConcurrentHashMap 加锁<br>ConcurrentSkipListMap 不需要加锁,浪费空间,<br>4.ConcurrentHashMap<br>ConcurrentHashMap如何保证线程安全,在1.7以前由划分segment分段锁机制,共计16个并发级别,隔离级别太大,有很多空间就浪费了,太小就段内的元素过多<br>1.8以后是cas算法C语言写得,无锁算法,put添加的时候,链表+红黑树<br>put方法（无锁添加）</p><h2 id="3、HashMap-的扩容机制是怎样的？"><a href="#3、HashMap-的扩容机制是怎样的？" class="headerlink" title="3、HashMap 的扩容机制是怎样的？"></a>3、HashMap 的扩容机制是怎样的？</h2><p>一般情况下,当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的 2 倍。<br>HashMap 的容量是有上限的,必须小于 1&lt;&lt;30,即 1073741824。如果容量超出了这个<br>数,则不再增长,且阈值会被设置为 Integer.MAX_VALUE。<br>JDK7 中的扩容机制<br>空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是空数<br>组。<br>有参构造函数：根据参数确定容量、负载因子、阈值等。<br>第一次 put 时会初始化数组,其容量变为不小于指定容量的 2 的幂数,然后根据负载因子<br>确定阈值。<br>如果不是第一次扩容,则 新容量=旧容量 x 2 ,新阈值=新容量 x 负载因子 。<br>JDK8 的扩容机制<br>空参数的构造函数：实例化的 HashMap 默认内部数组是 null,即没有实例化。第一次调<br>用 put 方法时,则会开始第一次初始化扩容,长度为 16。 ## 有参构造函数：用于指定容量。会根据指定的正整数找到不小于指定容量的 2 的幂数,将<br>这个数设置赋值给阈值（threshold）。第一次调用 put 方法时,会将阈值赋值给容量,<br>然后让 阈值 = 容量 x 负载因子。 ## 如果不是第一次扩容,则容量变为原来的 2 倍,阈值也变为原来的 2 倍。（容量和阈值都<br>变为原来的 2 倍时,负载因子还是不变）。<br>此外还有几个细节需要注意：<br>首次 put 时,先会触发扩容（算是初始化）,然后存入数据,然后判断是否需要扩容；<br>不是首次 put,则不再初始化,直接存入数据,然后判断是否需要扩容；</p><h2 id="4、ConcurrentHashMap-的存储结构是怎样的？"><a href="#4、ConcurrentHashMap-的存储结构是怎样的？" class="headerlink" title="4、ConcurrentHashMap 的存储结构是怎样的？"></a>4、ConcurrentHashMap 的存储结构是怎样的？</h2><p>Java7 中 ConcurrnetHashMap 使用的分段锁,也就是每一个 Segment 上同时只有一个<br>线程可以操作,每一个 Segment 都是一个类似 HashMap 数组的结构,它可以扩容,它<br>的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变,默认 Segment 的<br>个数是 16 个。<br>Java8 中的 ConcurrnetHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由<br>Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红<br>黑树,Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红<br>黑树,在冲突小于一定数量时又退回链表。</p><h2 id="5、线程池大小如何设置？"><a href="#5、线程池大小如何设置？" class="headerlink" title="5、线程池大小如何设置？"></a>5、线程池大小如何设置？</h2><p>CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源,可以将线程数设置为 N （CPU 核心数）+1,比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断,<br>或者其它原因导致的任务暂停而带来的影响。一旦任务暂停,CPU 就会处于空闲状态,而<br>在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。<br>I/O 密集型任务(2N)： 这种任务应用起来,系统会用大部分的时间来处理 I/O 交互,而<br>线程在处理 I/O 的时间段内不会占用 CPU 来处理,这时就可以将 CPU 交出给其它线程<br>使用。因此在 I/O 密集型任务的应用中,我们可以多配置一些线程,具体的计算方法是<br>2N。</p><h2 id="如何判断是-CPU-密集任务还是-IO-密集任务？"><a href="#如何判断是-CPU-密集任务还是-IO-密集任务？" class="headerlink" title="如何判断是 CPU 密集任务还是 IO 密集任务？"></a>如何判断是 CPU 密集任务还是 IO 密集任务？</h2><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单<br>凡涉及到网络读取,文件读取这类都是 IO 密集型,这类任务的特点是 CPU 计算耗费时间相<br>比于等待 IO 操作完成的时间来说很少,大部分时间都花在了等待 IO 操作完成上。<br>6、IO 密集=Ncpu*2 是怎么计算出来？</p><p>I/O 密集型任务任务应用起来,系统会用大部分的时间来处理 I/O 交互,而线程在处理<br>I/O 的时间段内不会占用 CPU 来处理,这时就可以将 CPU 交出给其它线程使用。因此在<br>I/O 密集型任务的应用中,我们可以多配置一些线程。例如：数据库交互,文件上传下<br>载,网络传输等。IO 密集型,即该任务需要大量的 IO,即大量的阻塞,故需要多配置线<br>程数。</p><h2 id="7、G1-收集器有哪些特点？"><a href="#7、G1-收集器有哪些特点？" class="headerlink" title="7、G1 收集器有哪些特点？"></a>7、G1 收集器有哪些特点？</h2><p>G1 的全称是 Garbage-First,意为垃圾优先,哪一块的垃圾最多就优先清理它。<br>G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布,变成可预期且可配置的。<br>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：<br>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势,使用多个 CPU（CPU 或者<br>CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程<br>执行的 GC 动作,G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</p><h2 id="分代收集：虽然-G1-可以不需要其他收集器配合就能独立管理整个-GC-堆-但是还是保留"><a href="#分代收集：虽然-G1-可以不需要其他收集器配合就能独立管理整个-GC-堆-但是还是保留" class="headerlink" title="分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆,但是还是保留"></a>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆,但是还是保留</h2><p>了分代的概念。<br>空间整合：与 CMS 的“标记-清理”算法不同,G1 从整体来看是基于“标记-整理”算法<br>实现的收集器；从局部上来看是基于“标记-复制”算法实现的。<br>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势,降低停顿时间是 G1 和 CMS 共<br>同的关注点,但 G1 除了追求低停顿外,还能建立可预测的停顿时间模型,能让使用者明<br>确指定在一个长度为 M 毫秒的时间片段内。<br>G1 收集器在后台维护了一个优先列表,每次根据允许的收集时间,优先选择回收价值最大的<br>Region（这也就是它的名字 Garbage-First 的由来）</p><h2 id="8、你有哪些手段来排查-OOM-的问题？"><a href="#8、你有哪些手段来排查-OOM-的问题？" class="headerlink" title="8、你有哪些手段来排查 OOM 的问题？"></a>8、你有哪些手段来排查 OOM 的问题？</h2><p>增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -<br>XX:HeapDumpPath=/tmp/heapdump.hprof,当 OOM 发生时自动 dump 堆内存信<br>息到指定目录。<br>同时 jstat 查看监控 JVM 的内存和 GC 情况,先观察问题大概出在什么区域。<br>使用 MAT 工具载入到 dump 文件,分析大对象的占用情况,比如 HashMap 做缓存未<br>清理,时间长了就会内存溢出,可以把改为弱引用。</p><h2 id="9、请你谈谈-MySQL-事务隔离级别-MySQL-的默认隔离级别是什么？"><a href="#9、请你谈谈-MySQL-事务隔离级别-MySQL-的默认隔离级别是什么？" class="headerlink" title="9、请你谈谈 MySQL 事务隔离级别,MySQL 的默认隔离级别是什么？"></a>9、请你谈谈 MySQL 事务隔离级别,MySQL 的默认隔离级别是什么？</h2><p>为了达到事务的四大特性,数据库定义了 4 种不同的事务隔离级别：<br> READ-UNCOMMITTED（读取未提交）：最低的隔离级别,允许脏读,也就是可能读取<br>到其他会话中未提交事务修改的数据,可能会导致脏读、幻读或不可重复读。<br> READ-COMMITTED（读取已提交）： 只能读取到已经提交的数据。Oracle 等多数数据<br>库默认都是该级别 （不重复读）,可以阻止脏读,但是幻读或不可重复读仍有可能发生。<br>REPEATABLE-READ（可重复读）：对同一字段的多次读取结果都是一致的,除非数据是<br>被本身事务自己所修改,可以阻止脏读和不可重复读,但幻读仍有可能发生。<br>SERIALIZABLE（可串行化）：最高的隔离级别,完全服从 ACID 的隔离级别。所有的事<br>务依次逐个执行,这样事务之间就完全不可能产生干扰,也就是说,该级别可以防止脏<br>读、不可重复读以及幻读。<br> MySQL 默认采用的 REPEATABLE_READ 隔离级别。</p><h2 id="可重复读解决了哪些问题？"><a href="#可重复读解决了哪些问题？" class="headerlink" title="可重复读解决了哪些问题？"></a>可重复读解决了哪些问题？</h2><p> 可重复读的核心就是一致性读(consistent read);保证多次读取同一个数据时,其值都和事<br>务开始时候的内容是一致,禁止读取到别的事务未提交的数据,会造成幻读。<br> 而事务更新数据的时候,只能用当前读。如果当前的记录的行锁被其他事务占用的话,就<br>需要进入锁等待。<br>32<br> 查询只承认在事务启动前就已经提交完成的数据。<br> 可重复读解决的是重复读的问题,可重复读在快照读的情况下是不会有幻读,但当前读的<br>时候会有幻读。</p><h2 id="11、对-SQL-慢查询会考虑哪些优化-？"><a href="#11、对-SQL-慢查询会考虑哪些优化-？" class="headerlink" title="11、对 SQL 慢查询会考虑哪些优化 ？"></a>11、对 SQL 慢查询会考虑哪些优化 ？</h2><p> 分析语句,是否加载了不必要的字段/数据。<br> 分析 SQL 执行计划（explain extended）,思考可能的优化点,是否命中索引等。<br> 查看 SQL 涉及的表结构和索引信息。<br> 如果 SQL 很复杂,优化 SQL 结构。<br> 按照可能的优化点执行表结构变更、增加索引、SQL 改写等操作。<br> 查看优化后的执行时间和执行计划。<br> 如果表数据量太大,考虑分表。<br> 利用缓存,减少查询次数</p><h2 id="12、谈一谈缓存穿透、缓存击穿和缓存雪崩-以及解决办法？"><a href="#12、谈一谈缓存穿透、缓存击穿和缓存雪崩-以及解决办法？" class="headerlink" title="12、谈一谈缓存穿透、缓存击穿和缓存雪崩,以及解决办法？"></a>12、谈一谈缓存穿透、缓存击穿和缓存雪崩,以及解决办法？</h2><p>缓存穿透<br> 问题：大量并发查询不存在的 KEY,在缓存和数据库中都不存在,同时给缓存和数据库带<br>来压力。<br> 原因：一般而言,缓存穿透有 2 种可能性：业务数据被误删,导致缓存和数据库中都没有<br>数据。恶意进行 ddos 攻击。<br> 分析：为什么会多次透传呢？不存在 一直为空,需要注意让缓存能够区分 KEY 不存在和<br>查询到一个空值。<br> 解决办法：缓存空值的 KEY,这样第一次不存在也会被加载会记录,下次拿到有这个<br>KEY。Bloom 过滤或 RoaingBitmap 判断 KEY 是否存在,如果布隆过滤器中没有查到这<br>个数据,就不去数据库中查。在处理请求前增加恶意请求检查,如果检测到是恶意攻击,<br>则拒绝进行服务。完全以缓存为准,使用延迟异步加载的策略（异步线程负责维护缓存的<br>数据,定期或根据条件触发更新）,这样就不会触发更新。<br>缓存击穿<br> 问题：某个 KEY 失效的时候,正好有大量并发请求访问这个 KEY。  分析：跟穿透其实很像,属于比较偶然的。<br> 解决办法：KEY 的更新操作添加全局互斥锁。完全以缓存为准,使用延迟异步加载的策略<br>（异步线程负责维护缓存的数据,定期或根据条件触发更新）,这样就不会触发更新。<br>缓存雪崩<br> 问题：当某一时刻发生大规模的缓存失效的情况,导致大量的请求无法获取数据,从而将<br>流量压力传导到数据库上,导致数据库压力过大甚至宕机。<br> 原因：一般而言,缓存雪崩有 2 种可能性：大量的数据同一个时间失效：比如业务关系强<br>相关的数据要求同时失效 Redis 宕机<br> 分析：一般来说,由于更新策略、或者数据热点、缓存服务宕机等原因,可能会导致缓存<br>数据同一个时间点大规模不可用,或者都更新。所以,需要我们的更新策略要在时间上合<br>适,数据要均匀分享,缓存服务器要多台高可用。<br> 解决办法：更新策略在时间上做到比较平均。如果数据需要同一时间失效,可以给这批数<br>据加上一些随机值,使得这批数据不要在同一个时间过期,降低数据库的压力。使用的热<br>数据尽量分散到不同的机器上。多台机器做主从复制或者多副本,实现高可用。做好主从<br>的部署,当主节点挂掉后,能快速的使用从结点顶上。实现熔断限流机制,对系统进行负<br>载能力控制。对于非核心功能的业务,拒绝其请求,只允许核心功能业务访问数据库获取<br>数据。服务降价：提供默认返回值,或简单的提示信息。</p><h2 id="13、LRU-是什么？如何实现？"><a href="#13、LRU-是什么？如何实现？" class="headerlink" title="13、LRU 是什么？如何实现？"></a>13、LRU 是什么？如何实现？</h2><p>最近最少使用策略 LRU（Least Recently Used）是一种缓存淘汰算法,是一种缓存淘汰机<br>制。<br> 使用双向链表实现的队列,队列的最大容量为缓存的大小。在使用过程中,把最近使用的<br>页面移动到队列头,最近没有使用的页面将被放在队列尾的位置<br> 使用一个哈希表,把页号作为键,把缓存在队列中的节点的地址作为值,只需要把这个页<br>对应的节点移动到队列的前面,如果需要的页面在内存中,此时需要把这个页面加载到内<br>存中,简单的说,就是将一个新节点添加到队列前面,并在哈希表中跟新相应的节点地<br>址,如果队列是满的,那么就从队尾移除一个节点,并将新节点添加到队列的前面。</p><h2 id="14、什么是堆内存？参数如何设置？"><a href="#14、什么是堆内存？参数如何设置？" class="headerlink" title="14、什么是堆内存？参数如何设置？"></a>14、什么是堆内存？参数如何设置？</h2><p>堆内存是指由程序代码自由分配的内存,与栈内存作区分。<br>在 Java 中,堆内存主要用于分配对象的存储空间,只要拿到对象引用,所有线程都可<br>以访问堆内存。<br> -Xmx, 指定最大堆内存。 如 -Xmx4g. 这只是限制了 Heap 部分的最大值为 4g。这个内<br>存不包括栈内存,也不包括堆外使用的内存。<br> -Xms, 指定堆内存空间的初始大小。 如 -Xms4g。 而且指定的内存大小,并不是操作系<br>统实际分配的初始值,而是 GC 先规划好,用到才分配。 专用服务器上需要保持 –Xms<br>和 –Xmx 一致,否则应用刚启动可能就有好几个 FullGC。当两者配置不一致时,堆内存<br>扩容可能会导致性能抖动。<br>34<br> -Xmn, 等价于 -XX:NewSize,使用 G1 垃圾收集器 不应该 设置该选项,在其他的某些业<br>务场景下可以设置。官方建议设置为 -Xmx 的 1/2 ~ 1/4.<br> -XX：MaxPermSize=size, 这是 JDK1.7 之前使用的。Java8 默认允许的 Meta 空间无限<br>大,此参数无效。<br> -XX：MaxMetaspaceSize=size, Java8 默认不限制 Meta 空间, 一般不允许设置该选<br>项。<br> -XX：MaxDirectMemorySize=size,系统可以使用的最大堆外内存,这个参数跟 -<br>Dsun.nio.MaxDirectMemorySize 效果相同。<br> -Xss, 设置每个线程栈的字节数。 例如 -Xss1m 指定线程栈为 1MB,与-<br>XX:ThreadStackSize=1m 等价</p><h2 id="15、栈和队列-举个使用场景例子？"><a href="#15、栈和队列-举个使用场景例子？" class="headerlink" title="15、栈和队列,举个使用场景例子？"></a>15、栈和队列,举个使用场景例子？</h2><p> 栈（后进先出）可以用于字符匹配,数据反转等场景<br> 队列（先进先出）可以用于任务队列,共享打印机等场景</p><h2 id="16、MySQL-为什么-InnoDB-是默认引擎？"><a href="#16、MySQL-为什么-InnoDB-是默认引擎？" class="headerlink" title="16、MySQL 为什么 InnoDB 是默认引擎？"></a>16、MySQL 为什么 InnoDB 是默认引擎？</h2><p>MyISAM与InnoDB 的区别（9个不同点）<br>区别：</p><ol><li><p>InnoDB支持事务,MyISAM不支持,对于InnoDB每一条SQL语言都默认封装成事务,自动提交,这样会影响速度,所以最好把多条SQL语言放在begin和commit之间,组成一个事务； </p></li><li><p>InnoDB支持外键,而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； </p></li><li><p>InnoDB是聚集索引,使用B+Tree作为索引结构,数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构）,必须要有主键,通过主键索引效率很高。但是辅助索引需要两次查询,先查询到主键,然后再通过主键查询到数据。因此,主键不应该过大,因为主键太大,其他索引也都会很大。</p><pre><code>MyISAM是非聚集索引,也是使用B+Tree作为索引结构,索引和数据文件是分离的,索引保存的是数据文件的指针。主键索引和辅助索引是独立的。也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件,辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</code></pre></li><li><p>InnoDB不保存表的具体行数,执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数,执行上述语句时只需要读出该变量即可,速度很快（注意不能加有任何WHERE条件）；</p></li></ol><p>那么为什么InnoDB没有了这个变量呢？</p><pre><code>因为InnoDB的事务特性,在同一时刻表中的行数对于不同的事务而言是不一样的,因此count统计会计算对于当前事务而言可以统计到的行数,而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在,InnoDB还会尝试去遍历其他聚簇索引。如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中,count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样,如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS</code></pre><ol start="5"><li><p>Innodb不支持全文索引,而MyISAM支持全文索引,在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了</p></li><li><p>MyISAM表格可以被压缩后进行查询操作</p></li><li><p>InnoDB支持表、行(默认)级锁,而MyISAM支持表级锁</p><pre><code>InnoDB的行锁是实现在索引上的,而不是锁在物理行记录上。潜台词是,如果访问没有命中索引,也无法使用行锁,将要退化为表锁。</code></pre></li></ol><p>例如：</p><pre><code>t_user(uid, uname, age, sex) innodb;uid PK无其他索引update t_user set age=10 where uid=1;             命中索引,行锁。update t_user set age=10 where uid != 1;           未命中索引,表锁。update t_user set age=10 where name=&#39;chackca&#39;;    无索引,表锁。</code></pre><p>8、InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键）,而Myisam可以没有</p><p>9、Innodb存储文件有frm、ibd,而Myisam是frm、MYD、MYI</p><pre><code>    Innodb：frm是表定义文件,ibd是数据文件    Myisam：frm是表定义文件,myd是数据文件,myi是索引文件</code></pre><p>如何选择：<br>    1. 是否要支持事务,如果要请选择innodb,如果不需要可以考虑MyISAM；</p><pre><code>2. 如果表中绝大多数都只是读查询,可以考虑MyISAM,如果既有读也有写,请使用InnoDB。3. 系统奔溃后,MyISAM恢复起来更困难,能否接受；4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM),说明其优势是有目共睹的,如果你不知道用什么,那就用InnoDB,至少不会差。</code></pre><p>InnoDB为什么推荐使用自增ID作为主键？</p><pre><code>答：自增ID可以保证每次插入时B+索引是从右边扩展的,可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键,会使得数据随机插入,效率比较差。</code></pre><p>innodb引擎的4大特性</p><pre><code>   插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)</code></pre><h2 id="19、MVCC-是什么？它的底层原理是什么？"><a href="#19、MVCC-是什么？它的底层原理是什么？" class="headerlink" title="19、MVCC 是什么？它的底层原理是什么？"></a>19、MVCC 是什么？它的底层原理是什么？</h2><p>MVCC,多版本并发控制,它是通过读取历史版本的数据,来降低并发事务冲突,从而提高并<br>发性能的一种机制。<br> 事务版本号<br> 表的隐藏列<br> undo log<br> read view</p><h2 id="20、undo-log-具体怎么回滚事务-？"><a href="#20、undo-log-具体怎么回滚事务-？" class="headerlink" title="20、undo log 具体怎么回滚事务 ？"></a>20、undo log 具体怎么回滚事务 ？</h2><p>举个例子：<br> 对于 insert 类型的 sql,会在 undo log 中记录下方才你 insert 进来的数据的 ID,当你想<br>roll back 时,根据 ID 完成精准的删除。<br> 对于 delete 类型的 sql,会在 undo log 中记录方才你删除的数据,当你回滚时会将删除<br>前的数据 insert 进去。<br> 对于 update 类型的 sql,会在 undo log 中记录下修改前的数据,回滚时只需要反向<br>update 即可。<br> 对于 select 类型的 sql,别费心了,select 不需要回滚。</p><h2 id="22、索引失效的情况有哪些？"><a href="#22、索引失效的情况有哪些？" class="headerlink" title="22、索引失效的情况有哪些？"></a>22、索引失效的情况有哪些？</h2><p> like 以%开头索引无效,当 like 以&amp;结尾,索引有效。<br> or 语句前后没有同事使用索引,当且仅当 or 语句查询条件的前后列均为索引时,索引生<br>效。<br> 组合索引,使用的不是第一列索引时候,索引失效,即最左匹配规则。<br> 数据类型出现隐式转换,如 varchar 不加单引号的时候可能会自动转换为 int 类型,这个<br>时候索引失效。<br> 在索引列上使用 IS NULL 或者 IS NOT NULL 时候,索引失效,因为索引是不索引空值<br>得。<br> 在索引字段上使用,NOT、 &lt;&gt;、！= 、时候是不会使用索引的,对于这样的处理只会进<br>行全表扫描。<br> 对索引字段进行计算操作,函数操作时不会使用索引。<br> 当全表扫描速度比索引速度快的时候不会使用索引。<br>索引失效场景一：带头大哥不能死,中间兄弟不能断</p><p>索引失效场景二：在索引列上做操作</p><p>索引失效场景三：范围条件右边全失效</p><p>索引低效场景四：select * 会降低索引的效率</p><p>索引失效场景五：使用!=或&lt;&gt;会导致索引失效</p><p>索引失效场景六、isnull和is not null字段无法使用索引</p><p>索引失效场景七、%like%查询时的索引失效问题</p><p>索引失效场景八、字符串不加单引号索引失效</p><p>索引失效场景九、少用or,用or连接索引会失效</p><h2 id="Spring-Bean-容器的生命周期是什么样的？"><a href="#Spring-Bean-容器的生命周期是什么样的？" class="headerlink" title="Spring Bean 容器的生命周期是什么样的？"></a>Spring Bean 容器的生命周期是什么样的？</h2><p> Bean 容器找到配置文件中 Spring Bean 的定义。<br> Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。<br> 如果涉及到一些属性值 利用 set()方法设置一些属性值。<br> 如果 Bean 实现了 BeanNameAware 接口,调用 setBeanName()方法,传入 Bean 的名<br>字。<br> 如果 Bean 实现了 BeanClassLoaderAware 接口,调用 setBeanClassLoader()方法,传<br>入 ClassLoader 对象的实例。<br> 如果 Bean 实现了 BeanFactoryAware 接口,调用 setBeanFactory()方法,传入<br>BeanFactory 对象的实例。<br> 与上面的类似,如果实现了其他 <code>*</code>.Aware 接口,就调用相应的方法。<br> 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象,执行<br>postProcessBeforeInitialization() 方法<br>39<br> 如果 Bean 实现了 InitializingBean 接口,执行 afterPropertiesSet()方法。<br> 如果 Bean 在配置文件中的定义包含 init-method 属性,执行指定的方法。<br> 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象,执行<br>postProcessAfterInitialization() 方法<br> 当要销毁 Bean 的时候,如果 Bean 实现了 DisposableBean 接口,执行 destroy() 方<br>法。<br> 当要销毁 Bean 的时候,如果 Bean 在配置文件中的定义包含 destroy-method 属性,执<br>行指定的方法。</p><h2 id="Redis-数据结构-压缩列表和跳跃表的区别"><a href="#Redis-数据结构-压缩列表和跳跃表的区别" class="headerlink" title="Redis 数据结构 压缩列表和跳跃表的区别"></a>Redis 数据结构 压缩列表和跳跃表的区别</h2><p>压缩列表（ziplist）本质上就是一个字节数组,是 Redis 为了节约内存而设计的一种线性<br>数据结构,可以包含多个元素,每个元素可以是一个字节数组或一个整数。<br> 跳跃表（skiplist）是一种有序数据结构,它通过在每个节点中维持多个指向其他节点的指<br>针,从而达到快速访问节点的目的。跳跃表支持平均 O（logN）、最坏 O（N）复杂度的<br>节点查找,还可以通过顺序性操作来批量处理节点</p><h2 id="1-redis的hash怎么实现的？-实现原理-rehash过程"><a href="#1-redis的hash怎么实现的？-实现原理-rehash过程" class="headerlink" title="1.redis的hash怎么实现的？(实现原理)rehash过程"></a>1.redis的hash怎么实现的？(实现原理)rehash过程</h2><p>redis初始创建hash表,有序集合,链表时, 存储结构采用一种ziplist的存储结构, 这种结构内存排列更紧密, 能提高访存性能.<br>hash_max_ziplist_entries和hash_max_ziplist_value值作为阀值,hash_max_ziplist_entries表示一旦ziplist中元素数量超过该值,则需要转换为dict结构；hash_max_ziplist_value表示一旦ziplist中数据长度大于该值,则需要转换为dict结构。<br>哈希等价于Java语言的HashMap或者是Python语言的字典（Dict）<br>redis hash 的内部结构.第一维是数组,第二维是链表.组成一个 hashtable.<br>在 Java 中 HashMap 扩容是个很耗时的操作,需要去申请新的数组,为了追求高性能,Redis 采用了渐进式 rehash 策略.这也是 hash 中最重要的部分.<br>在扩容的时候 rehash 策略会保留新旧两个 hashtable 结构,查询时也会同时查询两个 hashtable.Redis会将旧 hashtable 中的内容一点一点的迁移到新的 hashtable 中,当迁移完成时,就会用新的 hashtable 取代之前的.当 hashtable 移除了最后一个元素之后,这个数据结构将会被删除.<br><a href="https://juejin.im/post/5cfe6383e51d45599e019d8f">https://juejin.im/post/5cfe6383e51d45599e019d8f</a><br>与java的hashmap的rehash区别<br>个人理解：hashmap的rehash是一次性拷贝的,不同的是,Redis的字典只能是字符串,另外他们rehash的方式不一样,因为Java的HashMap的字典很大时,rehash是个耗时的操作,需要一次全部rehash。Redis为了追求高性能,不能堵塞服务,所以采用了渐进式rehash策略。<br>rehash的详细步骤<br><a href="https://www.cnblogs.com/meituantech/p/9376472.html">https://www.cnblogs.com/meituantech/p/9376472.html</a><br>与ConcurrentHashMap扩容的策略比较？<br>ConcurrentHashMap采用的扩容策略为： “多线程协同式rehash“。<br>1.扩容所花费的时间对比： 一个单线程渐进扩容,一个多线程协同扩容。在平均的情况下,是ConcurrentHashMap 快。这也意味着,扩容时所需要 花费的空间能够更快的进行释放。<br>2.读操作,两者性能相差不多。<br>3.写操作,Redis的字典返回更快些,因为它不像ConcurrentHashMap那样去帮着扩容(当要写的桶位已经搬到了newTable时),等扩容完才能进行操作。<br>4.删除操作,与写一样。<br><a href="http://xytschool.com/resource/236.html">http://xytschool.com/resource/236.html</a></p><h2 id="redis如何保证高可用"><a href="#redis如何保证高可用" class="headerlink" title="redis如何保证高可用"></a>redis如何保证高可用</h2><p>保证redis高可用机制需要redis主从复制、redis持久化机制、哨兵机制、keepalived等的支持。<br>主从复制的作用：数据备份、读写分离、分布式集群、实现高可用、宕机容错机制等。</p><h2 id="redis主从复制原理"><a href="#redis主从复制原理" class="headerlink" title="redis主从复制原理"></a>redis主从复制原理</h2><p>首先主从复制需要分为两个角色：master(主) 和 slave(从) ,注意：redis里面只支持一个主,不像Mysql、Nginx主从复制可以多主多从。</p><p>(1)redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave）,主数据库可以进行读写操作,当发生写操作的时候自动将数据同步到从数据库,而从数据库一般是只读的,并接收主数据库同步过来的数据,一个主数据库可以有多个从数据库,而一个从数据库只能有一个主数据库。</p><p>(2)通过redis的复制功能可以很好的实现数据库的读写分离,提高服务器的负载能力。主数据库主要进行写操作,而从数据库负责读操作。</p><p><a href="https://blog.csdn.net/itcats_cn/article/details/82428716">https://blog.csdn.net/itcats_cn/article/details/82428716</a></p><h1 id="说说redis的持久化机制-为啥不能用redis做专门的持久化数据库存储？"><a href="#说说redis的持久化机制-为啥不能用redis做专门的持久化数据库存储？" class="headerlink" title="说说redis的持久化机制,为啥不能用redis做专门的持久化数据库存储？"></a>说说redis的持久化机制,为啥不能用redis做专门的持久化数据库存储？</h1><p>个人理解：强一致性的数据是不适合放在缓存中的。另外MySQL对事务的支持也是redis本身不能达到的,需要单独实现<br>一般不是说redis or  MySQL,而是redis+MySQL<br><a href="https://blog.csdn.net/u011784767/article/details/76824822">https://blog.csdn.net/u011784767/article/details/76824822</a><br>为什么Redis进行RDB持久化数据时,新起一个进程而不是在原进程中起一个线程来持久化数据<br>(1)Redis RDB持久化机制会阻塞主进程,这样主进程就无法响应客户端请求。<br>(2)我们知道Redis对客户端响应请求的工作模型是单进程和单线程的,如果在主进程内启动一个线程,这样会造成对数据的竞争条件,为了避免使用锁降低性能。基于以上两点这就是为什么Redis通过启动一个进程来执行RDB了<br>—单线程的redis为什么这么快<br>(1)纯内存操作<br>(2)单线程操作,避免了频繁的上下文切换<br>(3)采用了非阻塞I/O多路复用机制</p><p>1</p><h2 id="Redis的数据类型以及使用场景"><a href="#Redis的数据类型以及使用场景" class="headerlink" title="Redis的数据类型以及使用场景"></a>Redis的数据类型以及使用场景</h2><p>(1)String<br>这个其实没啥好说的,最常规的set/get操作,value可以是String也可以是数字。<br>一般做一些复杂的计数功能的缓存。</p><p>(2)hash<br>这里value存放的是结构化的对象,比较方便的就是操作其中的某个字段。博主在做单点登录的时候,<br>就是用这种数据结构存储用户信息,以cookieId作为key,设置30分钟为缓存过期时间,能很好的模拟出类似session的效果。</p><p>(3)list<br>使用List的数据结构,可以做简单的消息队列的功能。另外还有一个就是,可以利用lrange命令,<br>做基于redis的分页功能,性能极佳,用户体验好。</p><p>(4)set<br>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？<br>因为我们的系统一般都是集群部署,使用JVM自带的Set,比较麻烦,难道为了一个做一个全局去重,再启一个公共服务,太麻烦了。</p><p>另外,就是利用交集、并集、差集等操作,可以计算共同喜好,全部的喜好,自己独有的喜好等功能。</p><p>(5)sorted set<br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用,取TOP N操作。sorted set可以用来做延时任务。最后一个应用就是可以做范围查找</p><h1 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h1><p>redis采用的是定期删除+惰性删除+内存淘汰策略。<br>[2020年6月29日17:25:36在平时的项目中测试,不定期会产生无用token的key数据,平时可以进行模糊删除]</p><p>缓存穿透,即黑客故意去请求缓存中不存在的数据,导致所有的请求都怼到数据库上,从而数据库连接异常。</p><p>解决方案:<br>(一)利用互斥锁,缓存失效的时候,先去获得锁,得到锁了,再去请求数据库。没得到锁,则休眠一段时间重试<br>(二)采用异步更新策略,无论key是否取到值,都直接返回。value值中维护一个缓存失效时间,缓存如果过期,<br>异步起一个线程去读数据库,更新缓存。需要做缓存预热(项目启动前,先加载缓存)操作。<br>(三)提供一个能迅速判断请求是否有效的拦截机制,比如,利用布隆过滤器,内部维护一系列合法有效的key。<br>迅速判断出,请求所携带的Key是否合法有效。如果不合法,则直接返回。</p><p>缓存雪崩,即缓存同一时间大面积的失效,这个时候又来了一波请求,结果请求都怼到数据库上,从而导致数据库连接异常。</p><p>解决方案:<br>(一)给缓存的失效时间,加上一个随机值,避免集体失效。<br>(二)使用互斥锁,但是该方案吞吐量明显下降了。<br>(三)双缓存。我们有两个缓存,缓存A和缓存B。缓存A的失效时间为20分钟,缓存B不设失效时间。<br>自己做缓存预热操作。然后细分以下几个小点<br>1 从缓存A读数据库,有则直接返回<br>2 A没有数据,直接从B读数据,直接返回,并且异步启动一个更新线程。<br>3 更新线程同时更新缓存A和缓存B。</p><h2 id="如何解决redis的并发竞争key问题"><a href="#如何解决redis的并发竞争key问题" class="headerlink" title="如何解决redis的并发竞争key问题"></a>如何解决redis的并发竞争key问题</h2><p>分析:这个问题大致就是,同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。<br>需要说明一下,博主提前百度了一下,发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。<br>因为我们的生产环境,基本都是redis集群环境,做了数据分片操作。你一个事务中有涉及到多个key操作的时候,<br>这多个key不一定都存储在同一个redis-server上。因此,redis的事务机制,十分鸡肋。</p><p>回答:如下所示<br>(1)如果对这个key操作,不要求顺序<br>这种情况下,准备一个分布式锁,大家去抢锁,抢到锁就做set操作即可,比较简单。<br>(2)如果对这个key操作,要求顺序<br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候,<br>需要保存一个时间戳。假设时间戳如下<br>系统A key 1 {valueA  3:00}<br>系统B key 1 {valueB  3:05}<br>系统C key 1 {valueC  3:10}<br>那么,假设这会系统B先抢到锁,将key1设置为{valueB 3:05}。接下来系统A抢到锁,发现自己的valueA的时间戳早于缓存中的时间戳,那就不做set操作了。以此类推。<br>redis分页<br>HSCAN testHash “0” count 10</p><p>注：测试field数量在22条时（没有测试Redis中Hash使分页生效时的field数量的下限）,分页未生效。<br>#mysql 执行一个 sql 的过程<br>执行完毕之后有一个缓存的过程<br><a href="https://www.cnblogs.com/luoying/p/12073812.html">https://www.cnblogs.com/luoying/p/12073812.html</a></p><h2 id="MySQL分页limit速度太慢的优化方法"><a href="#MySQL分页limit速度太慢的优化方法" class="headerlink" title="MySQL分页limit速度太慢的优化方法"></a>MySQL分页limit速度太慢的优化方法</h2><p>1.子查询优化法<br>先找出第一条数据,然后大于等于这条数据的id就是要获取的数据<br>缺点：数据必须是连续的,可以说不能有where条件,where条件会筛选数据,导致数据失去连续性<br>2.limit限制优化法<br>把limit偏移量限制低于某个数<br>3.where条件先过滤后分页</p><h2 id="wait-notify-为什么要搭配使用？"><a href="#wait-notify-为什么要搭配使用？" class="headerlink" title="wait notify 为什么要搭配使用？"></a>wait notify 为什么要搭配使用？</h2><p>单独调用会报异常<br>只有在调用线程拥有某个对象的独占锁时,才能够调用该对象的wait(),notify()和notifyAll()方法。因为程序验证通常是在对象的同步方法或同步代码块中调用它们的。如果尝试在未获取对象锁时调用这三个方法,<br>“java.lang.IllegalMonitorStateException:current thread not owner”。<br>底层把对象作为一个监视器</p><h2 id="栈会溢出吗？什么时候溢出？方法区会溢出吗？"><a href="#栈会溢出吗？什么时候溢出？方法区会溢出吗？" class="headerlink" title="栈会溢出吗？什么时候溢出？方法区会溢出吗？"></a>栈会溢出吗？什么时候溢出？方法区会溢出吗？</h2><p>栈是线程私有的,它的生命周期与线程相同,每个方法在执行的时候都会创建一个栈帧,用来<br>存储局部变量表,操作数栈,动态链接,方法出口等信息。局部变量表又包含基本数据类型,<br>对象引用类型。如果线程请求的栈深度大于虚拟机所允许的最大深度,将抛出<br>StackOverflowError 异常,方法递归调用产生这种结果。如果 Java 虚拟机栈可以动态扩展,<br>并且扩展的动作已经尝试过,但是无法申请到足够的内存去完成扩展,或者在新建立线程的时<br>候没有足够的内存去创建对应的虚拟机栈,那么 Java 虚拟机将抛出一个 OutOfMemory 异<br>常。(线程启动过多)。<br>方法区会发生溢出。<br>HotSpot jdk1.7 之前字符串常量池是方法区的一部分,方法区叫做“永久代”,在 1.7 之前<br>无限的创建对象就会造成内存溢出,提示信息：PermGen space 而是用 jdk1.7 之后,开始逐<br>步去永久代,就不会产生内存溢出。<br>方法区用于存放 Class 的相关信息,如类名、访问修饰符、常量池、字段描述、方法描述等,<br>如果动态生成大量的 Class 文件,也会产生内存溢出。常见的场景还有：大量 JSP 或动态产生<br>JSP 文件的应用（JSP 第一次运行时需要编译为 java 类）、基于 OSGi 的应用（即使是同一个<br>类文件,被不同的类加载器加载也会视为不同的类）</p><h2 id="redis排行榜代码"><a href="#redis排行榜代码" class="headerlink" title="redis排行榜代码"></a>redis排行榜代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">countPoint</span><span class="params">(Long pointId,String ponitList, Long userId)</span> </span>&#123;</span><br><span class="line">        String key = RedisConstants.get(pointId.toString());</span><br><span class="line">        String userIdStr = userId.toString();</span><br><span class="line">        <span class="keyword">boolean</span> flag = redisService.isMember(key, userIdStr);</span><br><span class="line">        DetailVo vo = DetailVo.builder()</span><br><span class="line">                .pointId(pointId)</span><br><span class="line">                .likeCreateTime(<span class="keyword">new</span> Date())</span><br><span class="line">                .likeUserId(userId)</span><br><span class="line">                .likedUserId(likedUserId)</span><br><span class="line">                .build();</span><br><span class="line">        Map resultMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            redisService.srem(key, userIdStr);</span><br><span class="line">            vo.setType(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//减分</span></span><br><span class="line">            redisService.incrScoreZset(ponitList,likedUserId.toString(),-<span class="number">1</span>);</span><br><span class="line">            resultMap.put(<span class="string">&quot;no&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisService.sadd(key, userIdStr);</span><br><span class="line">            <span class="comment">//加分</span></span><br><span class="line">            redisService.incrScoreZset(ponitList,likedUserId.toString(),<span class="number">1</span>);</span><br><span class="line">            vo.setType(<span class="number">1</span>);</span><br><span class="line">            resultMap.put(<span class="string">&quot;yes&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        mQProducer.sendUpdateUp(vo);</span><br><span class="line">        resultMap.put(<span class="string">&quot;Number&quot;</span>, redisService.scard(key));</span><br><span class="line">        <span class="keyword">return</span> resultMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="请问-这个-Dao-接口的工作原理是什么？Dao-接口里的方法-参数不同时-方法能重载吗？"><a href="#请问-这个-Dao-接口的工作原理是什么？Dao-接口里的方法-参数不同时-方法能重载吗？" class="headerlink" title="请问,这个 Dao 接口的工作原理是什么？Dao 接口里的方法,参数不同时,方法能重载吗？"></a>请问,这个 Dao 接口的工作原理是什么？Dao 接口里的方法,参数不同时,方法能重载吗？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Dao 接口即 Mapper 接口。接口的全限名,就是映射文件中的 namespace 的值；</span><br><span class="line">接口的方法名,就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的</span><br><span class="line">参数,就是传递给 sql 的参数。</span><br><span class="line">Mapper 接口是没有实现类的,当调用接口方法时,接口全限名+方法名拼接字符</span><br><span class="line">串作为 key 值,可唯一定位一个 MapperStatement。在 Mybatis 中,每一个</span><br><span class="line">&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签,都会被解析为一个</span><br><span class="line">MapperStatement 对象。</span><br><span class="line">举例：com.mybatis3.mappers.StudentDao.findStudentById,可以唯</span><br><span class="line">一找到 namespace 为 com.mybatis3.mappers.StudentDao 下面 id 为</span><br><span class="line">findStudentById 的 MapperStatement。</span><br><span class="line">Mapper 接口里的方法,是不能重载的,因为是使用 全限名+方法名 的保存和寻</span><br><span class="line">找策略。Mapper 接口的工作原理是 JDK 动态代理,Mybatis 运行时会使用 JDK</span><br><span class="line">动态代理为 Mapper 接口生成代理对象 proxy,代理对象会拦截接口方法,转而</span><br><span class="line">执行 MapperStatement 所代表的 sql,然后将 sql 执行结果返回。</span><br></pre></td></tr></table></figure><h2 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis 使用 RowBounds 对象进行分页,它是针对 ResultSet 结果集执行的内<br>存分页,而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分<br>页功能,也可以使用分页插件来完成物理分页。<br>分页插件的基本原理是使用 Mybatis 提供的插件接口,实现自定义插件,在插件<br>的拦截方法内拦截待执行的 sql,然后重写 sql,根据 dialect 方言,添加对应的物<br>理分页语句和物理分页参数。</p><h2 id="Mybatis-的一级、二级缓存"><a href="#Mybatis-的一级、二级缓存" class="headerlink" title="Mybatis 的一级、二级缓存"></a>Mybatis 的一级、二级缓存</h2><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存,其存储作用域为<br>Session,当 Session flush 或 close 之后,该 Session 中的所有 Cache 就<br>将清空,默认打开一级缓存。<br>2）二级缓存与一级缓存其机制相同,默认也是采用 PerpetualCache,HashMap<br>存储,不同在于其存储作用域为 Mapper(Namespace),并且可自定义存储源,<br>如 Ehcache。默认不打开二级缓存,要开启二级缓存,使用二级缓存属性类需要<br>实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置<br><cache> ；<br>3）对于缓存数据更新机制,当某一个作用域(一级缓存 Session/二级缓存<br>Namespaces)的进行了 C/U/D 操作后,默认该作用域下所有 select 中的缓存将<br>被 clear。</cache></p><h1 id="Redis面试专题"><a href="#Redis面试专题" class="headerlink" title="Redis面试专题"></a>Redis面试专题</h1><h2 id="redis-和-memcached-什么区别？为什么高并发下有时单线程的-redis-比多线程的"><a href="#redis-和-memcached-什么区别？为什么高并发下有时单线程的-redis-比多线程的" class="headerlink" title="redis 和 memcached 什么区别？为什么高并发下有时单线程的 redis 比多线程的"></a>redis 和 memcached 什么区别？为什么高并发下有时单线程的 redis 比多线程的</h2><p>memcached 效率要高？<br>区别：<br>1.mc 可缓存图片和视频。rd 支持除 k/v 更多的数据结构;<br>2.rd 可以使用虚拟内存,rd 可持久化和 aof 灾难恢复,rd 通过主从支持数据备份;<br>3.rd 可以做消息队列。<br>原因：mc 多线程模型引入了缓存一致性和锁,加锁带来了性能损耗。</p><h2 id="假如-Redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来？"><a href="#假如-Redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来？" class="headerlink" title="假如 Redis 里面有 1 亿个 key,其中有 10w 个 key 是以某个固定的已知的前缀开头的,如果将它们全部找出来？"></a>假如 Redis 里面有 1 亿个 key,其中有 10w 个 key 是以某个固定的已知的前缀开头的,如果将它们全部找出来？</h2><p>使用 keys 指令可以扫出指定模式的 key 列表。<br>对方接着追问：如果这个 redis 正在给线上的业务提供服务,那使用 keys 指令会有什么问<br>题？<br>这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一<br>段时间,线上服务会停顿,直到指令执行完毕,服务才能恢复。这个时候可以使用 scan 指<br>令,scan 指令可以无阻塞的提取出指定模式的 key 列表,但是会有一定的重复概率,在客<br>户端做一次去重就可以了,但是整体所花费的时间会比直接用 keys 指令长。</p><h2 id="Synchronized-锁升级过程"><a href="#Synchronized-锁升级过程" class="headerlink" title="Synchronized 锁升级过程"></a>Synchronized 锁升级过程</h2><p>首先,synchronized 是什么？我们需要明确的给个定义——同步锁,没错,它就是把锁。</p><p>可以用来干嘛？锁,当然当然是用于线程间的同步,以及保护临界区内的资源。我们知道,锁是个非常笼统的概念,像生活中有指纹锁、密码锁等等多个种类,那 synchronized 代表的锁具体是把什么锁呢？</p><p>答案是—— Java 内置锁。在 Java 中,每个对象中都隐藏着一把锁,而 synchronized 关键字就是激活这把隐式锁的把手（开关）。</p><p>先来简单了解一下 synchronized,我们知道其共有 3 种使用方式：</p><p>关于扫描时markword,可以去了解下对象在JVM中的结构,这里简单说明,每个对象都会有一个对象头markword,这块区域可以存放hashcode和锁信息以及GC信息</p><p>Synchronized 的使用</p><p>修饰静态方法：锁住当前 class,作用于该 class 的所有实例<br>修饰非静态方法：只会锁住当前 class 的实例<br>修饰代码块：该方法接受一个对象作为参数,锁住的即该对象<br>使用方法就不在这里赘述,可自行搜索其详细的用法,这不是本篇文章所关心的内容。</p><p>知道了 synchronized 的概念,回头来看标题,它说的锁升级到底是个啥？对于不太熟悉锁升级的人来说,可能会想：</p><p>所谓锁,不就是啪一下锁上就完事了吗？升级是个什么玩意？这跟打扑克牌也没关系啊。</p><p>对于熟悉的人来说,可能会想：</p><p>不就是「无锁 ==&gt; 偏向锁 ==&gt; 轻量级锁 ==&gt; 重量级锁 」吗？</p><p>你可能在很多地方看到过上面描述的锁升级过程,也能直接背下来。但你真的知道无锁、偏向锁、轻量级锁、重量级锁到底代表着什么吗？这些锁存储在哪里？以及什么情况下会使得锁向下一个 level 升级？</p><p>想知道答案,我们似乎必须先搞清楚 Java 内置锁,其内部结构是啥样的？内置锁又存放在哪里？</p><p>答案在开篇提到过——在 Java 对象中。</p><p>那么现在的问题就从「内置锁结构是啥」变成了「Java 对象长啥样」。</p><p> 对象结构<br>从宏观上看,Java 对象的结构很简单,分为三部分：</p><p>Java 对象结构</p><p>从微观上看,各个部分都还可以深入展开,详见下图：</p><p>Java 详细对象结构</p><p>接下来分别深入讨论一下这三部分。</p><p>对象头<br>从脑图中可以看出,其由 Mark Word、Class Pointer、数组长度三个字段组成。简单来说：</p><p>Mark Word：主要用于存储自身运行时数据<br>Class Pointer：是指针,指向方法区中该 class 的对象,JVM 通过此字段来判断当前对象是哪个类的实例<br>数组长度：当且仅当对象是数组时才会有该字段<br>Class Pointer 和数组长度没什么好说的,接下来重点聊聊 Mark Word。</p><p>Mark Word 所代表的「运行时数据」主要用来表示当前 Java 对象的线程锁状态以及 GC 的标志。而线程锁状态分别就是无锁、偏向锁、轻量级锁、重量级锁。</p><p>所以前文提到的这 4 个状态,其实就是 Java 内置锁的不同状态。</p><p>在 JDK 1.6 之前,内置锁都是重量级锁,效率低下。效率低下表现在</p><p>而在 JDK 1.6 之后为了提高 synchronized 的效率,才引入了偏向锁、轻量级锁。</p><p>随着锁竞争逐渐激烈,其状态会按照「无锁 ==&gt; 偏向锁 ==&gt; 轻量级锁 ==&gt; 重量级锁 」这个方向逐渐升级,并且不可逆,只能进行锁升级,而无法进行锁降级。</p><p>接下来我们思考一个问题,既然 Mark Word 可以表示 4 种不同的锁状态,其内部到底是怎么区分的呢？（由于目前主流的 JVM 都是 64 位,所以我们只讨论 64 位的 Mark Word）接下来我们通过图片直观的感受一下。</p><p>（1）无锁</p><p>无锁</p><p>这个可以理解为单线程很快乐的运行,没有其他的线程来和其竞争。</p><p>（2）偏向锁</p><p>偏向锁</p><p>首先,什么叫偏向锁？举个例子,一段同步的代码,一直只被线程 A 访问,既然没有其他的线程来竞争,每次都要获取锁岂不是浪费资源？所以这种情况下线程 A 就会自动进入偏向锁的状态。</p><p>后续线程 A 再次访问同步代码时,不需要做任何的 check,直接执行（对该线程的「偏爱」）,这样降低了获取锁的代价,提升了效率。</p><p>看到这里,你会发现无锁、偏向锁的 lock 标志位是一样的,即都是 01,这是因为无锁、偏向锁是靠字段 biased_lock 来区分的,0 代表没有使用偏向锁,1 代表启用了偏向锁。为什么要这么搞？你可以理解为无锁、偏向锁在本质上都可以理解为无锁（参考上面提到的线程 A 的状态）,所以 lock 的标志位都是 01 是没毛病的。</p><p>PS：这里的线程 ID 是持有当前对象偏向锁的线程</p><p>（3）轻量级锁</p><p>轻量级锁</p><p>但是,一旦有第二个线程参与竞争,就会立即膨胀为轻量级锁。企图抢占的线程一开始会使用自旋：</p><p>的方式去尝试获取锁。如果循环几次,其他的线程释放了锁,就不需要进行用户态到内核态的切换。虽然如此,但自旋需要占用很多 CPU 的资源（自行理解汽车空档疯狂踩油门）。如果另一个线程 一直不释放锁,难道它就在这一直空转下去吗？</p><p>当然不可能,JDK 1.7 之前是普通自旋,会设定一个最大的自旋次数,默认是 10 次,超过这个阈值就停止自旋。JDK 1.7 之后,引入了适应性自旋。简单来说就是：这次自旋获取到锁了,自旋的次数就会增加；这次自旋没拿到锁,自旋的次数就会减少。</p><p>（4）重量级锁</p><p>重量级锁</p><p>上面提到,试图抢占的线程自旋达到阈值,就会停止自旋,那么此时锁就会膨胀成重量级锁。当其膨胀成重量级锁后,其他竞争的线程进来就不会自旋了,而是直接阻塞等待,并且 Mark Word 中的内容会变成一个监视器（monitor）对象,用来统一管理排队的线程。</p><p>这个 monitor 对象,每个对象都会关联一个。monitor 对象本质上是一个同步机制,保证了同时只有一个线程能够进入临界区,在 HotSpot 的虚拟机中,是由 C++ 类 ObjectMonitor 实现的。</p><p>那么 monitor 对象具体是如何来管理线程的？接下来我们看几个 ObjectMonitor 类关键的属性：</p><p>ContentionQueue：是个队列,所有竞争锁的线程都会先进入这个队列中,可以理解为线程的统一入口,进入的线程会阻塞。<br>EntryList：ContentionQueue 中有资格的线程会被移动到这里,相当于进行一轮初筛,进入的线程会阻塞。<br>Owner：拥有当前 monitor 对象的线程,即 —— 持有锁的那个线程。<br>OnDeck：与 Owner 线程进行竞争的线程,同一时刻只会有一个 OnDeck 线程在竞争。<br>WaitSet：当 Owner 线程调用 wait()  方法被阻塞之后,会被放到这里。当其被唤醒之后,会重新进入 EntryList 当中,这个集合的线程都会阻塞。<br>Count：用于实现可重入锁,synchronized 是可重入的。<br>对象体<br>对象体包含了当前对象的字段和值,在业务中u l是较为核心的部分。</p><p>对齐字节<br>就是单纯用于填充的字节,没有其他的业务含义。其目的是为了保证对象所占用的内存大小为 8 的倍数,因为HotSpot VM 的内存管理要求对象的起始地址必须是 8 的倍数。</p><p> 锁升级<br>了解完  4 种锁状态之后,我们就可以整体的来看一下锁升级的过程了。<br>锁的详细升级过程<br>1.一开始对象是无锁状态的</p><p>2.一个线程尝试执行Synchronize代码块时,成功获得对象的锁,通过CAS操作往该对象markword中插入当前线程id, 同时修改偏向锁的标志位 。此时是偏向锁（偏向这个线程的锁,锁计数+1）,同一个线程可以重复进入该锁,锁计数+1,执行完毕会锁计数-1,直到锁计数复0,释放锁。</p><p>正是因为有记录线程id,所以Synchronized实现了可重入锁的逻辑（简单说就是一个锁的拥有者可以重复的获取自己的锁,而不会产生阻塞问题）<br>关于扫描时markword,可以去了解下对象在JVM中的结构,这里简单说明,每个对象都会有一个对象头markword,这块区域可以存放hashcode和锁信息以及GC信息</p><p>线程 A 进入 synchronized 开始抢锁,JVM 会判断当前是否是偏向锁的状态,如果是就会根据 Mark Word 中存储的线程 ID 来判断,当前线程 A 是否就是持有偏向锁的线程。如果是,则忽略 check,线程 A 直接执行临界区内的代码。</p><p>但如果 Mark Word 里的线程不是线程 A,就会通过自旋尝试获取锁,如果获取到了,就将 Mark Word 中的线程 ID 改为自己的；如果竞争失败,就会立马撤销偏向锁,膨胀为轻量级锁。</p><p>后续的竞争线程都会通过自旋来尝试获取锁,如果自旋成功那么锁的状态仍然是轻量级锁。然而如果竞争失败,锁会膨胀为重量级锁,后续等待的竞争的线程都会被阻塞。</p><p>无锁状态、偏向锁、轻量级锁、重量级锁 ,这是锁膨胀的过程,不可逆,但只有偏向锁可以变回无锁态。<br>转载博文：<br><a href="https://cloud.tencent.com/developer/article/2074879#:~:text=%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3%20Synchronized%20%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%201%20%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E9%94%81%E4%BD%8F%E5%BD%93%E5%89%8D%20class%EF%BC%8C%E4%BD%9C%E7%94%A8%E4%BA%8E%E8%AF%A5%20class,%E7%9A%84%E6%89%80%E6%9C%89%E5%AE%9E%E4%BE%8B%202%20%E4%BF%AE%E9%A5%B0%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E5%8F%AA%E4%BC%9A%E9%94%81%E4%BD%8F%E5%BD%93%E5%89%8D%20class%20%E7%9A%84%E5%AE%9E%E4%BE%8B%203%20%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%9A%E8%AF%A5%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E9%94%81%E4%BD%8F%E7%9A%84%E5%8D%B3%E8%AF%A5%E5%AF%B9%E8%B1%A1">https://cloud.tencent.com/developer/article/2074879#:~:text=%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3%20Synchronized%20%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%201%20%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E9%94%81%E4%BD%8F%E5%BD%93%E5%89%8D%20class%EF%BC%8C%E4%BD%9C%E7%94%A8%E4%BA%8E%E8%AF%A5%20class,%E7%9A%84%E6%89%80%E6%9C%89%E5%AE%9E%E4%BE%8B%202%20%E4%BF%AE%E9%A5%B0%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E5%8F%AA%E4%BC%9A%E9%94%81%E4%BD%8F%E5%BD%93%E5%89%8D%20class%20%E7%9A%84%E5%AE%9E%E4%BE%8B%203%20%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%9A%E8%AF%A5%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E9%94%81%E4%BD%8F%E7%9A%84%E5%8D%B3%E8%AF%A5%E5%AF%B9%E8%B1%A1</a><br>锁优化篇：<br>JDK1.6引入了大量的优化,如：自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁。锁主要存在四中状态,依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态,他们会随着竞争的激烈而逐渐升级。但是有一点,不可以进行锁降级</p><p>一、自旋锁：<br>线程频繁的阻塞和唤醒对CPU来说是一件负担很重的工作,会给系统带来很大的压力。同时很多锁状态只会持续很短一段时间,为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。  所谓自旋锁,就是让该线程等待一段时间,不会被立即挂起,看持有锁的线程是否会很快释放锁,如果释放了,就可以抢到锁。那怎么等待呢？其实就是执行一段无意义的循环,大家是不是瞬间觉得好low,原来就是执行一段for循环,别急着下结论,我们继续来分析</p><p>执行一段无意义的循环。如果持有锁的线程很快就释放了锁,那么自旋的效率就非常好。但是如果自旋很久都没抢到锁,那自旋就是浪费资源,说的难听点就是占着茅坑不拉屎。所以说,自旋等待的时间或者次数必须要有一个限度,如果超过了定义的时间仍然没有获取到锁,则把它挂起。</p><p>自旋锁在JDK 1.4.2中引入,默认关闭,但是可以使用-XX:+UseSpinning开启,在JDK1.6中默认开启。同时自旋的默认次数为10次,可以通过参数-XX:PreBlockSpin来调整；但是无论你怎么调整这些参数,都无法满足不可预知的情况。于是JDK1.6引入自适应的自旋锁,让虚拟机会变得越来越聪明。</p><p>二、适应自旋锁<br>JDK 1.6引入了更加聪明的自旋锁,叫做自适应自旋锁。他的自旋次数是会变的,我用大白话来讲一下,就是线程如果上次自旋成功了,那么这次自旋的次数会更加多,因为虚拟机认为既然上次成功了,那么这次自旋也很有可能会再次成功。反之,如果某个锁很少有自旋成功,那么以后的自旋的次数会减少甚至省略掉自旋过程,以免浪费处理器资源。大家现在觉得没这么low了吧</p><p>三、锁消除<br>锁消除用大白话来讲,就是在一段程序里你用了锁,但是jvm检测到这段程序里不存在共享数据竞争问题,也就是变量没有逃逸出方法外,这个时候jvm就会把这个锁消除掉</p><p>我们程序员写代码的时候自然是知道哪里需要上锁,哪里不需要,但是有时候我们虽然没有显示使用锁,但是我们不小心使了一些线程安全的API时,如StringBuffer、Vector、HashTable等,这个时候会隐形的加锁。比如下段代码</p><p>复制<br>public void sbTest(){<br>        StringBuffer sb= new StringBuffer();<br>        for(int i = 0 ; i &lt; 10 ; i++){<br>            sb.append(i);<br>        }<br>        System.out.println(sb.toString());<br>    }<br>复制<br>复制<br>上面这段代码,JVM可以明显检测到变量sb没有逃逸出方法sbTest()之外,所以JVM可以大胆地将sbTest内部的加锁操作消除。</p><p> 四、锁粗化<br>众所周知在使用锁的时候,要让锁的作用范围尽量的小,这样是为了在锁内执行代码尽可能少,缩短持有锁的时间,其他等待锁的线程能尽快拿到锁。在大多数的情况下这样做是正确的。但是连续加锁解锁操作,可能会导致不必要的性能损耗,比如下面这个for循环：</p><p>锁粗化前：<br>for (…) {<br>  synchronized (obj) {<br>    // 一些操作<br>  }<br>}<br>锁粗化后：<br>synchronized (this) {<br> for (…) {<br>   // 一些操作<br> }<br>}<br>复制<br>复制<br>大家应该能看出锁粗化大概是什么意思了。就是将多个连续的加锁、解锁操作连接在一起,扩展成一个范围更大的锁。即加锁解锁操作会移到for循环之外。</p><p>五、偏向锁<br>当我们创建一个对象时,该对象的部分Markword关键数据如下。</p><p>bit fields</p><p>是否偏向锁</p><p>锁标志位</p><p>hash</p><p>0</p><p>01</p><p>从图中可以看出,偏向锁的标志位是“01”,状态是“0”,表示该对象还没有被加上偏向锁。（“1”是表示被加上偏向锁）。该对象被创建出来的那一刻,就有了偏向锁的标志位,这也说明了所有对象都是可偏向的,但所有对象的状态都为“0”,也同时说明所有被创建的对象的偏向锁并没有生效。</p><p>不过,当线程执行到临界区（critical section）时,此时会利用CAS(Compare and Swap)操作,将线程ID插入到Markword中,同时修改偏向锁的标志位。</p><p>所谓临界区,就是只允许一个线程进去执行操作的区域,即同步代码块。CAS是一个原子性操作</p><p>此时的Mark word的结构信息如下：</p><p>bit fields</p><p>是否偏向锁</p><p>锁标志位</p><p>threadId</p><p>epoch</p><p>1</p><p>01</p><p>此时偏向锁的状态为“1”,说明对象的偏向锁生效了,同时也可以看到,哪个线程获得了该对象的锁。</p><p>偏向锁是jdk1.6引入的一项锁优化,其中的“偏”是偏心的偏。它的意思就是说,这个锁会偏向于第一个获得它的线程,在接下来的执行过程中,假如该锁没有被其他线程所获取,没有其他线程来竞争该锁,那么持有偏向锁的线程将永远不需要进行同步操作。也就是说:在此线程之后的执行过程中,如果再次进入或者退出同一段同步块代码,并不再需要去进行加锁或者解锁操作,而是会做以下的步骤：</p><p>Load-and-test,也就是简单判断一下当前线程id是否与Markword当中的线程id是否一致.<br>如果一致,则说明此线程已经成功获得了锁,继续执行下面的代码.<br>如果不一致,则要检查一下对象是否还是可偏向,即“是否偏向锁”标志位的值。<br>如果还未偏向,则利用CAS操作来竞争锁,也即是第一次获取锁时的操作。<br>释放锁 偏向锁的释放采用了一种只有竞争才会释放锁的机制,线程是不会主动去释放偏向锁,需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><p>暂停拥有偏向锁的线程,判断锁对象石是否还处于被锁定状态；<br>撤销偏向锁,恢复到无锁状态或者轻量级锁的状态；<br>安全点会导致stw（stop the word）,导致性能下降,这种情况下应当禁用； </p><p>查看停顿–安全点停顿日志</p><p>要查看安全点停顿,可以打开安全点日志,通过设置JVM参数 -</p><p>XX:+PrintGCApplicationStoppedTime 会打出系统停止的时间,</p><p>添加-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 这两个参数会打印出详细信息,可以查看到使用偏向锁导致的停顿,时间非常短暂,但是争用严重的情况下,停顿次数也会非常多；</p><p>注意：安全点日志不能一直打开： </p><ol><li>安全点日志默认输出到stdout,一是stdout日志的整洁性,二是stdout所重定向的文件如果不在/dev/shm,可能被锁。 </li><li>对于一些很短的停顿,比如取消偏向锁,打印的消耗比停顿本身还大。 </li><li>安全点日志是在安全点内打印的,本身加大了安全点的停顿时间。</li></ol><p>所以安全日志应该只在问题排查时打开。<br>如果在生产系统上要打开,再再增加下面四个参数：<br>-XX:+UnlockDiagnosticVMOptions -XX: -DisplayVMOutput -XX:+LogVMOutput -XX:LogFile=/dev/shm/vm.log<br>打开Diagnostic（只是开放了更多的flag可选,不会主动激活某个flag）,关掉输出VM日志到stdout,输出到独立文件,/dev/shm目录（内存文件系统）。</p><p>此日志分三部分：<br>第一部分是时间戳,VM Operation的类型 </p><p>第二部分是线程概况,被中括号括起来 </p><p>total: 安全点里的总线程数<br>initially_running: 安全点时开始时正在运行状态的线程数<br>wait_to_block: 在VM Operation开始前需要等待其暂停的线程数</p><p>第三部分是到达安全点时的各个阶段以及执行操作所花的时间,其中最重要的是vmop</p><p>spin: 等待线程响应safepoint号召的时间；<br>block: 暂停所有线程所用的时间；<br>sync: 等于 spin+block,这是从开始到进入安全点所耗的时间,可用于判断进入安全点耗时；<br>cleanup: 清理所用时间；<br>vmop: 真正执行VM Operation的时间。<br>可见,那些很多但又很短的安全点,全都是RevokeBias, 高并发的应用会禁用掉偏向锁。</p><p>jvm开启/关闭偏向锁</p><p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0<br>关闭偏向锁：-XX:-UseBiasedLocking</p><p>六、轻量级锁<br>自旋锁的目标是降低线程切换的成本。如果锁竞争激烈,我们不得不依赖于重量级锁,让竞争失败的线程阻塞；如果完全没有实际的锁竞争,那么申请重量级锁都是浪费的。轻量级锁的目标是,减少无实际竞争情况下,使用重量级锁产生的性能消耗,包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。</p><p>顾名思义,轻量级锁是相对于重量级锁而言的。使用轻量级锁时,不需要申请互斥量,仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record（Lock Record：JVM检测到当前对象是无锁状态,则会在当前线程的栈帧中创建一个名为LOCKRECOD表空间用于copy Mark word 中的数据）,如果更新成功,则轻量级锁获取成功,记录锁状态为轻量级锁；否则,说明已经有线程获得了轻量级锁,目前发生了锁竞争（不适合继续使用轻量级锁）,接下来膨胀为重量级锁。</p><p>当然,由于轻量级锁天然瞄准不存在锁竞争的场景,如果存在锁竞争但不激烈,仍然可以用自旋锁优化,自旋失败后再膨胀为重量级锁。</p><p>缺点：同自旋锁相似：如果锁竞争激烈,那么轻量级将很快膨胀为重量级锁,那么维持轻量级锁的过程就成了浪费。</p><p>七、重量级锁<br>        轻量级锁膨胀之后,就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的,而monitor又依赖操作系统的MutexLock(互斥锁)来实现的,所以重量级锁也被成为互斥锁。<br>当轻量级所经过锁撤销等步骤升级为重量级锁之后,它的Markword部分数据大体如下</p><p>bit fields</p><p>锁标志位</p><p>指向Mutex的指针</p><p>10</p><p>为什么说重量级锁开销大呢</p><p>主要是,当系统检查到锁是重量级锁之后,会把等待想要获得锁的线程进行阻塞,被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时,都需要操作系统来帮忙,这就需要从用户态转换到内核态,而转换状态是需要消耗很多时间的,有可能比用户执行代码的时间还要长。<br>这就是说为什么重量级线程开销很大的。</p><p>互斥锁(重量级锁)也称为阻塞同步、悲观锁</p><p>八、总结<br>        偏向所锁,轻量级锁都是乐观锁,重量级锁是悲观锁。</p><pre><code>    一个对象刚开始实例化的时候,没有任何线程来访问它的时候。它是可偏向的,意味着,它现在认为只可能有一个线程来访问它,所以当第一个</code></pre><p>线程来访问它的时候,它会偏向这个线程,此时,对象持有偏向锁。偏向第一个线程,这个线程在修改对象头成为偏向锁的时候使用CAS操作,并将<br>对象头中的ThreadID改成自己的ID,之后再次访问这个对象时,只需要对比ID,不需要再使用CAS在进行操作。</p><pre><code>    一旦有第二个线程访问这个对象,因为偏向锁不会主动释放,所以第二个线程可以看到对象时偏向状态,这时表明在这个对象上已经存在竞争了,检查原来持有该对象锁的线程是否依然存活,如果挂了,则可以将对象变为无锁状态,然后重新偏向新的线程,如果原来的线程依然存活,则马上执行那个线程的操作栈,检查该对象的使用情况,如果仍然需要持有偏向锁,则偏向锁升级为轻量级锁,（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了,则可以将对象回复成无锁状态,然后重新偏向。    轻量级锁认为竞争存在,但是竞争的程度很轻,一般两个线程对于同一个锁的操作都会错开,或者说稍微等待一下（自旋）,另一个线程就会释放锁。但是当自旋超过一定的次数,或者一个线程在持有锁,一个在自旋,又有第三个来访时,轻量级锁膨胀为重量级锁,重量级锁使除了拥有锁的线程以外的线程都阻塞,防止CPU空转。</code></pre><p>转载博文：<a href="https://cloud.tencent.com/developer/article/1698812?from=article.detail.2019347">https://cloud.tencent.com/developer/article/1698812?from=article.detail.2019347</a></p><h2 id="Mysql-json数据查询"><a href="#Mysql-json数据查询" class="headerlink" title="Mysql json数据查询"></a>Mysql json数据查询</h2><p>1、使用 字段-&gt;’$.json属性’ 进行查询条件</p><p>2、使用 json_extract 函数查询,json_extract(字段, “$.json属性”)</p><p>3、根据json数组查询,用 JSON_CONTAINS(字段, JSON_OBJECT(‘json属性’, “内容”))</p><p>举例：</p><p>SELECT * from<br>test<br>– WHERE attributes -&gt; ‘$.orderInviteCode.inviterUserId’ = 310000000780<br>– WHERE json_extract(attributes, “$.orderInviteCode.inviterUserId”) = 310000000780</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>Thread类有7个基本构造函数,当指定线程执行顺序时,可调用start方法,然后调用join方法,其中join的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       join(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ↓</span><br><span class="line">↓</span><br><span class="line">↓</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">               wait(<span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">               <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">               <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               wait(delay);</span><br><span class="line">               now = System.currentTimeMillis() - base;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>java无法销毁一个线程,但是当调用isAlive方法时,返回false则已销毁<br>为什么放弃了stop方法？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">this</span> method is inherently unsafe.  Stopping a thread with</span><br><span class="line">     *       Thread.stop causes it to unlock all of the monitors that it</span><br><span class="line">     *       <span class="function">has <span class="title">locked</span> <span class="params">(as a natural consequence of the unchecked</span></span></span><br><span class="line"><span class="params"><span class="function">     *       &#123;<span class="meta">@code</span> ThreadDeath&#125; exception propagating up the stack)</span>.  If</span></span><br><span class="line"><span class="function">     *       any of the objects previously <span class="keyword">protected</span> by these monitors were in</span></span><br><span class="line"><span class="function">     *       an inconsistent state, the damaged objects become visible to</span></span><br><span class="line"><span class="function">     *       other threads, potentially resulting in arbitrary behavior.  Many</span></span><br><span class="line"><span class="function">     *       uses of </span>&#123;<span class="meta">@code</span> stop&#125; should be replaced by code that simply</span><br><span class="line">     *       modifies some variable to indicate that the target thread should</span><br><span class="line">     *       stop running.  The target thread should check <span class="keyword">this</span> variable</span><br><span class="line">     *       regularly, and <span class="keyword">return</span> from its run method in an orderly fashion</span><br><span class="line">     *       <span class="keyword">if</span> the variable indicates that it is to stop running.  If the</span><br><span class="line">     *       <span class="function">target thread waits <span class="keyword">for</span> <span class="keyword">long</span> <span class="title">periods</span> <span class="params">(on a condition variable,</span></span></span><br><span class="line"><span class="params"><span class="function">     *       <span class="keyword">for</span> example)</span>, the </span>&#123;<span class="meta">@code</span> interrupt&#125; method should be used to</span><br><span class="line">     *       interrupt the wait.</span><br><span class="line">     *       For more information, see</span><br><span class="line">     *       &lt;a href=<span class="string">&quot;&#123;@docRoot&#125;/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;</span>&gt;Why</span><br><span class="line">     *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.</span><br><span class="line">防止死锁ddd</span><br><span class="line">所以已经在<span class="number">1.2</span>就过期了</span><br></pre></td></tr></table></figure><p>说明Thread interrupt（）  isinterrupted（）interrupted 的区别和含义<br>Thread.interrupt()   设置状态<br>isInterrupted()    判断 返回Boolean<br>interrupted 即判断又清除</p><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先是一个<span class="keyword">native</span>方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>向调度程序提示当前线程愿意让步,使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择,也就是说,当前也就是刚刚的那个线程还是有可能会被再次执行到的,并不是说一定会执行其他线程而该线程在下一次中不会执行到了.</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="面试" scheme="https://zkkget.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture</title>
    <link href="https://zkkget.github.io/posts/20220728clho7wpja0006youj3yncg18i.html"/>
    <id>https://zkkget.github.io/posts/20220728clho7wpja0006youj3yncg18i.html</id>
    <published>2022-07-28T02:44:05.000Z</published>
    <updated>2022-09-05T02:55:53.648Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>想学习CompletableFuture，因此查询资料发现<br>CompletableFuture是JDK8中的新特性，主要用于对JDK5中加入的Future的补充。<br>CompletableFuture实现了CompletionStage和Future接口。<br>需要先了解Future接口<br>什么是Future？<br>简单来说future就是一个Future对象，当执行return await。。。的时候，实际上返回的是一个延迟计算的Future对象，这个Future对象是Dart内置的，有自己的队列策略，它将要操作的事件放入EventQueue中，在队列中的事件按照先进先出的原则去逐一处理事件，当事件处理完成后，将结果返回给Future对象。</p><p>在这个过程中涉及到了异步和等待：</p><p>异步：就是不用阻塞当前线程，来等待该线程任务处理完成再去执行其他任务。<br>等待：await，声明运算为延迟执行<br>async和await<br>首先看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getData() async&#123;</span><br><span class="line">   return await http.get(Uri.encodeFull(url), headers: &#123;&quot;Accept&quot;: &quot;application/json&quot;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">//然后调用函数来获取结果</span><br><span class="line">String data = getData();</span><br></pre></td></tr></table></figure><p>这段代码在运行的时候会报错。<br>因为data是String类型，而函数getData()是一个异步操作函数，其返回值是一个await延迟执行的结果。<br>在Dart中，有await标记的运算，结果都是一个Future对象，Future不是String类型，所以就报错了。<br>如何获取异步函数的结果呢？Dart规定有async标记的函数，只能由await来调用，那么我们可以在函数前加一个await关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String data;</span><br><span class="line">setData() async &#123;</span><br><span class="line">  data = <span class="function">await <span class="title">getData</span><span class="params">()</span></span>;    <span class="comment">//getData()延迟执行后赋值给data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async和await的使用其实就只有两点：</p><p>await关键字必须在async函数内部使用<br>调用async函数必须使用await关键字</p><p>Dart(释义：镖)异步<br>Dart是单线程模型，是一种Event-Looper以及Event-Queue的模型，所有的事件都是通过EventLooper的依次执行。</p><p>Event-Looper与Netty的NioEventLoopGroup异曲同工，都是线程模型</p><p>作者：zhaoolee<br>链接：<a href="https://www.jianshu.com/p/aefd0e50b802">https://www.jianshu.com/p/aefd0e50b802</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>单线程模型<br>所谓单线程，就是一旦一个函数开始执行，就必须将这个函数执行完，才能去执行其他函数</p><p>作者：MakerChin<br>链接：<a href="https://www.jianshu.com/p/890df7ea8f87">https://www.jianshu.com/p/890df7ea8f87</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>Future接口的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//取消任务。参数:是否立即中断任务执行，或者等等任务结束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//任务是否已经取消，若已取消，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//任务是否已经完成。包括任务正常完成、抛出异常或被取消，都返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*等待任务执行结束，获得V类型的结果。InterruptedException: 线程被中断异常， ExecutionException: 任务执行异常，如果任务被取消，还会抛出CancellationException*/</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计算超时，将抛出TimeoutException*/</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用不带参数的get方法的调用被阻塞，直到计算完成。如果在计算完成之前，调用带参get()方法超时时，会抛出TimeoutException异常。若运行该计算的线程被中断，两种get()方法都会抛出InterruptedException。如果计算已经完成，那么get方法立即返回。<br>若计算还在进行，isDone方法返回false；如果完成了，则返回true。<br>调用cancel()时，若计算还没有开始，它被取消且不再开始。若计算处于运行之中，那么如果mayInterrupt参数为true，它就被中断。<br>相比future.get()，其实更推荐使用get (long timeout, TimeUnit unit) 方法，因为设置了超时时间可以防止程序无限制的等待future的返回结果。<br>FutureTask源码解析<br>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="comment">//状态为NEW</span></span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实际上Callable = Runnable + result，继续看上面的第二个构造方法，看看Executors.callable(runnable, result)的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//new了一个RunnableAdapter,返回Callable,说明RunnableAdapter实现了Callable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>状态值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//初始化状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//正在执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//正常完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//出现异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//正被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//已被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>FutureTask的run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*compareAndSwapObject(this, runnerOffset,]null, Thread.currentThread()))</span></span><br><span class="line"><span class="comment">         其中第一个参数为需要改变的对象，第二个为偏移量，第三个参数为期待的值，第四个为更新后的值。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//call()方法是由FutureTask调用的,说明call()不是异步执行的</span></span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//设置异常</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// NEW -&gt; COMPLETING</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            <span class="comment">//返回结果,也包括异常</span></span><br><span class="line">            outcome = v;</span><br><span class="line">            <span class="comment">//COMPLETING -&gt; NORMAL</span></span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">            <span class="comment">//唤醒等待的线程</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//是否是未完成状态,是则等待</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            <span class="comment">//等待过程</span></span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/itcats_cn/article/details/81322122">https://blog.csdn.net/itcats_cn/article/details/81322122</a></p><p>CompletableFuture类的官方API文档解释：</p><p>CompletableFuture是一个在完成时可以触发相关方法和操作的Future，并且它可以视作为CompletableStage。<br>除了直接操作状态和结果的这些方法和相关方法外（CompletableFuture API提供的方法），CompletableFuture还实现了以下的CompletionStage的相关策略：<br>① 非异步方法的完成，可以由当前CompletableFuture的线程提供，也可以由其他调用完方法的线程提供。<br>② 所有没有显示使用Executor的异步方法，会使用ForkJoinPool.commonPool()（那些并行度小于2的任务会创建一个新线程来运行）。为了简化监视、调试和跟踪异步方法，所有异步任务都被标记为CompletableFuture.AsynchronouseCompletionTask。<br>③ 所有CompletionStage方法都是独立于其他公共方法实现的，因此一个方法的行为不受子类中其他方法的覆盖影响。<br>CompletableFuture还实现了Future的以下策略<br>① 不像FutureTask，因CompletableFuture无法直接控制计算任务的完成，所以CompletableFuture的取消会被视为异常完成。调用cancel()方法会和调用completeExceptionally（）方法一样，具有同样的效果。isCompletedEceptionally()方法可以判断CompletableFuture是否是异常完成。<br>② 在调用get()和get(long, TimeUnit)方法时以异常的形式完成，则会抛出ExecutionException,大多数情况下都会使用join()和getNow(T)，它们会抛出CompletionException。<br>小结：</p><p>Concurrent包中的Future在获取结果时会发生阻塞，而CompletableFuture则不会，它可以通过触发异步方法来获取结果。<br>在CompletableFuture中，如果没有显示指定的Executor的参数，则会调用默认的ForkJoinPool.commonPool()。<br>调用CompletableFuture的cancel()方法和调用completeExceptionally()方法的效果一样。<br>在JDK5中，使用Future来获取结果时都非常的不方便，只能通过get()方法阻塞线程或者通过轮询isDone()的方式来获取任务结果，这种阻塞或轮询的方式会无畏的消耗CPU资源，而且还不能及时的获取任务结果，因此JDK8中提供了CompletableFuture来实现异步的获取任务结果。</p><p>使用下CompletableFuture的API<br>CompletableFuture类提供了非常多的方法供我们使用，包括了runAsync()、supplyAsync()、thenAccept()等方法。<br>runAsync()，异步运行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAsyncExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, executorService);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cf.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CompletedFuture...isDown&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">CompletedFuture…isDown</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里调用的runAsync()方法没有使用ForkJoinPool的线程，而是使用了Executors.newSingleThreadExecutor()中的线程。runAsync()其实效果跟单开一个线程一样。<br>supplyAsync()</p><p>supply有供应的意思，supplyAsync就可以理解为异步供应，查看supplyAsync()方法入参可以知道，其有两个入参：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier supplier,</span><br><span class="line">Executor executor</span><br></pre></td></tr></table></figure><p>这里先简单介绍下Supplier接口，Supplier接口是JDK8引入的新特性，它也是用于创建对象的，只不过调用Supplier的get()方法时，才会去通过构造方法去创建对象，并且每次创建出的对象都不一样。Supplier常用语法为：Supplier<MySupplier> sup= MySupplier::new;<br>再展示代码例子之前，再讲一个thenAccept()方法，可以发现thenAccept()方法的入参如下：</MySupplier></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comsumer&lt;? super T&gt;</span><br><span class="line">Comsumer接口同样是java8新引入的特性，它有两个重要接口方法：</span><br><span class="line"></span><br><span class="line">accept()</span><br><span class="line">andThen()</span><br><span class="line">thenAccept()可以理解为接收CompletableFuture的结果然后再进行处理。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面看下supplyAsync()和thenAccept()的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void thenApply() throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(2);</span><br><span class="line">        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123; //实现了Supplier的get()方法</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;supplyAsync &quot; + Thread.currentThread().getName());</span><br><span class="line">            return &quot;hello &quot;;</span><br><span class="line">        &#125;,executorService).thenAccept(s -&gt; &#123; //实现了Comsumper的accept()方法</span><br><span class="line">            try &#123;</span><br><span class="line">                thenApply_test(s + &quot;world&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (cf.isDone()) &#123;</span><br><span class="line">                System.out.println(&quot;CompletedFuture...isDown&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">supplyAsync pool-1-thread-1</span><br><span class="line">thenApply_test hello world</span><br><span class="line">thenApply_test pool-1-thread-1</span><br></pre></td></tr></table></figure><p>从代码逻辑可以看出，thenApply_test等到了pool-1-thread-1线程完成任务后，才进行的调用，并且拿到了supplye()方法返回的结果，而main则异步执行了，这就避免了Future获取结果时需要阻塞或轮询的弊端。<br>exceptionally<br>当任务在执行过程中报错了咋办？exceptionally()方法很好的解决了这个问题，当报错时会去调用exceptionally()方法，它的入参为：Function&lt;Throwable, ? extends T&gt; fn，fn为执行任务报错时的回调方法，下面看看代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void exceptionally() &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if (1 == 1) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;测试exceptionally...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;s1&quot;;</span><br><span class="line">        &#125;, executorService).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            return &quot;helloworld &quot; + e.getMessage();</span><br><span class="line">        &#125;);</span><br><span class="line">        cf.thenAcceptAsync(s -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;thenAcceptAsync: &quot; + s);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;main: &quot; + Thread.currentThread().getName());</span><br><span class="line">        while (true) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main: main</span><br><span class="line">java.lang.RuntimeException: 测试exceptionally…</span><br><span class="line">CompletableFuture is Down…helloworld java.lang.RuntimeException: 测试exceptionally…</span><br><span class="line">thenAcceptAsync: helloworld java.lang.RuntimeException: 测试exceptionally…</span><br></pre></td></tr></table></figure><p>从代码以及运行结果来看，当任务执行过程中报错时会执行exceptionally()中的代码，thenAcceptAsync()会获取抛出的异常并输出到控制台，不管CompletableFuture()执行过程中报错、正常完成、还是取消，都会被标示为已完成，所以最后CompletableFuture.isDown()为true。</p><p>在Java8中，新增的ForkJoinPool.commonPool()方法，这个方法可以获得一个公共的ForkJoin线程池，这个公共线程池中的所有线程都是Daemon线程，意味着如果主线程退出，这些线程无论是否执行完毕，都会退出系统。</p><p>2.3 源码分析<br>CompletableFuture类实现了Future接口和CompletionStage接口，Future大家都经常遇到，但是这个CompletionStage接口就有点陌生了，这里的CompletionStage实际上是一个任务执行的一个“阶段”，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; &#123;</span><br><span class="line">volatile Object result;       // CompletableFuture的结果值或者是一个异常的报装对象AltResult</span><br><span class="line">    volatile Completion stack;    // 依赖操作栈的栈顶</span><br><span class="line">    ...</span><br><span class="line">    // CompletableFuture的方法</span><br><span class="line">    ... </span><br><span class="line">// Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">    private static final long RESULT;</span><br><span class="line">    private static final long STACK;</span><br><span class="line">    private static final long NEXT;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            final sun.misc.Unsafe u;</span><br><span class="line">            UNSAFE = u = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = CompletableFuture.class;</span><br><span class="line">            RESULT = u.objectFieldOffset(k.getDeclaredField(&quot;result&quot;)); //计算result属性的位偏移量</span><br><span class="line">            STACK = u.objectFieldOffset(k.getDeclaredField(&quot;stack&quot;)); //计算stack属性的位偏移量</span><br><span class="line">            NEXT = u.objectFieldOffset </span><br><span class="line">                (Completion.class.getDeclaredField(&quot;next&quot;));  //计算next属性的位偏移量</span><br><span class="line">        &#125; catch (Exception x) &#123;</span><br><span class="line">            throw new Error(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CompletableFuture中有一个静态代码块，在CompletableFuture类初始化之前就进行调用，代码块里的内容就是通过Unsafe类去获取CompletableFuture的result、stack和next属性的“偏移量”，这个偏移量主要用于Unsafe的CAS操作时进行位移量的比较。<br>runAsync(Runnable, Executor) &amp; runAsync(Runnable)<br>runAsync()做的事情就是异步的执行任务，返回的是CompletableFuture对象，不过CompletableFuture对象不包含结果。runAsync()方法有两个重载方法，这两个重载方法的区别是Executor可以指定为自己想要使用的线程池，而runAsync(Runnable)则使用的是ForkJoinPool.commonPool()。</p><p>下面先来看看runAsync(Runnable)的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) &#123;</span><br><span class="line">       return asyncRunStage(asyncPool, runnable);</span><br><span class="line">   &#125;</span><br><span class="line">这里的asyncPool是一个静态的成员变量：</span><br></pre></td></tr></table></figure><p>private static final boolean useCommonPool =<br>        (ForkJoinPool.getCommonPoolParallelism() &gt; 1); // 并行级别<br>private static final Executor asyncPool = useCommonPool ?<br>    ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();<br>回到asyncRunStage()源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static CompletableFuture&lt;Void&gt; asyncRunStage(Executor e, Runnable f) &#123;</span><br><span class="line">       if (f == null) throw new NullPointerException();</span><br><span class="line">       CompletableFuture&lt;Void&gt; d = new CompletableFuture&lt;Void&gt;();</span><br><span class="line">       e.execute(new AsyncRun(d, f));</span><br><span class="line">       return d;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看到asyncRunStage()源码，可以知道任务是由Executor来执行的，那么可想而知Async类一定是实现了Callable接口或者继承了Runnable类，查看Async类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static final class AsyncRun extends ForkJoinTask&lt;Void&gt;</span><br><span class="line">            implements Runnable, AsynchronousCompletionTask &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; dep; Runnable fn;</span><br><span class="line">        AsyncRun(CompletableFuture&lt;Void&gt; dep, Runnable fn) &#123;</span><br><span class="line">            this.dep = dep; this.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final Void getRawResult() &#123; return null; &#125;</span><br><span class="line">        public final void setRawResult(Void v) &#123;&#125;</span><br><span class="line">        public final boolean exec() &#123; run(); return true; &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            CompletableFuture&lt;Void&gt; d; Runnable f;</span><br><span class="line">            if ((d = dep) != null &amp;&amp; (f = fn) != null) &#123;</span><br><span class="line">                dep = null; fn = null;//释放掉内存</span><br><span class="line">                if (d.result == null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        f.run();</span><br><span class="line">                        d.completeNull();</span><br><span class="line">                    &#125; catch (Throwable ex) &#123;</span><br><span class="line">                        d.completeThrowable(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d.postComplete(); // 任务结束后，会执行所有依赖此任务的其他任务，这些任务以一个无锁并发栈的形式存在</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在AsyncRun类中，实现了Runnable接口的run()方法，在run()方法内部，会调用传进来的Runnable对象的run()方法，这里就需要用户自己去实现了，上文中的实例代码就是通过Lambda表达式来实现了Runnable接口。调用了f.run()之后，然后就是completeNull()方法了，该方法底层通过调用UNSAFE类的compareAndSwapObject()方法，来以CAS的方式将CompletableFuture的结果赋为null。postComplete()就是任务结束后，会执行所有依赖此任务的其他任务，这些任务以一个无锁并发栈的形式存在。<br>postComplete()的源码还是有点复杂的，先不急着分析。先看看Completion这个抽象类的数据结构组成：</p><p>Completion<br>下面先看看Completion的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如果触发，则执行完成操作，返回可能需要传播的依赖项（如果存在）。</span><br><span class="line">@param mode SYNC, ASYNC, or NESTED</span><br><span class="line">abstract static class Completion extends ForkJoinTask&lt;Void&gt;</span><br><span class="line">        implements Runnable, AsynchronousCompletionTask &#123;</span><br><span class="line">        volatile Completion next;      </span><br><span class="line">        abstract CompletableFuture&lt;?&gt; tryFire(int mode);</span><br><span class="line">        abstract boolean isLive();</span><br><span class="line"></span><br><span class="line">        public final void run()                &#123; tryFire(ASYNC); &#125;</span><br><span class="line">        public final boolean exec()            &#123; tryFire(ASYNC); return true; &#125;</span><br><span class="line">        public final Void getRawResult()       &#123; return null; &#125;</span><br><span class="line">        public final void setRawResult(Void v) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Completion是一个抽象类，分别实现了Runnable、AsynchronousCompletionTask接口，继承了ForkJoinPoolTask类，而ForJoinPoolTask抽象类又实现了Future接口，因此Completion实际上就是一个Future。可以看到Completion的抽象方法和成员方法的实现逻辑都短短一行或者没有，可以猜到这些方法的实现都是在其子类中。其实现类包括了UniCompletion、BiCompletion、UniAccept、BiAccept等，如下图：<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Completion.jpg" alt="流程"></p><p>而Completion类中还有一个非常重要的成员属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile Completion next;</span><br></pre></td></tr></table></figure><p>有印象的读者应该能记得，CompletableFuture中有一个属性——stack，就是Completion类的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile Completion stack;</span><br></pre></td></tr></table></figure><p>由这个属性可以看出，CompletableFuture其实就是一个链表的一个数据结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">abstract static class UniCompletion&lt;T,V&gt; extends Completion &#123;</span><br><span class="line">        Executor executor;                 // executor to use (null if none)</span><br><span class="line">        CompletableFuture&lt;V&gt; dep;          // 代表的依赖的CompletableFuture</span><br><span class="line">        CompletableFuture&lt;T&gt; src;          // 代表的是源CompletableFuture</span><br><span class="line"></span><br><span class="line">        UniCompletion(Executor executor, CompletableFuture&lt;V&gt; dep,</span><br><span class="line">                      CompletableFuture&lt;T&gt; src) &#123;</span><br><span class="line">            this.executor = executor; this.dep = dep; this.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * 确保当前Completion可以被调用；并且使用ForkJoinPool标记为来确保只有一个线程可以调用，</span><br><span class="line">         * 如果是异步的，则在任务启动之后通过tryFire来进行调用。tryFire方法时在UniAccept类中。</span><br><span class="line">         */</span><br><span class="line">        final boolean claim() &#123;</span><br><span class="line">            Executor e = executor;</span><br><span class="line">            if (compareAndSetForkJoinTaskTag((short)0, (short)1)) &#123;</span><br><span class="line">                if (e == null)</span><br><span class="line">                    return true;</span><br><span class="line">                executor = null; // disable</span><br><span class="line">                e.execute(this);</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean isLive() &#123; return dep != null; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>claim方法要在执行action前调用，若claim方法返回false，则不能调用action，原则上要保证action只执行一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static final class UniAccept&lt;T&gt; extends UniCompletion&lt;T,Void&gt; &#123;</span><br><span class="line">        Consumer&lt;? super T&gt; fn;</span><br><span class="line">        UniAccept(Executor executor, CompletableFuture&lt;Void&gt; dep,</span><br><span class="line">                  CompletableFuture&lt;T&gt; src, Consumer&lt;? super T&gt; fn) &#123;</span><br><span class="line">            super(executor, dep, src); this.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 尝试去调用当前任务。uniAccept()方法为核心逻辑。</span><br><span class="line">         */</span><br><span class="line">        final CompletableFuture&lt;Void&gt; tryFire(int mode) &#123;</span><br><span class="line">            CompletableFuture&lt;Void&gt; d; CompletableFuture&lt;T&gt; a;</span><br><span class="line">            if ((d = dep) == null ||</span><br><span class="line">                !d.uniAccept(a = src, fn, mode &gt; 0 ? null : this))</span><br><span class="line">                return null;</span><br><span class="line">            dep = null; src = null; fn = null;</span><br><span class="line">            return d.postFire(a, mode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">final &lt;S&gt; boolean uniAccept(CompletableFuture&lt;S&gt; a,</span><br><span class="line">                                Consumer&lt;? super S&gt; f, UniAccept&lt;S&gt; c) &#123;</span><br><span class="line">        Object r; Throwable x;</span><br><span class="line">        if (a == null || (r = a.result) == null || f == null) //判断源任务是否已经完成了，a表示的就是源任务，a.result就代表的是原任务的结果。</span><br><span class="line">            return false;</span><br><span class="line">        tryComplete: if (result == null) &#123;</span><br><span class="line">            if (r instanceof AltResult) &#123;</span><br><span class="line">                if ((x = ((AltResult)r).ex) != null) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    break tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = null;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (c != null &amp;&amp; !c.claim())</span><br><span class="line">                    return false;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;) S s = (S) r;</span><br><span class="line">                f.accept(s);  //去调用Comsumer</span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于Completion的执行，还有几个关键的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int SYNC   =  0;//同步</span><br><span class="line">static final int ASYNC  =  1;//异步</span><br><span class="line">static final int NESTED = -1;//嵌套</span><br></pre></td></tr></table></figure><p>Completion在CompletableFuture中是如何工作的呢？现在先不着急了解其原理，下面再去看下一个重要的接口——CompletionStage。</p><p>CompletionStage<br>下面介绍下CompletionStage接口。看字面意思可以理解为“完成动作的一个阶段”，查看官方注释文档：CompletionStage是一个可能执行异步计算的“阶段”，这个阶段会在另一个CompletionStage完成时调用去执行动作或者计算，一个CompletionStage会以正常完成或者中断的形式“完成”，并且它的“完成”会触发其他依赖的CompletionStage。CompletionStage 接口的方法一般都返回新的CompletionStage，因此构成了链式的调用。<br>【下文中Stage代表CompletionStage】</p><p>那么在Java中什么是CompletionStage呢？<br>官方定义中，一个Function，Comsumer或者Runnable都会被描述为一个CompletionStage，相关方法比如有apply，accept，run等，这些方法的区别在于它们有些是需要传入参，有些则会产生“结果”。</p><p>Funtion方法会产生结果<br>Comsumer会消耗结果<br>Runable既不产生结果也不消耗结果<br>下面看看一个Stage的调用例子：</p><p>stage.thenApply(x -&gt; square(x)).thenAccept(x -&gt; System.out.println(x)).thenRun(() -&gt; System.out.println())<br>1<br>这里x -&gt; square(x)就是一个Function类型的Stage，它返回了x。x -&gt; System.out.println(x)就是一个Comsumer类型的Stage，用于接收上一个Stage的结果x。() -&gt;System.out.println()就是一个Runnable类型的Stage，既不消耗结果也不产生结果。</p><p>一个、两个或者任意一个CompletionStage的完成都会触发依赖的CompletionStage的执行，CompletionStage的依赖动作可以由带有then的前缀方法来实现。如果一个Stage被两个Stage的完成给触发，则这个Stage可以通过相应的Combine方法来结合它们的结果，相应的Combine方法包括：thenCombine、thenCombineAsync。但如果一个Stage是被两个Stage中的其中一个触发，则无法去combine它们的结果，因为这个Stage无法确保这个结果是那个与之依赖的Stage返回的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testCombine() throws Exception &#123;</span><br><span class="line">       String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           return &quot;hello&quot;;</span><br><span class="line">       &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           return &quot; world&quot;;</span><br><span class="line">       &#125;), (s1, s2) -&gt; s1 + &quot; &quot; + s2).join();</span><br><span class="line"></span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>虽然Stage之间的依赖关系可以控制触发计算，但是并不能保证任何的顺序。</p><p>另外，可以用一下三种的任何一种方式来安排一个新Stage的计算：default execution、default asynchronous execution（方法后缀都带有async）或者custom（自定义一个executor）。默认和异步模式的执行属性由CompletionStage实现而不是此接口指定。</p><p>小结：CompletionStage确保了CompletableFuture能够进行链式调用。</p><p>下面开始介绍CompletableFuture的几个核心方法：</p><p>postComplete</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final void postComplete() &#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; f = this; Completion h;    //this表示当前的CompletableFuture</span><br><span class="line">        while ((h = f.stack) != null ||                                  //判断stack栈是否为空</span><br><span class="line">               (f != this &amp;&amp; (h = (f = this).stack) != null)) &#123;    </span><br><span class="line">            CompletableFuture&lt;?&gt; d; Completion t;      </span><br><span class="line">            if (f.casStack(h, t = h.next)) &#123;                          //通过CAS出栈，</span><br><span class="line">                if (t != null) &#123;</span><br><span class="line">                    if (f != this) &#123;</span><br><span class="line">                        pushStack(h);             //如果f不是this，将刚出栈的h入this的栈顶</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    h.next = null;    // detach   帮助GC</span><br><span class="line">                &#125;</span><br><span class="line">                f = (d = h.tryFire(NESTED)) == null ? this : d;        //调用tryFire</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postComplete()方法可以理解为当任务完成之后，调用的一个“后完成”方法，主要用于触发其他依赖任务。</p><p>uniAccept</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">final &lt;S&gt; boolean uniAccept(CompletableFuture&lt;S&gt; a,</span><br><span class="line">                                Consumer&lt;? super S&gt; f, UniAccept&lt;S&gt; c) &#123;</span><br><span class="line">        Object r; Throwable x;</span><br><span class="line">        if (a == null || (r = a.result) == null || f == null)    //判断当前CompletableFuture是否已完成，如果没完成则返回false；如果完成了则执行下面的逻辑。</span><br><span class="line">            return false;</span><br><span class="line">        tryComplete: if (result == null) &#123;</span><br><span class="line">            if (r instanceof AltResult) &#123;   //判断任务结果是否是AltResult类型</span><br><span class="line">                if ((x = ((AltResult)r).ex) != null) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    break tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = null;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (c != null &amp;&amp; !c.claim()) //判断当前任务是否可以执行</span><br><span class="line">                    return false;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;) S s = (S) r;   //获取任务结果</span><br><span class="line">                f.accept(s);    //执行Comsumer</span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里有一个很巧妙的地方，就是uniAccept的入参中，CompletableFuture a表示的是源任务，UniAccept c中报装有依赖的任务，这点需要清除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pushStack</span><br><span class="line"></span><br><span class="line">final void pushStack(Completion c) &#123;</span><br><span class="line">        do &#123;&#125; while (!tryPushStack(c));      //使用CAS自旋方式压入栈，避免了加锁竞争</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">final boolean tryPushStack(Completion c) &#123;</span><br><span class="line">        Completion h = stack;         </span><br><span class="line">        lazySetNext(c, h);   //将当前stack设置为c的next</span><br><span class="line">        return UNSAFE.compareAndSwapObject(this, STACK, h, c); //尝试把当前栈（h）更新为新值（c）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static void lazySetNext(Completion c, Completion next) &#123;</span><br><span class="line">        UNSAFE.putOrderedObject(c, NEXT, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>光分析源码也没法深入理解其代码原理，下面结合一段示例代码来对代码原理进行分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void thenApply() throws Exception &#123;</span><br><span class="line">       ExecutorService executorService = Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">       CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">                //休眠200秒</span><br><span class="line">               Thread.sleep(200000);</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(&quot;supplyAsync &quot; + Thread.currentThread().getName());</span><br><span class="line">           return &quot;hello &quot;;</span><br><span class="line">       &#125;,executorService).thenAccept(s -&gt; &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               thenApply_test(s + &quot;world&quot;);</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       System.out.println(Thread.currentThread().getName());</span><br><span class="line">       while (true) &#123;</span><br><span class="line">           if (cf.isDone()) &#123;</span><br><span class="line">               System.out.println(&quot;CompletedFuture...isDown&quot;);</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/** 运行结果：</span><br><span class="line">    main</span><br><span class="line">    supplyAsync pool-1-thread-1</span><br><span class="line">    thenApply_test hello world</span><br><span class="line">    thenApply_test pool-1-thread-1</span><br><span class="line">    CompletedFuture...isDown</span><br><span class="line">    */</span><br></pre></td></tr></table></figure><p>这段示例代码所做的事情就是supplyAsync(Supplier supplier)休眠200秒之后，返回一个字符串，thenAccept(Consumer&lt;? super T&gt; action)等到任务完成之后接收这个字符串，并且调用thenApply_test()方法，随后输出 hello world。<br>代码中让线程休眠200秒是为了方便观察CompletableFuture的传递过程。</p><p>下面就描述下程序的整个运作流程。<br>① 主线程调用CompletableFuture的supplyAsync()方法，传入Supplier和Executor。在supplyAsync()中又继续调用CompletableFuture的asyncSupplyStage(Executor, Supplier)方法。</p><p>来到asyncSupplyStage()方法中，调用指定的线程池，并执行execute(new AsyncSupply(d,f))，这里d就是我们的“源任务”，接下来thenApply()要依赖着这个源任务进行后续逻辑操作，f就是Supplier的函数式编程。</p><p>AsyncSupply实现了Runnable的run()方法，核心逻辑就在run()方法里。在run()方法里，先判断d.result == null，判断该任务是否已经完成，防止并发情况下其他线程完成此任务了。f.get()就是调用的Supplier的函数式编程，这里会休眠200秒，所以executor线程池开启的线程会在这里阻塞200秒。</p><p>② 虽然executor线程池线程阻塞了，但是main线程任然会继续执行接下来的代码。</p><p>main线程会在asyncSupplyStage()方法中返回d，就是我们的“依赖任务”，而这个任务此时还处在阻塞中。接下来main线程会继续执行CompletableFuture的thenAccept(Comsumer&lt;? super T&gt; action)方法，然后调用CompletableFuture的uniAcceptStage()方法。<br>在这里插入图片描述<br>在uniAcceptStage()方法中，会将“依赖任务”、“源任务”、线程池以及Comsumer报装程一个UniAccept对象，然后调用push()压入stack的栈顶中。随后调用UniAccept的tryFire()方法。<br>在这里插入图片描述<br>其中的CompletableFuture的uniAccept()方法会判断任务是否完成，判断依据是a.result 是否为空，这里的a就是之前传入的“源任务”，等到“源任务”阻塞200秒过后，就会完成任务，并将字符串存入到 result中。<br>在这里插入图片描述<br>判断到“源任务”完成之后，就会调用接下来的逻辑。s拿到的值就是“源”任务返回的字符串，并且传入到了Comsumer.accept()方法中。然而“源任务”还在阻塞中，main线程会跳出uniAccept()，继续执行接下来的逻辑。接下来就是输出当前线程的名字，然后调用while(true)，结束条件为CompletableFuture.isDone()，当任务完成时则结束while(true)循环。</p><p>③ 回到“源任务”，虽然main线程已经结束了整个生命周期，但是executor线程池的线程任然阻塞着的，休眠了200秒之后，继续执行任务。<br>在这里插入图片描述<br>然后来到了postComplete()方法。这个方法在前面已经介绍到了，它是CompletableFuture的核心方法之一，做了许多事情。最重要的一件事情就是触发其他依赖任务，接下来调用的方法依次为：UniAccept.tryFire(mode) ——&gt; CompletableFuture.uniAccept(…) ——&gt; Comsumer.accept(s) ——&gt; 输出“hello world”，并输出当前调用线程的线程名。因这个调用链已经在②中介绍过了，所以就不再详细介绍其运作逻辑。<br>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">      runAsync();</span><br><span class="line">      supplyAsync();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //无返回值</span><br><span class="line">    public static void runAsync() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;run end ...&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        future.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //有返回值</span><br><span class="line">    public static void supplyAsync() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Long&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;run end ...&quot;);</span><br><span class="line">            return System.currentTimeMillis();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        long time = future.get();</span><br><span class="line">        System.out.println(&quot;time = &quot;+time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run end ...</span><br><span class="line">run end ...</span><br><span class="line">time = 1596010020281</span><br></pre></td></tr></table></figure><p>小结： 通过这个小示例，终于理解到了“源任务”和“依赖任务”之间的调用关系，以及CompletableFuture的基本运作原理。然而CompletableFuture还有其他的方法需要去深入分析，由于篇幅所限就不再赘述，感兴趣的读者可以以debug的模式去一点一点分析CompletableFuture其他方法的底层原理。这里不得不说Java并发包作者Doug Lea大神真的太厉害了，阅读他的源码之后，可以发现他写的代码不能以技术来形容，而应该使用“艺术”来形容。</p><p>总结<br>CompletableFuture底层由于借助了魔法类Unsafe的相关CAS方法，除了get或join结果之外，其他方法都实现了无锁操作。<br>CompletableFuture实现了CompletionStage接口，因而具备了链式调用的能力，CompletionStage提供了either、apply、run以及then等相关方法，使得CompletableFuture可以使用各种应用场景。<br>CompletableFuture中有“源任务”和“依赖任务”，“源任务”的完成能够触发“依赖任务”的执行，这里的完成可以是返回正常结果或者是异常。<br>CompletableFuture默认使用ForkJoinPool，也可以使用指定线程池来执行任务。</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="CompletableFuture" scheme="https://zkkget.github.io/tags/CompletableFuture/"/>
    
  </entry>
  
  <entry>
    <title>优雅永不过时</title>
    <link href="https://zkkget.github.io/posts/20220726clho7wpkh001zyoujdahn3a59.html"/>
    <id>https://zkkget.github.io/posts/20220726clho7wpkh001zyoujdahn3a59.html</id>
    <published>2022-07-26T02:26:41.000Z</published>
    <updated>2022-07-26T02:30:41.087Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>无论是日常编码，还是业务涉及，能够优雅的表达思想，提高代码简洁度，阅读性都是一种能力，总结一下优雅的做法</p><p>优雅的关闭流<br>java7 try with resource，针对实现了AutoCloseable接口的类，都可优雅的关闭流，从而舍弃finally关闭</p><p>try catch finally</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = null;</span><br><span class="line">try &#123;</span><br><span class="line">....</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (in != null) &#123;</span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e2) &#123;</span><br><span class="line">e2.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">try winth resource</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try (final BufferedReader in = new BufferedReader(new InputStreamReader((new URL(url + &quot;?&quot; + param)).openConnection().getInputStream()));PrintWriter out =new PrintWriter(response.getWriter()))&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;catch&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netty 优雅的关闭流程<br>1<br>shutdownGracefully()<br>Lambda表达式<br>list求交集</p><p>1<br>List<Long> collect = list1.stream().filter(list2::contains).collect(Collectors.toList());<br>设计模式代替if else,策略模式，模板模式<br>代码整洁度，例如多注入service，按着高矮胖瘦排列，视觉舒适，controller求求你别写业务代码了</Long></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public  List getRandomList(List&lt;?&gt; paramList,int count)&#123;</span><br><span class="line">        if(count==0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Random random=new Random();</span><br><span class="line">        List&lt;Integer&gt; tempList=new ArrayList&lt;&gt;();//临时存放产生的list索引，去除重复的索引</span><br><span class="line">        List newList=new ArrayList();//生成新的list集合</span><br><span class="line">        int temp=0;</span><br><span class="line">        if(count&lt;=1)&#123;//如果数据小于1，取一条数据</span><br><span class="line">            temp = random.nextInt(paramList.size());</span><br><span class="line">            newList.add(paramList.get(temp));</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for(int i=0;i&lt;Math.ceil(count);i++)&#123;</span><br><span class="line">                temp=random.nextInt(paramList.size());//初始化一个随机数，将产生的随机数作为被抽list的索引</span><br><span class="line">                if(!tempList.contains(temp))&#123;//判断随机抽取的随机数</span><br><span class="line">                    tempList.add(temp);</span><br><span class="line">                    newList.add(paramList.get(temp));</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>优雅判空<br>个人喜欢Assert判空，至于java8的Optional并没体会到优雅之处，日常StringUtils，Collections，isNoBlank等，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public String testOptional(Test test) &#123;</span><br><span class="line">        return Optional.ofNullable(test).flatMap(Test::getTest3)</span><br><span class="line">                .flatMap(Test3::getTest2)</span><br><span class="line">                .map(Test2::getInfo)</span><br><span class="line">                .orElse(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">看起来挺优雅，但日常没体会到</span><br><span class="line">还有日常常用的instanceof</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">else if (f instanceof TreeBin) &#123;</span><br><span class="line">        validated = true;</span><br><span class="line">        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">        if ((r = t.root) != null &amp;&amp;</span><br><span class="line">            (p = r.findTreeNode(hash, key, null)) != null) &#123;</span><br><span class="line">            V pv = p.val;</span><br><span class="line">            if (cv == null || cv == pv ||</span><br><span class="line">                (pv != null &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                oldVal = pv;</span><br><span class="line">                if (value != null)</span><br><span class="line">                    p.val = value;</span><br><span class="line">                else if (t.removeTreeNode(p))</span><br><span class="line">                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode算法题</title>
    <link href="https://zkkget.github.io/posts/20220726clho7wpjf0009youjb7nh4lva.html"/>
    <id>https://zkkget.github.io/posts/20220726clho7wpjf0009youjb7nh4lva.html</id>
    <published>2022-07-26T02:22:55.000Z</published>
    <updated>2022-07-26T02:26:11.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>一：力扣第14题 编写一个函数来查找字符串数组中的最长公共前缀<br>官方解法：<br>##方法一：横向扫描</p><p>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if (strs == null || strs.length == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = strs[0];</span><br><span class="line">        int count = strs.length;</span><br><span class="line">        for (int i = 1; i &lt; count; i++) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            if (prefix.length() == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String longestCommonPrefix(String str1, String str2) &#123;</span><br><span class="line">        int length = Math.min(str1.length(), str2.length());</span><br><span class="line">        int index = 0;</span><br><span class="line">        while (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return str1.substring(0, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复杂度分析</span><br><span class="line">时间复杂度：O(mn)O(mn)，其中 mm 是字符串数组中的字符串的平均长度，nn 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</span><br><span class="line">空间复杂度：O(1)O(1)。使用的额外空间复杂度为常数。</span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>#leetcode 用户灵魂画手<br>思路<br>标签：链表<br>当字符串数组长度为 0 时则公共前缀为空，直接返回<br>令最长公共前缀 ans 的值为第一个字符串，进行初始化<br>遍历后面的字符串，依次将其与 ans 进行比较，两两找出公共前缀，最终结果即为最长公共前缀<br>如果查找过程中出现了 ans 为空的情况，则公共前缀不存在直接返回<br>时间复杂度：O(s)O(s)，s 为所有字符串的长度之和<br>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs.length == 0) </span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        String ans = strs[0];</span><br><span class="line">        for(int i =1;i&lt;strs.length;i++) &#123;</span><br><span class="line">            int j=0;</span><br><span class="line">            for(;j&lt;ans.length() &amp;&amp; j &lt; strs[i].length();j++) &#123;</span><br><span class="line">                if(ans.charAt(j) != strs[i].charAt(j))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.substring(0, j);</span><br><span class="line">            if(ans.equals(&quot;&quot;))</span><br><span class="line">                return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">作者：guanpengchn</span><br><span class="line">链接：https://leetcode-cn.com/problems/longest-common-prefix/solution/hua-jie-suan-fa-14-zui-chang-gong-gong-qian-zhui-b/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>#最易理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        String s=&quot;&quot;;</span><br><span class="line">        int judge=1;</span><br><span class="line">        if(strs.length==0)&#123;//数组为空直接返回&quot;&quot;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;strs[0].length();i++)&#123;</span><br><span class="line">            char a=strs[0].charAt(i);//直接选择第一个数组元素，依次取这个字符串的字符</span><br><span class="line">            </span><br><span class="line">            for(int j=0;j&lt;strs.length;j++)&#123;</span><br><span class="line">                </span><br><span class="line">                if(i&gt;=strs[j].length())&#123;//因为每个字符串长度不同，防止溢出</span><br><span class="line">                    judge=0;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if(a!=strs[j].charAt(i))&#123;</span><br><span class="line">                    judge=0;//只要存在不同，直接退出</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                else&#123;</span><br><span class="line">                    if(j==strs.length-1)&#123;</span><br><span class="line">                        s=s+a;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            if(judge==0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">本文链接：https://blog.csdn.net/shancx/article/details/82746264</span><br></pre></td></tr></table></figure><p>二：未排序正整数数组中累加和为给定值的最长子数组长度<br>给定一个数组arr，该数组无序，每个数正数，给定一个K，求arr的所有子数组中所有元素相加和为k的最长子数组的长度。</p><p>例如：arr=[1,2,1,1,1],k=3</p><p>结果是3，[1,1,1]的长度。</p><p>思路：</p><p>首先用两个位置来标记子数组左右两头，记为left与right，开始的时候都在数组的最左边即left=right=0，过程如下：</p><p>1，开始变量left=0，right=0，代表子数组arr[left,right];</p><p>2，变量sum始终表示子数组arr[left,right]的和，开始的时候sum= arr[0],即是arr[0,0]的和；</p><p>3，变量len一直记录累加和为k的所有子数组中最大子数组的长度，开始的时候len=0;</p><p>4，根据sum与k的比较结果决定是left移动还right移动。若干sum==K，说明arr[left,right]累加和为k,如果长度大于len，更新len</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package Array;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by wuxiaosi on 2017/9/24.</span><br><span class="line"> */</span><br><span class="line">public class getMaxLength &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int k=3;</span><br><span class="line">        int[] arr=&#123;1,2,1,1,1&#125;;</span><br><span class="line">        System.out.println(getMaxLengthK(arr,k));</span><br><span class="line">    &#125;</span><br><span class="line">    public static int getMaxLengthK(int[] arr,int k)&#123;</span><br><span class="line">        if(arr==null||arr.length==0||k&lt;=0)&#123;</span><br><span class="line">            return  0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=0;</span><br><span class="line">        int sum=arr[0];</span><br><span class="line">        int len=0;</span><br><span class="line">        while(right&lt;arr.length)&#123;</span><br><span class="line">            if(sum==k)&#123;</span><br><span class="line">                len = Math.max(len,right-left+1);</span><br><span class="line">                sum=sum-arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            else if(sum&lt;k)&#123;</span><br><span class="line">                right++;//向右移动</span><br><span class="line">                if(right==arr.length)&#123;//right到数组边界长度，就break</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                sum=sum+arr[right];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sum=sum-arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「wuxiaosi808」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/wuxiaosi808/article/details/78079574</span><br></pre></td></tr></table></figure><p>三 有两个整数数组A1，A2，设计函数求其两个数组的最大值和第二大的值<br>思路一：</p><p>1.获取最值需要进行比较，每一次比较都会有一个较大的值，因为该值的不确定性，通过一个变量进行临时存储。</p><p>2.让数组中的每一个元素都和这个变量中的值进行比较，如果大于变量中的值，就用该变量记录较大值。</p><p>3.当所有的元素都比较完成，那么该变量中的存储就是数组中的最大值了。</p><p>步骤：</p><p>1.定义变量，初始化为数组中的任意一个元素。</p><p>2.通过循环语句对数组进行遍历。</p><p>3.在变量过程中定义判断条件，如果遍历到的元素比变量中的元素大，就赋值给该变量。</p><p>注意：</p><p>通过定义一个功能来完成，以便提高代码的复用性。该功能结果为数组中的最大元素，未知内容为数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) </span><br><span class="line">&#123;</span><br><span class="line">int[] arr1 = &#123;9,5,6,3,1,2,8,7&#125;;</span><br><span class="line">int max1 = getMax(arr1);</span><br><span class="line">System.out.println(&quot;max1=&quot;+max1);</span><br><span class="line">double[] arr2 = &#123;9.0,5.0,6.0,3.0,1.0,2.0,8.0,7.0&#125;;</span><br><span class="line">double max2 = getMax(arr2);</span><br><span class="line">System.out.println(&quot;max2=&quot;+max2);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">//获取int类型数组最大值</span><br><span class="line">public static int getMax(int[] arr)</span><br><span class="line">&#123;</span><br><span class="line">int max = arr[0];</span><br><span class="line">for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(arr[i]&gt;max)</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br><span class="line">//获取double类型数组最大值，功能相似，以重载的形式存在</span><br><span class="line">public static double getMax(double[] arr)</span><br><span class="line">&#123;</span><br><span class="line">double max = arr[0];</span><br><span class="line">for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(arr[i]&gt;max)</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><p>1.定义变量，初始化为数组角标0。</p><p>2.通过循环语句对数组进行遍历。</p><p>3.在变量过程中定义判断条件，如果遍历到的元素比角标所在的元素中的数值大，就将较大值的角标赋值给变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) </span><br><span class="line">&#123;</span><br><span class="line">int[] arr1 = &#123;9,5,6,3,1,2,8,7&#125;;</span><br><span class="line">int max1 = getMax(arr1);</span><br><span class="line">System.out.println(&quot;max1=&quot;+max1);</span><br><span class="line">double[] arr2 = &#123;9.0,5.0,6.0,3.0,1.0,2.0,8.0,7.0&#125;;</span><br><span class="line">double max2 = getMax(arr2);</span><br><span class="line">System.out.println(&quot;max2=&quot;+max2);</span><br><span class="line">&#125;</span><br><span class="line">//获取int类型数组最大值</span><br><span class="line">public static int getMax(int[] arr)</span><br><span class="line">&#123;</span><br><span class="line">int max = 0;</span><br><span class="line">for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(arr[i]&gt;arr[max])</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line">return arr[max];</span><br><span class="line">&#125;</span><br><span class="line">//获取double类型数组最大值，功能相似，以重载的形式存在</span><br><span class="line">public static double getMax(double[] arr)</span><br><span class="line">&#123;</span><br><span class="line">double max = 0;</span><br><span class="line">for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(arr[i]&gt;arr[max])</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line">return arr[max];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「Destiny_lt」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/ytu_lt/article/details/70160598</span><br></pre></td></tr></table></figure><h1 id="四-翻转单词顺序列（I-am-a-student-gt-student-a-am-I）"><a href="#四-翻转单词顺序列（I-am-a-student-gt-student-a-am-I）" class="headerlink" title="四 翻转单词顺序列（I am a student.-&gt;student. a am I）"></a>四 翻转单词顺序列（I am a student.-&gt;student. a am I）</h1><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”<br>方法一：双指针<br>算法解析：<br>倒序遍历字符串 ss ，记录单词左右索引边界 ii , jj ；<br>每确定一个单词的边界，则将其添加至单词列表 resres ；<br>最终，将单词列表拼接为字符串，并返回即可。<br>复杂度分析：<br>时间复杂度 O(N)O(N) ： 其中 NN 为字符串 ss 的长度，线性遍历字符串。<br>空间复杂度 O(N)O(N) ： 新建的 list(Python) 或 StringBuilder(Java) 中的字符串总长度 \leq N≤N ，占用 O(N)O(N) 大小的额外空间。<br>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        s = s.trim(); // 删除首尾空格</span><br><span class="line">        int j = s.length() - 1, i = j;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        while(i &gt;= 0) &#123;</span><br><span class="line">            while(i &gt;= 0 &amp;&amp; s.charAt(i) != &#x27; &#x27;) i--; // 搜索首个空格</span><br><span class="line">            res.append(s.substring(i + 1, j + 1) + &quot; &quot;); // 添加单词</span><br><span class="line">            while(i &gt;= 0 &amp;&amp; s.charAt(i) == &#x27; &#x27;) i--; // 跳过单词间空格</span><br><span class="line">            j = i; // j 指向下个单词的尾字符</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString().trim(); // 转化为字符串并返回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：分割 + 倒序<br>利用 “字符串分割”、“列表倒序” 的内置函数 （面试时不建议使用） ，可简便地实现本题的字符串翻转要求<br>复杂度分析：<br>时间复杂度 O(N)O(N) ： 总体为线性时间复杂度，各函数时间复杂度和参考资料链接如下。<br>split() 方法： 为 O(N)O(N) ；<br>trim() 和 strip() 方法： 最差情况下（当字符串全为空格时），为 O(N)O(N) ；<br>join() 方法： 为 O(N)O(N) ；<br>reverse() 方法： 为 O(N)O(N) ；<br>空间复杂度 O(N)O(N) ： 单词列表 strsstrs 占用线性大小的额外空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        String[] strs = s.trim().split(&quot; &quot;); // 删除首尾空格，分割字符串</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        for(int i = strs.length - 1; i &gt;= 0; i--) &#123; // 倒序遍历单词列表</span><br><span class="line">            if(strs[i].equals(&quot;&quot;)) continue; // 遇到空单词则跳过</span><br><span class="line">            res.append(strs[i] + &quot; &quot;); // 将单词拼接至 StringBuilder</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString().trim(); // 转化为字符串，删除尾部空格，并返回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/mian-shi-ti-58-i-fan-zhuan-dan-ci-shun-xu-shuang-z/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String ReverseSentence(String str)</span><br><span class="line">    &#123;</span><br><span class="line">        //先单个单词反转,再整体反转。I am a student.》》I ma a .tneduts 》》student. a am I</span><br><span class="line">        if(str.length()==0)</span><br><span class="line">            return str;</span><br><span class="line"></span><br><span class="line">        char[]chs=str.toCharArray();</span><br><span class="line"></span><br><span class="line">        //对单个字符数组元素进行反转</span><br><span class="line">        int i=0,j=0;//定义两个指针进行遍历</span><br><span class="line">        while(j&lt;=str.length())&#123;</span><br><span class="line"></span><br><span class="line">            //以空格作为区分，对每个单词进行反转</span><br><span class="line">            if(j==str.length()||chs[j]==&#x27; &#x27;)&#123;//j==str.length()不要忘记</span><br><span class="line">                reverse(chs,i,j-1);</span><br><span class="line">                i=j+1;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果chs[j]!=&#x27; &#x27;那么继续遍历直到找到空格</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //整体字符串反转</span><br><span class="line">        reverse(chs,0,str.length()-1);</span><br><span class="line"></span><br><span class="line">        return new String(chs);//学习</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private void reverse(char[]ch,int i,int j)&#123;</span><br><span class="line">        while(i&lt;j)&#123;</span><br><span class="line">            //反转交换,代码是一样的</span><br><span class="line">            char temp=ch[i];</span><br><span class="line">            ch[i]=ch[j];</span><br><span class="line">            ch[j]=temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">本文链接：https://blog.csdn.net/hefenglian/article/details/79932709</span><br></pre></td></tr></table></figure><h1 id="最牛逼的解法：JavaScript"><a href="#最牛逼的解法：JavaScript" class="headerlink" title="最牛逼的解法：JavaScript"></a>最牛逼的解法：JavaScript</h1><p>解法：先用trim()把字符串两端空格去掉，split(‘ ‘)把字符串切割成以空格为界限的单词块，filter()过滤掉数组中的纯空格，reverse()进行数组反转，join(‘ ‘)把数组变成中间只带一个空格的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    var reverseWords = function (s) &#123;</span><br><span class="line">        var str = s.trim().split(&#x27; &#x27;).filter(item =&gt; item!=&#x27;&#x27;).reverse().join(&#x27; &#x27;)</span><br><span class="line">        console.log(str)</span><br><span class="line">    &#125;;</span><br><span class="line">作者：CHH_</span><br><span class="line">链接：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/yi-xing-dai-ma-jie-jue-suo-you-by-chen-1wz/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>暴力求解法(百度百科)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">暴力求解法, 又名直接带入法（Directly Calculating）它是已知最古老的算法之一，与&quot;直观目测法&quot;，&quot;心灵感应法&quot;并称世界三大不可思议数学计算法则， 其可追溯至3200年前，古老的埃及人便开始使用象形文字进行复杂的数学演算。它首次的文本出现是欧几里德的《几何原本》（第V卷，命题i和ii）中，而在中国则可以追溯至宋朝末年出现的沈括《梦溪笔谈》</span><br><span class="line">暴力求解法的由来</span><br><span class="line"></span><br><span class="line">在汉高祖时期有一个有趣的小故事是这样的:</span><br></pre></td></tr></table></figure><p>“高祖年间,大将军韩信征讨突厥得胜,七月七日凯旋而归，其时举国腾。信进宫，高祖曰:’淮阴侯乃真人也，战无不功克，朕三年尝闻智勇，招为爱卿，果其然，甚好甚慰。’信曰:’大王聪明仁惠，敬贤礼士，江表英豪贤归附，臣听闻蜀地龙光射牛斗之墟，人杰多地灵，又适王举兵招马，无怪骏才星驰。’高祖对曰:’今汝方成大业，且问卿求?’信:’乃望众亲赐匹布，以二渐累。’回:’善，明日使文库之卿，方得人数。’隔日使返，帝问:”需布甚许?”曰:”臣不才，方得淮阴侯亲友八十五者，食客则七百七十六人之众，臣斗胆以树枝编排数之方得须七三万千三百二十馀一匹”帝惊道:”甚许!乃至库之空不能所期，淮阴岂谋他意?”遂隔日将信斩之，不知了了。”<br>暴力求解法的演算<br>1.例题:在地面上的同一1地点分别以速率V1、V2先后竖直像上抛出两个可视为质点的小球。第二个小球抛出后经过T时间与第一个小球相遇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">设第一小球抛出后t0时间与第二小球相遇 (此时第二小球已运动T,T&lt;t0)</span><br><span class="line">因为 h1 = h2</span><br><span class="line">v1t0 - <span class="number">1</span>/2g(t0)^<span class="number">2</span> = v2T -<span class="number">1</span>/2gT^<span class="number">2</span></span><br><span class="line">所以 T = (v2+√(v2^<span class="number">2</span>-2g(v1t0 - <span class="number">1</span>/2g(t0)^<span class="number">2</span>))) / g</span><br><span class="line">又 T &lt; v2/g</span><br><span class="line">根据复杂计算</span><br><span class="line">可得 T = (v2-√v2^<span class="number">2</span>-v1^<span class="number">2</span>) / g</span><br><span class="line">所以 Tmax = (v2-√v2^<span class="number">2</span>-v1^<span class="number">2</span>) / g</span><br></pre></td></tr></table></figure></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Leetcode算法题" scheme="https://zkkget.github.io/tags/Leetcode%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁一面整理</title>
    <link href="https://zkkget.github.io/posts/20220726clho7wpkn002oyoujgahn1hme.html"/>
    <id>https://zkkget.github.io/posts/20220726clho7wpkn002oyoujgahn1hme.html</id>
    <published>2022-07-26T02:21:30.000Z</published>
    <updated>2022-07-26T02:22:19.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>java的同步容器，并发容器？<br>同步：即每次只有一个线程访问容器状态。<br>并发：即每次可有多个线程访问容器状态。<br>同步容器：Vector，HashTable<br>并发容器：ConCurrentHashMap，CopeyOnwrite<br>–当并发读远多于修改的场景下需要使用List和Set时，可以考虑使用CopyOnWriteArrayList和CopyOnWriteArraySet；<br>–当需要并发使用&lt;Key, Value&gt;键值对存取数据时，可以使用ConcurrentHashMap；<br>–当要保证并发&lt;Key, Value&gt;键值对有序时可以使用ConcurrentSkipListMap。</p><p>ArrayList和LinkedList的插入和访问的复杂度<br>即数组与链表的访问插入复杂度<br>1&gt;.数组在访问时可通过下标直接查询，复杂度O(1),链表复杂度O(n)<br>2&gt;.数组插入时数组下标需要移动O(n)，链表直接操作指针O(1)<br>反射原理—&gt;</p><blockquote><p>反射可动态加载外部配置对象，通过class.forName加载类信息，而forName方法就是通过反射类调用的类信息，<br>jvm加载获取到里面的classLoader，通过native方法获取类信息，最终调用invoke0()方法，反射是线程安全的，<br>因为loadClass方法是synchronized修饰的，找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；<br>注解原理—&gt;</p></blockquote><blockquote><p>注解等同于加了标记,注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池<br>注解参数成员必须是public的，没有成员方法也行，但是就没得意义了<br>新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？<br>新生代分为Eden区，幸存from区，幸存to区，大小比例8:1:1<br>新生代使用复制算法，高效，省去了标记整理的过程，新生代需要清理的对象数量巨大，复制算法浪费空间，但效率高，<br>–&gt;引申<br>MinorGC的过程(复制-&gt;清空-&gt;互换)<br>1:Eden,SurvivorFrom复制到SurvivorTo，年龄+1</p></blockquote><p>首先，当Eden区满的时候会触发第一次GC,把还活着的对象拷贝到SurvivorFrom区，当Eden区再次出发GC的时候会扫描Eden区和form区，对这个区域进行垃圾回收，经过这次回收还活着的，复制到To区，对象年龄+1</p><p>2:清空Eden区、SurvivorFrom</p><p>然后清空Eden区和SurvivorFrom区的对象，谁空谁是to。</p><p>3:SurvivorTo和SurvivorFrom互换</p><p>互换之后SurvivorTo成为下一次GC的From区，当对象年龄达到15，最终如果存活，存入老年代。<br>—&gt;jvm分区</p><p>jvm分区<br>jvm分区<br>堆栈方法区<br>堆管存储，类实例和数组对象存储<br>栈管运行，存储基础数据类型和引用，栈帧<br>1.8之前是方法区，1.8之后改为元空间，存储静态变量 + 常量 + 类信息(构造方法/接口定义) + 运行时常量池存在方法区中<br>—&gt;垃圾回收算法<br>复制算法，标记清除，标记压缩，引用计数算法，可达性分析算法<br>复制算法</p><p>把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。</p><p>引用计数法：循环引用不可回收，不推荐</p><p>GCRoot：可达性分析算法</p><p>从根集对象向下搜索，如果一个对象没有任何链相连时，则说明对象不可用。</p><p>哪些可以作为GC root的对象<br>1.虚拟机栈中的引用对象<br>2.方法区中的类静态属性引用的对象<br>3.方法区中常量引用的对象<br>4.本地方法栈中引用的对象<br>如何确定垃圾？<br>已经不再被内存使用到的空间<br>JVM虚拟机 YGC和FGC发生的具体场景</p><p>YGC和FGC是什么<br>YGC ：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。 （复制算法 —&gt; 一般适用对象存活率低的场景）</p><p>FGC ：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。 （标记整理或者标记清除算法 —&gt; 一般适用于对象存活率高的场景）</p><p>2、什么时候执行YGC和FGC</p><p>1、eden空间不足,执行 young gc</p><p>2、old空间不足，perm空间不足，调用方法System.gc() ，ygc时的悲观策略,<br>dump live的内存信息时(jmap –dump:live)，都会执行full gc</p><p>3.JVM老年代和新生代的比例<br>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。<br>这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。<br>新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<br>默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )</p><p>频繁 fullgc 的排查<br>full gc产生场景如上叙述一下<br>其次猜测一下大概产生原因<br>尤其是大对象，80%以上的情况就是他。 那么大对象从哪里来的：<br>【1】数据库（包括 Mysql和 Mongodb等 NOSql数据库），结果集太大；<br>【2】第三方接口传输的大对象；<br>【3】消息队列，消息太大；</p><p>排查步骤—-&gt;<br>    (1):打印GCdetail<br>    -XX:+PrintGCDtails<br>    (2):生成dump文件  注意:dump操作的时候是会发生stop the word事件的，也就是说此时所有的用户线程都会暂停运行<br>    开启XX:+HeapDumpBeforeFullGC<br>    使用jvisualvm查看<br>&lt;关于top k 问题已经在实际解决Linux 阿里云服务器问题应用&gt;<br>—&gt;JMM<br>java memory model<br>—&gt;垃圾收集器<br>并行 串行 并发标记 CMS G1 ZGC<br>G1不产生内存碎片 可精准控制停顿</p><p>–&gt;CMS垃圾回收过程<br>1.总体介绍：<br>CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于老年代的回收采用CMS。CMS采用的基础算法是：标记—清除。</p><p>CMS<br>CMS<br>2.CMS过程：<br>初始标记(STW initial mark)<br>并发标记(Concurrent marking)<br>并发预清理(Concurrent precleaning)<br>重新标记(STW remark)<br>并发清理(Concurrent sweeping)<br>并发重置(Concurrent reset)<br>5.如何处理接口的重复请求？不得不说他不好好问，目的是问如何保证接口的幂等性?<br>分布式系统中，服务部署在不同的服务器上，但是数据要保证打到一个redis上<br>对于每个请求必须有一个唯一的标识。举个例子：订单支付请求，肯定得包含订单 id，一个订单 id 最多支付一次。<br>每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在数据库中记录个状态，比如支付之前记录一条这个订单的支付流水。<br>每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId 已经存在了，唯一键约束生效，报错插入不进去的。然后系统就不用再扣款了。<br>在网络延迟传输中，会造成消息队列重试，在重试过程中，消息会存在重复</p><p>解决方案：</p><p>1.如果是数据库的插入操作，给消息做一个主键，避免出现脏数据。<br>2.使用第三方做消费记录，例如Redis，全局id为K，消息为V，写入到Redis，消费之前先去查Redis是否存在<br>–&gt;引申分布式系统中如何生成高效的分布式唯一ID 雪花算法<br>可用分布式锁,redis 递增,机器的唯一码 拿出几位存为机器id,这样一来每次查询操作相对更快</p><p>G1回收器有个非常好的特性就是会不断的帮助JVM调整策略， 会根据实际的GC情况调整年轻代和老年代的比例大小，默认情况下，年轻代最多可以占用60%的堆内存。这其实就是GC的灵活性。</p><p>G1的另一个显著特点他能够让用户设置应用的暂停时间，通过参数：-XX:MaxGCPauseMillis来指定，为什么G1能做到这一点呢？也许你已经注意到了，G1回收的第4步，它是“选择一些内存块”，而不是整代内存来回收，这是G1跟其它GC非常不同的一点，其它GC每次回收都会回收整个Generation的内存(Eden, Old), 而回收内存所需的时间就取决于内存的大小，以及实际垃圾的多少，所以垃圾回收时间是不可控的；而G1每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如</p><p>Http与Https的区别？<br>博客:<a href="https://blog.csdn.net/guolin_blog/article/details/104546558">https://blog.csdn.net/guolin_blog/article/details/104546558</a><br>总结：首先回答对称加密以及非对称加密的区别。<br>对称加密比较简单，就是客户端和服务器共用同一个密钥，该密钥可以用于加密一段内容，同时也可以用于解密这段内容。对称加密的优点是加解密效率高，但是在安全性方面可能存在一些问题，因为密钥存放在客户端有被窃取的风险。对称加密的代表算法有：AES、DES等。</p><p>而非对称加密则要复杂一点，它将密钥分成了两种：公钥和私钥。公钥通常存放在客户端，私钥通常存放在服务器。使用公钥加密的数据只有用私钥才能解密，反过来使用私钥加密的数据也只有用公钥才能解密。非对称加密的优点是安全性更高，因为客户端发送给服务器的加密信息只有用服务器的私钥才能解密，因此不用担心被别人破解，但缺点是加解密的效率相比于对称加密要差很多。非对称加密的代表算法有：RSA、ElGamal等。<br>关键词：CA机构<br>个人理解：https使用的是对称加密与非对称加密相结合的方式。首先双端通信使用非对称加密，客户端加密传输时先请求第三方CA机构，CA加密处理完返回给服务器端，证书中加入了网站的域名，</p><p>redis掀桌连问</p><p>redis<br>redis<br>1.redis的hash怎么实现的？(实现原理)rehash过程<br>redis初始创建hash表,有序集合，链表时, 存储结构采用一种ziplist的存储结构, 这种结构内存排列更紧密, 能提高访存性能.<br>hash_max_ziplist_entries和hash_max_ziplist_value值作为阀值，hash_max_ziplist_entries表示一旦ziplist中元素数量超过该值，则需要转换为dict结构；hash_max_ziplist_value表示一旦ziplist中数据长度大于该值，则需要转换为dict结构。<br>哈希等价于Java语言的HashMap或者是Python语言的字典（Dict）<br>redis hash 的内部结构.第一维是数组,第二维是链表.组成一个 hashtable.<br>在 Java 中 HashMap 扩容是个很耗时的操作,需要去申请新的数组,为了追求高性能,Redis 采用了渐进式 rehash 策略.这也是 hash 中最重要的部分.<br>在扩容的时候 rehash 策略会保留新旧两个 hashtable 结构,查询时也会同时查询两个 hashtable.Redis会将旧 hashtable 中的内容一点一点的迁移到新的 hashtable 中,当迁移完成时,就会用新的 hashtable 取代之前的.当 hashtable 移除了最后一个元素之后,这个数据结构将会被删除.<br><a href="https://juejin.im/post/5cfe6383e51d45599e019d8f">https://juejin.im/post/5cfe6383e51d45599e019d8f</a><br>与java的hashmap的rehash区别<br>个人理解：hashmap的rehash是一次性拷贝的，不同的是，Redis的字典只能是字符串，另外他们rehash的方式不一样，因为Java的HashMap的字典很大时，rehash是个耗时的操作，需要一次全部rehash。Redis为了追求高性能，不能堵塞服务，所以采用了渐进式rehash策略。<br>rehash的详细步骤<br><a href="https://www.cnblogs.com/meituantech/p/9376472.html">https://www.cnblogs.com/meituantech/p/9376472.html</a><br>与ConcurrentHashMap扩容的策略比较？<br>ConcurrentHashMap采用的扩容策略为： “多线程协同式rehash“。<br>1.扩容所花费的时间对比： 一个单线程渐进扩容，一个多线程协同扩容。在平均的情况下，是ConcurrentHashMap 快。这也意味着，扩容时所需要 花费的空间能够更快的进行释放。<br>2.读操作，两者性能相差不多。<br>3.写操作，Redis的字典返回更快些，因为它不像ConcurrentHashMap那样去帮着扩容(当要写的桶位已经搬到了newTable时)，等扩容完才能进行操作。<br>4.删除操作，与写一样。<br><a href="http://xytschool.com/resource/236.html">http://xytschool.com/resource/236.html</a><br>redis如何保证高可用<br>保证redis高可用机制需要redis主从复制、redis持久化机制、哨兵机制、keepalived等的支持。<br>主从复制的作用：数据备份、读写分离、分布式集群、实现高可用、宕机容错机制等。</p><p>redis主从复制原理<br>首先主从复制需要分为两个角色：master(主) 和 slave(从) ，注意：redis里面只支持一个主，不像Mysql、Nginx主从复制可以多主多从。</p><p>(1)redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</p><p>(2)通过redis的复制功能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p><p><a href="https://blog.csdn.net/itcats_cn/article/details/82428716">https://blog.csdn.net/itcats_cn/article/details/82428716</a></p><h1 id="说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？"><a href="#说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？" class="headerlink" title="说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？***"></a>说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？***</h1><p>个人理解：强一致性的数据是不适合放在缓存中的。另外MySQL对事务的支持也是redis本身不能达到的，需要单独实现<br>一般不是说redis or  MySQL,而是redis+MySQL<br><a href="https://blog.csdn.net/u011784767/article/details/76824822">https://blog.csdn.net/u011784767/article/details/76824822</a><br>为什么Redis进行RDB持久化数据时，新起一个进程而不是在原进程中起一个线程来持久化数据<br>(1)Redis RDB持久化机制会阻塞主进程，这样主进程就无法响应客户端请求。<br>(2)我们知道Redis对客户端响应请求的工作模型是单进程和单线程的，如果在主进程内启动一个线程，这样会造成对数据的竞争条件，为了避免使用锁降低性能。基于以上两点这就是为什么Redis通过启动一个进程来执行RDB了<br>—单线程的redis为什么这么快<br>(1)纯内存操作<br>(2)单线程操作，避免了频繁的上下文切换<br>(3)采用了非阻塞I/O多路复用机制</p><p>1<br>—Redis的数据类型以及使用场景<br>(1)String<br>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。<br>一般做一些复杂的计数功能的缓存。</p><p>(2)hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，<br>就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p><p>(3)list<br>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，<br>做基于redis的分页功能，性能极佳，用户体验好。</p><p>(4)set<br>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？<br>因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再启一个公共服务，太麻烦了。</p><p>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><p>(5)sorted set<br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。sorted set可以用来做延时任务。最后一个应用就是可以做范围查找</p><p>1</p><h1 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h1><p>redis采用的是定期删除+惰性删除+内存淘汰策略。<br>[2020年6月29日17:25:36在平时的项目中测试，不定期会产生无用token的key数据，平时可以进行模糊删除]</p><p>```<br>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p><p>解决方案:<br>(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试<br>(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，<br>异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。<br>(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。<br>迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p><p>缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p><p>解决方案:<br>(一)给缓存的失效时间，加上一个随机值，避免集体失效。<br>(二)使用互斥锁，但是该方案吞吐量明显下降了。<br>(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。<br>自己做缓存预热操作。然后细分以下几个小点<br>1 从缓存A读数据库，有则直接返回<br>2 A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。<br>3 更新线程同时更新缓存A和缓存B。</p><p>8、如何解决redis的并发竞争key问题</p><p>分析:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。<br>需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。<br>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，<br>这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。</p><p>回答:如下所示<br>(1)如果对这个key操作，不要求顺序<br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>(2)如果对这个key操作，要求顺序<br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，<br>需要保存一个时间戳。假设时间戳如下<br>系统A key 1 {valueA  3:00}<br>系统B key 1 {valueB  3:05}<br>系统C key 1 {valueC  3:10}<br>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。<br>redis分页<br>HSCAN testHash “0” count 10</p><p>注：测试field数量在22条时（没有测试Redis中Hash使分页生效时的field数量的下限），分页未生效。<br>#mysql 执行一个 sql 的过程<br>执行完毕之后有一个缓存的过程</p><p>mysql<br>mysql<br><a href="https://www.cnblogs.com/luoying/p/12073812.html">https://www.cnblogs.com/luoying/p/12073812.html</a></p><p>MySQL分页limit速度太慢的优化方法<br>1.子查询优化法<br>先找出第一条数据，然后大于等于这条数据的id就是要获取的数据<br>缺点：数据必须是连续的，可以说不能有where条件，where条件会筛选数据，导致数据失去连续性<br>2.limit限制优化法<br>把limit偏移量限制低于某个数<br>3.where条件先过滤后分页<br>wait notify 为什么要搭配使用？<br>单独调用会报异常<br>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。因为程序验证通常是在对象的同步方法或同步代码块中调用它们的。如果尝试在未获取对象锁时调用这三个方法，<br>“java.lang.IllegalMonitorStateException:current thread not owner”。<br>底层把对象作为一个监视器</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "赵KK日常技术记录","blogId": "62435-1742912502174-081","qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png","keyword": "验证码","random": "1","height": "auto","expires": "7","lockToc": "yes","interval": "60","baseUrl": ""});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="面试" scheme="https://zkkget.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
