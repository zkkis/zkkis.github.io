<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>公众号【赵KK日常技术记录】欢迎关注点击</title>
    <url>/posts/20230427a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/666.png" alt="公众号"></p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>公众号【赵KK日常技术记录】欢迎关注</category>
      </categories>
      <tags>
        <tag>公众号【赵KK日常技术记录】欢迎关注</tag>
      </tags>
  </entry>
  <entry>
    <title>个人公众号赵KK日常技术记录     温馨提示本站所有资料仅供学习交流-严禁用于商业用途-请于24小时内删除</title>
    <url>/posts/20230427a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><!DOCTYPE html>

<html>

<head>

  <meta charset="UTF-8">

  <title>Markdown标题变红</title>

  <style>

    .title-red {
      color: red;
    }
  </style>

  <script>

    var headings = document.getElementsByTagName('h1');
    for (var i = 0; i < headings.length; i++) {
      headings[i].classList.add("title-red");
    }
  </script>

</head>

<body>

<h1>个人公众号赵KK日常技术记录     温馨提示本站所有资料仅供学习交流-严禁用于商业用途-请于24小时内删除</h1>

</body>

</html></div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>AI工具大合集</category>
      </categories>
  </entry>
  <entry>
    <title>AI工具大合集【不定期更新】</title>
    <url>/posts/20230425a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h1 id="答案在路上，自由在风里，风吹哪页读哪页，哪页不懂撕哪页"><a href="#答案在路上，自由在风里，风吹哪页读哪页，哪页不懂撕哪页" class="headerlink" title="答案在路上，自由在风里，风吹哪页读哪页，哪页不懂撕哪页"></a>答案在路上，自由在风里，风吹哪页读哪页，哪页不懂撕哪页</h1><h1 id="今天你别想走出这个网页"><a href="#今天你别想走出这个网页" class="headerlink" title="今天你别想走出这个网页"></a>今天你别想走出这个网页</h1><h1 id="温馨提示：本站所有资料仅供学习交流-严禁用于商业用途-请于24小时内删除"><a href="#温馨提示：本站所有资料仅供学习交流-严禁用于商业用途-请于24小时内删除" class="headerlink" title="温馨提示：本站所有资料仅供学习交流,严禁用于商业用途,请于24小时内删除"></a>温馨提示：本站所有资料仅供学习交流,严禁用于商业用途,请于24小时内删除</h1><h1 id="文章底部有文章目录按钮"><a href="#文章底部有文章目录按钮" class="headerlink" title="文章底部有文章目录按钮~~~~~"></a>文章底部有文章目录按钮~~~~~</h1><h1 id="需要什么资料可以在最下方留言-不定期更新"><a href="#需要什么资料可以在最下方留言-不定期更新" class="headerlink" title="需要什么资料可以在最下方留言,不定期更新"></a>需要什么资料可以在最下方留言,不定期更新</h1><h1 id="AI-Gamma一键生成PPT工具直达链接"><a href="#AI-Gamma一键生成PPT工具直达链接" class="headerlink" title="AI Gamma一键生成PPT工具直达链接"></a>AI Gamma一键生成PPT工具直达链接</h1><h2 id="https-gamma-app-signup-r-sqgovd3iif5btr4"><a href="#https-gamma-app-signup-r-sqgovd3iif5btr4" class="headerlink" title="https://gamma.app/signup?r=sqgovd3iif5btr4"></a><a href="https://gamma.app/signup?r=sqgovd3iif5btr4">https://gamma.app/signup?r=sqgovd3iif5btr4</a></h2><p><img src="/posts/20230425a1/640.png" alt="Gamma"><br><img src="/posts/20230425a1/1.png" alt="求关注"><br><img src="/posts/20230425a1/2.png" alt="求点赞"><br><img src="/posts/20230425a1/3.png" alt="求转发"></p>
<h2 id="导入MindShow-生成PPT先让ChatGPT生成MarkDown代码"><a href="#导入MindShow-生成PPT先让ChatGPT生成MarkDown代码" class="headerlink" title="导入MindShow 生成PPT先让ChatGPT生成MarkDown代码"></a>导入MindShow 生成PPT先让ChatGPT生成MarkDown代码</h2><p><a href="https://www.mindshow.fun/#/login?inviteCode=6597612">https://www.mindshow.fun/#/login?inviteCode=6597612</a><br><img src="/posts/20230425a1/mindshow.png" alt="Gamma"></p>
<h1 id="听说你有编码命名强迫症？命名困难症？"><a href="#听说你有编码命名强迫症？命名困难症？" class="headerlink" title="听说你有编码命名强迫症？命名困难症？"></a>听说你有编码命名强迫症？命名困难症？</h1><p><a href="https://www.chtml.cn/">https://www.chtml.cn/</a><br><img src="/posts/20230425a1/7.png" alt="编码命名"></p>
<h1 id="一起薅羊毛啦！我在用小绿鲸读文献，点击链接"><a href="#一起薅羊毛啦！我在用小绿鲸读文献，点击链接" class="headerlink" title="一起薅羊毛啦！我在用小绿鲸读文献，点击链接"></a>一起薅羊毛啦！我在用小绿鲸读文献，点击链接</h1><p><a href="https://www.xljsci.com/?regCode=j28w8w">https://www.xljsci.com?regCode=j28w8w</a><br><img src="/posts/20230425a1/01.png" alt="小绿鲸"><br>并使用邀请码【j28w8w】注册，和我一起得200M网盘容量！(请在浏览器中打开链接)</p>
<h1 id="AI-PPT-中文绘画大网站直达链接"><a href="#AI-PPT-中文绘画大网站直达链接" class="headerlink" title="AI PPT 中文绘画大网站直达链接"></a>AI PPT 中文绘画大网站直达链接</h1><p><a href="https://aigc.yizhentv.com/invite/register.html?inviteCode=VSLG9JAGJVGHW1">https://aigc.yizhentv.com/invite/register.html?inviteCode=VSLG9JAGJVGHW1</a><br><img src="/posts/20230425a1/6.png" alt="JasperAI"></p>
<h1 id="免费用字体-我用字由-邀请码68445803"><a href="#免费用字体-我用字由-邀请码68445803" class="headerlink" title="免费用字体  我用字由 邀请码68445803"></a>免费用字体  我用字由 邀请码68445803</h1><p><img src="/posts/20230425a1/%E5%AD%97%E7%94%B1.png" alt="字由"></p>
<h1 id="点击链接参与粉丝抽奖"><a href="#点击链接参与粉丝抽奖" class="headerlink" title="点击链接参与粉丝抽奖"></a>点击链接参与粉丝抽奖</h1><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486690&amp;idx=1&amp;sn=42eba1d4d2ae9e222194fb87fa432861&amp;chksm=ceb0939ff9c71a898f352370c6eaea127bd5bf9d0dceacab48585b7110119749aca22a280b64&amp;token=1841629559&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486690&amp;idx=1&amp;sn=42eba1d4d2ae9e222194fb87fa432861&amp;chksm=ceb0939ff9c71a898f352370c6eaea127bd5bf9d0dceacab48585b7110119749aca22a280b64&amp;token=1841629559&amp;lang=zh_CN#rd</a></p>
<h2 id="自媒体分享计划-https-cloud-tencent-com-developer-support-plan-invite-code-32g0nq650b0go"><a href="#自媒体分享计划-https-cloud-tencent-com-developer-support-plan-invite-code-32g0nq650b0go" class="headerlink" title="自媒体分享计划 https://cloud.tencent.com/developer/support-plan?invite_code=32g0nq650b0go"></a>自媒体分享计划 <a href="https://cloud.tencent.com/developer/support-plan?invite_code=32g0nq650b0go">https://cloud.tencent.com/developer/support-plan?invite_code=32g0nq650b0go</a></h2><h2 id="邀请好友加入阿里云开发者大家庭"><a href="#邀请好友加入阿里云开发者大家庭" class="headerlink" title="邀请好友加入阿里云开发者大家庭"></a>邀请好友加入阿里云开发者大家庭</h2><p><a href="https://developer.aliyun.com/mission/invite?taskCode=6660&amp;recordId=da66fefbb1869cb851fd9157a063994a&amp;share_source=copy_link">https://developer.aliyun.com/mission/invite?taskCode=6660&amp;recordId=da66fefbb1869cb851fd9157a063994a&amp;share_source=copy_link</a></p>
<!DOCTYPE html>

<html>

<head>

  <meta charset="UTF-8">

  <title>Markdown标题变红</title>

  <style>

    .title-red {
      color: green;
    }
  </style>

  <script>

    var headings = document.getElementsByTagName('h1');
    for (var i = 0; i < headings.length; i++) {
    var randomColor = Math.floor(Math.random()*16777215).toString(16);
    headings[i].style.color = "#" + randomColor;
  }
  </script>

</head>

<body>

<h1>温馨提示：本站所有资料仅供学习交流,严禁用于商业用途,请于24小时内删除</h1>

</body>

</html>

<h1 id="AI绘画提示词"><a href="#AI绘画提示词" class="headerlink" title="AI绘画提示词"></a>AI绘画提示词</h1><p>我用夸克网盘分享了「AI绘画提示词.txt」，点击链接即可保存。打开「夸克APP」在线查看，支持多种文档格式转换。<br>链接：<a href="https://pan.quark.cn/s/33511fcf587e">https://pan.quark.cn/s/33511fcf587e</a></p>
<h1 id="GPT相关新闻"><a href="#GPT相关新闻" class="headerlink" title="GPT相关新闻"></a>GPT相关新闻</h1><p>OpenAl、谷歌、微软 CEO 将在本周四往白宫参会与美国副总统讨论 AI 风险问题。<br>2.本周一，美国好莱坞编剧发起 15 年来首次大罢工。认为AI威胁其生存，要求限制 AI 在编剧领域的使用<br>3.HR GPT 来了: GONEX- IRIS，自动化进行员工满意度和绩效分析、入职流程、薪资核算、政策提供等。<br>美国在线教育公司股价暴跌。Chegg下跌 40%4Pearson 下跌 15%，Duolingo 下跌 10%。<br>5.Twilio Segment报告: 92%的公司采用人工智能技术提供个性化的客户体验，以推动业务增长。<br>6.中国AIGC产业峰会现场，智谱AI CEO: 国有 GPT大语言模型痛点: 成本、人力、算法。<br>7.Moonbeam: <a href="https://moonbeam.network/">https://moonbeam.network/</a> 长文章AI内容创作助手<br>8.MidJourney Prompt Helper: <a href="https://prompt.noonshot.com/midjourney">https://prompt.noonshot.com/midjourney</a> 帮忙写MJ咒语</p>
<p>1.周鸿讳内部信:360 员工不会被 GPT淘汰<br>2.刘慈欣谈Al:人类若生活在科技的安乐窝里，终将会被“消灭”!<br>3.美国官员也加入chatGPT 热潮:将研究利用AI 保护国土安全<br>4.生成式AI是最大功臣，英伟达市值近4个月增加3290亿美元<br>5.拉勾招聘:25%AIGC算法工程师岗位月薪超68K超4成科技人才在职场应用ChatGPT<br>6.2023年3月，AIGC(意为人工智能生成内容)人才岗位需求量环比增加42%。<br>7.复旦大学开发的国内首个类ChatGPT大模型MOSS开源，其具有160亿参数，在FP16精度下可在单张A100/A800或两张3090显卡上运行。<br>8.钉钉:接入[通义千问] 大模型，智能办公助手。</p>
<p>Gptrpg:一个基于GPT的代理在RPG类似的环境中的演示<br>“序列猴子”，为个人出门问问内测探索大模型与企业打造专属CoPilot<br>AppGrowing国际版推出AI本地化旁白功能。<br>HealthGPT:使用自然语言查询您的苹果健康数据<br>KeepChatGPT:完美解决chatGPT网络错误，不再频繁地刷新网页<br>Al Story Generator:可让用户轻松利用AI创作自己独特的故事和小说<br>Auto-GPT-ZH:Auto-GPT中文版本，由爱好者组织，同步更新原项目，可用于AI领域创业、自媒体组织、用AI工作学习创作变现等。<br>Vault-ai:使用简单的React前端上传您自己的自定义知识库文件(PDF、txt等)</p>
<h1 id="PPT模板社区-好工具一定要分享给最好的朋友，ProcessOn助您和好友一起高效办公！"><a href="#PPT模板社区-好工具一定要分享给最好的朋友，ProcessOn助您和好友一起高效办公！" class="headerlink" title="PPT模板社区 好工具一定要分享给最好的朋友，ProcessOn助您和好友一起高效办公！"></a>PPT模板社区 好工具一定要分享给最好的朋友，ProcessOn助您和好友一起高效办公！</h1><p><a href="https://www.processon.com/i/5b961737e4b0bd4db9342c44/?full_name=%E8%B5%B5KK">https://www.processon.com/i/5b961737e4b0bd4db9342c44/?full_name=%E8%B5%B5KK</a></p>
<h1 id="JasperAI-10000字免费额度试用-https-jasper-ai"><a href="#JasperAI-10000字免费额度试用-https-jasper-ai" class="headerlink" title="JasperAI 10000字免费额度试用 https://jasper.ai"></a>JasperAI 10000字免费额度试用 <a href="https://jasper.ai/">https://jasper.ai</a></h1><p><img src="/posts/20230425a1/4.png" alt="JasperAI"></p>
<h1 id="这就是公众号说的免费GPT-4-chat-forefront-ai"><a href="#这就是公众号说的免费GPT-4-chat-forefront-ai" class="headerlink" title="这就是公众号说的免费GPT-4 chat.forefront.ai"></a>这就是公众号说的免费GPT-4 chat.forefront.ai</h1><p><img src="/posts/20230425a1/5.png" alt="JasperAI"></p>
<p>Lumen5是一款在线视频制作平台，可以把文本、图片等内容快速转化成视频，非常适合制作社交媒体广告和短视频。以下是Lumen5的网址和简单教程：<br>网址：<a href="https://lumen5.com/">https://lumen5.com/</a> 教程：<a href="https://lumen5.com/learn">https://lumen5.com/learn</a><br>使用Lumen5制作视频非常简单，只需要将你的文本或网址粘贴到平台上，选择模板并上传图片或视频素材，Lumen5就可以自动为你生成一个视频。<br>除了Lumen5之外，还有很多类似的在线视频制作平台可供选择，例如：<br>Canva：<a href="https://www.canva.com/create/videos/">https://www.canva.com/create/videos/</a><br>Animoto：<a href="https://animoto.com/">https://animoto.com/</a><br>Biteable：<a href="https://biteable.com/">https://biteable.com/</a><br>Powtoon：<a href="https://www.powtoon.com/">https://www.powtoon.com/</a><br>Renderforest：<a href="https://www.renderforest.com/">https://www.renderforest.com/</a></p>
<h1 id="关注公众号回复SVF获取SVF补帧插件和说明操作手册"><a href="#关注公众号回复SVF获取SVF补帧插件和说明操作手册" class="headerlink" title="关注公众号回复SVF获取SVF补帧插件和说明操作手册"></a>关注公众号回复SVF获取SVF补帧插件和说明操作手册</h1><h1 id="无需魔法的模型插件网站秒下载"><a href="#无需魔法的模型插件网站秒下载" class="headerlink" title="无需魔法的模型插件网站秒下载"></a>无需魔法的模型插件网站秒下载</h1><p><a href="https://www.liblibai.com/#/index/model">https://www.liblibai.com/#/index/model</a></p>
<h2 id="Stable-Diffusion。Controlnet发布新模型tile，可用于高清图生成"><a href="#Stable-Diffusion。Controlnet发布新模型tile，可用于高清图生成" class="headerlink" title="Stable Diffusion。Controlnet发布新模型tile，可用于高清图生成"></a>Stable Diffusion。Controlnet发布新模型tile，可用于高清图生成</h2><p>模型介绍：<a href="https://github.com/Mikubill/sd-webui-controlnet/issues/1033">https://github.com/Mikubill/sd-webui-controlnet/issues/1033</a><br>插件下载：<a href="https://github.com/Mikubill/sd-webui-controlnet">https://github.com/Mikubill/sd-webui-controlnet</a><br>模型下载：<a href="https://huggingface.co/lllyasviel/ControlNet-v1-1/tree/main">https://huggingface.co/lllyasviel/ControlNet-v1-1/tree/main</a></p>
<h2 id="Stable-Diffusion-大模型"><a href="#Stable-Diffusion-大模型" class="headerlink" title="Stable Diffusion 大模型"></a>Stable Diffusion 大模型</h2><p>我用夸克网盘分享了「人工智能公司及其产品概述」，点击链接即可保存。打开「夸克APP」，无需下载在线播放视频，畅享原画5倍速，支持电视投屏。<br>链接：<a href="https://pan.quark.cn/s/96c553f93b1e">https://pan.quark.cn/s/96c553f93b1e</a></p>
<p>我用夸克网盘分享了「154页GPT中文文档」，点击链接即可保存。打开「夸克APP」，无需下载在线播放视频，畅享原画5倍速，支持电视投屏。<br>链接：<a href="https://pan.quark.cn/s/65dffd78335e">https://pan.quark.cn/s/65dffd78335e</a></p>
<p>我用夸克网盘分享了「免费GPT工具」，点击链接即可保存。打开「夸克APP」，无需下载在线播放视频，畅享原画5倍速，支持电视投屏。<br>链接：<a href="https://pan.quark.cn/s/6c89133a2df0">https://pan.quark.cn/s/6c89133a2df0</a></p>
<p>我用夸克网盘分享了「Stable Diffusion 大模型」，点击链接即可保存。打开「夸克APP」，无需下载在线播放视频，畅享原画5倍速，支持电视投屏。<br>链接：<a href="https://pan.quark.cn/s/3fd212356810">https://pan.quark.cn/s/3fd212356810</a></p>
<p>我用夸克网盘分享了「Stable Diffusion  Lora模型」，点击链接即可保存。打开「夸克APP」，无需下载在线播放视频，畅享原画5倍速，支持电视投屏。<br>链接：<a href="https://pan.quark.cn/s/9117425d5332">https://pan.quark.cn/s/9117425d5332</a></p>
<p>我用夸克网盘分享了「AI绘画提示词.txt」，点击链接即可保存。打开「夸克APP」在线查看，支持多种文档格式转换。<br>链接：<a href="https://pan.quark.cn/s/6fac287f1e60">https://pan.quark.cn/s/6fac287f1e60</a></p>
<p>我用夸克网盘分享了「PPT超级市场.txt」，点击链接即可保存。打开「夸克APP」在线查看，支持多种文档格式转换。<br>链接：<a href="https://pan.quark.cn/s/fb9e633a8185">https://pan.quark.cn/s/fb9e633a8185</a></p>
<p>我用夸克网盘分享了「免费GPT网站合集.txt」，点击链接即可保存。打开「夸克APP」在线查看，支持多种文档格式转换。<br>链接：<a href="https://pan.quark.cn/s/dc36c6c502aa">https://pan.quark.cn/s/dc36c6c502aa</a></p>
<p>我用夸克网盘分享了「timat.png」，点击链接即可保存。打开「夸克APP」，无需下载在线播放视频，畅享原画5倍速，支持电视投屏。<br>链接：<a href="https://pan.quark.cn/s/9dadbfdad0ee">https://pan.quark.cn/s/9dadbfdad0ee</a></p>
<h2 id="在使用MMOCR制作自己的数据集时，可以使用以下标注工具："><a href="#在使用MMOCR制作自己的数据集时，可以使用以下标注工具：" class="headerlink" title="在使用MMOCR制作自己的数据集时，可以使用以下标注工具："></a>在使用MMOCR制作自己的数据集时，可以使用以下标注工具：</h2><p>1.LabelImg:LabelImg是一款免费的图像标注工具，支持多种标注类型，包括边界框、矩形、多边形、点等。</p>
<p>2.VGG Image Annotator (VIA):VIA是一款基于Web的图像标注工具，支持多种标注类型，包括边界框、矩形、多边形、点等。</p>
<p>3.RectLabel:RectLabel是一款专门用于矩形标注的工具，支持多种颜色和字体选择。</p>
<p>Supervisely:Supervisely是一款在线图像标注工具，支持多种标注类型，包括边界框、矩形、多边形、点等。<br>5.Labelbox:Labelbox是一款云端图像标注平台，支持多种标注类型，包括边界框、矩形、多边形、点等。同时还提供了丰富的API接口和机器学习算法支持。</p>
<h2 id="图文转视频"><a href="#图文转视频" class="headerlink" title="图文转视频"></a>图文转视频</h2><p>Lumen5是一款在线视频制作平台，可以把文本、图片等内容快速转化成视频，非常适合制作社交媒体广告和短视频。以下是Lumen5的网址和简单教程：<br>网址：<a href="https://lumen5.com/">https://lumen5.com/</a> 教程：<a href="https://lumen5.com/learn">https://lumen5.com/learn</a><br>使用Lumen5制作视频非常简单，只需要将你的文本或网址粘贴到平台上，选择模板并上传图片或视频素材，Lumen5就可以自动为你生成一个视频。<br>除了Lumen5之外，还有很多类似的在线视频制作平台可供选择，例如：<br>Canva：<a href="https://www.canva.com/create/videos/">https://www.canva.com/create/videos/</a><br>Animoto：<a href="https://animoto.com/">https://animoto.com/</a><br>Biteable：<a href="https://biteable.com/">https://biteable.com/</a><br>Powtoon：<a href="https://www.powtoon.com/">https://www.powtoon.com/</a><br>Renderforest：<a href="https://www.renderforest.com/">https://www.renderforest.com/</a></p>
<h2 id="文字生成视频首先推荐剪映，必剪"><a href="#文字生成视频首先推荐剪映，必剪" class="headerlink" title="文字生成视频首先推荐剪映，必剪"></a>文字生成视频首先推荐剪映，必剪</h2><p>Rephrase.ai<br><a href="https://www.rephrase.ai/">https://www.rephrase.ai/</a></p>
<p>Synthesia<br><a href="https://www.synthesia.io/?via=ai-bot">https://www.synthesia.io/?via=ai-bot</a><br>它们的功能和操作方式都有所不同，建议你可以试试几个不同的平台，选择最适合自己的一个。</p>
<h2 id="AI生成ppt"><a href="#AI生成ppt" class="headerlink" title="AI生成ppt"></a>AI生成ppt</h2><p>自动做PPT：beautiful AI<br>Tome：<a href="https://beta.tome.app/">https://beta.tome.app/</a><br>Gamma： <a href="https://gamma.app/signup?r=sqgovd3iif5btr4">https://gamma.app/signup?r=sqgovd3iif5btr4</a><br>chatBA：<a href="https://www.chatba.com/">https://www.chatba.com/</a><br>iA presenter：<a href="https://ia.net/presenter">https://ia.net/presenter</a><br>chronicle：<a href="https://chroniclehq.com/">https://chroniclehq.com/</a><br>beautiful.ai <a href="https://www.beautiful.ai/">https://www.beautiful.ai/</a><br>Mind Show:<a href="https://www.mindshow.fun/#/home">https://www.mindshow.fun/#/home</a> 自动生成PPT根据大纲内容<br>M365 设计器:<a href="https://www.microsoft.com/zh-cn/microsoft-365/premium-templates-with-microsoft-365">https://www.microsoft.com/zh-cn/microsoft-365/premium-templates-with-microsoft-365</a> 丢进文字和图片，自动美化排版PPT<br>Flourish:<a href="https://flourish.studio/">https://flourish.studio/</a> 输入数据表格，自动生成PPT动态可视化图表<br>SlidesGPT：仅需一句话，人工智能就能一键生成PPT的工具<br>Icecream：对电脑性能要求不高的PPT制作工具<br>Wepik：智能AI在几分钟内帮你生成演示文稿的工具<br>SlideHub：商务办公人士都爱使用的 PPT演示工具<br>Ludus：像搭积木一样的块式幻灯片演示工具<br>Decktopus：极短的时间内创建视觉效果惊人的PPT工具<br>Storydoc：可帮你轻松创建交互式演示文稿的工具</p>
<h1 id="免费下载PPT的网站："><a href="#免费下载PPT的网站：" class="headerlink" title="免费下载PPT的网站："></a>免费下载PPT的网站：</h1><h2 id="以下是10余款AI免费PPT工具网站的推荐："><a href="#以下是10余款AI免费PPT工具网站的推荐：" class="headerlink" title="以下是10余款AI免费PPT工具网站的推荐："></a>以下是10余款AI免费PPT工具网站的推荐：</h2><p>Canva（<a href="https://www.canva.com/%EF%BC%89">https://www.canva.com/）</a><br>Canva是一款非常强大的在线平台，可以用来创建各种视觉元素，包括PPT幻灯片。Canva使用简单，提供了大量的模板、样式和设计元素，并且支持AI技术，可以根据用户的需要自动调整视觉元素。</p>
<p>Zoho Show（<a href="https://www.zoho.com/show/%EF%BC%89">https://www.zoho.com/show/）</a><br>Zoho Show是一款在线PPT工具，支持AI技术，可以根据用户的要求自动排版和设计幻灯片。Zoho Show提供了许多模板和主题，使得用户可以快速创建出漂亮的PPT。</p>
<p>Prezi（<a href="https://prezi.com/%EF%BC%89">https://prezi.com/）</a><br>Prezi是一种非线性的演示工具，使用了AI和动画技术，可以使演示更加生动有趣。Prezi提供了许多主题和模板，还可以自由移动和缩放画布上的元素，给用户更大的自由度。</p>
<p>Visme（<a href="https://www.visme.co/%EF%BC%89">https://www.visme.co/）</a><br>Visme是一款科技感强的PPT工具，支持AI技术，可以根据用户的选择自动生成幻灯片。Visme提供了许多图标、图表等视觉元素，在用户创建演示时会自动进行排版和布局优化</p>
<p>Slides Carnival:<a href="https://www.slidescarnival.com/">https://www.slidescarnival.com/</a><br>PPT Template:<a href="https://www.ppttemplate.net/">https://www.ppttemplate.net/</a><br>Free PowerPoint Templates:<a href="https://www.free-power-point-templates.com/">https://www.free-power-point-templates.com/</a><br>PoweredTemplate:<a href="https://www.poweredtemplate.com/">https://www.poweredtemplate.com/</a><br>Presentation Magazine:<a href="https://www.presentationmagazine.com/free-powerpoint-templates/">https://www.presentationmagazine.com/free-powerpoint-templates/</a><br>FPPT:<a href="https://www.free-power-point-templates.com/">https://www.free-power-point-templates.com/</a><br>24Slides:<a href="https://24slides.com/free-powerpoint-templates/">https://24slides.com/free-powerpoint-templates/</a><br>Canva:<a href="https://www.canva.com/templates/presentations/">https://www.canva.com/templates/presentations/</a><br>Pikbest:<a href="https://www.pikbest.com/free-powerpoint-templates/">https://www.pikbest.com/free-powerpoint-templates/</a><br>Template.net:<a href="https://www.template.net/business/powerpoint-templates/free">https://www.template.net/business/powerpoint-templates/free</a></p>
<h2 id="免费GPT网站合集："><a href="#免费GPT网站合集：" class="headerlink" title="免费GPT网站合集："></a>免费GPT网站合集：</h2><p>chat8:<a href="https://chat.gamejx.cn/#/register?bronk_on=646565">https://chat.gamejx.cn/#/register?bronk_on=646565</a><br>chatgpt:<a href="https://s.wikll.com/">https://s.wikll.com/</a><br>AI网站：<a href="http://www.aitoolist.cn/">www.aitoolist.cn</a><br>AI网站工具：<a href="http://www.futurepedia.io/">www.futurepedia.io</a><br>ai工具网站也可以：<a href="http://www.ainav.cn/">www.ainav.cn</a><br>百度云文生图:<a href="https://ai.baidu.com/creativity/imageeditor">https://ai.baidu.com/creativity/imageeditor</a><br>阿里云文生图<br><a href="https://help.aliyun.com/document_detail/477804.html">https://help.aliyun.com/document_detail/477804.html</a><br>图文生图<br><a href="https://help.aliyun.com/document_detail/477821.html">https://help.aliyun.com/document_detail/477821.html</a><br>文生图、图生图<br><a href="https://www.apispace.com/23329/api/aigc/apiDocument?apiId=11993">https://www.apispace.com/23329/api/aigc/apiDocument?apiId=11993</a><br>腾讯云:<br>文生图<br><a href="https://cloud.tencent.com/document/product/1668/88064">https://cloud.tencent.com/document/product/1668/88064</a><br>图生图<br><a href="https://cloud.tencent.com/document/product/1668/88066">https://cloud.tencent.com/document/product/1668/88066</a></p>
<h2 id="导出PDF转PPT"><a href="#导出PDF转PPT" class="headerlink" title="导出PDF转PPT"></a>导出PDF转PPT</h2><p><a href="https://smallpdf.com/cn/pdf-converter">https://smallpdf.com/cn/pdf-converter</a></p>
<h2 id="PDF转换器"><a href="#PDF转换器" class="headerlink" title="PDF转换器"></a>PDF转换器</h2><p><a href="https://www.pdf2go.com/zh">https://www.pdf2go.com/zh</a></p>
<h2 id="chatgpt大合集"><a href="#chatgpt大合集" class="headerlink" title="chatgpt大合集"></a>chatgpt大合集</h2><p><a href="https://chat.huashuyunai.com/#/pages/index/index">https://chat.huashuyunai.com/#/pages/index/index</a></p>
<p><a href="https://chat.extkj.cn/#/chat/1002">https://chat.extkj.cn/#/chat/1002</a></p>
<p><a href="https://chat.aidutu.cn/#/chat/1002">https://chat.aidutu.cn/#/chat/1002</a></p>
<p><a href="https://supremes.pro/">https://supremes.pro/</a></p>
<p><a href="https://ai-toolbox.codefuture.top/">https://ai-toolbox.codefuture.top/</a></p>
<p><a href="https://chat.intercat.cn/web/">https://chat.intercat.cn/web/</a></p>
<p><a href="https://yiyan.baidu.com/welcome">https://yiyan.baidu.com/welcome</a> </p>
<p><a href="https://effidit.qq.com/">https://effidit.qq.com/</a> </p>
<p><a href="https://www.giiso.com/#/">https://www.giiso.com/#/</a></p>
<p><a href="https://chat.lanrenbangong.com/?adaid=14">https://chat.lanrenbangong.com/?adaid=14</a></p>
<p><a href="https://tryai1.github.io/">https://tryai1.github.io/</a></p>
<h2 id="GPT镜像"><a href="#GPT镜像" class="headerlink" title="GPT镜像"></a>GPT镜像</h2><p><a href="https://chat.theb.ai/">https://chat.theb.ai/</a><br><a href="https://chatforai.com/">https://chatforai.com/</a><br><a href="https://chatgpt.h7ml.cn/">https://chatgpt.h7ml.cn/</a><br><a href="https://poe.com/">https://poe.com/</a><br><a href="https://chatgpt.poshist.cn/">https://chatgpt.poshist.cn/</a><br><a href="https://gpt.h7ml.cn/">https://gpt.h7ml.cn/</a><br><a href="https://chat.wxredcover.cn/">https://chat.wxredcover.cn/</a><br><a href="https://chat.yqcloud.top/">https://chat.yqcloud.top/</a><br><a href="https://chat.forchange.cn/">https://chat.forchange.cn/</a><br><a href="https://ai.v2less.com/">https://ai.v2less.com/</a> 访问密码：lessismore<br><a href="https://www.aicodehelper.com/">https://www.aicodehelper.com/</a><br><a href="https://ai-toolbox.codefuture.top/">https://ai-toolbox.codefuture.top/</a><br><a href="https://chilloutai.com/">https://chilloutai.com/</a><br><a href="https://harry-potter.openai-lab.com/">https://harry-potter.openai-lab.com</a><br><a href="https://wordstory.streamlit.app/">https://wordstory.streamlit.app/</a><br><a href="https://hotoke.ai/">https://hotoke.ai/</a><br><a href="https://chat.geekr.dev/">https://chat.geekr.dev/</a><br><a href="https://desk.im/">https://desk.im</a><br><a href="https://xc.com/">https://xc.com/</a><br><a href="https://chat.51buygpt.com/">https://chat.51buygpt.com/</a><br><a href="https://freechatgpt.chat/">https://freechatgpt.chat/</a><br><a href="https://askai.ws/">https://askai.ws/</a><br><a href="https://ai.yiios.com/">https://ai.yiios.com/</a><br><a href="http://chat.apigpt.cn/">http://chat.apigpt.cn/</a><br><a href="https://94gpt.com/">https://94gpt.com/</a><br><a href="https://www.teach-anything.com/">https://www.teach-anything.com/</a><br><a href="http://itecheasy.com.cn/">http://itecheasy.com.cn/</a><br><a href="https://trychatgp.com/">https://trychatgp.com/</a><br><a href="https://chatgpt.ddiu.io/">https://chatgpt.ddiu.io/</a><br><a href="https://ai117.com/">https://ai117.com/</a><br><a href="http://chat.livepo.top/">http://chat.livepo.top/</a><br><a href="https://freechatgpt.lol/">https://freechatgpt.lol/</a><br><a href="https://freegpt.cc/">https://freegpt.cc</a><br><a href="https://ai.ls/">https://ai.ls</a><br><a href="https://chat.alpaca-bi.com/">https://chat.alpaca-bi.com/</a><br><a href="https://chat.paoying.net/">https://chat.paoying.net/</a><br><a href="https://chat.eaten.fun/">https://chat.eaten.fun/</a><br><a href="https://www.askopenai.cn/">https://www.askopenai.cn/</a><br><a href="https://chat.h7ml.cn/">https://chat.h7ml.cn/</a><br><a href="https://chatgpt-flutter.h7ml.cn/">https://chatgpt-flutter.h7ml.cn/</a><br><a href="https://www.aitoolgpt.com/">https://www.aitoolgpt.com/</a><br><a href="https://www.chatsverse.xyz/">https://www.chatsverse.xyz/</a><br><a href="http://chat.wikll.com/">http://chat.wikll.com</a></p>
<h2 id="在线体验-ChatGPT-的网站集合，UI-界面与官方相似。"><a href="#在线体验-ChatGPT-的网站集合，UI-界面与官方相似。" class="headerlink" title="在线体验 ChatGPT 的网站集合，UI 界面与官方相似。"></a>在线体验 ChatGPT 的网站集合，UI 界面与官方相似。</h2><p>Chat TGBot：<a href="https://chat.tgbot.co/">https://chat.tgbot.co/</a><br>BAI Chat：<a href="https://chat.theb.ai/">https://chat.theb.ai/</a><br>ChatGPT 国产镜像：<a href="https://ai.bo-e.com/">https://ai.bo-e.com/</a><br>ZYT.IM：<a href="https://zyt.im/#/chat/">https://zyt.im/#/chat/</a><br>Fast GPT：<a href="https://fastgpt.app/">https://fastgpt.app/</a><br>Free GPT：<a href="https://freegpt.one/">https://freegpt.one/</a><br>AI EDU：<a href="https://aigcfun.com/%E3%80%81https://chat.forchange.cn/">https://aigcfun.com/、https://chat.forchange.cn/</a><br>Chat LivePo：<a href="https://chat.livepo.top/">https://chat.livepo.top/</a><br>AI 小思：<a href="https://chatgpt-web-production-facc.up.railway.app/">https://chatgpt-web-production-facc.up.railway.app/</a></p>
<p>SlideSalad<br>Beautiful.ai<br>Slidebean<br>Visme<br>Zoho Show<br>Genially<br>Renderforest<br>PowerPoint Designer<br>SlideDog<br>HelloSlide<br><a href="https://flowus.cn/login?code=DCMSHF">https://flowus.cn/login?code=DCMSHF</a><br>PPT模板大市场<br><a href="https://www.pptsupermarket.com/?ref=lovejay.top">https://www.pptsupermarket.com/?ref=lovejay.top</a></p>
<p>中文写作AI<br><a href="https://xiezuocat.com/">https://xiezuocat.com/</a></p>
<p>在线markdown教学<br><a href="https://markdown.com.cn/editor/">https://markdown.com.cn/editor/</a></p>
<p>全球技术新闻<br><a href="https://www.freebuf.com/">https://www.freebuf.com/</a><br>超级好用得浏览器小组件<br><a href="https://go.itab.link/">https://go.itab.link/</a></p>
<h2 id="免费图片压缩的网站："><a href="#免费图片压缩的网站：" class="headerlink" title="免费图片压缩的网站："></a>免费图片压缩的网站：</h2><p>TinyPNG:<a href="https://tinypng.com/">https://tinypng.com/</a><br>CompressJPEG:<a href="https://compressjpeg.com/">https://compressjpeg.com/</a><br>ImageOptim:<a href="https://imageoptim.com/">https://imageoptim.com/</a><br>Kraken.io:<a href="https://kraken.io/">https://kraken.io/</a><br>ResizeImage.net:<a href="https://www.resizeimage.net/">https://www.resizeimage.net/</a><br>Online-Convert:<a href="https://www.online-convert.com/image/to-jpeg">https://www.online-convert.com/image/to-jpeg</a><br>Imgix:<a href="https://imgix.net/">https://imgix.net/</a><br>Webpizer:<a href="https://webpizer.app/">https://webpizer.app/</a><br>FastStone Image Viewer:<a href="https://www.faststone.org/imageviewer/index.html">https://www.faststone.org/imageviewer/index.html</a><br>GIMP:<a href="https://www.gimp.org/">https://www.gimp.org/</a></p>
<h2 id="免费的AI绘图网站，以下是其中几个："><a href="#免费的AI绘图网站，以下是其中几个：" class="headerlink" title="免费的AI绘图网站，以下是其中几个："></a>免费的AI绘图网站，以下是其中几个：</h2><p>Deep Dream Generator(深度梦境生成器)：<a href="https://deepdreamgenerator.com/">https://deepdreamgenerator.com/</a><br>NeuralStyler(神经风格化)：<a href="https://neuralstyler.com/">https://neuralstyler.com/</a><br>Artisto(艺术家)：<a href="https://artisto.net/">https://artisto.net/</a><br>AI Painter(AI画家)：<a href="https://aipainter.art/">https://aipainter.art/</a><br>PaintsChainer(画链)：<a href="https://paintschainer.com/">https://paintschainer.com/</a></p>
<h2 id="10个免费翻译英文PDF文献的网站："><a href="#10个免费翻译英文PDF文献的网站：" class="headerlink" title="10个免费翻译英文PDF文献的网站："></a>10个免费翻译英文PDF文献的网站：</h2><p>Google Translate(<a href="https://translate.google.com/">https://translate.google.com/</a>)<br>DeepL Translator(<a href="https://www.deepl.com/translator">https://www.deepl.com/translator</a>)<br>Bing Translator(<a href="https://www.bing.com/translator">https://www.bing.com/translator</a>)<br>Baidu Translate(<a href="https://fanyi.baidu.com/translate">https://fanyi.baidu.com/translate</a>)<br>FreeTranslation(<a href="https://www.freetranslation.com/">https://www.freetranslation.com/</a>)<br>TextMaster(<a href="https://textmaster.com/translate-pdf">https://textmaster.com/translate-pdf</a>)<br>Online-Translators(<a href="https://www.online-translators.com/">https://www.online-translators.com/</a>)<br>iTranslate(<a href="https://www.itranslate.com/">https://www.itranslate.com/</a>)<br>DocTranslator(<a href="https://doc-translate.com/">https://doc-translate.com/</a>)<br>PDFescape(<a href="https://www.pdfescape.net/tools/online-pdf-">https://www.pdfescape.net/tools/online-pdf-</a> translator)</p>
<h2 id="将网页转为PDF的网站或浏览器插件："><a href="#将网页转为PDF的网站或浏览器插件：" class="headerlink" title="将网页转为PDF的网站或浏览器插件："></a>将网页转为PDF的网站或浏览器插件：</h2><p>Adobe Acrobat Online:Adobe公司的官方在线PDF编辑器，可以将任何网页转换为PDF文件。</p>
<p>Smallpdf:一个免费的在线PDF工具，可以将网页、Word文档等转换为PDF格式。</p>
<p>Zamzar:一个在线文件转换工具，支持将多种文件格式转换为PDF,包括网页。</p>
<p>Google Docs:Google的在线办公套件，其中包含一个名为“打印”的功能，可以将网页转换为PDF文件。</p>
<p>Chrome浏览器插件：”Save as PDF”、”PDF Converter”、”Webpage to PDF”等插件都可以将网页转换为PDF文件</p>
<p>10个将网页转为PDF的免费网站或者免费浏览器插件：</p>
<p>Smallpdf:<a href="https://smallpdf.com/cn/pdf-converter">https://smallpdf.com/cn/pdf-converter</a><br>Zamzar:<a href="https://www.zamzar.com/convert/web-to-pdf/">https://www.zamzar.com/convert/web-to-pdf/</a><br>PDF Online:<a href="https://www.pdfonline.com/">https://www.pdfonline.com/</a><br>Adobe Acrobat Reader DC:<a href="https://get.adobe.com/reader/">https://get.adobe.com/reader/</a><br>Google Chrome PDF Viewer:<a href="https://chrome.google.com/webstore/detail/pdf-viewer/jnkmfdildnkiilkmekokdddomajhfobje?hl=en">https://chrome.google.com/webstore/detail/pdf-viewer/jnkmfdildnkiilkmekokdddomajhfobje?hl=en</a><br>Firefox PDF Viewer:<a href="https://addons.mozilla.org/en-US/firefox/addon/pdf-viewer/">https://addons.mozilla.org/en-US/firefox/addon/pdf-viewer/</a><br>Print Friendly &amp; PDF Converter:<a href="https://printfriendlypdf.com/">https://printfriendlypdf.com/</a><br>Web2PDF:<a href="https://www.web2pdf.com/">https://www.web2pdf.com/</a><br>ILovePDF:<a href="https://www.ilovepdf.com/">https://www.ilovepdf.com/</a><br>Free PDF Converter:<a href="https://www.freepdfconvert.com/">https://www.freepdfconvert.com/</a></p>
<h2 id="10个查询论文文献的免费网站和浏览器插件："><a href="#10个查询论文文献的免费网站和浏览器插件：" class="headerlink" title="10个查询论文文献的免费网站和浏览器插件："></a>10个查询论文文献的免费网站和浏览器插件：</h2><p>Google Scholar(谷歌学术)：这是一个免费的搜索引擎，可以搜索学术出版物、学位论文、会议论文等。它还提供了一些有用的功能，如引用计数、作者分析和文献推荐。</p>
<p>ResearchGate(研究门)：这是一个专门为研究人员设计的社交网络平台，可以帮助你找到同行的研究成果，并与他们交流。它还提供了一个免费的文献数据库，可以搜索各种学科领域的文章。</p>
<p>Sci-Hub(科学网)：这是一个非常流行的免费获取学术论文的网站，它通过爬取各种在线数据库来提供免费的全文下载服务。但是，由于版权问题，它在某些国家和地区可能无法访问。</p>
<p>PubMed Central(PubMed中心)：这是一个由美国国立卫生研究院提供的免费数据库，包含了数百万篇医学文献。它还提供了一些高级功能，如文献筛选和引用管理。</p>
<p>Directory of Open Access Journals(开放获取期刊目录)：这是一个由全球各地的大学和机构提供的免费期刊数据库，包含了各种学科领域的开放获取期刊。</p>
<p>Mendeley(门德列)：这是一个免费的文献管理和组织工具，可以帮助你整理和管理自己的文献库。它还提供了一些有用的功能，如文献推荐和引用管理。</p>
<p>Zotero(佐罗)：这是一个免费的开源文献管理工具，可以帮助你收集、整理和引用文献。它支持多种文件格式，包括PDF、Word和HTML。</p>
<p>ReadCube(阅读立方体)：这是一个免费的文献管理和阅读工具，可以帮助你整理和管理自己的文献库，并提供了一些有用的功能，如文献推荐和引用管理。</p>
<p>Paperpile(纸堆)：这是一个免费的文献管理和阅读工具，可以帮助你整理和管理自己的文献库，并提供了一些有用的功能，如文献推荐和引用管理。</p>
<p>Web of Science(科学引文索引)：这是一个由Clarivate Analytics提供的免费数据库，包含了全球范围内的学术出版物和研究报告。它还提供了一些高级功能，如文献筛选和引用管理。</p>
<h2 id="免费制作视频封面的网站名称"><a href="#免费制作视频封面的网站名称" class="headerlink" title="免费制作视频封面的网站名称"></a>免费制作视频封面的网站名称</h2><p>Canva: <a href="https://www.canva.com/">https://www.canva.com/</a><br>Adobe Spark Video: <a href="https://spark.adobe.com/make/video-cover-maker/">https://spark.adobe.com/make/video-cover-maker/</a><br>Piktochart: <a href="https://piktochart.com/features/vector-graphics/">https://piktochart.com/features/vector-graphics/</a><br>Pixlr: <a href="https://pixlr.com/">https://pixlr.com/</a><br>Fotor: <a href="https://www.fotor.com/create/video-cover/">https://www.fotor.com/create/video-cover/</a><br>Vecteezy: <a href="https://www.vecteezy.com/free-vector-images/video-cover-templates">https://www.vecteezy.com/free-vector-images/video-cover-templates</a><br>Coverr: <a href="https://coverr.co/">https://coverr.co/</a><br>Snappa: <a href="https://snappa.com/video-cover-maker">https://snappa.com/video-cover-maker</a><br>DesignCap: <a href="https://www.designcap.com/video-cover-maker/">https://www.designcap.com/video-cover-maker/</a><br>BeFunky: <a href="https://www.befunky.com/create/video-cover/">https://www.befunky.com/create/video-cover/</a></p>
<h2 id="免费将doc文件转换为PDF的在线工具："><a href="#免费将doc文件转换为PDF的在线工具：" class="headerlink" title="免费将doc文件转换为PDF的在线工具："></a>免费将doc文件转换为PDF的在线工具：</h2><p>Smallpdf(<a href="https://smallpdf.com/cn/pdf-to-word):Smallpdf">https://smallpdf.com/cn/pdf-to-word):Smallpdf</a> 是一个非常方便的在线PDF转换工具，可以将Word文档、Excel表格和PPT演示文稿等文件转换为PDF格式。只需上传您的doc文件，选择输出格式为PDF,然后点击“转换”按钮即可。</p>
<p>PDF Converter(<a href="https://www.onlineconvert.com/zht/pdf-to-word):PDF">https://www.onlineconvert.com/zht/pdf-to-word):PDF</a> Converter 是一个功能强大的在线转换工具，支持将多种文件格式(包括doc、docx、xls、xlsx、ppt、pptx等)转换为PDF格式。上传您的doc文件，选择输出格式为PDF,然后点击“转换”按钮即可。</p>
<p>Zamzar(<a href="https://www.zamzar.com/convert/to/pdf/):Zamzar">https://www.zamzar.com/convert/to/pdf/):Zamzar</a> 是一个提供多种文件格式转换服务的网站，可以将doc文件转换为PDF格式。上传您的doc文件，选择输出格式为PDF,然后等待文件下载完成即可。</p>
<p>请注意，在使用这些在线工具时，请确保您拥有合法的文件转换权利。同时，由于网络连接速度和服务器负载等因素的影响，文件转换可能需要一定时间。</p>
<h2 id="免费将PDF翻译为中文的网站："><a href="#免费将PDF翻译为中文的网站：" class="headerlink" title="免费将PDF翻译为中文的网站："></a>免费将PDF翻译为中文的网站：</h2><p>Smallpdf:<a href="https://smallpdf.com/cn/pdf-to-chinese">https://smallpdf.com/cn/pdf-to-chinese</a><br>Zamzar:<a href="https://www.zamzar.com/convert/pdf-to-text/">https://www.zamzar.com/convert/pdf-to-text/</a><br>Online-Convert:<a href="https://www.online-convert.com/zh/pdf-to-text">https://www.online-convert.com/zh/pdf-to-text</a><br>PDF Online:<a href="https://www.pdfonline.com/pdf-to-text/">https://www.pdfonline.com/pdf-to-text/</a><br>Adobe Acrobat:<a href="https://acrobat.adobe.com/us/en/acrobat/online/pdf-to-text.html">https://acrobat.adobe.com/us/en/acrobat/online/pdf-to-text.html</a></p>
<p>如果您需要高质量的翻译，但又希望它是免费的，您可以尝试以下方法：</p>
<p>使用在线翻译工具：有一些在线翻译工具，如Google Translate、Bing Translator等，可以将PDF文件上传到它们的网站上进行翻译。虽然这些工具可能无法提供与专业翻译服务或软件相同的质量，但它们通常是免费的，并且可以帮助您快速将PDF文件翻译成中文。</p>
<p>寻找志愿者翻译者：您可以在一些志愿者翻译平台上发布任务，寻找愿意为您免费翻译PDF文件的志愿者。例如，您可以在FreeTranslation.com、TranslatorsCafé.com等平台上发布任务，并等待志愿者的响应。请注意，由于志愿者通常没有经过专业培训，因此他们的翻译质量可能不如专业翻译服务或软件提供的翻译质量高。</p>
<p>使用开源翻译软件：有一些开源翻译软件，如OpenOffice Translator、POEditor等，可以将PDF文件导入到软件中进行翻译。虽然这些软件可能不是非常强大，但它们是免费的，并且可以帮助您将PDF文件翻译成中文。</p>
<h2 id="视频去水印"><a href="#视频去水印" class="headerlink" title="视频去水印"></a>视频去水印</h2><p><a href="https://bgrem.ai/zh/remove-video-bg/?params=start">https://bgrem.ai/zh/remove-video-bg/?params=start</a></p>
<p>FLIKI<br><a href="https://fliki.ai/">https://fliki.ai/</a></p>
<h2 id="免费的AI写作网站："><a href="#免费的AI写作网站：" class="headerlink" title="免费的AI写作网站："></a>免费的AI写作网站：</h2><p>1.AI Writer:<a href="https://aiwriter.com/">https://aiwriter.com/</a><br>2.Articoolo:<a href="https://articoolo.com/">https://articoolo.com/</a><br>3.Quillbot:<a href="https://quillbot.com/">https://quillbot.com/</a><br>4.Copyscape-Generator:<a href="https://copyscape-generator.com/">https://copyscape-generator.com/</a><br>5.Grammarly Blog:<a href="https://www.grammarly.com/blog/">https://www.grammarly.com/blog/</a><br>6.Hemingway Editor:<a href="https://hemingwayapp.com/">https://hemingwayapp.com/</a><br>7.Slickwrite:<a href="https://www.slickwrite.com/">https://www.slickwrite.com/</a><br>8.Writefull:<a href="https://www.writefull.com/">https://www.writefull.com/</a><br>9.CoSchedule Headline Analyzer:<a href="https://headlineanalyzer.coschedule.com/">https://headlineanalyzer.coschedule.com/</a><br>10.Yoast SEO Blog:<a href="https://yoastseoblog.com/">https://yoastseoblog.com/</a></p>
<h2 id="写文案其实并不是一件难事，只要平时不断积累，再擅用工具，就能轻松应对。以下这9款工具能提供素材级创意支持，编辑、排版、寻找热点话题、寻找爆款文章，甚至进行文章原创度检测等功能，让文案创作变得更加高效和有成效。无论是独立创作者还是团队协作，这些工具都是不可或缺的利器。"><a href="#写文案其实并不是一件难事，只要平时不断积累，再擅用工具，就能轻松应对。以下这9款工具能提供素材级创意支持，编辑、排版、寻找热点话题、寻找爆款文章，甚至进行文章原创度检测等功能，让文案创作变得更加高效和有成效。无论是独立创作者还是团队协作，这些工具都是不可或缺的利器。" class="headerlink" title="写文案其实并不是一件难事，只要平时不断积累，再擅用工具，就能轻松应对。以下这9款工具能提供素材级创意支持，编辑、排版、寻找热点话题、寻找爆款文章，甚至进行文章原创度检测等功能，让文案创作变得更加高效和有成效。无论是独立创作者还是团队协作，这些工具都是不可或缺的利器。"></a>写文案其实并不是一件难事，只要平时不断积累，再擅用工具，就能轻松应对。以下这9款工具能提供素材级创意支持，编辑、排版、寻找热点话题、寻找爆款文章，甚至进行文章原创度检测等功能，让文案创作变得更加高效和有成效。无论是独立创作者还是团队协作，这些工具都是不可或缺的利器。</h2><p>阿i妈妈智 能文案(一款提供从图文到视频再到落地页的素材级创意支持，是您营销创意数字资产积累的阵地，更大化提升营销的效率和效果。<br>秘塔写作猫(一款集智 能写作、文本校对、改写润色等功能为一体的网站)<br>GET写作(一款拥有10w+的写作模版，可以键改写和扩写的网站)<br>句子控(一款汇集了很多名人名言，影视经典语录等，超好用的神级app)<br>押韵助手(一款支持在线查询押韵的字、词、诗、歌，支持单押多押，海量词库，文案创作者必备神器。)<br>巨量创意(一款可以定制属于自己的图片、视频脚本、AI配音、智 能配乐等，功能强大。<br>易撰(一款全能型的工具，编辑排版、寻找热点话题、寻找爆款文章，还可以进行文章原创度的检测。 )<br>字语智 能(提供热点整合，丰富写作素材，海量写作模板和AI创新写作。)<br>写文案其实没有想象中那么难，除了平时不断地积累，再就是擅用工具，好好利用以上这9款工具，就再也不愁没有灵感和创意啦~</p>
<h2 id="完成人物作图后，如果能让人物动起来，那真的可以让人大喊666-这里就要分享一种很简单的方法，就是利用万彩骨骼大师"><a href="#完成人物作图后，如果能让人物动起来，那真的可以让人大喊666-这里就要分享一种很简单的方法，就是利用万彩骨骼大师" class="headerlink" title="完成人物作图后，如果能让人物动起来，那真的可以让人大喊666~这里就要分享一种很简单的方法，就是利用万彩骨骼大师"></a>完成人物作图后，如果能让人物动起来，那真的可以让人大喊666~这里就要分享一种很简单的方法，就是利用万彩骨骼大师</h2><p>（<a href="http://bone.animiz.cn/%EF%BC%89">http://bone.animiz.cn/）</a><br>一款专门制作2D角色的骨骼动画软件，轻松让静态图片转换为动态，实现眨眼、微笑、挥手、移动、跑步、跳跃、旋转等一系列动画动作。</p>
<h2 id="Upscayl-–-免费开源的-AI-图像放大工具，跨平台"><a href="#Upscayl-–-免费开源的-AI-图像放大工具，跨平台" class="headerlink" title="Upscayl – 免费开源的 AI 图像放大工具，跨平台"></a>Upscayl – 免费开源的 AI 图像放大工具，跨平台</h2><p>使用 Upscayl 需要兼容 Vulkan 的 GPU，主要包括：</p>
<p>NVIDIA<br>GeForce 600 系列及更新产品<br>Quadro K 系列及更新产品<br>Tesla K/M/X 系列<br>GRID K2/K520<br>AMD<br>Radeon HD 7000 系列及更新产品<br>Radeon R7/R9 200 系列及更新产品<br>Radeon RX 400/500/5000 系列及更新产品<br>FirePro W 系列及更新产品<br>Intel<br>第六代 Core 处理器及更新产品，包括 Haswell、Broadwell、Skylake、Kaby Lake、Coffee Lake 等</p>
<p>官网：<a href="https://kutt.appinn.com/UwTFTN">https://kutt.appinn.com/UwTFTN</a></p>
<h2 id="EasyCode-AI-–-集成在-VS-Code-里的-ChatGPT，帮你写代码、改代码"><a href="#EasyCode-AI-–-集成在-VS-Code-里的-ChatGPT，帮你写代码、改代码" class="headerlink" title="EasyCode AI – 集成在 VS Code 里的 ChatGPT，帮你写代码、改代码"></a>EasyCode AI – 集成在 VS Code 里的 ChatGPT，帮你写代码、改代码</h2><p>亲测不太管用，要不你们用一下哈利波特的魔法？</p>
<h2 id="免费的AI生成PPT网站，以下是其中几个："><a href="#免费的AI生成PPT网站，以下是其中几个：" class="headerlink" title="免费的AI生成PPT网站，以下是其中几个："></a>免费的AI生成PPT网站，以下是其中几个：</h2><p>Slides Carnival:<a href="https://www.slidescarnival.com/">https://www.slidescarnival.com/</a><br>Canva:<a href="https://www.canva.com/templates/presentations/">https://www.canva.com/templates/presentations/</a><br>Prezi:<a href="https://prezi.com/slide-generator/">https://prezi.com/slide-generator/</a><br>Google Slides:<a href="https://www.google.com/slides/about/">https://www.google.com/slides/about/</a><br>Zoho Show:<a href="https://www.zoho.com/slide-show/">https://www.zoho.com/slide-show/</a><br>Visme:<a href="https://www.visme.co/create/presentations/">https://www.visme.co/create/presentations/</a><br>Slidebean:<a href="https://slidebean.com/free-powerpoint-templates/">https://slidebean.com/free-powerpoint-templates/</a><br>SlideSalad:<a href="https://slidesalad.com/free-powerpoint-templates/">https://slidesalad.com/free-powerpoint-templates/</a><br>IA present ：<a href="https://ia.net/presenter">https://ia.net/presenter</a></p>
<h2 id="prompt提示词"><a href="#prompt提示词" class="headerlink" title="prompt提示词"></a>prompt提示词</h2><p><a href="https://moonvy.com/apps/ops/?utm_source=appinn.com">https://moonvy.com/apps/ops/?utm_source=appinn.com</a><br>AIPRM<br>Prompt Storm<br>novelai：<a href="https://tags-dev.novelai.dev/">https://tags-dev.novelai.dev/</a><br>black lily: <a href="http://heizicao.gitee.io/novelai/#/home">http://heizicao.gitee.io/novelai/#/home</a><br>tag zoo:<a href="http://tag.zoos.life/">http://tag.zoos.life/</a></p>
<p>😀腾讯-陈鹏《Kubernetes 实践指南》在线阅读（内含离线下载方法）：<br><a href="https://imroc.cc/kubernetes">https://imroc.cc/kubernetes</a></p>
<p>😀其他K8s阅读材料推荐：<br>《Kubernetes 编程基础知识》<a href="https://cloudnative.to/blog/kubernetes-programming-base/">https://cloudnative.to/blog/kubernetes-programming-base/</a><br>《一文梳理REST API的设计原则》<a href="https://zhuanlan.zhihu.com/p/106724321">https://zhuanlan.zhihu.com/p/106724321</a><br>《在 Kubernetes 上开发》<a href="https://kubernetes.io/zh-cn/blog/2018/05/01/developing-on-kubernetes/">https://kubernetes.io/zh-cn/blog/2018/05/01/developing-on-kubernetes/</a><br>《最新、最全、最详细的 K8S 学习笔记总结（2021最新版）！建议收藏》<br><a href="https://segmentfault.com/a/1190000039844000">https://segmentfault.com/a/1190000039844000</a><br>《一文看懂 Kubelet》<a href="https://zhuanlan.zhihu.com/p/338462784">https://zhuanlan.zhihu.com/p/338462784</a><br>《调度框架》<a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/scheduling-framework/">https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/scheduling-framework/</a></p>
<p>1Tome: PPT生成Al，输入文案，自动帮你生成PPT，视觉效果超丰富<br>2Prezo: PPT创作Al，输入文案即可为你自动生成PPT<br>3]SlidesAl: 易上手的PPT创作Al，输入文案一键生成PPT<br>4Beautifulai: 效果很好的PPT生成Al，简单输入提示词，自动生成PPT<br>5Motionit ai: 输入文案自动为你创建PPT<br>6STORYD:输入文案数据，为你快速创建PPT擅长图表类的PPT<br>7Present Al: 输入文案可为你快速生成PPT<br>8MagicSlides: 只需三步，输入文案，选择风格，即可生成PPT<br>9MyReport: 输入提示词，快速为你创作PPT<br>https/<a href="http://www.bing.comvcreatol/">www.bing.comvcreatol</a></p>
<h2 id="AI生产力"><a href="#AI生产力" class="headerlink" title="AI生产力"></a>AI生产力</h2><p>ChatGPT<br>Midjourney<br>Tome<br>AutoDraw<br>Copy.ai<br>Autodraw<br>Remove.bg<br>Fliki<br>FakeYou<br>Jukebox</p>
<p>chatgpt： <a href="https://chat.openai.com/">https://chat.openai.com/</a><br>Descript： <a href="https://www.descript.com/">https://www.descript.com/</a> 设计软件<br>Midjourney： <a href="https://discord.com/">https://discord.com/</a><br>Notion AI ： <a href="https://www.notion.so/product/ai">https://www.notion.so/product/ai</a><br>Tome ： <a href="https://beta.tome.app/">https://beta.tome.app/</a><br>runway ： <a href="https://runwayml.com/">https://runwayml.com/</a><br>阿里云大模型申请入口：通义千问 (aliyun.com)</p>
<p>代码工具：<a href="https://copilot.github.com/">https://copilot.github.com/</a><br>文字转语音：<a href="https://azure.microsoft.com/zh-cn/products/cognitive-services/text-to-speech/">https://azure.microsoft.com/zh-cn/products/cognitive-services/text-to-speech/</a><br>语音合成：<a href="https://valle-demo.github.io/">https://valle-demo.github.io/</a><br>开源项目地址：<a href="https://github.com/nvbn/thefuck">https://github.com/nvbn/thefuck</a> 命令行自动改错</p>
<h1 id="5个AI模型下载地址-100M-S-含Prompt提示词"><a href="#5个AI模型下载地址-100M-S-含Prompt提示词" class="headerlink" title="5个AI模型下载地址 100M/S 含Prompt提示词"></a>5个AI模型下载地址 100M/S 含Prompt提示词</h1><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486788&amp;idx=1&amp;sn=4e5368d55b6f231d1d464346bdc016ed&amp;chksm=ceb09239f9c71b2fa3c2a6998b9125b364d4d89df44743f2de19cdb5b6027a1b3c87a9399b06&amp;token=1149111433&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486788&amp;idx=1&amp;sn=4e5368d55b6f231d1d464346bdc016ed&amp;chksm=ceb09239f9c71b2fa3c2a6998b9125b364d4d89df44743f2de19cdb5b6027a1b3c87a9399b06&amp;token=1149111433&amp;lang=zh_CN#rd</a></p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>AI工具大合集</category>
      </categories>
      <tags>
        <tag>AI工具大合集</tag>
      </tags>
  </entry>
  <entry>
    <title>每日早报60s</title>
    <url>/posts/20230423a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p><img src="https://api.03c3.cn/zb/" alt="每日60S"><br><img src="https://v2.alapi.cn/api/zaobao?token=BX2vvKW28gktjrPr&format=image" alt="60s-for-news"></p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>每日早报60s</category>
      </categories>
      <tags>
        <tag>每日早报60s</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务管理报错Transaction rolled back because it has been marked as rollback-only</title>
    <url>/posts/20220725clhk6ptdy000scsujeynn5p7a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>事务是我们平时项目中对数据操作最为直接、常用的方式，现在无论是大小公司都离不开对事务的操作，伴随业务的提升，客户量的积累也大大增加了对事务管理的难度。<br>在本章节中将会讲到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、线上环境对roll back only 的处理</span><br><span class="line"></span><br><span class="line">2、线上环境对嵌套事务的解决方案</span><br><span class="line"></span><br><span class="line">3、11个demo分析事务失效的场景</span><br><span class="line"></span><br><span class="line">4、分布式事务</span><br><span class="line"></span><br><span class="line">5、事务也能异步</span><br></pre></td></tr></table></figure>
<p>1、线上环境对roll back only 的处理与产生</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.dao.CannotAcquireLockException: </span><br><span class="line">### Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br><span class="line">### The error may involve xxxMapper.insert-Inline</span><br><span class="line">### The error occurred <span class="keyword">while</span> setting parameters</span><br><span class="line">### SQL: INSERT INTO xxx</span><br><span class="line">### Cause: com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br><span class="line">; Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction; nested exception is com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br></pre></td></tr></table></figure>
<p>产生原因：<br>事务嵌套，内层事务将异常捕获未抛出。</p>
<p>2、线上环境对嵌套事务的解决方案<br>优化点可以从以下几点进行考虑：<br>最为直接的方法便是去掉嵌套事务，在controller层统一决定异常处理<br>对于类似开发过程中，需考虑将相关方法长事务中查询方法剔除，将方法内事务缩短为最小事务<br>出现突发情况，应提供最为简单有效的方案，让业务正常操作，不受影响<br>开发应对当时的技术方案告知相关测试<br>在代码层面,后续代码需要前面操作事务释放锁<br>无需等待插入结果   直接插入后续数据<br>将查询放在事务外面尽量将大事务变为小事务<br>捕获异常  自动重试<br>但是短时间内我还没有时间进行整改，在不影响主流程的情况下未进行整改，但我后续才知道大错特错。<br>排查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@timestamp</span> September 1st <span class="number">2021</span>, <span class="number">10</span>:<span class="number">20</span>:<span class="number">24.637</span></span><br><span class="line"># <span class="meta">@version</span>  <span class="number">1</span></span><br><span class="line">t LOG_DATEFORMAT_PATTERN    yyyy-MM-dd HH:mm:ss.SSS</span><br><span class="line">t LOG_LEVEL_PATTERN %5p</span><br><span class="line">t _id   VMaG</span><br><span class="line">t _index    applog-<span class="number">2021.09</span><span class="number">.01</span></span><br><span class="line"># _score    <span class="number">1</span></span><br><span class="line">t _type doc</span><br><span class="line">t appindex  applog</span><br><span class="line">t appname   app</span><br><span class="line">t host  <span class="number">10.0</span><span class="number">.74</span><span class="number">.157</span></span><br><span class="line">t level ERROR</span><br><span class="line"># level_value   <span class="number">40</span>,<span class="number">000</span></span><br><span class="line">t logger_name   ExceptionLogCollector</span><br><span class="line">t message   未知异常[<span class="number">500</span>] =&gt; Transaction rolled back because it has been marked as rollback-only</span><br><span class="line"># port  <span class="number">10</span>,<span class="number">792</span></span><br><span class="line">t stack_trace   org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br><span class="line">at org.springframework.transaction.support.AbstractPlatformTransactionManager.processRollback(AbstractPlatformTransactionManager.java:<span class="number">873</span>) ~[spring-tx-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:<span class="number">710</span>) ~[spring-tx-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:<span class="number">533</span>) ~[spring-tx-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:<span class="number">304</span>) ~[spring-tx-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:<span class="number">98</span>) ~[spring-tx-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:<span class="number">186</span>) ~[spring-aop-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:<span class="number">688</span>) ~[spring-aop-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar!/:<span class="number">5.1</span><span class="number">.4</span>.RELEASE]</span><br><span class="line">spring-tx-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar-</span><br><span class="line">org.springframework.transaction.interceptor.TransactionInterceptor#事务拦截器</span><br><span class="line">avatar</span><br></pre></td></tr></table></figure>
<p>spring事务分为声明式事务和编程式事务，若目标方法存在事务，spring会对bean生成一个代理对象，从日志来看是cglib的<br>入口98行springaop事务增强 TransactionAspectSupport在事务中的调用，执行代理类的目标方法触发invoke</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">方法为<span class="keyword">protected</span>的，根据源代码注释解析</span></span><br></pre></td></tr></table></figure>
<p>if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager))<br>如果事务属性为null 且事务类型是CallbackPreferringPlatformTransactionManager进入304行commitTransactionAfterReturning(txInfo);方法<br>意为事务成功后执行，有异常不执行，没有事务不执行，也就是为后面的事务方法异常时没执行进行了铺垫，533行<br>txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());事务进行commit时进行判断<br>如果不是进行全局事务提交 但是是RollbackOnly的话<br>走processRollback处理实际回滚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">                    <span class="string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">        <span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Transactional code has requested rollback&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            processRollback(defStatus, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            日志追踪的<span class="number">710</span>行-----记住此处传<span class="function"><span class="keyword">true</span></span></span><br><span class="line"><span class="function">            <span class="title">processRollback</span><span class="params">(defStatus, <span class="keyword">true</span>)</span></span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        processCommit(defStatus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="keyword">boolean</span> unexpected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            入参为<span class="keyword">true</span></span><br><span class="line">            <span class="keyword">boolean</span> unexpectedRollback = unexpected;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                triggerBeforeCompletion(status);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Rolling back transaction to savepoint&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    status.rollbackToHeldSavepoint();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Initiating transaction rollback&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    doRollback(status);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Participating in larger transaction</span></span><br><span class="line">                    <span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                                logger.debug(<span class="string">&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            doSetRollbackOnly(status);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                                logger.debug(<span class="string">&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Should roll back transaction but cannot - no transaction available&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Unexpected rollback only matters here if we&#x27;re asked to fail early</span></span><br><span class="line">                    <span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">                        unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">                triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">            日志追踪的<span class="number">873</span>行  抛出异常</span><br><span class="line">            <span class="comment">// Raise UnexpectedRollbackException if we had a global rollback-only marker</span></span><br><span class="line">            <span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line">                        <span class="string">&quot;Transaction rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            cleanupAfterCompletion(status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>事务这里场景和传播行为相关知识点太多了，这个后续接着分析<br>但就此场景将伪代码贴一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        methodA()</span><br><span class="line">    &#125;<span class="keyword">catch</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        methodB()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodC()</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    methodC() &#123;</span><br><span class="line">        当C方法抛出异常时</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>不知道大家对于rpc行为调用的接口是如何处理的，我们以前是将rpc调用的接口有Biz接收进来，进行参数处理，领域模型转换后，调取service进行内部数据处理的，但此时的接口在主流程上会伴随着另一个第三方接口的写操作，需进行事务处理，那么内层service接口为什么还要进行事务管理？在设计上理应不对rpc接口操作的service进行开放调用的，但业务上区分不同场景，不同供应商，不同酒店等对接口进行了反射调用，或者app调用，导致内层service也进行了事务操作，那么问题来了，嵌套事务时，如果内层事务注解取消不抛出<br>UnexpectedRollbackException，实际此方法内并没有完全执行完，<br>我希望是怎样的？我希望在保持事务原子性的前提，内层事务回滚则整个全局事务回滚，且不报此异常<br>第一种方法isGlobalRollbackOnParticipationFailure方法，让主事务来决定是否回滚，</p>
<p>改动成本大<br>而在Springaop中，被拦截的方法需要显式的抛出异常，并不能经过任何处理，这样aop才能进行回滚，默认aop是只catchruntimeException的异常 第二种方法可以在catch块里加上 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly() 手动回滚 即便上层事务发生了异常，也想要最终提交整个事务呢？如果有这样的需求的话，可以给事务管理器配置一个参数 setGlobalRollbackOnParticipationFailure(false); # 改动成本大<br>解决方案：在内层方法中不进行方法的try catch，有异常操作时在外层事务进行处理，且可决定是否回滚，特定的异常也再次处理</p>
<p>回顾：事务的失效场景(事务不生效和事务不回滚)</p>
<p>3、11个demo分析事务失效的场景</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class DemoService &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private Test1Mapper test1Mapper;</span><br><span class="line">	</span><br><span class="line">	@Autowired</span><br><span class="line">	private TestMapper testMapper;</span><br><span class="line">	</span><br><span class="line">	@Autowired</span><br><span class="line">	private InvalidTransactionService invalidTransactionService;</span><br><span class="line">	</span><br><span class="line">	@Autowired</span><br><span class="line">	private ExecutorService executorService;</span><br><span class="line">	</span><br><span class="line">	@Autowired</span><br><span class="line">	private DemoService _self;</span><br><span class="line">	</span><br><span class="line">	@Autowired</span><br><span class="line">	private ValidTransactionService validTransactionService;</span><br><span class="line">	</span><br><span class="line">	@Autowired</span><br><span class="line">	private RequireNewTransactionService requireNewTransactionService;</span><br><span class="line">	</span><br><span class="line">	/********************************************************</span><br><span class="line">	 * 事务不生效场景1</span><br><span class="line">	 * 相当于调用this调用，没有产生代理对象调用，解决方法，自己把自己注入以后调用</span><br><span class="line">	 ********************************************************/</span><br><span class="line">	public void demo1() &#123;</span><br><span class="line"></span><br><span class="line">		invalidTransaction();</span><br><span class="line">		</span><br><span class="line">		//TODO other logic code here</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Transactional</span><br><span class="line">	public void invalidTransaction() &#123;</span><br><span class="line">		TestDO test = new TestDO();</span><br><span class="line">		test.setName(&quot;11111&quot;);</span><br><span class="line">		testMapper.insert(test);</span><br><span class="line">		</span><br><span class="line">		Test1DO test1 = new Test1DO();</span><br><span class="line">		test1.setCust(&quot;2222&quot;);</span><br><span class="line">		test1Mapper.insert(test1);</span><br><span class="line">		throw new WMSException(ErrorCodeEnum.BD10001001.code(),&quot;事务不生效场景1&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/********************************************************</span><br><span class="line">	 * 事务不生效场景二</span><br><span class="line">	 * 这个例子的目的是为了catch住内层事务的异常，让外层事务成功，但是实际上没有内外层事务都回滚了</span><br><span class="line">	 *</span><br><span class="line">	 * 这里A和B都受事务控制，并且是处于同一个事务的。</span><br><span class="line">	 * A调用B，A中抓了B的异常，当B发生异常的时候，B的操作应该回滚，但是A吃了异常，A方法中没有产生异常，所以A的操作又应该提交，二者是相互矛盾的。</span><br><span class="line">	 * spring的事务关联拦截器在抓到B的异常后就会标记rollback-only为true，当A执行完准备提交后，发现rollback-only为true，也会回滚，并抛出异常告诉调用者。</span><br><span class="line">	 *</span><br><span class="line">	 * 报错提示：Transaction rolled back because it has been marked as rollback-only</span><br><span class="line">	 *</span><br><span class="line">	 * 如果想使外层事务生效可以把内层事务传播特性修改为：@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">	 * </span><br><span class="line">	 ********************************************************/</span><br><span class="line">	@Transactional</span><br><span class="line">	public void demo2() &#123;</span><br><span class="line">		TestDO test = new TestDO();</span><br><span class="line">		test.setName(&quot;3333&quot;);</span><br><span class="line">		testMapper.insert(test);</span><br><span class="line">		try &#123;</span><br><span class="line">			invalidTransactionService.transaction();</span><br><span class="line">		&#125;catch (Exception e) &#123;</span><br><span class="line">			log.error(&quot;服务异常，异常被捕获&quot;, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/********************************************************</span><br><span class="line">	 * 事务不生效场景三</span><br><span class="line">	 *</span><br><span class="line">	 * 因为开了线程异步执行，等于事务完全在两个线程内，不在一个线程，所以即使抛错，也是一个生效一个不生效，</span><br><span class="line">	 * 事务没有回滚</span><br><span class="line">	 * </span><br><span class="line">	 ********************************************************/</span><br><span class="line">	@Transactional</span><br><span class="line">	public void demo3() &#123;</span><br><span class="line">		TestDO test = new TestDO();</span><br><span class="line">		test.setName(&quot;5555&quot;);</span><br><span class="line">		testMapper.insert(test);</span><br><span class="line">		</span><br><span class="line">		executorService.execute(() -&gt; &#123;</span><br><span class="line">			Test1DO test1 = new Test1DO();</span><br><span class="line">			test1.setCust(&quot;6666&quot;);</span><br><span class="line">			test1Mapper.insert(test1);</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		throw new WMSException(ErrorCodeEnum.BD10001001.code(),&quot;事务不生效场景3&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/********************************************************</span><br><span class="line">	 * 事务不生效场景八</span><br><span class="line">	 * Spring默认情况下会对运行期例外(RunTimeException)进行事务回滚。这个例外是unchecked，如果遇到checked意外就不回滚。</span><br><span class="line">	 * Exception包含RuntimeException体系和其他非RuntimeException的体系</span><br><span class="line">	 * Error和RuntimeException及其子类成为未检查异常（unchecked），其它异常成为已检查异常（checked）。</span><br><span class="line">	 * spring声明式事务管理默认对非检查型异常和运行时异常进行事务回滚，而对检查型异常则不进行回滚操作</span><br><span class="line">	 *</span><br><span class="line">	 *</span><br><span class="line">	 *那么什么是检查型异常什么又是非检查型异常呢？</span><br><span class="line">	 * 1.继承自runtimeexception或error的是非检查型异常，而继承自exception的则是检查型异常（当然，runtimeexception本身也是exception的子类）。</span><br><span class="line">	 * 2.对非检查型类异常可以不用捕获，而检查型异常则必须用try语句块进行处理或者把异常交给上级方法处理总之就是必须写代码处理它。所以必须在service捕获异常，然后再次抛出，这样事务方才起效。</span><br><span class="line">	 *</span><br><span class="line">	 * @throws IOException </span><br><span class="line">	 * </span><br><span class="line">	 ********************************************************/</span><br><span class="line">	@Transactional</span><br><span class="line">	public void demo8() throws IOException &#123;</span><br><span class="line">		TestDO test = new TestDO();</span><br><span class="line">		test.setName(&quot;11111&quot;);</span><br><span class="line">		testMapper.insert(test);</span><br><span class="line">		</span><br><span class="line">		Test1DO test1 = new Test1DO();</span><br><span class="line">		test1.setCust(&quot;2222&quot;);</span><br><span class="line">		test1Mapper.insert(test1);</span><br><span class="line">		throw new IOException(&quot;事务不生效场景8&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/********************************************************</span><br><span class="line">	 * 事务不生效场景九</span><br><span class="line">	 * @throws IOException </span><br><span class="line">	 * </span><br><span class="line">	 ********************************************************/</span><br><span class="line">	</span><br><span class="line">	public void demo9()&#123;</span><br><span class="line">		invalidTransaction2();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Transactional</span><br><span class="line">	private void invalidTransaction2() &#123;</span><br><span class="line">		TestDO test = new TestDO();</span><br><span class="line">		test.setName(&quot;11111&quot;);</span><br><span class="line">		testMapper.insert(test);</span><br><span class="line">		</span><br><span class="line">		Test1DO test1 = new Test1DO();</span><br><span class="line">		test1.setCust(&quot;2222&quot;);</span><br><span class="line">		test1Mapper.insert(test1);</span><br><span class="line">		throw new WMSException(&quot;事务不生效场景9&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/********************************************************</span><br><span class="line">	 * 事务生效场景1</span><br><span class="line">	 * </span><br><span class="line">	 ********************************************************/</span><br><span class="line">	public void demo4() &#123;</span><br><span class="line">		</span><br><span class="line">		_self.invalidTransaction();</span><br><span class="line">		</span><br><span class="line">		//TODO other logic code here</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/********************************************************</span><br><span class="line">	 * 事务生效场景二</span><br><span class="line">	 *</span><br><span class="line">	 * 因为内层没有事务控制，所以内层报错，不会混回滚，同样外层catch住，所以外层业务成功</span><br><span class="line">	 ********************************************************/</span><br><span class="line">	@Transactional</span><br><span class="line">	public void demo5() &#123;</span><br><span class="line">		TestDO test = new TestDO();</span><br><span class="line">		test.setName(&quot;7777&quot;);</span><br><span class="line">		testMapper.insert(test);</span><br><span class="line">		</span><br><span class="line">		try &#123;</span><br><span class="line">			validTransactionService.transaction();</span><br><span class="line">		&#125;catch (Exception e) &#123;</span><br><span class="line">			log.error(&quot;服务异常，异常被捕获&quot;, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/********************************************************</span><br><span class="line">	 * 事务生效场景三</span><br><span class="line">	 *</span><br><span class="line">	 *内层事务配置的是REQUIRES_NEW，表示自己用自己的，不和外层有牵连，内层如果报错，事务会回滚</span><br><span class="line">	 * 外层如果catch住了，就可以正常执行，外层生效，内层回滚</span><br><span class="line">	 ********************************************************/</span><br><span class="line">	@Transactional</span><br><span class="line">	public void demo6() &#123;</span><br><span class="line">		TestDO test = new TestDO();</span><br><span class="line">		test.setName(&quot;9999&quot;);</span><br><span class="line">		testMapper.insert(test);</span><br><span class="line">		</span><br><span class="line">		try &#123;</span><br><span class="line">			requireNewTransactionService.transactionWithException();</span><br><span class="line">		&#125;catch (Exception e) &#123;</span><br><span class="line">			log.error(&quot;服务异常，异常被捕获&quot;, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/********************************************************</span><br><span class="line">	 * 独立事务</span><br><span class="line">	 * 内外层事务独立，内层操作未报错，事务正常执行，外层有错，事务回滚。</span><br><span class="line">	 ********************************************************/</span><br><span class="line">	@Transactional</span><br><span class="line">	public void demo7() &#123;</span><br><span class="line">		TestDO test = new TestDO();</span><br><span class="line">		test.setName(&quot;9999&quot;);</span><br><span class="line">		testMapper.insert(test);</span><br><span class="line">		</span><br><span class="line">		requireNewTransactionService.transaction();</span><br><span class="line">		throw new WMSException(ErrorCodeEnum.BD10001001.code(),&quot;独立事务&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、分布式事务以及分布式事务嵌套<br>一次业务操作需要跨多个数据源或需要垮多个系统进行远程调用,就会产生分布式事务问题<br>全局事务一致性问题<br>全局事务id+三组件 tc+tm+rm<br>Seata（AT 模式）的默认全局隔离级别是 读未提交（Read Uncommitted）</p>
<p>Seata 是 Simple Extensible Autonomous Transaction Architecture 的简写，由 feascar 改名而来。<br>AT模式 默认<br>TCC模式<br>XA模式<br>SAGA模式 长事务解决方案</p>
<p>XID 由ip 端口号 加全局事务id生成</p>
<p>关于分布式事务，工程领域主要讨论的是强一致性和最终一致性的解决方案。典型方案包括：<br>两阶段提交（2PC, Two-phase Commit）方案<br>eBay 事件队列方案<br>TCC 补偿模式<br>缓存数据最终一致性</p>
<p>一致性理论<br>分布式事务的目的是保障分库数据一致性，而跨库事务会遇到各种不可控制的问题，如个别节点永久性宕机，像单机事务一样的ACID是无法奢望的。另外，业界著名的CAP理论也告诉我们，对分布式系统，需要将数据一致性和系统可用性、分区容忍性放在天平上一起考虑。<br>两阶段提交协议（简称2PC）是实现分布式事务较为经典的方案，但2PC 的可扩展性很差，在分布式架构下应用代价较大，eBay 架构师Dan Pritchett 提出了BASE 理论，用于解决大规模分布式系统下的数据一致性问题。BASE 理论告诉我们：可以通过放弃系统在每个时刻的强一致性来换取系统的可扩展性。<br>CAP理论在分布式系统中，一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）3 个要素最多只能同时满足两个，不可兼得。<br>其中，分区容忍性又是不可或缺的。<br>avatar<br>一致性：分布式环境下多个节点的数据是否强一致。可用性：分布式服务能一直保证可用状态。当用户发出一个请求后，服务能在有限时间内返回结果。分区容忍性：特指对网络分区的容忍性。举例：Cassandra、Dynamo<br>等，默认优先选择AP，弱化C；HBase、MongoDB 等，默认优先选择CP，弱化A。<br>BASE理论核心思想：<br>基本可用（BasicallyAvailable）：指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用。<br>软状态（SoftState）：指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。<br>最终一致性（EventualConsistency）：指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态。<br>2. 一致性模型<br>数据的一致性模型可以分成以下 3 类：<br>强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。 弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。 最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。 分布式系统数据的强一致性、弱一致性和最终一致性可以通过Quorum NRW算法分析。<br>3. 分布式事务解决方案<br>2PC方案——强一致性<br>2PC的核心原理是通过提交分阶段和记日志的方式，记录下事务提交所处的阶段状态，在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在这个状态节点重试，如Coordinator重启后，通过日志可以确定提交处于Prepare还是PrepareAll状态，若是前者，说明有节点可能没有Prepare成功，或所有节点Prepare成功但还没有下发Commit，状态恢复后给所有节点下发RollBack；若是PrepareAll状态，需要给所有节点下发Commit，数据库节点需要保证Commit幂等。<br>avatar<br>2PC方案的问题：同步阻塞。数据不一致。单点问题。升级的3PC方案旨在解决这些问题，主要有两个改进：增加超时机制。两阶段之间插入准备阶段。但三阶段提交也存在一些缺陷，要彻底从协议层面避免数据不一致，可以采用Paxos或者Raft算法。<br>eBay 事件队列方案——最终一致性<br>eBay 的架构师Dan Pritchett，曾在一篇解释BASE 原理的论文《Base：An Acid<br>Alternative》中提到一个eBay<br>分布式系统一致性问题的解决方案。它的核心思想是将需要分布式处理的任务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行失败重试，它要求各服务的接口是幂等的。描述的场景为，有用户表user<br>和交易表transaction，用户表存储用户信息、总销售额和总购买额，交易表存储每一笔交易的流水号、买家信息、卖家信息和交易金额。如果产生了一笔交易，需要在交易表增加记录，同时还要修改用户表的金额。<br>avatar<br>论文中提出的解决方法是将更新交易表记录和用户表更新消息放在一个本地事务来完成，为了避免重复消费用户表更新消息带来的问题，增加一个操作记录表updates_applied来记录已经完成的交易相关的信息。</p>
<p>这个方案的核心在于第二阶段的重试和幂等执行。失败后重试，这是一种补偿机制，它是能保证系统最终一致的关键流程。<br>TCC （Try-Confirm-Cancel）补偿模式——最终一致性<br>某业务模型如图，由服务 A、服务B、服务C、服务D 共同组成的一个微服务架构系统。服务A 需要依次调用服务B、服务C 和服务D<br>共同完成一个操作。当服务A 调用服务D 失败时，若要保证整个系统数据的一致性，就要对服务B 和服务C 的invoke<br>操作进行回滚，执行反向的revert 操作。回滚成功后，整个微服务系统是数据一致的。<br>avatar<br>实现关键要素：服务调用链必须被记录下来。每个服务提供者都需要提供一组业务逻辑相反的操作，互为补偿，同时回滚操作要保证幂等。必须按失败原因执行不同的回滚策略。<br>缓存数据最终一致性<br>在我们的业务系统中，缓存（Redis 或者Memcached）通常被用在数据库前面，作为数据读取的缓冲，使得I/O<br>操作不至于直接落在数据库上。以商品详情页为例，假如卖家修改了商品信息，并写回到数据库，但是这时候用户从商品详情页看到的信息还是从缓存中拿到的过时数据，这就出现了缓存系统和数据库系统中的数据不一致的现象。<br>要解决该场景下缓存和数据库数据不一致的问题我们有以下两种解决方案：为缓存数据设置过期时间。当缓存中数据过期后，业务系统会从数据库中获取数据，并将新值放入缓存。这个过期时间就是系统可以达到最终一致的容忍时间。更新数据库数据后同时清除缓存数据。数据库数据更新后，同步删除缓存中数据，使得下次对商品详情的获取直接从数据库中获取，并同步到缓存。<br>常用组件： Seata，Sega，Atomikos<br>avatar<br>TC (Transaction Coordinator) - 事务协调者<br>维护全局和分支事务的状态，驱动全局事务提交或回滚。<br>TM (Transaction Manager) - 事务管理器<br>定义全局事务的范围：开始全局事务、提交或回滚全局事务。<br>RM (Resource Manager) - 资源管理器<br>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。<br>avatar<br>安装<br>关键注解全局@GlobalTranstional<br>1.更改事务组名称service<br>2.store更改mode 修改db<br>3.执行sql<br>4.修改注册进nacos<br>5.启动seata-server.bat<br>如何保证分布唯一全局id的生成</p>
<p>5、分布式事务异步方案<br>看下分布式事务的异步问题，根据事务的xid搭配future在切面里对注解进行处理，实现异步+分布式事务的并存<br>注意事项<br>这个依赖只是用来解决部分问题，不是解决全部问题<br>这个仅用于TM端，不要用来RM端(其实要实现RM端的话，可以仿照SeataAsyncAspect，写一个aspect，很简单的)<br>不要进行事务嵌套，不支持事务嵌套！！！<br>确保异步的多个操作之间是没有先后顺序的<br>这个是一个私人包装处理，仅供参考，还未应用到生产环境<br>—-待续</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>【声明】阿里云服务器导致图片不显示[可在此贴下方留言]</title>
    <url>/posts/20220725clhk6pte60019csuj6swegpg0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>1.图片服务器原因不定期修复…紧急修复中….<br>2.重要重要【图片不显示，请更换为火狐浏览器打开！！！或者手机在微信中打开也可食用】,放大图片更清晰<br>3.服务器内存过小,2020年10月13日后续部分内容将图片转至腾讯云<br>4.2d妹子会叫,有问题请留言<br>5.阿里云服务器到期,后续将不再续费,个人项目停止维护</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
  </entry>
  <entry>
    <title>【置顶】Springboot之---强大的Servlet</title>
    <url>/posts/20220127clhk6pte8001ccsujcpi5erds.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h4 id="If-I-have-seen-further-it-is-by-standing-on-the-shoulders-of-giants"><a href="#If-I-have-seen-further-it-is-by-standing-on-the-shoulders-of-giants" class="headerlink" title="If I have seen further, it is by standing on the shoulders of giants"></a>If I have seen further, it is by standing on the shoulders of giants</h4><h4 id="如果我比别人看得更远-那是因为我站在巨人的肩膀上"><a href="#如果我比别人看得更远-那是因为我站在巨人的肩膀上" class="headerlink" title="如果我比别人看得更远,那是因为我站在巨人的肩膀上"></a>如果我比别人看得更远,那是因为我站在巨人的肩膀上</h4><h3 id="如今回头看下Servlet不仅如此强大-还具有很强烈的参考意义-能在现如今流行的大部分框架中找到它的影子。下面文章不止与探索Servlet-可能在其中穿插其他的关联知识点-旨在能从此次的学习中获取更多的知识点参考资料总结-转化为自己的理解输出-在文中我尽量以截图-复制全限定类名的方式记录-以便感兴趣的再次查找。"><a href="#如今回头看下Servlet不仅如此强大-还具有很强烈的参考意义-能在现如今流行的大部分框架中找到它的影子。下面文章不止与探索Servlet-可能在其中穿插其他的关联知识点-旨在能从此次的学习中获取更多的知识点参考资料总结-转化为自己的理解输出-在文中我尽量以截图-复制全限定类名的方式记录-以便感兴趣的再次查找。" class="headerlink" title="如今回头看下Servlet不仅如此强大,还具有很强烈的参考意义,能在现如今流行的大部分框架中找到它的影子。下面文章不止与探索Servlet,可能在其中穿插其他的关联知识点,旨在能从此次的学习中获取更多的知识点参考资料总结,转化为自己的理解输出,在文中我尽量以截图+复制全限定类名的方式记录,以便感兴趣的再次查找。"></a>如今回头看下Servlet不仅如此强大,还具有很强烈的参考意义,能在现如今流行的大部分框架中找到它的影子。下面文章不止与探索Servlet,可能在其中穿插其他的关联知识点,旨在能从此次的学习中获取更多的知识点参考资料总结,转化为自己的理解输出,在文中我尽量以截图+复制全限定类名的方式记录,以便感兴趣的再次查找。</h3><h2 id="Springboot与Servlet"><a href="#Springboot与Servlet" class="headerlink" title="Springboot与Servlet"></a>Springboot与Servlet</h2><p>在springboot中内嵌了Tomcat容器,而Tomcat又是Servlet的容器,Springboot就与Servlet产生了紧密的联系。<br>在分析各个类时,注意下每个类所在的包是如何在tomcat与boot之间跨越的~</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>1、初始化<br>2、处理请求<br>3、销毁<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/servlet.png" alt="流程"></p>
<h3 id="应用上下文ServletContext"><a href="#应用上下文ServletContext" class="headerlink" title="应用上下文ServletContext"></a>应用上下文ServletContext</h3><p>应用上下文即可看做：一次请求到达,到响应结束的过程中间的catlog,即阅读中结合上下文语境,是一个广义定义。<br>为什么说到上下文呢？来看下ServletContext的实现,第一个经典实现既是ApplicationContext我们不止在一次源码和应用中见到它,另外加载器目前有两种选择：ContextLoaderListener和ContextLoaderServlet。其功能是完全相同。会在下文进行介绍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Standard implementation of &lt;code&gt;ServletContext&lt;/code&gt; that represents</span></span><br><span class="line"><span class="comment"> * a web application&#x27;s execution environment.  An instance of this class is</span></span><br><span class="line"><span class="comment"> * associated with each instance of &lt;code&gt;StandardContext&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> * 代表web应用程序的执行环境。这个类的一个实例是</span></span><br><span class="line"><span class="comment"> *与StandardContext的每个实例关联。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Craig R. McClanahan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Remy Maucherat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> <span class="keyword">implements</span> <span class="title">ServletContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> STRICT_SERVLET_COMPLIANCE;<span class="comment">///翻译为是否严格遵守</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> GET_RESOURCE_REQUIRE_SLASH;<span class="comment">//获取资源是否需要斜线。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        STRICT_SERVLET_COMPLIANCE = Globals.STRICT_SERVLET_COMPLIANCE;</span><br><span class="line"></span><br><span class="line">        String requireSlash = System.getProperty(<span class="string">&quot;org.apache.catalina.core.ApplicationContext.GET_RESOURCE_REQUIRE_SLASH&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (requireSlash == <span class="keyword">null</span>) &#123;</span><br><span class="line">            GET_RESOURCE_REQUIRE_SLASH = STRICT_SERVLET_COMPLIANCE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            GET_RESOURCE_REQUIRE_SLASH = Boolean.parseBoolean(requireSlash);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：特别重要上述配置为tomcat中第一个开关配置,决定多个属性的值。来自于下面的Globals.STRICT_SERVLET_COMPLIANCE;默认为false<br>验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> STRICT_SERVLET_COMPLIANCE =Boolean.parseBoolean(System.getProperty(<span class="string">&quot;org.apache.catalina.STRICT_SERVLET_COMPLIANCE&quot;</span>, <span class="string">&quot;false&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>和官网截图<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/compliance.png" alt="流程"><br>问题:会因为tomcat的版本配置不同改变此值,在8.5.57当中会改变为true,当controller中配置多个映射路径会出现访问不到的问题<br>此处参考博文：<a href="https://blog.csdn.net/xing930408/article/details/111225064">https://blog.csdn.net/xing930408/article/details/111225064</a><br>Tomcat文档：<a href="https://tomcat.apache.org/tomcat-8.5-doc/config/systemprops.html">https://tomcat.apache.org/tomcat-8.5-doc/config/systemprops.html</a><br>而GET_RESOURCE_REQUIRE_SLASH直接赋值为STRICT_SERVLET_COMPLIANCE</p>
<h2 id="SpringBoot-ApplicationContext"><a href="#SpringBoot-ApplicationContext" class="headerlink" title="SpringBoot ApplicationContext"></a>SpringBoot ApplicationContext</h2><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContext.html">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContext.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,MessageSource, ApplicationEventPublisher, ResourcePatternResolver</span><br></pre></td></tr></table></figure>

<p>都在说ApplicationContext衍生了BeanFactory那么对此都扩展了那些功能？ApplicationContext定了高级容器的基本规范,其实他也不是直接继承BeanFactory基础容器,可以看到ApplicationContext的直接父接口对BeanFactory进行很多拓展其中就包括：<br>1.事件的注册和发布<br>2.消息解析<br>3.资源解析<br>4.Bean工厂层级管理<br>5.监听器<br>6.容器环境<br>通过以上拓展,我们基本可以知道高级IOC容器有哪些特点,这也是学习整个ApplicationContext容器重点了解的部分</p>
<p>再比较ApplicationContext和ConfigurableApplicationContext定义的方法以及下图层级关系,ConfigurableApplicationContext是ApplicationContext的子接口,也就包含了ApplicationContext。通过方法可以知道,ConfigurableApplicationContext重在对各种属性的配置,而ApplicationContext接口主要各种属性的get方法。</p>
<p>Spring这种将get和set分开到两个接口的设计增大了属性设置和获取的灵活性,将两者分开也更加清晰。在以后的解决方案设计中,可以参考,将配置信息和获取信息分开,两者互不干扰,在保证重要的基础属性不变的情况,可以按需进行拓展。其实Spring的框架设计中应用了大量的装饰者模式,这也是高拓展点的需要</p>
<p>该类提供了高级IOC规范<br>其中有几个注意点：</p>
<p>从ListableBeanFactory接口继承来的：用于访问应用组件的工厂方法<br>从ResourceLoader接口继承来的：用通用的方式加载文件资源<br>从ApplicationEventPublisher接口继承来的：注册和发布事件<br>从MessageSource接口继承来的：处理消息,支持国际化</p>
<p>从父应用上下文定义的在子上下文中将始终保持优先</p>
<p><a href="https://www.javaguides.net/2019/10/how-to-get-application-context-in-spring-boot.html">https://www.javaguides.net/2019/10/how-to-get-application-context-in-spring-boot.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,</span><br><span class="line">        MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回一个唯一的应用上下文id+</span><br><span class="line">     * @return the unique id of the context, or &#123;@code null&#125; if none</span><br><span class="line">     */</span><br><span class="line">    @Nullable</span><br><span class="line">    String getId();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回已经部署的该应用上下文的名称.</span><br><span class="line">     * @return a name for the deployed application, or the empty String by default</span><br><span class="line">     */</span><br><span class="line">    String getApplicationName();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回此上下文友好的名称---这有什么用呢？</span><br><span class="line">     * @return a display name for this context (never &#123;@code null&#125;)</span><br><span class="line">     */</span><br><span class="line">    String getDisplayName();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回该上下文第一次被加载的时间戳</span><br><span class="line">     * @return the timestamp (ms) when this context was first loaded</span><br><span class="line">     */</span><br><span class="line">    long getStartupDate();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *返回父应用上下文, 如果没有父上下文,该上下文就是在上下文层次的根</span><br><span class="line">     * @return the parent context, or &#123;@code null&#125; if there is no parent</span><br><span class="line">     */</span><br><span class="line">    @Nullable</span><br><span class="line">    ApplicationContext getParent();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这其中对AutowireCapableBeanFactory getAutowireCapableBeanFactory()方法有疑惑,然后网上百度了一下。Spring提供了一种机制,能够为第三方框架赋能,让Spring去管理的Bean去装配和填充那些没有被SpringIOC管理的bean。也就是Spring提供了使用第三方框架的能力,能够做到无缝的将第三方框架整合到Spring中来进行使用,Junit与Quartz借用了这种机制为自己赋能。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「还你一梦」的原创文章,遵循CC 4.0 BY-SA版权协议,转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ligel136738/article/details/113533132">https://blog.csdn.net/ligel136738/article/details/113533132</a></p>
<h2 id="AutowireCapableBeanFactory"><a href="#AutowireCapableBeanFactory" class="headerlink" title="AutowireCapableBeanFactory"></a>AutowireCapableBeanFactory</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.springframework.beans.factory.config;</span><br><span class="line"></span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.TypeConverter;</span><br><span class="line">import org.springframework.beans.factory.BeanFactory;</span><br><span class="line">import org.springframework.beans.factory.NoSuchBeanDefinitionException;</span><br><span class="line">import org.springframework.beans.factory.NoUniqueBeanDefinitionException;</span><br><span class="line">import org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface AutowireCapableBeanFactory extends BeanFactory &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    int AUTOWIRE_NO = 0;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    int AUTOWIRE_BY_NAME = 1;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    int AUTOWIRE_BY_TYPE = 2;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    int AUTOWIRE_CONSTRUCTOR = 3;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    @Deprecated</span><br><span class="line">    int AUTOWIRE_AUTODETECT = 4;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    String ORIGINAL_INSTANCE_SUFFIX = &quot;.ORIGINAL&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T createBean(Class&lt;T&gt; beanClass) throws BeansException;</span><br><span class="line"></span><br><span class="line">    void autowireBean(Object existingBean) throws BeansException;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    Object configureBean(Object existingBean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Object createBean(Class&lt;?&gt; beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;</span><br><span class="line"></span><br><span class="line">    Object autowire(Class&lt;?&gt; beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)</span><br><span class="line">            throws BeansException;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    Object initializeBean(Object existingBean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">            throws BeansException;</span><br><span class="line"></span><br><span class="line">    Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)</span><br><span class="line">            throws BeansException;</span><br><span class="line"></span><br><span class="line">    void destroyBean(Object existingBean);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    @Nullable</span><br><span class="line">    Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    @Nullable</span><br><span class="line">    Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,</span><br><span class="line">            @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在ApplacationContext中并没有实现此工厂接口,如上文可见,是在初始化Spring管理Bean之外的实例时直接调用getAutowireCapableBeanFactory方法<br>AutowireCapableBeanFactory定义了5种装配策略：</p>
<p>不自动注入：AUTOWIRE_NO<br>使用BeanName策略注入：AUTOWIRE_BY_NAME<br>使用类型装配策略：AUTOWIRE_BY_TYPE<br>使用构造器装配策略：AUTOWIRE_CONSTRUCTOR<br>自动装配策略：AUTOWIRE_AUTODETECT</p>
<p>以AbstractAutowireCapableBeanFactory为例,其实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autowireBean</span><span class="params">(Object existingBean)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用非单例bean定义,以避免将bean注册为依赖bean</span></span><br><span class="line">        <span class="comment">// Use non-singleton bean definition, to avoid registering bean as dependent bean.</span></span><br><span class="line">        RootBeanDefinition bd = <span class="keyword">new</span> RootBeanDefinition(ClassUtils.getUserClass(existingBean));</span><br><span class="line">        Bean的作用域</span><br><span class="line">        bd.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">        检查给定类在给定上下文中是否是缓存安全的,</span><br><span class="line">        即它是由给定类加载器加载还是由其父级加载。类加载器</span><br><span class="line">        bd.allowCaching = ClassUtils.isCacheSafe(bd.getBeanClass(), getBeanClassLoader());</span><br><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(existingBean);</span><br><span class="line">        初始化BeanRapper并创建</span><br><span class="line">        initBeanWrapper(bw);</span><br><span class="line">        实际上该方法的逻辑主要是在populateBean中。这个方法是Spring中一个重要的方法。用于装配Bean。主要是通过反射获取到我们<span class="keyword">new</span>出来的对象的属性及注解,若是注解时Autowired、Value、Inject时,进行Bean组装。此方法执行完毕,我们<span class="keyword">new</span>出来的方法就可以通过注解注入的bean进行操作了</span><br><span class="line">        作者：小胖学编程</span><br><span class="line">        链接：https:<span class="comment">//www.jianshu.com/p/14dd69b5c516</span></span><br><span class="line">        来源：简书</span><br><span class="line">        著作权归作者所有。商业转载请联系作者获得授权,非商业转载请注明出处。</span><br><span class="line">        populateBean(bd.getBeanClass().getName(), bd, bw);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring容器内部工作机制AbstractApplicationContext"><a href="#Spring容器内部工作机制AbstractApplicationContext" class="headerlink" title="Spring容器内部工作机制AbstractApplicationContext"></a>Spring容器内部工作机制AbstractApplicationContext</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/ApplicationContext.jpg" alt="流程"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.context.support.AbstractApplicationContext</span><br><span class="line"><span class="keyword">package</span> org.springframework.context.support;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用模板方法设计模式,需要具体的子类来实现抽象方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此工厂中,国际化消息 MessageSource 的 bean的名称。</span></span><br><span class="line"><span class="comment">     * 如果没有提供消息,消息解析将委托给父节点。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> MessageSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_SOURCE_BEAN_NAME = <span class="string">&quot;messageSource&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此工厂中,SpringBean 的生命周期LifecycleProcessor 的 bean的名称</span></span><br><span class="line"><span class="comment">     * 如果没有提供,则使用DefaultLifecycleProcessor。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.context.LifecycleProcessor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.context.support.DefaultLifecycleProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LIFECYCLE_PROCESSOR_BEAN_NAME = <span class="string">&quot;lifecycleProcessor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此工厂中,应用事件多路广播器 的 bean的名称。</span></span><br><span class="line"><span class="comment">     * 如果没有提供,则使用默认的simpleapplicationeventmultiaster。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.context.event.ApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APPLICATION_EVENT_MULTICASTER_BEAN_NAME = <span class="string">&quot;applicationEventMulticaster&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ContextClosedEvent.class.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 这个类使用的logger。可用于子类。 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此上下文的唯一id(如果有的话)。 */</span></span><br><span class="line">    <span class="keyword">private</span> String id = ObjectUtils.identityToString(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 显示名称 */</span></span><br><span class="line">    <span class="keyword">private</span> String displayName = ObjectUtils.identityToString(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 父上下文。 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此上下文使用的环境。 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 应用于刷新的 BeanFactoryPostProcessors */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此上下文启动时的系统时间(毫秒)。 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startupDate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 指示此上下文当前是否处于活动状态的标志。 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean active = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 指示此上下文是否已关闭的标志。 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean closed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于&quot;刷新&quot; 和 &quot;销毁&quot; 时的同步监视器（浅显是说就是当做锁） */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object startupShutdownMonitor = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果已注册,则引用JVM关闭链接。 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Thread shutdownHook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此上下文使用的 ResourcePatternResolver 资源模式解析器 */</span></span><br><span class="line">    <span class="keyword">private</span> ResourcePatternResolver resourcePatternResolver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** LifecycleProcessor 生命周期处理器,用于在此上下文中管理bean的生命周期。 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> LifecycleProcessor lifecycleProcessor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 我们将这个接口的实现委托给 MessageSource */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 事件发布所使用的助手类。 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventMulticaster applicationEventMulticaster;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 静态的、指定的 listeners 监听器Set集合. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 早期发布的 ApplicationEvents 应用事件Set集合. */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;ApplicationEvent&gt; earlyApplicationEvents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 创建一个没有父元素的新的AbstractApplicationContext。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用给定的父上下文来创建一个新的AbstractApplicationContext。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        setParent(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// ApplicationContext接口的实现</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置此应用程序上下文的惟一id。</span></span><br><span class="line"><span class="comment">     * 默认值是上下文实例的对象id,或者上下文bean的名称(如果上下文本身定义为bean的话)。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 上下文的唯一id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 获取此应用程序上下文的id。 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getApplicationName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为这个上下文设置一个(显示)名称。</span></span><br><span class="line"><span class="comment">     * 通常在具体上下文实现的初始化过程中完成。</span></span><br><span class="line"><span class="comment">     * 默认值是上下文实例的对象id。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplayName</span><span class="params">(String displayName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置显示的上下文名称不能为空</span></span><br><span class="line">        Assert.hasLength(displayName, <span class="string">&quot;Display name must not be empty&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.displayName = displayName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取并返回此应用上下文的展示名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 此应用上下文的展示名称（非null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDisplayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.displayName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回父上下文,如果没有父上下文,则返回 null。</span></span><br><span class="line"><span class="comment">     * (返回null意为着,此应用上下文是整个应用上下文体系的根上下文）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationContext <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为这个应用程序上下文设置 Environment 环境</span></span><br><span class="line"><span class="comment">     * 默认值由 createEnvironment()方法决定。</span></span><br><span class="line"><span class="comment">     * 用这个方法替换默认值不是唯一选择,还可通过 getEnvironment() 方法进行配置。</span></span><br><span class="line"><span class="comment">     * 但不管在哪一种情况下,这些修改都应该在 refresh() 方法前执行。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.context.support.AbstractApplicationContext#createEnvironment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取并返回此应用上下文的环境,如果为null,则通过 createEnvironment() 方法进行创建并返回。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurableEnvironment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.environment = createEnvironment();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并返回新的StandardEnvironment 标准环境。</span></span><br><span class="line"><span class="comment">     * 子类可以重写此方法,以便提供自定义 ConfigurableEnvironment 可配置环境的实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ConfigurableEnvironment <span class="title">createEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此应用上下文已经可用,则将此上下文的内部bean工厂返回为AutowireCapableBeanFactory。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 在首次加载此上下文时返回时间戳(ms)。 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStartupDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.startupDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将给定的事件发布给所有监听器。</span></span><br><span class="line"><span class="comment">     * 注意:监听器在 MessageSource 之后初始化,以便能够在监听器实现中访问它。</span></span><br><span class="line"><span class="comment">     * 因此,MessageSource 实现不能发布事件。要发布的事件(可能是特定于应用程序或标准框架事件)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将给定的事件发布给所有监听器。</span></span><br><span class="line"><span class="comment">     * 注意:监听器在 MessageSource 之后初始化,以便能够在监听器实现中访问它。</span></span><br><span class="line"><span class="comment">     * 因此,MessageSource 实现不能发布事件。</span></span><br><span class="line"><span class="comment">     * 要发布的事件(可能是 ApplicationEvent 或要转换为 PayloadApplicationEvent 的有效负载对象)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">        publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将给定的事件发布给所有监听器。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event 要发布的事件(可能是 ApplicationEvent 或要转换为 PayloadApplicationEvent 的有效负载对象)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventType 可解析的事件类型(如果已知)（前面的文章已经提到过）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必要时将事件装饰为 ApplicationEvent</span></span><br><span class="line">        ApplicationEvent applicationEvent;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">            applicationEvent = (ApplicationEvent) event;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">            <span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eventType = ((PayloadApplicationEvent) applicationEvent).getResolvableType();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果可能的话,现在就进行多播——或者在初始化多播器之后延迟</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过父上下文发布事件…</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">                ((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回上下文使用的内部 ApplicationEventMulticaster 应用事件多路广播器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上下文使用的内部 ApplicationEventMulticaster 应用事件多路广播器（从不为null）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException 如果上下文尚未初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ApplicationEventMulticaster <span class="title">getApplicationEventMulticaster</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.applicationEventMulticaster == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;ApplicationEventMulticaster not initialized - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;call &#x27;refresh&#x27; before multicasting events via the context: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.applicationEventMulticaster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回上下文使用的内部生命周期处理器。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 内部生命周期处理器。 (从不为null)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException 如果上下文尚未初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">LifecycleProcessor <span class="title">getLifecycleProcessor</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleProcessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;LifecycleProcessor not initialized - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;call &#x27;refresh&#x27; before invoking lifecycle methods via the context: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lifecycleProcessor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此 ResourcePatternResolver资源模式解析器,</span></span><br><span class="line"><span class="comment">     * 用于将多个资源的位置按照模式解析到资源实例中。</span></span><br><span class="line"><span class="comment">     * 默认是org.springframework.core.io.support.PathMatchingResourcePatternResolver。</span></span><br><span class="line"><span class="comment">     * 支持ant风格的位置模式。</span></span><br><span class="line"><span class="comment">     * 可以在子类中重写,用于扩展解析策略,例如在web环境中。在需要解决位置模式时不要调用此函数。</span></span><br><span class="line"><span class="comment">     * 相反,调用上下文的getResources方法,它将委托给ResourcePatternResolver。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 此应用上下文的 ResourcePatternResolver 资源模式解析器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getResources</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// ConfigurableApplicationContext接口的实现</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置此应用程序上下文的父上下文。</span></span><br><span class="line"><span class="comment">     * 父级ApplicationContext#getEnvironment()环境是</span></span><br><span class="line"><span class="comment">     * ConfigurableEnvironment#merge(ConfigurableEnvironment),如果父级非null,</span></span><br><span class="line"><span class="comment">     * 并且它的环境是ConfigurableEnvironment的实例,那么它就会与这个(子级)应用程序上下文环境合并</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ConfigurableEnvironment#merge(ConfigurableEnvironment)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Environment parentEnvironment = parent.getEnvironment();</span><br><span class="line">            <span class="keyword">if</span> (parentEnvironment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">                getEnvironment().merge((ConfigurableEnvironment) parentEnvironment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 添加Bean工厂后置处理器 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeanFactoryPostProcessor</span><span class="params">(BeanFactoryPostProcessor postProcessor)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(postProcessor, <span class="string">&quot;BeanFactoryPostProcessor must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.beanFactoryPostProcessors.add(postProcessor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回将应用到内部BeanFactory的BeanFactoryPostProcessors列表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;BeanFactoryPostProcessor&gt; <span class="title">getBeanFactoryPostProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactoryPostProcessors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 添加应用上下文监听器 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(listener, <span class="string">&quot;ApplicationListener must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.applicationEventMulticaster != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.applicationEventMulticaster.addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回静态指定的ApplicationListeners集合.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.applicationListeners;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载或刷新一个持久化的配置,可能是XML文件、属性文件或关系数据库模式。</span></span><br><span class="line"><span class="comment">     * 由于这是一种启动方法,如果失败,应该销毁已经创建的单例,以避免悬空资源。</span></span><br><span class="line"><span class="comment">     * 换句话说,在调用该方法之后,要么全部实例化,要么完全不实例化。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果bean工厂无法初始化,则抛出 BeansException 异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果已经初始化且不支持多次刷新,则会抛出 IllegalStateException 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">        <span class="comment">// 加载或刷新配置前的同步处理</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            <span class="comment">// 为刷新而准备此上下文</span></span><br><span class="line">            prepareRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 告诉子类去刷新内部bean工厂。</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备好bean工厂,以便在此上下文中使用。</span></span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 允许在上下文子类中对bean工厂进行后置处理。</span></span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用在上下文中注册为bean的工厂处理器。</span></span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注册拦截bean创建的bean处理器。</span></span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 初始化此上下文的 message resource 消息资源。</span></span><br><span class="line">                initMessageSource();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 为这个上下文初始化事件多路广播器。</span></span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 初始化特定上下文子类中的其他特殊bean。</span></span><br><span class="line">                onRefresh();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注册监听器（检查监听器的bean并注册它们）。</span></span><br><span class="line">                registerListeners();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 实例化所有剩余的(非 lazy-init 懒初始化的)单例。</span></span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 最后一步: 发布相应的事件。</span></span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 销毁已经创建的单例,以避免悬空资源。</span></span><br><span class="line">                destroyBeans();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重置 &#x27;active&#x27; 表示.</span></span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将异常传播给调用者。</span></span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 重置Spring内核中的共用的缓存,因为我们可能再也不需要单例bean的元数据了……</span></span><br><span class="line">                resetCommonCaches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 准备这个上下文来刷新、设置它的启动日期和活动标志以及执行属性源的任何初始化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在此上下文环境中,初始化任何占位符处的属性资源</span></span><br><span class="line">        initPropertySources();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证标记为必需的所有属性是否可解析</span></span><br><span class="line">        <span class="comment">// 请参考 ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">        getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 允许在多路广播器可用时,就会发布初期 ApplicationEvents 应用事件的集合</span></span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用实际实例替换任何存根属性源。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.env.PropertySource.StubPropertySource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.web.context.support.WebApplicationContextUtils#initServletPropertySources</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initPropertySources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于子类：默认情况下不执行任何操作。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知此上下文的子类去加载或刷新其内在的bean工厂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新的bean工厂实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        refreshBeanFactory();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置工厂的标准上下文的特征属性,</span></span><br><span class="line"><span class="comment">     * 例如上下文的ClassLoader类加载器和post-processors后置处理器。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory 要配置的bean工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 告诉内部bean工厂使用上下文的类加载器等。</span></span><br><span class="line">        beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">        beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">        beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用上下文回调配置bean工厂。</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在简单的工厂中,BeanFactory接口没有注册为可解析的类型。</span></span><br><span class="line">        <span class="comment">// MessageSource注册（并发现自动）为一个bean。</span></span><br><span class="line">        beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">        beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">        beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">        beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册早期后置处理器,用于检测内部bean作为应用程序监听器。</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何找到一个LoadTimeWeaver,那么就准备将后置处理器“织入”bean工厂</span></span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">            beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">            <span class="comment">// 为类型匹配设置临时类加载器。</span></span><br><span class="line">            beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册默认environment环境bean。</span></span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在标准初始化后修改应用程序上下文的内部bean工厂。</span></span><br><span class="line"><span class="comment">     * 所有bean定义都将被加载,但是没有bean会被实例化。</span></span><br><span class="line"><span class="comment">     * 这允许在某些应用上下文实现中注册特殊的BeanPostProcessors等。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory 应用环境下的Bean工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化并调用所有已注册的BeanFactoryPostProcessor 的 bean,如果已给出顺序,请按照顺序。</span></span><br><span class="line"><span class="comment">     * 必须在单实例实例化之前调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何找到一个LoadTimeWeaver,那么就准备将后置处理器“织入”bean工厂</span></span><br><span class="line">        <span class="comment">// (例如,一个 @Bean 方法通过ConfigurationClassPostProcessor来注册)</span></span><br><span class="line">        <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">            beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">            beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BeanPostProcessor 的 bean,如果给出显式顺序,请按照顺序。</span></span><br><span class="line"><span class="comment">     * 必须在应用程序bean的任何实例化之前调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化MessageSource。</span></span><br><span class="line"><span class="comment">     * 如果在此上下文中未定义国际化资源,则使用父上下文的国际化资源。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">            <span class="comment">// 使用此上下文的 MessageSource 知道父上下文的 MessageSource.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">                HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">                <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有已注册的父MessageSource,则只将父上下文设置为父MessageSource</span></span><br><span class="line">                    <span class="comment">// registered already.</span></span><br><span class="line">                    hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用空MessageSource可以接受getMessage方法的调用。</span></span><br><span class="line">            DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">            dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">            <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">            beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化ApplicationEventMulticaster。</span></span><br><span class="line"><span class="comment">     * 如果在上下文中没有定义,则使用SimpleApplicationEventMulticaster。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">                    beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">            beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化LifecycleProcessor.</span></span><br><span class="line"><span class="comment">     * 如果在当前上下文中没有定义,则使用 DefaultLifecycleProcessor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.context.support.DefaultLifecycleProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initLifecycleProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.lifecycleProcessor =</span><br><span class="line">                    beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Using LifecycleProcessor [&quot;</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DefaultLifecycleProcessor defaultProcessor = <span class="keyword">new</span> DefaultLifecycleProcessor();</span><br><span class="line">            defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.lifecycleProcessor = defaultProcessor;</span><br><span class="line">            beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="keyword">this</span>.lifecycleProcessor);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + LIFECYCLE_PROCESSOR_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.lifecycleProcessor.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法,可以重写以添加特定于上下文的刷新工作。</span></span><br><span class="line"><span class="comment">     * 在特殊实例实例化之前调用特殊bean的初始化。</span></span><br><span class="line"><span class="comment">     * 此实现为空。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException in case of errors</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 对于子类：默认情况下不做任何事情。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加应用程序监听器作为监听器的bean。</span></span><br><span class="line"><span class="comment">     * 不影响其他监听器,可以在没有bean的情况下添加。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先注册静态的指定的监听器。</span></span><br><span class="line">        <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">            getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不要在这里初始化factorybean:我们需要保留所有未初始化的常规bean,让后处理器应用到它们!</span></span><br><span class="line">        String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">            getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在我们最终拥有一个多路广播器来发布早期的应用程序事件......</span></span><br><span class="line">        Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">                getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 完成此上下文的bean工厂的初始化,初始化所有剩余的单例bean。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化此上下文的转换服务conversion service。</span></span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">                beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">            beanFactory.setConversionService(</span><br><span class="line">                    beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有bean后置处理器post-processor,则注册默认嵌入式值解析器</span></span><br><span class="line">        <span class="comment">// (例如像一个 PropertyPlaceholderConfigurer bean) 以前任何注册过:</span></span><br><span class="line">        <span class="comment">// 此时,主要用于注释属性值的解析。</span></span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">            beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尽早初始化LoadTimeWeaverAware bean,以便尽早注册它们的transformers。</span></span><br><span class="line">        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">            getBean(weaverAwareName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止使用临时类加载器进行类型匹配。</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 允许缓存所有bean定义元数据,不希望有进一步的更改。</span></span><br><span class="line">        beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化所有剩余的(non-lazy-init非延时加载的)单例。</span></span><br><span class="line">        beanFactory.preInstantiateSingletons();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成此上下文的刷新,调用LifecycleProcessor的onRefresh()方法</span></span><br><span class="line"><span class="comment">     * 并发布org.springframework.context.event.ContextRefreshedEvent 事件.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 清除上下文级别的资源缓存(如扫描的ASM元数据)。</span></span><br><span class="line">        clearResourceCaches();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为这个上下文初始化生命周期处理器。</span></span><br><span class="line">        initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先将刷新传播到生命周期处理器。</span></span><br><span class="line">        getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布最终事件。</span></span><br><span class="line">        publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何处于激活状态,将参与到 LiveBeansView MBean 中</span></span><br><span class="line">        LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消此上下文的刷新尝试,在抛出异常后重置 active 标志。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex 导致取消的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cancelRefresh</span><span class="params">(BeansException ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置Spring的共同的反射元数据缓存,</span></span><br><span class="line"><span class="comment">     * 特别是 ReflectionUtils, AnnotationUtils, ResolvableType</span></span><br><span class="line"><span class="comment">     * 和 CachedIntrospectionResults 缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ReflectionUtils#clearCache()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AnnotationUtils#clearCache()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ResolvableType#clearCache()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> CachedIntrospectionResults#clearClassLoader(ClassLoader)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetCommonCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReflectionUtils.clearCache();</span><br><span class="line">        AnnotationUtils.clearCache();</span><br><span class="line">        ResolvableType.clearCache();</span><br><span class="line">        CachedIntrospectionResults.clearClassLoader(getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向JVM运行时注册一个关闭链接,在JVM关闭时关闭这个上下文,除非此时它已经关闭。</span></span><br><span class="line"><span class="comment">     * 委托给 doClose() 方法去关闭,用于实际的关闭过程。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Runtime#addShutdownHook</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #close()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #doClose()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 尚未注册关机链接</span></span><br><span class="line">            <span class="keyword">this</span>.shutdownHook = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (startupShutdownMonitor) &#123;</span><br><span class="line">                        doClose();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">this</span>.shutdownHook);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于销毁此实例的回调,最初附加到 DisposableBean 的实现(spring 5.0中不再存在)。 </span></span><br><span class="line"><span class="comment">     * close() 方法是关闭 ApplicationContext 本应用上下文的方法,</span></span><br><span class="line"><span class="comment">     * 该destroy()方法只是委托给close()方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> 从Spring Framework 5.0开始,本方法被标记为过时,而支持 close()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭此应用程序上下文,销毁其bean工厂中的所有bean。</span></span><br><span class="line"><span class="comment">     * 实际关闭过程是委派 doClose()方法。</span></span><br><span class="line"><span class="comment">     * 同时,如果已在JVM注册了关闭链接,也删除其关闭链接,因为它不再需要了。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #doClose()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #registerShutdownHook()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            doClose();</span><br><span class="line">            <span class="comment">// 如果已在JVM注册了关闭链接,现在我们不再需要它了：</span></span><br><span class="line">            <span class="comment">// 我们已经明确地关闭了上下文。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Runtime.getRuntime().removeShutdownHook(<span class="keyword">this</span>.shutdownHook);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="comment">// 忽略已经关闭的VM</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际上执行上下文关闭:</span></span><br><span class="line"><span class="comment">     * 发布ContextClosedEvent山下文关闭事件,并销毁此应用程序上下文的bean工厂中的单例对象。</span></span><br><span class="line"><span class="comment">     * 如果有的话,则调用 close() 方法和一个JVM关闭链接。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #destroyBeans()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #close()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #registerShutdownHook()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.active.get() &amp;&amp; <span class="keyword">this</span>.closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Closing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LiveBeansView.unregisterApplicationContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 发布上下文关闭事件</span></span><br><span class="line">                publishEvent(<span class="keyword">new</span> ContextClosedEvent(<span class="keyword">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception thrown from ApplicationListener handling ContextClosedEvent&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 停止所有 Lifecycle bean,以避免单个地销毁期间而产生延迟。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.lifecycleProcessor.onClose();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;Exception thrown from LifecycleProcessor on context close&quot;</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 销毁上下文的bean工厂中所有缓存的单例对象。</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// 关闭该上下文本身的状态。</span></span><br><span class="line">            closeBeanFactory();</span><br><span class="line">            <span class="comment">// 让子类做一些最后的清理…</span></span><br><span class="line">            onClose();</span><br><span class="line">            <span class="comment">// 设置此应用上下文为非活跃状态</span></span><br><span class="line">            <span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法,用于销毁该上下文管理的所有bean。</span></span><br><span class="line"><span class="comment">     * 调用 DisposableBean.destroy() 或 指定的“destroy-method”销毁方法,</span></span><br><span class="line"><span class="comment">     * 默认销毁将此实现的上下文中所有缓存的单例对象。</span></span><br><span class="line"><span class="comment">      * 可以重写,以在标准单例销毁之前或之后添加上下文特定的bean销毁步骤,</span></span><br><span class="line"><span class="comment">      * 同时上下文的BeanFactory仍然处于活动状态。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.beans.factory.config.ConfigurableBeanFactory#destroySingletons()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getBeanFactory().destroySingletons();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以重写以添加特定于上下文的关闭工作的模板方法。</span></span><br><span class="line"><span class="comment">     * 默认实现为空。</span></span><br><span class="line"><span class="comment">     * 在此上下文的BeanFactory已被关闭后,调用 doClose() 方法做最后的关闭过程.</span></span><br><span class="line"><span class="comment">     * 如果在BeanFactory仍然激活状态时,需要执行自定义关闭逻辑,</span></span><br><span class="line"><span class="comment">     * 则重重写  destroyBeans() 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于子类:默认不做任何事情。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.active.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明此上下文的BeanFactory当前是活动的,如果不是,则抛出 IllegalStateException。</span></span><br><span class="line"><span class="comment">     * 由所有依赖于活动上下文的 BeanFactory 委托方法调用,特别是所有bean访问方法。</span></span><br><span class="line"><span class="comment">     * 默认实现检查 isActive() 这个上下文的“active”状态。</span></span><br><span class="line"><span class="comment">     * 可能被覆盖用于更具体的检查,或用于如果 getBeanFactory() 本身在这种情况下抛出异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">assertBeanFactoryActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.active.get()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.closed.get()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getDisplayName() + <span class="string">&quot; has been closed already&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getDisplayName() + <span class="string">&quot; has not been refreshed yet&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// BeanFactory 接口的实现</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBean(name, requiredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBean(name, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBean(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBean(requiredType, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span> </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBeanProvider(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span> </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBeanProvider(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().containsBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().isSingleton(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().isPrototype(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().isTypeMatch(name, typeToMatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().isTypeMatch(name, typeToMatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException &#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getType(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getAliases(String name) &#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getAliases(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// ListableBeanFactory 接口的实现</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().containsBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBeanDefinitionCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanDefinitionNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBeanDefinitionNames();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForType(ResolvableType type) &#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBeanNamesForType(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type) &#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBeanNamesForType(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit) &#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;T&gt; type)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBeansOfType(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;T&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBeansOfType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType) &#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBeanNamesForAnnotation(annotationType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getBeansWithAnnotation</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBeansWithAnnotation(annotationType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">findAnnotationOnBean</span><span class="params">(String beanName, Class&lt;A&gt; annotationType)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>&#123;</span><br><span class="line"></span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().findAnnotationOnBean(beanName, annotationType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// HierarchicalBeanFactory 接口的实现</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanFactory <span class="title">getParentBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsLocalBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().containsLocalBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果父上下文实现了ConfigurableApplicationContext接口,</span></span><br><span class="line"><span class="comment">     * 则返回父上下文的内部bean工厂；否则,返回父上下文本身。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.context.ConfigurableApplicationContext#getBeanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> BeanFactory <span class="title">getInternalParentBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getParent() <span class="keyword">instanceof</span> ConfigurableApplicationContext ?</span><br><span class="line">                ((ConfigurableApplicationContext) getParent()).getBeanFactory() : getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// MessageSource 接口的实现</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String code, <span class="meta">@Nullable</span> Object[] args, <span class="meta">@Nullable</span> String defaultMessage, Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMessageSource().getMessage(code, args, defaultMessage, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String code, <span class="meta">@Nullable</span> Object[] args, Locale locale)</span> <span class="keyword">throws</span> NoSuchMessageException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMessageSource().getMessage(code, args, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(MessageSourceResolvable resolvable, Locale locale)</span> <span class="keyword">throws</span> NoSuchMessageException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMessageSource().getMessage(resolvable, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回上下文使用的内部 MessageSource。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 此上下文内部的 MessageSource (非 null&#125;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException 如果上下文尚未初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MessageSource <span class="title">getMessageSource</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.messageSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;MessageSource not initialized - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;call &#x27;refresh&#x27; before accessing messages via the context: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.messageSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果父上下文也是AbstractApplicationContext抽象类,则返回父上下文的内部 MessageSource；</span></span><br><span class="line"><span class="comment">      * 否则,返回父上下文本身。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> MessageSource <span class="title">getInternalParentMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getParent() <span class="keyword">instanceof</span> AbstractApplicationContext ?</span><br><span class="line">            ((AbstractApplicationContext) getParent()).messageSource : getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// ResourcePatternResolver 接口的实现</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Lifecycle 接口的实现</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getLifecycleProcessor().start();</span><br><span class="line">        publishEvent(<span class="keyword">new</span> ContextStartedEvent(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getLifecycleProcessor().stop();</span><br><span class="line">        publishEvent(<span class="keyword">new</span> ContextStoppedEvent(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.lifecycleProcessor.isRunning());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 必须由子类实现的抽象方法</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类必须实现此方法来执行实际配置的加载。</span></span><br><span class="line"><span class="comment">     * 在任何其他初始化工作之前,可通过 refresh() 调用此方法。</span></span><br><span class="line"><span class="comment">     * 子类要么创建一个新的bean工厂并持有对它的引用,</span></span><br><span class="line"><span class="comment">     * 要么返回一个它持有的BeanFactory实例。</span></span><br><span class="line"><span class="comment">     * 在后一种情况下,如果多次刷新上下文,它通常会抛出一个IllegalStateException。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException 如果bean工厂的初始化失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException 如果已经初始化并且不支持多次刷新尝试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类必须实现此方法来释放它们内部bean工厂。</span></span><br><span class="line"><span class="comment">     * 在所有其他关闭工作之后, close() 将调用此方法。</span></span><br><span class="line"><span class="comment">     * 永远不要抛出异常,而是日志关闭失败。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">closeBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类必须在这里返回其内部bean工厂。</span></span><br><span class="line"><span class="comment">     * 它们应该有效地实现查找,这样就可以重复调用查找,而不会影响性能。</span></span><br><span class="line"><span class="comment">     * 注意:在返回内部bean工厂之前,子类应该检查上下文是否仍然是活动的。</span></span><br><span class="line"><span class="comment">     * 一旦上下文关闭,内部工厂通常被认为不可用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 此应用上下文的内部bean工厂(非null)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException 如果上下文还没有包含内部bean工厂(通常是 refresh()&#125;从未被调用),或者上下文已经被关闭</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #closeBeanFactory()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回关于此上下文的信息。 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(getDisplayName());</span><br><span class="line">        sb.append(<span class="string">&quot;, started on &quot;</span>).append(<span class="keyword">new</span> Date(getStartupDate()));</span><br><span class="line">        ApplicationContext parent = getParent();</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;, parent: &quot;</span>).append(parent.getDisplayName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="getBeansWithAnnotation方法实例："><a href="#getBeansWithAnnotation方法实例：" class="headerlink" title="getBeansWithAnnotation方法实例："></a>getBeansWithAnnotation方法实例：</h2><p>XXLJOB实际使用注解使用@JobHandler标识是一个job handler,当XXLJOB在执行AOP方法时,扫描注解执行handle方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line">        MDC.put(RequestUtil.REQUEST_TRACEID, RequestUtil.getRequestId());</span><br><span class="line">        Object result= joinPoint.proceed();</span><br><span class="line">        MDC.clear();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>再执行Executor加载jobhandler时执行IJobHandler newJobHandler = XxlJobExecutor.loadJobHandler(triggerParam.getExecutorHandler());调佣start方法初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init JobHandler Repository</span></span><br><span class="line">        initJobHandlerRepository(applicationContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// refresh GlueFactory</span></span><br><span class="line">        GlueFactory.refreshInstance(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// super start</span></span><br><span class="line">        <span class="keyword">super</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initJobHandlerRepository</span><span class="params">(ApplicationContext applicationContext)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init job handler action</span></span><br><span class="line">        Map&lt;String, Object&gt; serviceBeanMap = applicationContext.getBeansWithAnnotation(JobHandler.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serviceBeanMap!=<span class="keyword">null</span> &amp;&amp; serviceBeanMap.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object serviceBean : serviceBeanMap.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (serviceBean <span class="keyword">instanceof</span> IJobHandler)&#123;</span><br><span class="line">                    String name = serviceBean.getClass().getAnnotation(JobHandler.class).value();</span><br><span class="line">                    IJobHandler handler = (IJobHandler) serviceBean;</span><br><span class="line">                    <span class="keyword">if</span> (loadJobHandler(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;xxl-job jobhandler naming conflicts.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    registJobHandler(name, handler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">初始化动作</span><br><span class="line"> <span class="comment">// init job handler action</span></span><br><span class="line">Map&lt;String, Object&gt; serviceBeanMap = applicationContext.getBeansWithAnnotation(JobHandler.class);</span><br></pre></td></tr></table></figure>

<h2 id="AnnotationConfigWebApplicationContext"><a href="#AnnotationConfigWebApplicationContext" class="headerlink" title="AnnotationConfigWebApplicationContext"></a>AnnotationConfigWebApplicationContext</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/AnnotationConfigWebApplicationContext.jpg" alt="流程"><br>AnnotationConfigWebApplicationContext–&gt;WebApplicationContext–&gt;ApplicationContext<br>核心方法：loadBeanDefinitions</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) &#123;</span><br><span class="line">    //加载Bean</span><br><span class="line">    AnnotatedBeanDefinitionReader reader = getAnnotatedBeanDefinitionReader(beanFactory);</span><br><span class="line">    //扫描注解</span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = getClassPathBeanDefinitionScanner(beanFactory);</span><br><span class="line">    //装配Bean</span><br><span class="line">    BeanNameGenerator beanNameGenerator = getBeanNameGenerator();</span><br><span class="line">    if (beanNameGenerator != null) &#123;</span><br><span class="line">        reader.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">        scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">        //注册Bean</span><br><span class="line">        beanFactory.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScopeMetadataResolver scopeMetadataResolver = getScopeMetadataResolver();</span><br><span class="line">    if (scopeMetadataResolver != null) &#123;</span><br><span class="line">        reader.setScopeMetadataResolver(scopeMetadataResolver);</span><br><span class="line">        scanner.setScopeMetadataResolver(scopeMetadataResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!this.annotatedClasses.isEmpty()) &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Registering annotated classes: [&quot; +</span><br><span class="line">                    StringUtils.collectionToCommaDelimitedString(this.annotatedClasses) + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //注册Bean</span><br><span class="line">        reader.register(ClassUtils.toClassArray(this.annotatedClasses));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!this.basePackages.isEmpty()) &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Scanning base packages: [&quot; +</span><br><span class="line">                    StringUtils.collectionToCommaDelimitedString(this.basePackages) + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //扫描指定基包</span><br><span class="line">        scanner.scan(StringUtils.toStringArray(this.basePackages));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    if (configLocations != null) &#123;</span><br><span class="line">        for (String configLocation : configLocations) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = ClassUtils.forName(configLocation, getClassLoader());</span><br><span class="line">                if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(&quot;Registering [&quot; + configLocation + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                reader.register(clazz);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (ClassNotFoundException ex) &#123;</span><br><span class="line">                if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(&quot;Could not load class for config location [&quot; + configLocation +</span><br><span class="line">                            &quot;] - trying package scan. &quot; + ex);</span><br><span class="line">                &#125;</span><br><span class="line">                int count = scanner.scan(configLocation);</span><br><span class="line">                if (count == 0 &amp;&amp; logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;No annotated classes found for specified class/package [&quot; + configLocation + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BeanPostProcessor-后置处理器"><a href="#BeanPostProcessor-后置处理器" class="headerlink" title="BeanPostProcessor(后置处理器)"></a>BeanPostProcessor(后置处理器)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的context中随处可见对BeanPostProcessor的方法调用,用于检查标记接口或用代理封装,在Bean对象在实例化和依赖注入完毕后调用,第三方扩展功能均会实现此接口,在Bean的初始化时,通过InitializingBean来调用afterPropertiesSet方法。</p>
<h2 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h2><p>在某些特殊的情况下,Bean需要实现某个功能,但该功能必须借助于Spring容器才能实现,此时就必须让该Bean先获取Spring容器,然后借助于Spring容器实现该功能。为了让Bean获取它所在的Spring容器,可以让该Bean实现ApplicationContextAware接口。ApplicationContextAware 通过它Spring容器会自动把上下文环境对象调用ApplicationContextAware接口中的setApplicationContext方法。在ApplicationContextAware的实现类中,就可以通过这个上下文环境对象得到Spring容器中的Bean。看到—Aware就知道是干什么的了,就是属性注入的,但是这个ApplicationContextAware的不同地方在于,实现了这个接口的bean,当spring容器初始化的时候,会自动的将ApplicationContext注入进来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置此对象在其中运行的ApplicationContext。通常,此调用将用于初始化对象。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//setContext</span></span><br><span class="line">        applicationContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getApplicationContext().getBean(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ResourceLoaderAware"><a href="#ResourceLoaderAware" class="headerlink" title="ResourceLoaderAware"></a>ResourceLoaderAware</h2><p>ResourceLoaderAware是特殊的标记接口，它希望拥有一个ResourceLoader 引用的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现了 ResourceLoaderAware接口的类部署到application context(比如受Spring管理的bean)中时，它会被application context识别为 ResourceLoaderAware。 接着application context会调用setResourceLoader(ResourceLoader)方法，并把自身作为参数传入该方法(记住，所有Spring里的application context都实现了ResourceLoader接口)。</p>
<p>既然 ApplicationContext 就是ResourceLoader，那么该bean就可以实现 ApplicationContextAware接口并直接使用所提供的application context来载入资源，但是通常更适合使用特定的满足所有需要的 ResourceLoader实现。 这样一来，代码只需要依赖于可以看作辅助接口的资源载入接口，而不用依赖于整个Spring ApplicationContext 接口。</p>
<p>从Spring 2.5开始, 你可以使用ResourceLoader 的自动装配来代替实现 ResourceLoaderAware 接口。“传统的” constructor及 byType的自动装配模式 (第 3.3.5 节 “自动装配（autowire）协作者”已有论述)现在可以分别为构造方法参数及setter方法参数提供 ResourceLoader 类型的依赖。请使用新式的基于注解的自动装配特性以提供更大的灵活性（包括装配属性及多个方法参数的能力）。在这种情况下，只要属性、构造方法或者方法被 @Autowired注解修饰，ResourceLoader 就会被装配到需要ResourceLoader类型的属性、构造方法参数或者方法参数中</p>
<h3 id="Servlet与HttpServlet"><a href="#Servlet与HttpServlet" class="headerlink" title="Servlet与HttpServlet"></a>Servlet与HttpServlet</h3><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/servlet%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="流程"><br>类图标明很是明显,在这个图中展示了servlet,tomcat,Springboot的关系,完美解释了那句Springboot是内嵌了tomcat的嵌入式引擎,嵌入式容器的说法~</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">而HttpServlet即是大部分请求的处理对象,嵌入式引擎----&gt;嵌入式容器----&gt;webfilter----&gt;weblistener</span><br><span class="line">javax.servlet.ServletContext#addServlet(java.lang.String, java.lang.Class&lt;? extends javax.servlet.Servlet&gt;)返回一个ServletRegistration对象,可用于进一步</span><br><span class="line">配置已注册的servlet</span><br><span class="line">javax.servlet.ServletRegistration</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletRegistration</span> <span class="keyword">extends</span> <span class="title">Registration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TODO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urlPatterns The URL patterns that this Servlet should be mapped to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TODO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if urlPattern is null or empty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if the associated ServletContext has</span></span><br><span class="line"><span class="comment">     *                                  already been initialised</span></span><br><span class="line"><span class="comment">     */</span>URL必须映射</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">addMapping</span><span class="params">(String... urlPatterns)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">getMappings</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRunAsRole</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dynamic</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ServletRegistration</span>, <span class="title">Registration</span>.<span class="title">Dynamic</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadOnStartup</span><span class="params">(<span class="keyword">int</span> loadOnStartup)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">setServletSecurity</span><span class="params">(ServletSecurityElement constraint)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMultipartConfig</span><span class="params">(MultipartConfigElement multipartConfig)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunAsRole</span><span class="params">(String roleName)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思考：为什么Applacationcontext会有那么多重载方法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> ServletRegistration.<span class="function">Dynamic <span class="title">addServlet</span><span class="params">(String servletName, String className)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> addServlet(servletName, className, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> ServletRegistration.<span class="function">Dynamic <span class="title">addServlet</span><span class="params">(String servletName, Servlet servlet)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> addServlet(servletName, <span class="keyword">null</span>, servlet, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> ServletRegistration.<span class="function">Dynamic <span class="title">addServlet</span><span class="params">(String servletName,</span></span></span><br><span class="line"><span class="params"><span class="function">           Class&lt;? extends Servlet&gt; servletClass)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> addServlet(servletName, servletClass.getName(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>–用在不同场景下解决同一类问题<br>而在HttpServlet中的关键方法service可看到平时请求接口的所有方法<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/servlet-service.png" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/service-post.png" alt="流程"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_DELETE = <span class="string">&quot;DELETE&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_HEAD = <span class="string">&quot;HEAD&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_GET = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_OPTIONS = <span class="string">&quot;OPTIONS&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_POST = <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_PUT = <span class="string">&quot;PUT&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_TRACE = <span class="string">&quot;TRACE&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String method = req.getMethod();</span><br><span class="line">        <span class="comment">//GET</span></span><br><span class="line">        <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">            <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">                <span class="comment">// to go through further expensive logic</span></span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                    <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                    maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">            <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doHead(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">            doPost(req, resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">            doPut(req, resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">            doDelete(req, resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">            doOptions(req,resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">            doTrace(req,resp);</span><br><span class="line">            <span class="comment">//There&#x27;s no need to override this method. 没有必要~</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">            <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            String errMsg = lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">            errArgs[<span class="number">0</span>] = method;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            </span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String protocol = req.getProtocol();</span><br><span class="line">    String msg = lStrings.getString(<span class="string">&quot;http.method_post_not_supported&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：在javaHttpServlet中,与Tomcat中的dopost方法如出一辙</p>
<p>真正的调用链(妥妥的责任链模式)是<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/HTTP%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.jpg" alt="流程"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tomcat与SpringMVC的结合点：</span><br><span class="line">（1）所有配置了路由信息的处理方法最终都是通过反射的方式进行调用的；</span><br><span class="line">（2）在Java8中,反射方法调用最终落脚于NativeMethodAccessorImpl类的native方法：</span><br><span class="line">private static native Object invoke0(Method var0, Object var1, Object[] var2);</span><br><span class="line">在此处与JVM底层交互,实现跨代码衔接执行；</span><br><span class="line">（3）观察到的比较重要的设计模式：职责链模式（ApplicationFilterChain）、委派模式（DelegatingFilterProxy）、</span><br><span class="line">工厂模式、策略模式、代理模式（FilterChainProxy）、外观模式、适配器模式（HandlerAdapter）；</span><br><span class="line">（4）Tomcat与SpringMVC的结合点：ApplicationFilterChain与DispatcherServlet（继承于FrameworkServlet）；</span><br><span class="line">（5）在集成了Tomcat的SpringBoot项目中,先启动的不是Tomcat,而是Spring,Spring的工厂（默认DefaultListableBeanFactory）</span><br><span class="line">读取注解完成各类Bean（WebApplicationContext、securityFilterChainRegistration、dispatcherServletRegistration、各类FilterInitializer与Filter）</span><br><span class="line">的初始化,放入IoC容器,然后做路由Mapping,创建FilterChain,开启JMX等；</span><br><span class="line">（6）Servlet、Filter是单实例多线程的,成员变量线程不安全,方法内局部变量线程安全；SingleThreadModel采用同步/实例池的方式来确保不会有两个线程同时执行servlet的service方法,但已被弃用,需自行确保成员变量线程安全；</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「wanxu12345678910」的原创文章,遵循CC 4.0 BY-SA版权协议,转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/wanxu12345678910/article/details/83352371</span><br></pre></td></tr></table></figure>

<p>ContextLoaderServlet与下文中的ContextLoaderListener功能完全相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">         &lt;servlet-name&gt;context&lt;/servlet-name&gt;</span><br><span class="line">         &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;</span></span><br><span class="line"><span class="class">           <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderServlet</span></span></span><br><span class="line"><span class="class">         &lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">         &lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;1&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt; </span></span><br></pre></td></tr></table></figure>

<h3 id="HttpServletResponse响应码"><a href="#HttpServletResponse响应码" class="headerlink" title="HttpServletResponse响应码"></a>HttpServletResponse响应码</h3><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/statusCode.png" alt="流程"></p>
<h4 id="监听器：-实现接口、标记"><a href="#监听器：-实现接口、标记" class="headerlink" title="监听器：   实现接口、标记"></a>监听器：   实现接口、标记</h4><p>比如MQ,观察者模式,所有的时间监听都会继承  extend   java.util.EventListener接口,但里面什么都没有<br>,称之为mark接口,经典实现：ContextLoaderListener、RequestContextListener(重要)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A tagging interface that all event listener interfaces must extend.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/listener.png" alt="流程"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bootstrap listener to start up and shut down Spring&#x27;s root &#123;<span class="doctag">@link</span> WebApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> * Simply delegates to &#123;<span class="doctag">@link</span> ContextLoader&#125; as well as to &#123;<span class="doctag">@link</span> ContextCleanupListener&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As of Spring 3.1, &#123;<span class="doctag">@code</span> ContextLoaderListener&#125; supports injecting the root web</span></span><br><span class="line"><span class="comment"> * application context via the &#123;<span class="doctag">@link</span> #ContextLoaderListener(WebApplicationContext)&#125;</span></span><br><span class="line"><span class="comment"> * constructor, allowing for programmatic configuration in Servlet 3.0+ environments.</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> org.springframework.web.WebApplicationInitializer&#125; for usage examples.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 17.02.2003</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setContextInitializers</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.WebApplicationInitializer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>见名知意既然包含contextLoader必然跟上线文息息相关,在初始化容器时加载配置~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent requestEvent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(requestEvent.getServletRequest() <span class="keyword">instanceof</span> HttpServletRequest)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;Request is not an HttpServletRequest: &quot;</span> + requestEvent.getServletRequest());</span><br><span class="line">        &#125;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) requestEvent.getServletRequest();</span><br><span class="line">        ServletRequestAttributes attributes = <span class="keyword">new</span> ServletRequestAttributes(request);</span><br><span class="line">        request.setAttribute(REQUEST_ATTRIBUTES_ATTRIBUTE, attributes);</span><br><span class="line">        <span class="comment">//将请求对象放入ThreadLocal中</span></span><br><span class="line">        LocaleContextHolder.setLocale(request.getLocale());</span><br><span class="line">        RequestContextHolder.setRequestAttributes(attributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color="red"> 重要：Servlet在同一个线程中,当初始化时放到对象里,当请求销毁时,自动将Threadlocal对象销毁,防止了内存泄漏的问题 </font><br>当有请求到达时,会从线程池中取出一个线程来执行任务,执行完毕后再将线程回收至线程池,这样当前请求不可能拿到上一个请求保存在ThreadLocal对象里的值<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Threadlocal.png" alt="流程"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent requestEvent)</span> </span>&#123;</span><br><span class="line">        ServletRequestAttributes attributes = <span class="keyword">null</span>;</span><br><span class="line">        Object reqAttr = requestEvent.getServletRequest().getAttribute(REQUEST_ATTRIBUTES_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (reqAttr <span class="keyword">instanceof</span> ServletRequestAttributes) &#123;</span><br><span class="line">            attributes = (ServletRequestAttributes) reqAttr;</span><br><span class="line">        &#125;</span><br><span class="line">        RequestAttributes threadAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="keyword">if</span> (threadAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We&#x27;re assumably within the original request thread...</span></span><br><span class="line">            LocaleContextHolder.resetLocaleContext();</span><br><span class="line">            RequestContextHolder.resetRequestAttributes();</span><br><span class="line">            <span class="keyword">if</span> (attributes == <span class="keyword">null</span> &amp;&amp; threadAttributes <span class="keyword">instanceof</span> ServletRequestAttributes) &#123;</span><br><span class="line">                attributes = (ServletRequestAttributes) threadAttributes;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            attributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/ThreadLocalremove.png" alt="流程"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bootstrap listener to start up and shut down Spring&#x27;s root &#123;<span class="doctag">@link</span> WebApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> * Simply delegates to &#123;<span class="doctag">@link</span> ContextLoader&#125; as well as to &#123;<span class="doctag">@link</span> ContextCleanupListener&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As of Spring 3.1, &#123;<span class="doctag">@code</span> ContextLoaderListener&#125; supports injecting the root web</span></span><br><span class="line"><span class="comment"> * application context via the &#123;<span class="doctag">@link</span> #ContextLoaderListener(WebApplicationContext)&#125;</span></span><br><span class="line"><span class="comment"> * constructor, allowing for programmatic configuration in Servlet 3.0+ environments.</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> org.springframework.web.WebApplicationInitializer&#125; for usage examples.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 17.02.2003</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setContextInitializers</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.WebApplicationInitializer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插播一句：在书写过程中发现某URL响应变慢,在分析SQL时,用到了in查询,执行分析计划用到了索引</p>
<h1 id="Servlet-on-Springboot"><a href="#Servlet-on-Springboot" class="headerlink" title="Servlet on Springboot"></a>Servlet on Springboot</h1><h3 id="组件扫描：ServletComponentScan"><a href="#组件扫描：ServletComponentScan" class="headerlink" title="组件扫描：ServletComponentScan"></a>组件扫描：ServletComponentScan</h3><p>熟悉波~ 是不是应用跟Springboot的@ComponentScan如出一辙</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(ServletComponentScanRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServletComponentScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alias for the &#123;<span class="doctag">@link</span> #basePackages()&#125; attribute. Allows for more concise annotation</span></span><br><span class="line"><span class="comment">     * declarations e.g.: &#123;<span class="doctag">@code</span> <span class="doctag">@ServletComponentScan</span>(&quot;org.my.pkg&quot;)&#125; instead of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@ServletComponentScan</span>(basePackages=&quot;org.my.pkg&quot;)&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;basePackages&quot;)</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base packages to scan for annotated servlet components. &#123;<span class="doctag">@link</span> #value()&#125; is an</span></span><br><span class="line"><span class="comment">     * alias for (and mutually exclusive with) this attribute.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Use &#123;<span class="doctag">@link</span> #basePackageClasses()&#125; for a type-safe alternative to String-based</span></span><br><span class="line"><span class="comment">     * package names.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages()&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment">     * scan for annotated servlet components. The package of each class specified will be</span></span><br><span class="line"><span class="comment">     * scanned.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> classes from the base packages to scan</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置声明：@interface  暴露SpringBean @Bean<br>事件：Event</p>
<h4 id="filter："><a href="#filter：" class="headerlink" title="filter："></a>filter：</h4><p>webFilter<br>OncePerRequestFilter：只调用一次且是线程安全的<br>而其子类得ApplicationContextHeaderFilter调用的dofilter方法就是我们上面提到的真正在请求中执行的filter</p>
<h3 id="激活Springbootweb"><a href="#激活Springbootweb" class="headerlink" title="激活Springbootweb"></a>激活Springbootweb</h3><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/oncePerRequestFilter.png" alt="流程"></p>
<p>文无第一,武无第二,没有最好的技术框架或体系,只有最适合当下业务的框架或体系<br>谈谈你对技术的理解：天上飞的理念,必定有落地的实现</p>
<h3 id="组装SpringApplicationBuilder"><a href="#组装SpringApplicationBuilder" class="headerlink" title="组装SpringApplicationBuilder"></a>组装SpringApplicationBuilder</h3><p>你看看这名字就知道他以后干啥的,并且它包含了太多太多的东西,<br>SpringApplication和ApplicationContext实例的生成器,基本包含了所有的SpringbootApplacation特性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SpringApplication application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ConfigurableApplicationContext context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SpringApplicationBuilder parent;</span><br><span class="line">AtomicBoolean是不是的看看</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean running = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Class&lt;?&gt;&gt; sources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; defaultProperties = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; additionalProfiles = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> registerShutdownHookApplied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> configuredAsChild = <span class="keyword">false</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProfiles</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(TestProfiles.class)</span><br><span class="line">                .properties(<span class="string">&quot;spring.config.location=classpath:/test-profiles.yml&quot;</span>)</span><br><span class="line">                .properties(<span class="string">&quot;spring.profiles.active=oracle&quot;</span>)</span><br><span class="line">                .run(args);</span><br><span class="line">        <span class="comment">// 输出变量</span></span><br><span class="line">        System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;jdbc.driver&quot;</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 启动第二个Spring容器,指定端口为8848</span></span><br><span class="line">        ConfigurableApplicationContext context2 = <span class="keyword">new</span> SpringApplicationBuilder(TestProfiles.class)</span><br><span class="line">                .properties(<span class="string">&quot;spring.config.location=classpath:/test-profiles.yml&quot;</span>)</span><br><span class="line">                .properties(<span class="string">&quot;spring.profiles.active=mysql&quot;</span>)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=8848&quot;</span>)</span><br><span class="line">                .run(args);</span><br><span class="line">        <span class="comment">// 输出变量</span></span><br><span class="line">        System.out.println(context2.getEnvironment().getProperty(<span class="string">&quot;jdbc.driver&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Springboot自动装配<br>/META-INF/spring.factories<br>XXXAotuConfigration<br>NIO不是异步IO而是非阻塞IO<br>java9推崇模块化</p>
<p>ClassLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(contextClassLoader.getClass().getName());</span><br><span class="line">        ClassLoader parent = contextClassLoader.getParent();</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader.getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>update_time =2022年2月14日13:48:19</p>
<h2 id="传统的Servlet容器-Apache-Tomcat"><a href="#传统的Servlet容器-Apache-Tomcat" class="headerlink" title="传统的Servlet容器 Apache Tomcat"></a>传统的Servlet容器 Apache Tomcat</h2><p>这里只记录了部分重要场景<br>包含核心组件<br>静态资源处理<br>类加载<br>连接器<br>JDBC数据源</p>
<h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><p>javax.servlet.http.HttpServletResponse</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(contextClassLoader.getClass().getName());</span><br><span class="line">        ClassLoader parent = contextClassLoader.getParent();</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了其中的状态码之外,结合最近的测试其中的实现可具体参考<br>addHeader方法,getHeader方法等等<br>BootStrap–system—common—webapp</p>
<h2 id="静态资源处理类org-apache-catalina-servlets-DefaultServlet"><a href="#静态资源处理类org-apache-catalina-servlets-DefaultServlet" class="headerlink" title="静态资源处理类org.apache.catalina.servlets.DefaultServlet"></a>静态资源处理类org.apache.catalina.servlets.DefaultServlet</h2><p>注意下包名</p>
<p>大多数情况下我们关注的更多是server.xml中Tomcat的配置,而在web.xml中除了路径映射等配置外</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- The mapping <span class="keyword">for</span> the <span class="keyword">default</span> servlet --&gt;</span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">       &lt;servlet-name&gt;<span class="keyword">default</span>&lt;/servlet-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- The mappings <span class="keyword">for</span> the JSP servlet --&gt;</span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">       &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</span><br><span class="line">       &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>关于是否是开发模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--   development         Is Jasper used in development mode? If <span class="keyword">true</span>,   --&gt;</span><br><span class="line"> &lt;!--                       the frequency at which JSPs are checked <span class="keyword">for</span>    --&gt;</span><br><span class="line"> &lt;!--                       modification may be specified via the          --&gt;</span><br><span class="line"> &lt;!--                       modificationTestInterval parameter. [<span class="keyword">true</span>]     --&gt;</span><br></pre></td></tr></table></figure>
<p>由于DefaultServlet是HttpServlet的子类,所以在此不展开讨论<br>而在server.xml中标签与后台接口是一一绑定的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">&quot;8080&quot;</span> protocol=<span class="string">&quot;HTTP/1.1&quot;</span> connectionTimeout=<span class="string">&quot;20000&quot;</span> redirectPort=<span class="string">&quot;8443&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>而在JDBC中的大多数类中也遵循此规则,那么就上面这段分析标签Connector则对应<br>org.apache.catalina.connector.Connector,验证一下标签中对应protocol,connectionTimeout,redirectPort<br>其中标签对应部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Defaults to using HTTP/1.1 NIO implementation.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>而在tomcat8.0+中getProtocol对应protocol<br>redirectPort对应属性默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The redirect port for non-SSL to SSL redirects.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> redirectPort = <span class="number">443</span>;</span><br></pre></td></tr></table></figure>
<p>关于标签中connector中这个Http11NioProtocol则在tomcat官方文档中可见其中一句话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">When using HTTP connectors (based on APR or NIO/NIO2), Tomcat supports using sendfile to send large static files. These writes, as soon as the system load increases, will be performed asynchronously in the most efficient way. Instead of sending a large response using blocking writes, it is possible to write content to a static file, and write it using a sendfile code. A caching valve could take advantage of this to cache the response data in a file rather than store it in memory. Sendfile support is available if the request attribute org.apache.tomcat.sendfile.support is set to Boolean.TRUE</span><br></pre></td></tr></table></figure>
<p>也可在server.xml中搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;Connector protocol=&quot;AJP/1.3&quot;</span><br><span class="line">               address=&quot;::1&quot;</span><br><span class="line">               port=&quot;8009&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; /&gt;</span><br><span class="line">    --&gt;</span><br></pre></td></tr></table></figure>
<p>server.port在文件中的位置</p>
<!-- {
      "name": "server.port",
      "type": "java.lang.Integer",
      "description": "Server HTTP port.",
      "sourceType": "org.springframework.boot.autoconfigure.web.ServerProperties",
      "defaultValue": 8080
    }, -->
<h2 id="重点来了-ServerProperties包含了tomcat-Jetty-Undertow-而在Springboot2-2-6中则存在Netty"><a href="#重点来了-ServerProperties包含了tomcat-Jetty-Undertow-而在Springboot2-2-6中则存在Netty" class="headerlink" title="重点来了 ServerProperties包含了tomcat,Jetty,Undertow,而在Springboot2.2.6中则存在Netty"></a>重点来了 ServerProperties包含了tomcat,Jetty,Undertow,而在Springboot2.2.6中则存在Netty</h2><p>那么理所当然,在tomcat中的一些配置也存在于此</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maximum amount of worker threads.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxThreads = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Minimum amount of worker threads.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minSpareThreads = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h2 id="那么为什么Tomcat被称之为嵌入式容器呢？"><a href="#那么为什么Tomcat被称之为嵌入式容器呢？" class="headerlink" title="那么为什么Tomcat被称之为嵌入式容器呢？"></a>那么为什么Tomcat被称之为嵌入式容器呢？</h2><p>在启动时无需自启动容器,在Bootstrap中调用tomcat,另外tomcat中TomcatEmbeddedContext,Embedded即直译为嵌入式<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/embedded.png" alt="流程"><br>这里记忆有些混乱了,有点找不过来哪里是入口了,但先从TomcatServletWebServerFactoryCustomizer的customize()方法调用找,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Stream&lt;Wrapper&gt; <span class="title">getLoadOnStartupWrappers</span><span class="params">(Container[] children)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Wrapper&gt;&gt; grouped = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Container child : children) &#123;</span><br><span class="line">            Wrapper wrapper = (Wrapper) child;</span><br><span class="line">            <span class="keyword">int</span> order = wrapper.getLoadOnStartup();</span><br><span class="line">            <span class="keyword">if</span> (order &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                grouped.computeIfAbsent(order, ArrayList::<span class="keyword">new</span>);</span><br><span class="line">                grouped.get(order).add(wrapper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grouped.values().stream().flatMap(List::stream);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因为要看下Netty,所以还是重新看下server.properties<br>我将Spring Boot AutoConfigure升级到了2.6.2,内置的Tomcat就升级到9.0了<br>为了方便查看才升级的,之前的2.1.x就不截图了<br>server.properties的位置在configuration的下面的json文件<br>spring-configuration-metadata.json</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &quot;name&quot;: &quot;server&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties&quot;,</span><br><span class="line">      &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那既然为了看Netty在这个json文件中同样存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &quot;name&quot;: &quot;server.netty&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties$Netty&quot;,</span><br><span class="line">      &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties&quot;,</span><br><span class="line">      &quot;sourceMethod&quot;: &quot;getNetty()&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然在json中存在getNetty等方法,猜测那么对应的ServerProperties也存在对应的方法,<br>因为存在实例么,tomcat搭配server.xml和web.xml简单看了一下,当然Tomcat还是主要和Servlet的关联关系更为重要,<br>本身tomcat知识点也最够庞大的,包含类加载器,双拼委派,打破双亲委派、jvm调优等等,可以顺带看下这里的专题</p>
<h2 id="当一次请求发起都发生了什么？"><a href="#当一次请求发起都发生了什么？" class="headerlink" title="当一次请求发起都发生了什么？"></a>当一次请求发起都发生了什么？</h2><p>用户通过浏览器进行了一个操作,这个操作可以是输入url地址并回车,或者是点击超链接,或者是在搜索框中输入关键字进行搜索,接着浏览器就捕获到了这个事件<br>由于 HTTP 协议底层具体的数据传输使用的是 TCP/IP 协议,因此浏览器需要向服务端发出 TCP 连接请求<br>服务器接受浏览器的连接请求,并经过 TCP 三次握手建立连接<br>浏览器将请求数据打包成一个 HTTP 协议格式的数据包<br>浏览器将打包好的数据包推入网络,经过网络传输最终到达服务器指定程序<br>服务端程序拿到数据包后,根据 HTTP 协议格式进行解包,获取到客户端的意图<br>得知客户端意图后进行处理,比如提供静态文件或者调用服务端程序获得动态结果<br>服务器将响应结果按照 HTTP 协议格式打包<br>服务器将响应数据包推入网络,数据包经过网络传输最终达到到浏览器<br>浏览器拿到数据包后,按照 HTTP 协议的格式解包,然后对数据进行解析<br>浏览器将解析后的静态数据（如html、图片）展示给用户</p>
<p>Tomcat 作为一个 HTTP 服务器,主要需要完成的功能是接受连接、解析请求数据、处理请求和发送响应这几个步骤。<br>作者：若兮缘<br>链接：<a href="https://www.jianshu.com/p/7c9401b85704">https://www.jianshu.com/p/7c9401b85704</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权,非商业转载请注明出处。<br>关于tomcat的架构就取自这篇文章,图文都很喜欢~</p>
<p>导入过程Running With JRE 7 Or Later</p>
<p>启动tomcat所需环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">   eval $_NOHUP <span class="string">&quot;\&quot;$_RUNJAVA\&quot;&quot;</span> <span class="string">&quot;\&quot;$CATALINA_LOGGING_CONFIG\&quot;&quot;</span> $LOGGING_MANAGER <span class="string">&quot;$JAVA_OPTS&quot;</span> <span class="string">&quot;$CATALINA_OPTS&quot;</span> \</span><br><span class="line">     -D$ENDORSED_PROP=<span class="string">&quot;\&quot;$JAVA_ENDORSED_DIRS\&quot;&quot;</span> \</span><br><span class="line">     -classpath <span class="string">&quot;\&quot;$CLASSPATH\&quot;&quot;</span> \</span><br><span class="line">     -Dcatalina.base=<span class="string">&quot;\&quot;$CATALINA_BASE\&quot;&quot;</span> \</span><br><span class="line">     -Dcatalina.home=<span class="string">&quot;\&quot;$CATALINA_HOME\&quot;&quot;</span> \</span><br><span class="line">     -Djava.io.tmpdir=<span class="string">&quot;\&quot;$CATALINA_TMPDIR\&quot;&quot;</span> \</span><br><span class="line">     org.apache.catalina.startup.Bootstrap <span class="string">&quot;$@&quot;</span> start \</span><br></pre></td></tr></table></figure>
<p>后续不在赘述。重点在Server.properties中版本区别是否包含Netty的这个类,<br>本来我是想跟着dei一下bug的,实际是我没起来,版本又不兼容,中间穿插了需求,就不dei了skr~</p>
<h2 id="一方库、二方库、三方库说明"><a href="#一方库、二方库、三方库说明" class="headerlink" title="一方库、二方库、三方库说明"></a>一方库、二方库、三方库说明</h2><p>有些二方库为apache所需类库,当然定义也尽相同,以统一标准为准吧~就像嵌入式这个单词,<br>如果学习的时候根据服务的命名,猜测其作用,然后再去证实的话,可能我早就认识这个单词了</p>
<blockquote>
<p>一方库：本工程中的各模块的相互依赖<br>二方库：公司内部的依赖库,一般指公司内部的其他项目发布的jar包<br>三方库：公司之外的开源库, 比如apache、ibm、google等发布的依赖<br>为什么写这句话就是因为javax是指扩展我的java,因为原生的二方库是不允许被覆盖的。提到的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stream&lt;Wrapper&gt; <span class="title">getLoadOnStartupWrappers</span><span class="params">(Container[] children)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Wrapper&gt;&gt; grouped = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Container child : children) &#123;</span><br><span class="line">            Wrapper wrapper = (Wrapper) child;</span><br><span class="line">            <span class="keyword">int</span> order = wrapper.getLoadOnStartup();</span><br><span class="line">            <span class="keyword">if</span> (order &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                grouped.computeIfAbsent(order, ArrayList::<span class="keyword">new</span>);</span><br><span class="line">                grouped.get(order).add(wrapper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grouped.values().stream().flatMap(List::stream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再比如这里面的grouped.computeIfAbsent(order, ArrayList::new);其中Absent译为缺席,入参是key=order,以及函数方法,在key!=null的情况下赋值为newAraayList并返回去。<br>and this flatMap VS map,其他人举的例子很明朗,我就不摘抄了,<a href="https://www.cnblogs.com/yucy/p/10260014.html">https://www.cnblogs.com/yucy/p/10260014.html</a></p>
<h2 id="JDBC中的servlet"><a href="#JDBC中的servlet" class="headerlink" title="JDBC中的servlet"></a>JDBC中的servlet</h2><blockquote>
<p>数据库三大范式：<br>1．第一范式(确保每列保持原子性)<br>2．第二范式(确保表中的每列都和主键相关)<br>3．第三范式(确保每列都和主键列直接相关,而不是间接相关)<br>1、DML:Data Manipulation Language  操作语句<br>2、DDL：data define Language、<br>3、存储过程执行后<br>4、查询中也是有事务的：select查询后结果集关闭后<br>事务并发可能的影响：<br>1、脏读（读取未提交数据）<br>A事务读取B事务尚未提交的数据,此时如果B事务发生错误并执行回滚操作,那么A事务读取到的数据就是脏数据。<br>就好像原本的数据比较干净、纯粹,此时由于B事务更改了它,这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据,<br>但事务B良心发现,又用回滚把数据恢复成原来干净、纯粹的样子,而事务A却什么都不知道,最终结果就是事务A读取了此次的脏数据,称为脏读。<br>2、不可重复读（前后多次读取,数据内容不一致）<br>事务A在执行读取操作,由整个事务A比较大,前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据,<br>比如此时读取了小明的年龄为20岁,事务B执行更改操作,将小明的年龄更改为30岁,此时事务A第二次读取到小明的年龄时,<br>发现其年龄是30岁,和之前的数据不一样了,也就是数据不重复了,系统不可以读取到重复的数据,成为不可重复读<br>3、幻读（前后多次读取,数据总量不一致）<br>事务A在执行读取操作,需要两次统计数据的总量,前一次查询数据总量后,此时事务B执行了新增数据的操作并提交后,<br>这个时候事务A读取的数据总量和之前统计的不一样,就像产生了幻觉一样,平白无故的多了几条数据,成为幻读<br>幻读产生的根本原因是采用的行级锁,所以只针对脏读和重复读有用<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/drivermanager.png" alt="流程"><br>Drivermanager–&gt;getconnection—&gt;connection–&gt;createStatement–&gt;ResultSet executeQuery(String sql) throws SQLException;<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/connection.png" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/drivermanager.png" alt="流程"><br>重载connection方法可实现在各个数据库中切换,基本不需要太多的代码,JDBC中用到的设计模式？—-桥接模式<br>不知道为啥都在强调jdbc的设计模式,所以引用下《重学设计模式–小博哥》中的案例分析<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E6%A1%88%E4%BE%8B%E5%9C%BA%E6%99%AF.png" alt="场景"><br>代码实现登陆：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(PayController.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doPay</span><span class="params">(String uId, String tradeId, BigDecimal amount,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">int</span> channelType, <span class="keyword">int</span> modeType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 微信⽀付</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == channelType) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;模拟微信渠道⽀付划账开始。uId：&#123;&#125; tradeId：&#123;&#125; amount：</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            &quot;</span>, uId, tradeId, amount);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == modeType) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;密码⽀付,⻛控校验环境安全&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> == modeType) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;⼈脸⽀付,⻛控校验脸部识别&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">3</span> == modeType) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;指纹⽀付,⻛控校验指纹信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">                上⾯的类提供了⼀个⽀付服务功能,通过提供的必要字段； ⽤户ID 、交易ID 、 ⾦额 、渠道 、模 式 ,来控制⽀付⽅式。</span><br><span class="line">                以上的 ifelse 应该是最差的⼀种写法,即使写 ifelse 也是可以优化的⽅式去写的。</span><br><span class="line">                <span class="number">3.</span> 测试验证</span><br><span class="line">                <span class="number">3.1</span> 编写测试类</span><br><span class="line">                以上分别测试了两种不同的⽀付类型和⽀付模式；微信⼈脸⽀付、⽀付宝指纹⽀付</span><br><span class="line">                <span class="number">3.2</span> 测试结果</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ⽀付宝⽀付</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> == channelType) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;模拟⽀付宝渠道⽀付划账开始。uId：&#123;&#125; tradeId：&#123;&#125;</span></span><br><span class="line"><span class="string">                    amount： &#123;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            &quot;</span>, uId, tradeId, amount);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == modeType) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;密码⽀付,⻛控校验环境安全&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> == modeType) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;⼈脸⽀付,⻛控校验脸部识别&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">3</span> == modeType) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;指纹⽀付,⻛控校验指纹信息&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实面对这种情况一般我是看到大多数是应用策略+模板的,桥接真的很少听</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pay</span> </span>&#123;</span><br><span class="line"> <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(Pay.class);</span><br><span class="line"> <span class="keyword">protected</span> IPayMode payMode;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Pay</span><span class="params">(IPayMode payMode)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.payMode = payMode;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">transfer</span><span class="params">(String uId, String tradeId, BigDecimal</span></span></span><br><span class="line"><span class="params"><span class="function">amount)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个类中定义了⽀付⽅式的需要实现的划账接⼝： transfer ,以及桥接接⼝； IPayMode ,并<br>在构造函数中⽤户⽅⾃⾏选择⽀付⽅式。<br>如果没有接触过此类实现,可以᯿点关注 IPayMode payMode ,这部分是桥接的核⼼</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WxPay</span> <span class="keyword">extends</span> <span class="title">Pay</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">WxPay</span><span class="params">(IPayMode payMode)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">super</span>(payMode);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">transfer</span><span class="params">(String uId, String tradeId, BigDecimal amount)</span> </span>&#123;</span><br><span class="line"> logger.info(<span class="string">&quot;模拟微信渠道⽀付划账开始。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>,</span><br><span class="line">uId, tradeId, amount);</span><br><span class="line"> <span class="keyword">boolean</span> security = payMode.security(uId);</span><br><span class="line"> logger.info(<span class="string">&quot;模拟微信渠道⽀付⻛控校验。uId：&#123;&#125; tradeId：&#123;&#125; security：</span></span><br><span class="line"><span class="string">&#123;&#125;&quot;</span>, uId, tradeId, security);</span><br><span class="line"> <span class="keyword">if</span> (!security) &#123;</span><br><span class="line"> logger.info(<span class="string">&quot;模拟微信渠道⽀付划账拦截。uId：&#123;&#125; tradeId：&#123;&#125; amount：</span></span><br><span class="line"><span class="string">&#123;&#125;&quot;</span>, uId, tradeId, amount);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;0001&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> logger.info(<span class="string">&quot;模拟微信渠道⽀付划账成功。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>,</span><br><span class="line">uId, tradeId, amount);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;0000&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>支付宝支付</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">public class ZfbPay extends Pay &#123;</span><br><span class="line"> public ZfbPay(IPayMode payMode) &#123;</span><br><span class="line"> super(payMode);</span><br><span class="line"> &#125;</span><br><span class="line"> public String transfer(String uId, String tradeId, BigDecimal amount) &#123;</span><br><span class="line"> logger.info(<span class="string">&quot;模拟⽀付宝渠道⽀付划账开始。uId：&#123;&#125; tradeId：&#123;&#125; amount：</span></span><br><span class="line"><span class="string">&#123;&#125;&quot;</span>, uId, tradeId, amount);</span><br><span class="line"> boolean security = payMode.security(uId);</span><br><span class="line"> logger.info(<span class="string">&quot;模拟⽀付宝渠道⽀付⻛控校验。uId：&#123;&#125; tradeId：&#123;&#125; security：</span></span><br><span class="line"><span class="string">&#123;&#125;&quot;</span>, uId, tradeId, security);</span><br><span class="line"> <span class="keyword">if</span> (!security) &#123;</span><br><span class="line"> logger.info(<span class="string">&quot;模拟⽀付宝渠道⽀付划账拦截。uId：&#123;&#125; tradeId：&#123;&#125;</span></span><br><span class="line"><span class="string">amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;0001&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> logger.info(<span class="string">&quot;模拟⽀付宝渠道⽀付划账成功。uId：&#123;&#125; tradeId：&#123;&#125; amount：</span></span><br><span class="line"><span class="string">&#123;&#125;&quot;</span>, uId, tradeId, amount);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;0000&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%9E%8B.png" alt="流程"><br>桥接模式接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="keyword">interface</span> IPayMode &#123;</span><br><span class="line"> boolean security(String uId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷脸</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayFaceMode</span> <span class="keyword">implements</span> <span class="title">IPayMode</span></span>&#123;</span><br><span class="line"> <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(PayCypher.class);</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">security</span><span class="params">(String uId)</span> </span>&#123;</span><br><span class="line"> logger.info(<span class="string">&quot;⼈脸⽀付,⻛控校验脸部识别&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">其他同上</span><br></pre></td></tr></table></figure>
<p>测试类编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;\r\n模拟测试场景；微信⽀付、⼈脸⽅式。&quot;</span>);</span><br><span class="line"> Pay wxPay = <span class="keyword">new</span> WxPay(<span class="keyword">new</span> PayFaceMode());</span><br><span class="line"> wxPay.transfer(<span class="string">&quot;weixin_1092033111&quot;</span>, <span class="string">&quot;100000109893&quot;</span>, <span class="keyword">new</span></span><br><span class="line">BigDecimal(<span class="number">100</span>));</span><br><span class="line"> System.out.println(<span class="string">&quot;\r\n模拟测试场景；⽀付宝⽀付、指纹⽅式。&quot;</span>);</span><br><span class="line"> Pay zfbPay = <span class="keyword">new</span> ZfbPay(<span class="keyword">new</span> PayFingerprintMode());</span><br><span class="line"> zfbPay.transfer(<span class="string">&quot;jlu19dlxo111&quot;</span>,<span class="string">&quot;100000109894&quot;</span>,<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="ResultSet-executeQuery-String-sql-throws-SQLException"><a href="#ResultSet-executeQuery-String-sql-throws-SQLException" class="headerlink" title="ResultSet executeQuery(String sql) throws SQLException;"></a>ResultSet executeQuery(String sql) throws SQLException;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">org.springframework.transaction.interceptor.TransactionInterceptor</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>;</span><br><span class="line">    Method var10001 = invocation.getMethod();</span><br><span class="line">    invocation.getClass();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.invokeWithinTransaction(var10001, targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.transaction.TransactionDefinition</span><br></pre></td></tr></table></figure>
<p>其实这里看不出来跟servlet的关联性有多么高,如果实在要说其中的关联性,<br>还不如将jdbc的整合过程与Mybatis进行比较,或者分析jdbc代码分析封装硬编码的过程,<br>就连其包下的大部分类名都不与之相关,当然你要说再Servlet与jdbc集成开发的时代,他也是有一定时代和代表性的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="params"><span class="function">    java.util.Properties info)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CallerSensitive是什么鬼？"><a href="#CallerSensitive是什么鬼？" class="headerlink" title="CallerSensitive是什么鬼？"></a>CallerSensitive是什么鬼？</h3><p>CallerSensitive老规矩,猜测下Caller=调用,Sensitive=敏感的,那么标识在方法上则是当调用方法时的一些控制。<br>其中特指Reflection.getCallerClass()能够追踪到调用者的第一人。项目中用是用不到。</p>
<h3 id="学习方法就是学习大佬的学习方法"><a href="#学习方法就是学习大佬的学习方法" class="headerlink" title="学习方法就是学习大佬的学习方法"></a>学习方法就是学习大佬的学习方法</h3><p>这里JDBC就先到此为止,我先不得不先记录下我在javacache中遇到的小问题思考。</p>
<h2 id="为什么有ConcurrentHashMap还要加入synchronized"><a href="#为什么有ConcurrentHashMap还要加入synchronized" class="headerlink" title="为什么有ConcurrentHashMap还要加入synchronized"></a>为什么有ConcurrentHashMap还要加入synchronized</h2><p>在org.springframework.cache.support.AbstractCacheManager中有一段关于初始化缓存静态配置的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize the static configuration of caches.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Triggered on startup through &#123;<span class="doctag">@link</span> #afterPropertiesSet()&#125;;</span></span><br><span class="line"><span class="comment">     * can also be called to re-initialize at runtime.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.2.2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #loadCaches()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;? extends Cache&gt; caches = loadCaches();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.cacheMap) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cacheNames = Collections.emptySet();</span><br><span class="line">            <span class="keyword">this</span>.cacheMap.clear();</span><br><span class="line">            Set&lt;String&gt; cacheNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(caches.size());</span><br><span class="line">            <span class="keyword">for</span> (Cache cache : caches) &#123;</span><br><span class="line">                String name = cache.getName();</span><br><span class="line">                <span class="keyword">this</span>.cacheMap.put(name, decorateCache(cache));</span><br><span class="line">                cacheNames.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.cacheNames = Collections.unmodifiableSet(cacheNames);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><font color="red"> Triggered：触发 </font><br>原因：本身put和add的线程安全是由ConcurrentHashMap保证的,但是此时获取的值ConcurrentHashMap并不能保证其他线程对共享变量的值操作时还是原来的值。<br>怎么说呢,这么看来可能失去了map的本来特性,但其实还是不理解,是不理解这个原因准不准确。</p>
<p>谁提出谁解决:concurrentHashMap只能保证一次操作的原子性,一系列操作的时候就需要加锁了,不能保证第N+1个线程进来的时候获取到的状态是未clear的</p>
<p>Collections.emptySet()：如果你想 new 一个空的 List ,而这个 List 以后也不会再添加元素,那么就用 Collections.emptyList() 好了。<br>new ArrayList() 或者 new LinkedList() 在创建的时候有会有初始大小,多少会占用一内存。<br>每次使用都new 一个空的list集合,浪费就积少成多,浪费就严重啦,就不好啦。</p>
<p>还有一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cache <span class="title">getCache</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Cache cache = <span class="keyword">this</span>.cacheMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Fully synchronize now for missing cache creation...</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.cacheMap) &#123;</span><br><span class="line">                cache = <span class="keyword">this</span>.cacheMap.get(name);</span><br><span class="line">                <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cache = getMissingCache(name);</span><br><span class="line">                    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        cache = decorateCache(cache);</span><br><span class="line">                        <span class="keyword">this</span>.cacheMap.put(name, cache);</span><br><span class="line">                        updateCacheNames(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> cache;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">其中的getMissingCache方法</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Cache <span class="title">getMissingCache</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">无论如何都要返回<span class="keyword">null</span>,那么他还要进行判空意义又何在？</span><br><span class="line"></span><br><span class="line">源码注释是这样写的</span><br><span class="line">Return a missing cache with the specified name, or <span class="keyword">null</span> <span class="keyword">if</span> such a cache does not exist or could not be created on demand.</span><br><span class="line">Caches may be lazily created at runtime <span class="keyword">if</span> the <span class="keyword">native</span> provider supports it. If a lookup by name does not yield any result, an AbstractCacheManager subclass gets a chance to register such a cache at runtime. The returned cache will be automatically added to <span class="keyword">this</span> cache manager.</span><br><span class="line">返回指定名称的缺失缓存,如果此类缓存不存在或无法按需创建,则返回<span class="keyword">null</span>。</span><br><span class="line">如果本机提供程序支持,可以在运行时延迟创建缓存,就是其扩展实际是在子类中来复写的,</span><br><span class="line">注意：在spring-data-redis的<span class="number">1.7</span><span class="number">.2</span>中是没有复写此方法的</span><br><span class="line">在官网中查询https:<span class="comment">//spring.io/projects/spring-data-redis#support</span></span><br><span class="line">接入了</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">2.1</span><span class="number">.9</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">低版本可是没有的呢,具体变化是在<span class="number">2.</span>X前后的区别</span><br><span class="line"><span class="function"><span class="keyword">protected</span> RedisCache <span class="title">getMissingCache</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> allowInFlightCacheCreation ? createRedisCache(name, defaultCacheConfig) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="第二次见到identityHashMap"><a href="#第二次见到identityHashMap" class="headerlink" title="第二次见到identityHashMap"></a>第二次见到identityHashMap</h2><p>实际应用<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247484317&amp;idx=1&amp;sn=1a5d78d0e5d5e09b1d2ca969a5ae7d23&amp;chksm=ceb09ce0f9c715f6688bf4b38a933730f61df7b432b3ac452924b502fba735e048289c3e0d91&amp;token=950928768&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247484317&amp;idx=1&amp;sn=1a5d78d0e5d5e09b1d2ca969a5ae7d23&amp;chksm=ceb09ce0f9c715f6688bf4b38a933730f61df7b432b3ac452924b502fba735e048289c3e0d91&amp;token=950928768&amp;lang=zh_CN#rd</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    var var1 = new Integer(1);</span><br><span class="line">    var var2 = new Integer(1);</span><br><span class="line">    System.out.println(var1.equals(var2));</span><br><span class="line"></span><br><span class="line">    System.out.println(var1.hashCode());</span><br><span class="line">    System.out.println(var2.hashCode());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(System.identityHashCode(var1));</span><br><span class="line">    System.out.println(System.identityHashCode(var2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">控制台输出</span><br><span class="line">true</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1524960486</span><br><span class="line">117009527</span><br></pre></td></tr></table></figure>
<p>org.springframework.cache.Cache对于缓存是应用接口,<br>Hashmap是否是在并发写的情况下,如果是则不是线程安全的<br>Consistency(一致性)<br>getinclude<br>想要看到源文档时,搜索：JSR107规范即可<br>推荐文章：<a href="https://www.jianshu.com/p/f6a1eae">https://www.jianshu.com/p/f6a1eae</a></p>
<h3 id="接着来看缓存类CacheManager"><a href="#接着来看缓存类CacheManager" class="headerlink" title="接着来看缓存类CacheManager"></a>接着来看缓存类CacheManager</h3><p>从名字就能看出是管理缓存的类,CacheManager有两种,一种是Spring的,一种是javax的,就是上面所说的扩展类,但实现确实大体一致,<br>就接口实现入手,先从最简单的看起,从名字看就是SimpleCacheManager,提供最基本的set方法,load方法。<br>SimpleCacheManager在spring-context包下,5.1.4版本,rediscachemanager在spring-data-redis包下<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/fg15k701aa.png" alt="流程"></p>
<blockquote>
<p>CachingProvider：创建、配置、获取、管理和控制多个CacheManager<br>CacheManager：创建、配置、获取、管理和控制多个唯一命名的Cache。（一个CacheManager仅被一个CachingProvider所拥有）<br>Cache：一个类似Map的数据结构。（一个Cache仅被一个CacheManager所拥有）<br>Entry：一个存储在Cache中的key-value对<br>Expiry：每一个存储在Cache中的条目有一个定义的有效期,过期后不可访问、更新、删除。缓存有效期可以通过ExpiryPolicy设置<br><a href="https://cloud.tencent.com/developer/article/1497762">https://cloud.tencent.com/developer/article/1497762</a><br>缓存么,除了快之外,还要满足有过期时间,但是除了在redis中并没有提供响应的方法,为什么呢？我觉得既然你启动或者加载就将bean放入cache管理了<br>就不可能伴随过期,应该会有响应的destroy方法在实例结束运行时清理,要不不可能实例还没运行完就进行清理吧。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;RedisCache&gt; <span class="title">loadCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;RedisCache&gt; caches = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, RedisCacheConfiguration&gt; entry : initialCacheConfiguration.entrySet()) &#123;</span><br><span class="line">            caches.add(createRedisCache(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> caches;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>读取缓存的配置时间,一级缓存60s,二级缓存30s<br>在spring-autoconfigure-metadata.properties中的org.springframework.data.redis.cache.RedisCacheConfiguration配置此参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration.AutoConfigureAfter=</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>启动时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">c.y.c.b.redis.config.RedisConfiguration  : [BSF][Redis]已启动,addressList:</span><br><span class="line"><span class="number">2022</span>-<span class="number">02</span>-<span class="number">18</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">45.674</span>  INFO <span class="number">2604</span> --- [           main] c.y.c.b.e.c.EurekaClientConfiguration    : [BSF][Eureka-Client]已启动!!! eureka.client.serviceUrl.defaultZone=http:<span class="comment">//10.:8080/eureka/</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">02</span>-<span class="number">18</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">47.846</span>  WARN <span class="number">2604</span> --- [           main] c.n.c.sources.URLConfigurationSource     : No URLs will be polled as dynamic configuration sources.</span><br><span class="line"><span class="number">2022</span>-<span class="number">02</span>-<span class="number">18</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">47.847</span>  INFO <span class="number">2604</span> --- [           main] c.n.c.sources.URLConfigurationSource     : To enable URLs as dynamic configuration sources, define System property archaius.configurationSource.additionalUrls or make config.properties available on classpath.</span><br><span class="line"><span class="number">2022</span>-<span class="number">02</span>-<span class="number">18</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">47.943</span>  INFO <span class="number">2604</span> --- [           main] c.netflix.config.DynamicPropertyFactory  : DynamicPropertyFactory is initialized with configuration sources: com.netflix.config.ConcurrentCompositeConfiguration@4bf9f44b</span><br><span class="line"><span class="number">2022</span>-<span class="number">02</span>-<span class="number">18</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">54.662</span>  INFO <span class="number">2604</span> --- [           main] c.y.c.b.s.ShardingJdbcConfiguration      : [BSF][Sharding-jdbc]已启动!!!</span><br><span class="line"><span class="number">2022</span>-<span class="number">02</span>-<span class="number">18</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">57.232</span>  INFO <span class="number">2604</span> --- [           main] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-<span class="number">1</span>&#125; inited</span><br><span class="line"><span class="number">2022</span>-<span class="number">02</span>-<span class="number">18</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">58.661</span>  INFO <span class="number">2604</span> --- [           main] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-<span class="number">2</span>&#125; inited</span><br><span class="line"><span class="number">2022</span>-<span class="number">02</span>-<span class="number">18</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">02.531</span> ERROR <span class="number">2604</span> --- [           main] c.b.mybatisplus.MybatisConfiguration </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者在redisconfig中配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">simpleKeyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (o, method, objects) -&gt; &#123;</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            stringBuilder.append(o.getClass().getSimpleName());</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            stringBuilder.append(method.getName());</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Object obj : objects) &#123;</span><br><span class="line">                stringBuilder.append(obj.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisCacheManager(</span><br><span class="line">            RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory),</span><br><span class="line">            <span class="keyword">this</span>.getRedisCacheConfigurationWithTtl(<span class="number">600</span>), <span class="comment">// 默认策略,未配置的 key 会使用这个</span></span><br><span class="line">            <span class="keyword">this</span>.getRedisCacheConfigurationMap() <span class="comment">// 指定 key 策略</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, RedisCacheConfiguration&gt; <span class="title">getRedisCacheConfigurationMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, RedisCacheConfiguration&gt; redisCacheConfigurationMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        redisCacheConfigurationMap.put(<span class="string">&quot;UserInfoList&quot;</span>, <span class="keyword">this</span>.getRedisCacheConfigurationWithTtl(<span class="number">3000</span>));</span><br><span class="line">        redisCacheConfigurationMap.put(<span class="string">&quot;UserInfoListAnother&quot;</span>, <span class="keyword">this</span>.getRedisCacheConfigurationWithTtl(<span class="number">18000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisCacheConfigurationMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisCacheConfiguration <span class="title">getRedisCacheConfigurationWithTtl</span><span class="params">(Integer seconds)</span> </span>&#123;</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        redisCacheConfiguration = redisCacheConfiguration.serializeValuesWith(</span><br><span class="line">            RedisSerializationContext</span><br><span class="line">                .SerializationPair</span><br><span class="line">                .fromSerializer(jackson2JsonRedisSerializer)</span><br><span class="line">        ).entryTtl(Duration.ofSeconds(seconds));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisCacheConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">过期时间</span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;UserInfoList&quot;, keyGenerator = &quot;simpleKeyGenerator&quot;)</span> <span class="comment">// 3000秒</span></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;UserInfoListAnother&quot;, keyGenerator = &quot;simpleKeyGenerator&quot;)</span> <span class="comment">// 18000秒</span></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;DefaultKeyTest&quot;, keyGenerator = &quot;simpleKeyGenerator&quot;)</span> <span class="comment">// 600秒,未指定的key,使用默认策略</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>在spring2.0前后差异<br>构造器差异<br>before</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RedisCacheManager cacheManager = <span class="keyword">new</span> RedisCacheManager(RedisTemplate redisTemplate);</span><br></pre></td></tr></table></figure>
<p>after</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RedisCacheManager cacheManager = <span class="keyword">new</span> RedisCacheManager(RedisCacheWriter redisCacheWriter,RedisCacheConfiguration redisCacheConfiguration);</span><br></pre></td></tr></table></figure>
<p>创建RedisCacheWriter分为有锁和无锁<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/rediscachewriter.png" alt="流程"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RedisCacheWriter <span class="title">nonLockingRedisCacheWriter</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(connectionFactory, <span class="string">&quot;ConnectionFactory must not be null!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultRedisCacheWriter(connectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    JedisConnectionFactory</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create new &#123;<span class="doctag">@link</span> RedisCacheWriter&#125; with locking behavior.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory must not be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> new instance of &#123;<span class="doctag">@link</span> DefaultRedisCacheWriter&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> RedisCacheWriter <span class="title">lockingRedisCacheWriter</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(connectionFactory, <span class="string">&quot;ConnectionFactory must not be null!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultRedisCacheWriter(connectionFactory, Duration.ofMillis(<span class="number">50</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>即使是同一个缓存CacheManager管理的缓存实例,配置有可能不一样。<br>指定redis数据序列化<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/connectionfactory.png" alt="流程"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(keySerializer()))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer()))</span><br></pre></td></tr></table></figure>
<p>JAVA序列化方式<br>序列化方式一实现：Serializable接口<br>序列化方式二：Externalizable显式序列化<br>序列化方式三：实现Serializable接口+添加writeObject()和readObject()方法。(显+隐序列化)<br>对了,想要使用cache记得开启缓存注解,@EnableCaching<br>转过头来看下CacheOperation,这里面是缓存相关注解的父类,在SpringCacheAnnotationParser中管理了子类相关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">        CACHE_OPERATION_ANNOTATIONS.add(Cacheable.class);</span><br><span class="line">        CACHE_OPERATION_ANNOTATIONS.add(CacheEvict.class);</span><br><span class="line">        CACHE_OPERATION_ANNOTATIONS.add(CachePut.class);</span><br><span class="line">        CACHE_OPERATION_ANNOTATIONS.add(Caching.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>解析注解的时候他们的入参,实现一模一样,只有返回值不一样,但是一模一样的代码写了三遍,为什么不判断类型动态返回呢~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            DefaultCacheConfig cachingConfig, AnnotatedElement ae, <span class="keyword">boolean</span> localOnly)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Collection&lt;? extends Annotation&gt; anns = (localOnly ?</span><br><span class="line">                AnnotatedElementUtils.getAllMergedAnnotations(ae, CACHE_OPERATION_ANNOTATIONS) :</span><br><span class="line">                AnnotatedElementUtils.findAllMergedAnnotations(ae, CACHE_OPERATION_ANNOTATIONS));</span><br><span class="line">        <span class="keyword">if</span> (anns.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Collection&lt;CacheOperation&gt; ops = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        anns.stream().filter(ann -&gt; ann <span class="keyword">instanceof</span> Cacheable).forEach(</span><br><span class="line">                ann -&gt; ops.add(parseCacheableAnnotation(ae, cachingConfig, (Cacheable) ann)));</span><br><span class="line">        anns.stream().filter(ann -&gt; ann <span class="keyword">instanceof</span> CacheEvict).forEach(</span><br><span class="line">                ann -&gt; ops.add(parseEvictAnnotation(ae, cachingConfig, (CacheEvict) ann)));</span><br><span class="line">        anns.stream().filter(ann -&gt; ann <span class="keyword">instanceof</span> CachePut).forEach(</span><br><span class="line">                ann -&gt; ops.add(parsePutAnnotation(ae, cachingConfig, (CachePut) ann)));</span><br><span class="line">        anns.stream().filter(ann -&gt; ann <span class="keyword">instanceof</span> Caching).forEach(</span><br><span class="line">                ann -&gt; parseCachingAnnotation(ae, cachingConfig, (Caching) ann, ops));</span><br><span class="line">        <span class="keyword">return</span> ops;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CacheableOperation <span class="title">parseCacheableAnnotation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            AnnotatedElement ae, DefaultCacheConfig defaultConfig, Cacheable cacheable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CacheableOperation.Builder builder = <span class="keyword">new</span> CacheableOperation.Builder();</span><br><span class="line"></span><br><span class="line">        builder.setName(ae.toString());</span><br><span class="line">        builder.setCacheNames(cacheable.cacheNames());</span><br><span class="line">        builder.setCondition(cacheable.condition());</span><br><span class="line">        builder.setUnless(cacheable.unless());</span><br><span class="line">        builder.setKey(cacheable.key());</span><br><span class="line">        builder.setKeyGenerator(cacheable.keyGenerator());</span><br><span class="line">        builder.setCacheManager(cacheable.cacheManager());</span><br><span class="line">        builder.setCacheResolver(cacheable.cacheResolver());</span><br><span class="line">        builder.setSync(cacheable.sync());</span><br><span class="line"></span><br><span class="line">        defaultConfig.applyDefault(builder);</span><br><span class="line">        CacheableOperation op = builder.build();</span><br><span class="line">        validateCacheOperation(ae, op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CacheEvictOperation <span class="title">parseEvictAnnotation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            AnnotatedElement ae, DefaultCacheConfig defaultConfig, CacheEvict cacheEvict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CacheEvictOperation.Builder builder = <span class="keyword">new</span> CacheEvictOperation.Builder();</span><br><span class="line"></span><br><span class="line">        builder.setName(ae.toString());</span><br><span class="line">        builder.setCacheNames(cacheEvict.cacheNames());</span><br><span class="line">        builder.setCondition(cacheEvict.condition());</span><br><span class="line">        builder.setKey(cacheEvict.key());</span><br><span class="line">        builder.setKeyGenerator(cacheEvict.keyGenerator());</span><br><span class="line">        builder.setCacheManager(cacheEvict.cacheManager());</span><br><span class="line">        builder.setCacheResolver(cacheEvict.cacheResolver());</span><br><span class="line">        builder.setCacheWide(cacheEvict.allEntries());</span><br><span class="line">        builder.setBeforeInvocation(cacheEvict.beforeInvocation());</span><br><span class="line"></span><br><span class="line">        defaultConfig.applyDefault(builder);</span><br><span class="line">        CacheEvictOperation op = builder.build();</span><br><span class="line">        validateCacheOperation(ae, op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CacheOperation <span class="title">parsePutAnnotation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            AnnotatedElement ae, DefaultCacheConfig defaultConfig, CachePut cachePut)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CachePutOperation.Builder builder = <span class="keyword">new</span> CachePutOperation.Builder();</span><br><span class="line"></span><br><span class="line">        builder.setName(ae.toString());</span><br><span class="line">        builder.setCacheNames(cachePut.cacheNames());</span><br><span class="line">        builder.setCondition(cachePut.condition());</span><br><span class="line">        builder.setUnless(cachePut.unless());</span><br><span class="line">        builder.setKey(cachePut.key());</span><br><span class="line">        builder.setKeyGenerator(cachePut.keyGenerator());</span><br><span class="line">        builder.setCacheManager(cachePut.cacheManager());</span><br><span class="line">        builder.setCacheResolver(cachePut.cacheResolver());</span><br><span class="line"></span><br><span class="line">        defaultConfig.applyDefault(builder);</span><br><span class="line">        CachePutOperation op = builder.build();</span><br><span class="line">        validateCacheOperation(ae, op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseCachingAnnotation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            AnnotatedElement ae, DefaultCacheConfig defaultConfig, Caching caching, Collection&lt;CacheOperation&gt; ops)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Cacheable[] cacheables = caching.cacheable();</span><br><span class="line">        <span class="keyword">for</span> (Cacheable cacheable : cacheables) &#123;</span><br><span class="line">            ops.add(parseCacheableAnnotation(ae, defaultConfig, cacheable));</span><br><span class="line">        &#125;</span><br><span class="line">        CacheEvict[] cacheEvicts = caching.evict();</span><br><span class="line">        <span class="keyword">for</span> (CacheEvict cacheEvict : cacheEvicts) &#123;</span><br><span class="line">            ops.add(parseEvictAnnotation(ae, defaultConfig, cacheEvict));</span><br><span class="line">        &#125;</span><br><span class="line">        CachePut[] cachePuts = caching.put();</span><br><span class="line">        <span class="keyword">for</span> (CachePut cachePut : cachePuts) &#123;</span><br><span class="line">            ops.add(parsePutAnnotation(ae, defaultConfig, cachePut));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JSR(JCP  Java Community Process)文档查询地址,例如JSR107规范,servlet规范等等,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html</span><br></pre></td></tr></table></figure>
<p>以及各类中文版在线开发文档</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//www.docs4dev.com/docs</span></span><br></pre></td></tr></table></figure>
<p>对了本次的主题虽然是Servlet,但不全是Servlet,都是用servlet带出来的,比如现在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">boolean</span> waitForTasksToCompleteOnShutdown,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">long</span> awaitTerminationMillis,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="meta">@NonNull</span> BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="meta">@NonNull</span> String threadPoolId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="meta">@NonNull</span> ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="meta">@NonNull</span> RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, waitForTasksToCompleteOnShutdown, awaitTerminationMillis, workQueue, threadPoolId, threadFactory, handler);</span><br><span class="line">       <span class="keyword">this</span>.threadPoolId = threadPoolId;</span><br><span class="line"></span><br><span class="line">       RejectedExecutionHandler rejectedProxy = (RejectedExecutionHandler) Proxy</span><br><span class="line">               .newProxyInstance(</span><br><span class="line">                       handler.getClass().getClassLoader(),</span><br><span class="line">                       <span class="keyword">new</span> Class[]&#123;RejectedExecutionHandler.class&#125;,</span><br><span class="line">                       <span class="keyword">new</span> RejectedProxyInvocationHandler(handler, rejectCount));</span><br><span class="line">       setRejectedExecutionHandler(rejectedProxy);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>mybatis动态代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里使用JDK动态代理,通过Proxy.newProxyInstance生成动态代理类</span></span><br><span class="line">    <span class="comment">// newProxyInstance的参数：类加载器、接口类、InvocationHandler接口实现类</span></span><br><span class="line">    <span class="comment">// 动态代理可以将所有接口的调用重定向到调用处理器InvocationHandler,调用它的invoke方法</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>问题： 一个接口方法,返回值相同,方法相同,参数为Person,现在有子类PersonMan和PersonWoman,如何对接口进行适配？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Integer age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonMan</span> <span class="keyword">extends</span>  <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String character;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonWoman</span>  <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String constellation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在泛型类型中支持class等,以及省去参数转换的上界通配符&lt;? extends E&gt;：上界通配符,表明参数化类型可能是所指定的类型,或者此类型的子类；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface PersonService &#123;</span><br><span class="line"></span><br><span class="line">    public void  queryPerson(List&lt;? extends Person&gt; list);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class PersonServiceImpl implements PersonService&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void queryPerson(List&lt;? extends Person&gt; list) &#123;</span><br><span class="line">        System.out.println(JSONObject.toJSONString(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//List&lt;PersonMan&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//List&lt;PersonWoman&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">personService.queryPerson(list);</span><br></pre></td></tr></table></figure>
<p>那么如果参数类型为注解呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryPerson</span><span class="params">(List&lt;? extends Person&gt; list,Class&lt;? extends Annotation&gt; t)</span> </span>&#123;</span><br><span class="line">        System.out.println(JSONObject.toJSONString(list));</span><br><span class="line">       </span><br><span class="line">        System.out.println(cast.annotationType());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么为什么上面的parsePutAnnotation不用呢？<br>NONONO,其实是用了的,只不过方法不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final Set&lt;Class&lt;? extends Annotation&gt;&gt; CACHE_OPERATION_ANNOTATIONS = new LinkedHashSet&lt;&gt;(8);</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        CACHE_OPERATION_ANNOTATIONS.add(Cacheable.class);</span><br><span class="line">        CACHE_OPERATION_ANNOTATIONS.add(CacheEvict.class);</span><br><span class="line">        CACHE_OPERATION_ANNOTATIONS.add(CachePut.class);</span><br><span class="line">        CACHE_OPERATION_ANNOTATIONS.add(Caching.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其实我就是看他的写的emoj,而且在caching这个注解里他包含了4种注解,然后统一进行管理的。</p>
<p>插播：Dbeaver中普通操作都会,安利一个类似idea的快捷键功能,Template—&gt;SQL编辑器中可设置常用SQL,快捷键加Tab唤出.</p>
<h3 id="国际化包含文本的国际化和时区的国际化"><a href="#国际化包含文本的国际化和时区的国际化" class="headerlink" title="国际化包含文本的国际化和时区的国际化"></a>国际化包含文本的国际化和时区的国际化</h3><h3 id="Repository-VS-NoRepositoryBean"><a href="#Repository-VS-NoRepositoryBean" class="headerlink" title="@Repository VS  @NoRepositoryBean"></a>@Repository VS  @NoRepositoryBean</h3><p>回到cache相关中,在开启缓存时提示错误需要加入@Enablecahing注解,而在验证缓存注解时,在接口加了NoRepositoryBean,那么NoRepositoryBean又是什么？跟@Repository有何不同？<br>NoRepositoryBean：见名知意就是不需要创建的bean,在Springboot jpa中标识,雷同与不需要序列化的字段标识transient；<br>NoRepositoryBean用做标记当前接口或者类（抽象）不应该作为RepositoryBean被注册到Spring上下文,Springdata提供了自动代理的机制</p>
<h2 id="JMS-java-message-service-JSR-914"><a href="#JMS-java-message-service-JSR-914" class="headerlink" title="JMS(java  message service)JSR-914"></a>JMS(java  message service)JSR-914</h2><p>1.JMS：用于应用程序之间,或在分布式系统中发送消息。而一些生产者,消费者,消息等不是消息队列的特指,而是JMS的所有特性。<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/jms.jpg" alt="Liucheng"><br>2.AMQP：(Advanced Message Queuing Protocol)<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/AMQP.png" alt="Liucheng"><br>消息队列协议,中文规范,消息代理(message brokers) 从发布者（publisher）亦称作生产者（producers）接受消息,根据<br>不同的路由规则（Routing Rule）把接受到的消息发送给处理消息的消费者（consumers）；</p>
<h1 id="3-kafka-零拷贝？-哎嗨-重点来了"><a href="#3-kafka-零拷贝？-哎嗨-重点来了" class="headerlink" title="3.kafka? 零拷贝？ 哎嗨,重点来了"></a>3.kafka? 零拷贝？ 哎嗨,重点来了</h1><p>官网：<a href="https://kafka.apache.org/">https://kafka.apache.org/</a><br>Kafka是一个分布式的基于发布/订阅模式的消息队列（Message Queue）,主要应用于大数据实时处理领域。<br>其实大多数的消息队列的实时性只能保持在秒级,而在银行是能够在纳秒之间的,kafka2.8.x之前是基于zookeeper的,<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/kafka.png" alt="kafka"><br>架构图<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/kafka2.png" alt="kafka"></p>
<p>默认分区内存大小32M,每个批次大小是16K<br>1.批次数据满了才会发送,16K<br>2.linger.ms批次数据未满时,延迟发送时间<br>Sender数据拉取<br>同步vs异步发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>配置</span><br><span class="line"><span class="number">2.</span>连接集群</span><br><span class="line"><span class="number">3.</span>指定序列化类型</span><br><span class="line"><span class="number">4.</span>创建生产者</span><br><span class="line"><span class="number">5.</span>发送数据</span><br><span class="line"><span class="number">6.</span>关闭资源</span><br></pre></td></tr></table></figure>
<p>分区自定义,合理使用资源,负载均衡<br>可配置类都要放到统一类管理<br>1.指定分区的情况<br>2.没有指定分区,带key,key的hash值与topic的分区值取模<br>3.没有指定分区,不带key,粘性分区,随机选择一个分区,尽可能一直使用该分区<br>自定义分区器：实现分区器接口<br>一般会说那个表名作为key<br>自定义分区器：<br>恰好达到批次大小就进行发送<br>导致数据延迟：<br>生产环境配置5-100ms之间<br>压缩类型snappy<br>提供生产者吞吐量<br>应答ack  0   1  -1<br>动态ISR replica.lag.time.max.ms默认30s,超出则踢出<br>数据完全可靠条件：<br><font color="red"> ACK级别设置为1 +分区副本大于等于2 +ISR应答最小副本数量大于等于2  </font><br>要求可靠性<br>要求速度<br>默认值为int最大值<br>ack和重试数据<br>幂等性和事务:保证单分区单回话内不会重复<br>开启事务,必须开启幂等性<br>指定事务id<br>数据有序<br>单分区有序：<br>多分区有序：<br>数据乱序<br>kafka1.x前后差别：<br>是否开启幂等性区别：<br>其中一个出现异常则先缓存,后落盘<br>zookeeper中存放的信息<br>工具：prettyzoo</p>
<p>1、brokerid<br>2、主题<br>3.消费者信息</p>
<p><font color="green">AR:是kafka中你那个所有分区副本的总称</font><br><font color="green">ISR:leader和follower之间正常通讯的节点</font><br>除了基础知识点之外我最想看的就是kafka的零拷贝跟netty的关系。</p>
<blockquote>
<p>DMA<br>在介绍零拷贝之前,我们先来看一个技术名词DMA（Direct Memory Access<br>直接内存访问）。它是现代电脑的重要特征之一,允许不同速度的硬件之间直接交互,而不需要占用CPU的中断负载。DMA传输将一个地址空间复制到另一个地址空间,当CPU<br>初始化这个传输之后,实际的数据传输是有DMA设备之间完成,这样可以大大的减少CPU的消耗。我们常见的硬件设备都支持DMA</p>
</blockquote>
<p>零拷贝有两种方式：mmap/sendfile,而直接内存的方式跟Netty也是如出一辙。<br>关于压缩类型snappy,他是Java提供的实现,在maven以来中可在kafka中看到<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/snappy.png" alt="kafka"></p>
<h3 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.kafka.clients.producer.ProducerRecord</span><br><span class="line">    可指定主题</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    分区</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer partition;</span><br><span class="line">    头信息</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">    key</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    value</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line">    linger.ms</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timestamp;</span><br></pre></td></tr></table></figure>
<p>构造器有几种,对于发送消息就有几种类型,consumerRecord同理,key和value需要指定序列化类。<br>所有的配置项存放在ProducerConfig中,本来想看几个代表性参数就可以了,但是后续的调优参数有很多配置是用的到的,还是要仔细看看。<br>比如每个batchsize批次内存大小默认是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.define(BATCH_SIZE_CONFIG, Type.INT, 16384, atLeast(0), Importance.MEDIUM, BATCH_SIZE_DOC)</span><br></pre></td></tr></table></figure>
<p>16384/1024=16k<br>比如linger.ms默认为0ms</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.define(LINGER_MS_CONFIG, Type.LONG, 0, atLeast(0), Importance.MEDIUM, LINGER_MS_DOC)</span><br></pre></td></tr></table></figure>
<p>key指定的序列化类为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Serializer class for key that implements the &lt;code&gt;org.apache.kafka.common.serialization.Serializer&lt;/code&gt; interface.</span><br><span class="line">如果在配置文件中指定则需要全限定类名</span><br></pre></td></tr></table></figure>
<h3 id="zookeeper中存放的信息"><a href="#zookeeper中存放的信息" class="headerlink" title="zookeeper中存放的信息"></a>zookeeper中存放的信息</h3><p>broker启动后在zookeeper中注册<br>controller将节点信息记录到zookeeper中,推荐使用工具链接prettyzoo,存放brokerid,topic,消费者信息等。</p>
<h3 id="Linux新增知识点"><a href="#Linux新增知识点" class="headerlink" title="Linux新增知识点"></a>Linux新增知识点</h3><p>kafka 搭配 xcall jps ,查看集群下机器节点</p>
<h3 id="kafka服务器挂了怎么办？"><a href="#kafka服务器挂了怎么办？" class="headerlink" title="kafka服务器挂了怎么办？"></a>kafka服务器挂了怎么办？</h3><p>1.先尝试重启,重启成功直接解决<br>2.增加内存,CPU,宽带<br>3.如果副本数大于等于2,可以按照服役新节点方法执行,并配置负载均衡</p>
<h3 id="Broker中的重要参数"><a href="#Broker中的重要参数" class="headerlink" title="Broker中的重要参数"></a>Broker中的重要参数</h3><table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">replica.lag.time.max.ms</td>
<td align="left">ISR 中,如果 Follower 长时间未向 Leader 发送通信请求或同步数据,则该 Follower 将被踢出 ISR。该时间阈值,<font color="red">默认30s</font> 。</td>
</tr>
<tr>
<td align="left">auto.leader.rebalance.enable</td>
<td align="left"><font color="red">默认是 true</font>。 自动 Leader Partition 平衡。</td>
</tr>
<tr>
<td align="left">leader.imbalance.per.broker.percentage</td>
<td align="left"><font color="red">默认是 10%</font>。每个 broker 允许的不平衡的 leader的比率。如果每个 broker 超过了这个值,控制器会触发 leader 的平衡。</td>
</tr>
<tr>
<td align="left">leader.imbalance.check.interval.seconds</td>
<td align="left"><font color="red">认值 300 秒 </font>。检查 leader 负载是否平衡的间隔时间。</td>
</tr>
<tr>
<td align="left">log.segment.bytes</td>
<td align="left">Kafka 中 log 日志是分成一块块存储的,此配置是指 log 日志划分 成块的大小,<font color="red">默认值 1G</font>。</td>
</tr>
<tr>
<td align="left">log.index.interval.bytes</td>
<td align="left"><font color="red">默认 4kb</font>,kafka 里面每当写入了 4kb 大小的日志（.log）,然后就往 index 文件里面记录一个索引</td>
</tr>
<tr>
<td align="left">log.retention.hours</td>
<td align="left">Kafka 中数据保存的时间,<font color="red">默认7天</font>。</td>
</tr>
<tr>
<td align="left">log.retention.minutes</td>
<td align="left">Kafka 中数据保存的时间,分钟级别,<font color="red">默认关闭</font>。</td>
</tr>
</tbody></table>
<h3 id="文件清理策略"><a href="#文件清理策略" class="headerlink" title="文件清理策略"></a>文件清理策略</h3><p>Kafka 中默认的日志保存时间为<font color="red">7天</font>。<br>日志删除策略</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMq从入门到放弃</title>
    <url>/posts/20211028clhk6ptdw000qcsujfl3ncn20.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h1 id="【置顶】-留言请点击友链留言室或者在文章底部留言"><a href="#【置顶】-留言请点击友链留言室或者在文章底部留言" class="headerlink" title="【置顶】 留言请点击友链留言室或者在文章底部留言"></a>【置顶】 留言请点击友链留言室或者在文章底部留言</h1><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/rocktMq.jpg" alt="mq"></p>
<h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p><a href="http://rocketmq.apache.org/release_notes/release-notes-4.3.2/">http://rocketmq.apache.org/release_notes/release-notes-4.3.2/</a></p>
<h1 id="中文文档"><a href="#中文文档" class="headerlink" title="中文文档"></a>中文文档</h1><p><a href="https://rocketmq-1.gitbook.io/rocketmq-connector/quick-start/qian-qi-zhun-bei/dan-ji-huan-jing">https://rocketmq-1.gitbook.io/rocketmq-connector/quick-start/qian-qi-zhun-bei/dan-ji-huan-jing</a></p>
<h1 id="idea调试工具"><a href="#idea调试工具" class="headerlink" title="idea调试工具"></a>idea调试工具</h1><p><a href="https://www.jetbrains.com/help/idea/2019.1/debug-tool-window.html">https://www.jetbrains.com/help/idea/2019.1/debug-tool-window.html</a><br><a href="https://github.com/DillonDong/notes">https://github.com/DillonDong/notes</a></p>
<h1 id="Windows环境下安装RocketMQ"><a href="#Windows环境下安装RocketMQ" class="headerlink" title="Windows环境下安装RocketMQ"></a>Windows环境下安装RocketMQ</h1><p>一.预备环境<br>1.系统<br>Windows<br>2. 环境<br>JDK1.8、Maven、Git<br>二. RocketMQ部署<br>1.下载<br>1.1地址：<a href="http://rocketmq.apache.org/release_notes/release-notes-4.3.0/">http://rocketmq.apache.org/release_notes/release-notes-4.3.0/</a><br>1.2选择‘Binary’进行下载<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/rocktmq1.jpg" alt="rocketMq"><br>1.3解压已下载工程<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/rocktmq2.jpg" alt="rocketMq"><br>2. 配置<br>2.1 系统环境变量配置<br>变量名：ROCKETMQ_HOME<br>变量值：MQ解压路径\MQ文件夹名<br>eg、ROCKETMQ_HOME=D:\dev\rocketmq-all-4.3.0-bin-release<br>3. 启动<br>3.1 启动NAMESERVER<br>Cmd命令框执行进入至‘MQ文件夹\bin’下，然后执行‘start mqnamesrv.cmd’，启动NAMESERVER。成功后会弹出提示框，此框勿关闭。<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/rocktmq3.jpg" alt="rocketMq"><br>3.2 启动BROKER<br>Cmd命令框执行进入至‘MQ文件夹\bin’下，然后执行‘start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true’，启动BROKER。成功后会弹出提示框，此框勿关闭</p>
<ol start="2">
<li>编译启动<br>用CMD进入‘\rocketmq-externals\rocketmq-console’文件夹，执行‘mvn clean package -Dmaven.test.skip=true’，编译生成。<br>编译成功之后，Cmd进入‘target’文件夹，执行‘java -jar rocketmq-console-ng-1.0.0.jar’，启动‘rocketmq-console-ng-1.0.0.jar’。</li>
<li>测试<br>浏览器中输入‘127.0.0.1:配置端口’，成功后即可查看。<br>eg：<a href="http://127.0.0.1:8088/">http://127.0.0.1:8088</a><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/rocketmq4.jpg" alt="rocketMq"></li>
</ol>
<h1 id="基本配置项"><a href="#基本配置项" class="headerlink" title="基本配置项"></a>基本配置项</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.contextPath=</span><br><span class="line">server.port=8088</span><br><span class="line">#spring.application.index=true</span><br><span class="line">spring.application.name=rocketmq-console</span><br><span class="line">spring.http.encoding.charset=UTF-8</span><br><span class="line">spring.http.encoding.enabled=true</span><br><span class="line">spring.http.encoding.force=true</span><br><span class="line">logging.config=classpath:logback.xml</span><br><span class="line">#if this value is empty,use env value rocketmq.config.namesrvAddr  NAMESRV_ADDR | now, you can set it in ops page.default localhost:9876</span><br><span class="line">rocketmq.config.namesrvAddr=127.0.0.1:9876</span><br><span class="line">#if you use rocketmq version &lt; 3.5.8, rocketmq.config.isVIPChannel should be false.default true</span><br><span class="line">rocketmq.config.isVIPChannel=</span><br><span class="line">#rocketmq-console&#x27;s data path:dashboard/monitor</span><br><span class="line">rocketmq.config.dataPath=/tmp/rocketmq-console/data</span><br><span class="line">#set it false if you don&#x27;t want use dashboard.default true</span><br><span class="line">rocketmq.config.enableDashBoardCollect=true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="java整合MQ"><a href="#java整合MQ" class="headerlink" title="java整合MQ"></a>java整合MQ</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RockermqproducerApplicationTests</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;apache.rocketmq.producer.producerGroup&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String producerGroup;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NameServer 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;apache.rocketmq.namesrvAddr&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//生产者的组名</span></span><br><span class="line">        DefaultMQProducer producer=<span class="keyword">new</span> DefaultMQProducer(producerGroup);</span><br><span class="line">        <span class="comment">//指定NameServer地址，多个地址以 ; 隔开</span></span><br><span class="line">        producer.setNamesrvAddr(namesrvAddr);</span><br><span class="line">        <span class="comment">//消息发送失败重试次数</span></span><br><span class="line">        producer.setRetryTimesWhenSendFailed(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//异步发送失败重试次数</span></span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//消息没有发送成功，是否发送到另外一个Broker中</span></span><br><span class="line">        producer.setRetryAnotherBrokerWhenNotStoreOK(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Producer对象在使用之前必须要调用start初始化，初始化一次即可</span></span><br><span class="line"><span class="comment">             * 注意：切记不可以在每次发送消息时，都调用start方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            producer.start();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10000</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Message msg=<span class="keyword">new</span> Message(<span class="string">&quot;topic_example_java&quot;</span>,<span class="string">&quot;TagA&quot;</span>,(<span class="string">&quot;Hello Java Demo RocketMQ:&quot;</span>+i).getBytes(Charset.defaultCharset()));</span><br><span class="line">                SendResult result=producer.send(msg);</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送结果：&quot;</span>+result);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>消息消费顺序：全局消息顺序<br>  局部消息顺序</p>
<p>保证局部消息的顺序<br>只在一个队列保证一个人消费<br>消费时，同一个OrderId获取到的肯定是同一个队列。</p>
<p>消息存储结构</p>
<p>刷盘机制：同步刷盘<br>异步刷盘<br>RocketMQ的消息是存储到磁盘上的，这样既能保证断电后恢复， 又可以让存储的消息量超出内存的限制。RocketMQ为了提高性能，会尽可能地保证磁盘的<br>顺序写。消息在通过Producer写入RocketMQ的时 候，有两种写磁盘方式，分布式同步刷盘和异步刷盘<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/rocketmq5.jpg" alt="rocketMq"></p>
<p>顺序消息消费及时监控处理<br>对于顺序消息，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试（每次间隔时间为 1 秒），这时，应用会出现消息消费被阻塞的情况。因此，在使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/rocketmq6.jpg" alt="rocketMq"></p>
<p>消费幂等：若某操作执行多次或一次对系统产生的结果是相同的，则称该操作是幂等的<br>例如支付场景，因为网络原因导致二次消费，会不会造成重复扣款</p>
<blockquote>
<p>RocketMq的文件存储系统有两点优化以保证性能：</p>
</blockquote>
<blockquote>
<p>消息存储（顺序写）：RocketMQ的消息用顺序写,保证了消息存储的速度。目前的高性能磁盘，顺序写速度可以达到600MB/s，<br>超过了一般网卡的传输速度，但是磁盘随机写的速度只有大概100KB/s<br>消息发送（零拷贝）：将本机磁盘文件的内容发送到客户端需要进行多次复制，比如从磁盘复制数据到内核态内存；从内核态内存复制到用户态内存；从用户态内存复制到网络驱动，&gt;最后从网络驱动复制到网卡中。RocketMq采用Java中零拷贝的技术，让从内核态内存复制到用户态内存这一步省略，直接赋值到网络驱动中<br>零拷贝技术有个限制是不能超过2G，所以RocketMQ默认设置单个CommitLog日志数据文件为1G</p>
</blockquote>
<p>RokectMq架构<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/rocketmq7.jpg" alt="rocketMq"></p>
<h1 id="存储结构是什么样的？"><a href="#存储结构是什么样的？" class="headerlink" title="存储结构是什么样的？"></a>存储结构是什么样的？</h1><p>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成的</p>
<p>CommitLog：消息真正的物理存储文件是CommitLog，默认一个文件一个G，存储的是Topic，QueueId和Message，一个存储满了会自动创建一个新的。<br>ConsumeQueue：是消息的逻辑队列，类似数据库的索引文件，存储的是指向物理存储的地址，为了加快消息的读取速度。消费者消费某条消息时，先查询索引获取CommitLog的对应的物理地址。每个Topic下的每个Message Queue都有一个对应的ConsumeQueue文件，文件很小，通常会加载到内存中。如果该文件丢失或者损坏，可以通过CommitLog恢复<br>IndexFile：也是个索引文件，为了消息查询提供了一种通过key或时间区间来查询消息的方法，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程</p>
<h1 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a>如何保证消息不丢失？</h1><p>RocketMq提供消息持久化机制，消息的刷盘策略分为同步刷盘和异步刷盘。同步刷盘即刷盘成功后再返回一个成功信息，能够保证数据一定保存成功，但是会降低系统吞吐量，异步刷盘与同步刷盘相反，我一般会采用同步刷盘的策略来保证消息不会丢失。<br>RocketMq采用的文件系统存储而不是关系型数据库存储，因为在一般情况下文件系统的性能是比数据库性能高的<br>而RocketMq为了提高文件系统的读写的高性能，做了两点优化。第一点是采用顺序写的方式，这样可以大大提高磁盘写的性能。第二点采用了零拷贝，原来的文件读取流程是：从磁盘复制数据到内核态内存；从内核态内存复制到用户态内存；从用户态内存复制到网络驱动，最后从网络驱动复制到网卡中发送，零拷贝则省去了从内核态内存复制到用户态内存的这一过程，提高了读取的性能，但是零拷贝对文件大小有要求，所以RocketMq的持久化文件<font color="#0099ff" size="3" face="黑体">commitlog默认为1G</font>。<br>commitlog是存储了RocketMq的消息等核心信息，除此之外，还提供可一个ConsumeQueue作为持久化文件的索引，提高查询的效率，一般文件比较小，都是加载在内存中。除了ConsumeQueue之外，还会存储一个IndexFile文件，用来提供针对某一个key或者时间区间的查询。</p>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="Producer负载均衡"><a href="#Producer负载均衡" class="headerlink" title="Producer负载均衡"></a>Producer负载均衡</h2><p>Producer端，每个实例在发消息的时候，默认会轮询所有的message queue发送，以达到让消息平均落在不同的queue上。而由于queue可以散落在不同的broker，所以消息就发送到不同的broker下</p>
<h2 id="Consumer负载均衡"><a href="#Consumer负载均衡" class="headerlink" title="Consumer负载均衡"></a>Consumer负载均衡</h2><p>如果consumer实例的数量比message queue的总数量还多的话，多出来的consumer实例将无法分到queue，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让queue的总数量大于等于consumer的数量。</p>
<p>消费者的集群模式–启动多个消费者就可以保证消费者的负载均衡（均摊队列）</p>
<p>默认使用的是均摊队列：会按照queue的数量和实例的数量平均分配queue给每个实例，这样每个消费者可以均摊消费的队列</p>
<h1 id="消息重试机制"><a href="#消息重试机制" class="headerlink" title="消息重试机制"></a>消息重试机制</h1><h2 id="1-顺序消息的重试"><a href="#1-顺序消息的重试" class="headerlink" title="1. 顺序消息的重试"></a>1. 顺序消息的重试</h2><p>对于顺序消息，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试（每次间隔时间为 1 秒），这时，应用会出现消息消费被阻塞的情况。</p>
<p>因此，在使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生。</p>
<h2 id="2-无序消息的重试"><a href="#2-无序消息的重试" class="headerlink" title="2. 无序消息的重试"></a>2. 无序消息的重试</h2><p>对于无序消息（普通、定时、延时、事务消息），当消费者消费消息失败时，您可以通过设置返回状态达到消息重试的结果。</p>
<p>无序消息的重试只针对集群消费方式生效；广播方式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息。</p>
<p>消息队列 RocketMQ 默认允许每条消息最多重试 16 次，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，如果依然失败就会进入死信队列。</p>
<p>一条消息无论重试多少次，这些重试消息的 Message ID 不会改变。</p>
<p>也可以通过配置，让其不再重试，但是不建议这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doConsumeMessage(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">//捕获消费逻辑中的所有异常，并返回 Action.CommitMessage;</span></span><br><span class="line">            <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息处理正常，直接返回 Action.CommitMessage;</span></span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="消费幂等"><a href="#消费幂等" class="headerlink" title="消费幂等"></a>消费幂等</h1><p>消息队列 RocketMQ 消费者在接收到消息以后，有必要根据业务上的唯一 Key 对消息做幂等处理的必要性。</p>
<h2 id="1-什么时候产生重复消息？"><a href="#1-什么时候产生重复消息？" class="headerlink" title="1. 什么时候产生重复消息？"></a>1. 什么时候产生重复消息？</h2><p>在互联网应用中，尤其在网络不稳定的情况下，消息队列 RocketMQ 的消息有可能会出现重复，这个重复简单可以概括为以下情况：</p>
<p>发送时消息重复</p>
<p>当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
<p>消费时消息重复</p>
<p>消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。 为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
<p>负载均衡时消息重复（包括但不限于网络抖动、Broker 重启以及订阅方应用重启）</p>
<p>当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息。</p>
<h2 id="2-处理方式"><a href="#2-处理方式" class="headerlink" title="2. 处理方式"></a>2. 处理方式</h2><p>因为 Message ID 有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据。 最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 进行设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Message message = <span class="keyword">new</span> Message();</span><br><span class="line">message.setKey(<span class="string">&quot;ORDERID_100&quot;</span>);</span><br><span class="line">SendResult sendResult = producer.send(message);</span><br></pre></td></tr></table></figure>
<p>订阅方收到消息时可以根据消息的 Key 进行幂等处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">consumer.subscribe(<span class="string">&quot;ons_test&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        String key = message.getKey()</span><br><span class="line">        <span class="comment">// 根据业务唯一标识的 key 做幂等处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>接下来，就需要根据业务进行处理：</p>
<p>拿个数据要写库，先根据主键查一下，如果这数据都有了，你就别插入了，只需要更新一下；或者可以设置一个唯一索引<br>如果是写Redis，每次操作都是set，天然可以保证幂等性<br>如果不是上面两种场景，需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西；<strong>消费者需要先根据这个id去比如redis里查一下，之前消费过吗？</strong>如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。<br>如何解决消息积压的问题？<br>这个可能出现在消费端出了问题，不消费了，或者消费的极其极其慢，导致大量的消息无法消费，最后消息队列集群的磁盘都快写满了</p>
<p>首先最重要的就是修复消费者，接着最大的问题就是在消费者重启后，如何快速处理积压的消息？</p>
<p>新建一个topic，临时建立好原先10倍或者20倍的queue数量<br>接着扩容临时的consumer，此时消费速度是原来的十几倍<br>等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</p>
<h1 id="如何设计一个Mq？"><a href="#如何设计一个Mq？" class="headerlink" title="如何设计一个Mq？"></a>如何设计一个Mq？</h1><p>是上面内容的一个总结，需要分点进行设计</p>
<p>扩展性</p>
<p>生产者的扩展性<br>消息队列的扩展性<br>消费者的扩展性<br>高可用性</p>
<p>如何设计刷盘策略？<br>如何保证消息0丢失？<br>如何保证在其中有机器宕机时，保障服务可用？<br>消息重试机制</p>
<p>当一个消息没有被消费时，如何进行重试，保证消息一定被消费？<br>当消费端不可用时，如何保证消费端重启后，依然可以消费消息？<br>心跳检测机制</p>
<p>如何检测生产者、消息队列和消费者是否宕机？<br>负载均衡模式</p>
<p>如何做到消息生产以及消费的负载均衡？<br>顺序消息</p>
<p>如何实现顺序消息？</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>不限次数的AI对标ChatGPT提高生产力无需魔法</title>
    <url>/posts/20230510a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>由前 OpenAI 副总裁创建的人工智能新项目 “Claude” 来了，我叫它克劳德，与gpt来说，如果gpt的逻辑思维更强，那么Claude就是一个在逻辑上更善于表达的AI，但是coding能力ChatGPT is better</p>
<p>看起来大部分的测试方面都是GPT完胜，那么为什么还要推荐Claude呢？</p>
<p>你懂的，因为不需要魔法，或者需要但是只需要一点点，也可以完全不需要。</p>
<p>免注册使用</p>
<p>去这里：<a href="https://slack.com/intl/zh-cn/">https://slack.com/intl/zh-cn/</a></p>
<p>下载slack<br><img src="/posts/20230510a1/9.png" alt="JasperAI"></p>
<p>2.登录亲测使用手机号+139邮箱完美接入。小声说139邮箱可以加入一个工作区，然后里面竟然接入了gpt，但是对话是公开的<br><img src="/posts/20230510a1/10.png" alt="JasperAI"></p>
<p>3.创建一个workspace，公司名什么的随便填就可以</p>
<p>4.添加应用(需要一点点魔法)</p>
<p>无需魔法，重新在slack中添加claude应用的方法 - 知乎 (zhihu.com)</p>
<p><a href="https://zhuanlan.zhihu.com/p/625689180">https://zhuanlan.zhihu.com/p/625689180</a></p>
<p>5.搜索Claude，点击allow</p>
<p><img src="/posts/20230510a1/11.png" alt="JasperAI"><br>6.<br><img src="/posts/20230510a1/12.png" alt="JasperAI"><br><img src="/posts/20230510a1/13.png" alt="JasperAI"></p>
<p>接下来就看你的了</p>
<p>往期精彩内容</p>
<p>CodeGeeX: 多语言代码生成模型VS Code 和 IntelliJ IDEA安装即用<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486740&amp;idx=1&amp;sn=a8403db2d471b7db2a7b0b1fac4e1e06&amp;chksm=ceb09269f9c71b7f69ef1d5b1ba4bea2e59f841cb6787c269441e72461631a314e329b3314ff&amp;token=2145806419&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486740&amp;idx=1&amp;sn=a8403db2d471b7db2a7b0b1fac4e1e06&amp;chksm=ceb09269f9c71b7f69ef1d5b1ba4bea2e59f841cb6787c269441e72461631a314e329b3314ff&amp;token=2145806419&amp;lang=zh_CN#rd</a></p>
<p>比Chatgpt还早Jasper的免费10000字的AI<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486683&amp;idx=1&amp;sn=721db5610f1f6e3aea4c6dc8d315165b&amp;chksm=ceb093a6f9c71ab0a90a4b69353987443e083a6c106eb4a01e4c1e944c58af31e34261ba1622&amp;token=2145806419&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486683&amp;idx=1&amp;sn=721db5610f1f6e3aea4c6dc8d315165b&amp;chksm=ceb093a6f9c71ab0a90a4b69353987443e083a6c106eb4a01e4c1e944c58af31e34261ba1622&amp;token=2145806419&amp;lang=zh_CN#rd</a></p>
<p>Wonder Studio AI 制作属于你自己的CG视频附内测地址<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486668&amp;idx=1&amp;sn=65cb33865793d42de3e96d28e5d400e8&amp;chksm=ceb093b1f9c71aa75f87e3659c0cd5a7cfc3e66c63a58491d8f494c32bf7deb1de7f8137de50&amp;token=2145806419&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486668&amp;idx=1&amp;sn=65cb33865793d42de3e96d28e5d400e8&amp;chksm=ceb093b1f9c71aa75f87e3659c0cd5a7cfc3e66c63a58491d8f494c32bf7deb1de7f8137de50&amp;token=2145806419&amp;lang=zh_CN#rd</a></p>
<p>文心一言申请通过了，写周报糊弄领导<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486341&amp;idx=1&amp;sn=b9633d93b2e2dbc2291d7b1938af72ba&amp;chksm=ceb094f8f9c71dee394fa42583a4a207ed44fc25b392402bb1714b543375f0fca877552a6a8b&amp;token=2145806419&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247486341&amp;idx=1&amp;sn=b9633d93b2e2dbc2291d7b1938af72ba&amp;chksm=ceb094f8f9c71dee394fa42583a4a207ed44fc25b392402bb1714b543375f0fca877552a6a8b&amp;token=2145806419&amp;lang=zh_CN#rd</a></p>
<p>近期C站频繁更新，导致大多数时间大家进不去，大多数人的模型又都是基础模型，我现在将自己的大模型推荐分享给大家，并标明Lora的模型效果，我自己最常用的几个模型分享。</p>
<p>所有的AI工具集和大模型已经打包好啦，持续更新内容<del>回复[AI工具]赶紧领取吧</del>限时24小时删除。过期请直接私信。最新包含PPT生成工具，AI大模型，Lora模型，gpt网站，中文AI绘画大模型，大厂绘画网站内测，67万条prompt提示词，免费GPT网站合集等等，别忘了三连呦~</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
  </entry>
  <entry>
    <title>Springboot正确的停机方式</title>
    <url>/posts/20230509a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>在Spring Boot应用中,有几种常见的停止方式:</p>
<ol>
<li>使用CTRL+C:这是最简单的停止方式,但不推荐在生产环境使用。因为它会立即终止进程,没有机会实现优雅关闭。</li>
<li>使用SIGTERM信号:发送SIGTERM信号到Spring Boot进程的PID,Spring Boot会注册一个ShutdownHook来优雅关闭应用。这是生产环境推荐的停止方式。</li>
</ol>
<p>kill -SIGTERM pid<br>3. 调用Actuator的shutdown接口:Actuator暴露了一个/shutdown的HTTP端点来关闭应用。这也是生产环境推荐的方式之一。</p>
<p>curl -X POST <a href="http://localhost:8080/actuator/shutdown">http://localhost:8080/actuator/shutdown</a><br>4. 运行应用提供的退出命令:如果在应用中提供了自定义的退出命令,也可以通过运行该命令来关闭应用。<br>比如,在应用的入口类中提供:</p>
<p>@Component<br>public class ExitCommand implements CommandLineRunner {<br>    @Override<br>    public void run(String… args) throws Exception {<br>        System.exit(0);<br>    }<br>}<br>然后运行命令:</p>
<p>curl -X POST <a href="http://localhost:8080/exit">http://localhost:8080/exit</a><br>5. 调用ApplicationContext的close方法:通过在程序中直接调用<code>applicationContext.close()</code>方法关闭应用上下文来触发关闭。</p>
<p>@Autowired<br>private ConfigurableApplicationContext applicationContext;</p>
<p>public void exit() {<br>    applicationContext.close();<br>}<br>然后通过HTTP请求、JMX等方式调用该<code>exit()</code>方法。<br>总之,在生产环境中推荐使用Actuator接口的方式或发送SIGINT/SIGTERM信号的方式来关闭Spring Boot应用。这些方式能够实现优雅关闭,释放资源。而CTRL+C方式只适合在开发环境使用。<br>正确关闭SpringBoot应用,以释放应用占用的资源,这一点在生产环境尤其重要。我们在开发和运维Spring Boot应用时,需要清楚各种停止方式的区别,选用适合的方式</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
  </entry>
  <entry>
    <title>java并发编程专题连载系列</title>
    <url>/posts/20230207a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="曾经整理过一个并发专题的连载系列-但由于时间久远-且查阅资料有限-本次尽量按照项目实际应用遇到的问题进行举例。由于时间有限-本文将长时间进行更新…一开始就将一个类设计成是线程安全的-比在后期重新修复它更容易。"><a href="#曾经整理过一个并发专题的连载系列-但由于时间久远-且查阅资料有限-本次尽量按照项目实际应用遇到的问题进行举例。由于时间有限-本文将长时间进行更新…一开始就将一个类设计成是线程安全的-比在后期重新修复它更容易。" class="headerlink" title="曾经整理过一个并发专题的连载系列,但由于时间久远,且查阅资料有限,本次尽量按照项目实际应用遇到的问题进行举例。由于时间有限,本文将长时间进行更新…一开始就将一个类设计成是线程安全的,比在后期重新修复它更容易。"></a>曾经整理过一个并发专题的连载系列,但由于时间久远,且查阅资料有限,本次尽量按照项目实际应用遇到的问题进行举例。由于时间有限,本文将长时间进行更新…一开始就将一个类设计成是线程安全的,比在后期重新修复它更容易。</h2><p>网易云课堂知识大纲<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/1a200f88c7024d5fb7258886178e7165.jpg" alt="知识大纲"><br>相关官方文档：<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html">https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html</a></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。通常，<br>每一个任务称为一个线程（ thread), 它是线程控制的简称。可以同时运行一个以上线程的程<br>序称为多线程程序（multithreaded)。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在java api文档中原文对Thread类解释如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.</span><br><span class="line">Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.</span><br><span class="line"></span><br><span class="line">When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:</span><br><span class="line"></span><br><span class="line">The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.</span><br><span class="line">All threads that are not daemon threads have died, either by returning from t</span><br></pre></td></tr></table></figure>
<p>译文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程是程序中的执行线程。 Java虚拟机允许应用程序同时运行多个执行线程。</span><br><span class="line">每个线程都有一个优先级。优先级较高的线程优先执行优先级较低的线程。每个线程可能也可能不会标记为守护程序。当在某些线程中运行的代码创建一个新线程时，新线程的优先级最初设置等于创建线程的优先级，并且仅当创建线程是守护程序时，才是守护程序线程。</span><br><span class="line">当Java虚拟机启动时，通常会有一个非daemon线程（通常调用某些指定类的主题的方法）。 Java虚拟机继续执行线程，直到发生以下任何一个：</span><br><span class="line"></span><br><span class="line">已经调用了类运行时的退出方法，安全管理器已允许进行退出操作。</span><br><span class="line">所有不是守护程序线程的线程都死了，要么从T返回</span><br></pre></td></tr></table></figure>
<p>对于本段话则可以进行提问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么是守护线程？</span><br><span class="line">什么是daemon线程？</span><br></pre></td></tr></table></figure>
<h2 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程"></a>为什么需要多线程</h2><p>1.资源利用,多CPU系统中提高CPU利用率<br>2.提高应用程序响应,程序的运行效率会提高<br>3.编译程序优化指令执行次序，使得缓存能够得到更加合理地利用</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>多线程并发执行时,对共享内存中共享对象的属性发生修改时所导致的数据冲突问题,称之为线程安全问题</p>
<p>即使你的程序没有显式地创建任何线程,框架也可能为你创建了一些线程,这些线程<br>调用的代码必须是线程安全的(thread-safe)。这一点给开发人员的设计和实现赋予了更<br>重要的一份责任,因为开发线程安全的类要比非线程安全的类需要更加仔细,进行更多的<br>分析。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程可以有如下 6 种状态：<br>•New (新创建）<br>•Runnable (可运行）<br>•Blocked (被阻塞）<br>•Waiting (等待）<br>•Timed waiting (计时等待）<br>•Terminated (被终止）<br>下一节对每一种状态进行解释。<br>要确定一个线程的当前状态， 可调用 getState 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread which has not yet started.</span><br><span class="line">         */</span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line">         * state is executing in the Java virtual machine but it may</span><br><span class="line">         * be waiting for other resources from the operating system</span><br><span class="line">         * such as processor.</span><br><span class="line">         */</span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">         * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line">         * to enter a synchronized block/method or</span><br><span class="line">         * reenter a synchronized block/method after calling</span><br><span class="line">         * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">         */</span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread.</span><br><span class="line">         * A thread is in the waiting state due to calling one of the</span><br><span class="line">         * following methods:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">         * perform a particular action.</span><br><span class="line">         *</span><br><span class="line">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="line">         * on an object is waiting for another thread to call</span><br><span class="line">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="line">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="line">         * is waiting for a specified thread to terminate.</span><br><span class="line">         */</span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">         * A thread is in the timed waiting state due to calling one of</span><br><span class="line">         * the following methods with a specified positive waiting time:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         */</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a terminated thread.</span><br><span class="line">         * The thread has completed execution.</span><br><span class="line">         */</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h2><p>当用 new 操作符创建一个新线程时，如 newThread(r)， 该线程还没有开始运行。这意味<br>着它的状态是 new。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在<br>线程运行之前还有一些基础工作要做。<br>那么所有创建线程的本质都是new Thread()</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123; System.out.printf(<span class="string">&quot;线程%s 正在执行&quot;</span>,Thread.currentThread().getName()); &#125;,<span class="string">&quot;thread-01&quot;</span>).start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;线程%s 是否有存活%s&quot;</span>,Thread.currentThread().getName(),Thread.currentThread().isAlive());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">控制台输出</span><br><span class="line">线程main 是否有存活<span class="keyword">true</span>线程thread-<span class="number">01</span> 正在执行Disconnected from the target VM, address: <span class="string">&#x27;127.0.0.1:53273&#x27;</span>, transport: <span class="string">&#x27;socket&#x27;</span></span><br></pre></td></tr></table></figure>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>并发编程专题</category>
      </categories>
      <tags>
        <tag>并发编程专题</tag>
      </tags>
  </entry>
  <entry>
    <title>字节跳动｜字节客户端｜一二三面+hr面（已Offer）</title>
    <url>/posts/20221018a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="一面｜45min"><a href="#一面｜45min" class="headerlink" title="一面｜45min"></a>一面｜45min</h2><p>1.输入url到页面展示过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入url地址</span><br><span class="line">应用层进行DNS解析</span><br><span class="line">应用层生成HTTP请求报文</span><br><span class="line">传输层建立TCP连接</span><br><span class="line">网络层使用IP协议来选择路线</span><br><span class="line">数据链路层实现网络相邻节点间可靠的数据通信</span><br><span class="line">物理层传输数据</span><br><span class="line">服务器处理反向传输</span><br><span class="line">服务器返回一个 HTTP 响应</span><br><span class="line">浏览器渲染</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/qinian8/article/details/99081105</span><br></pre></td></tr></table></figure>
<p>2.http和https的区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。</span><br><span class="line">HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。</span><br><span class="line"></span><br><span class="line">HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</span><br><span class="line"></span><br><span class="line">HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</span><br><span class="line"></span><br><span class="line">HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</span><br><span class="line">使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</span><br><span class="line">HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</span><br><span class="line">http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</span><br><span class="line">HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/guolin_blog/article/details/104546558</span><br></pre></td></tr></table></figure>
<p>3.数字证书的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）概念：</span><br><span class="line">数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。</span><br><span class="line"></span><br><span class="line">认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。</span><br><span class="line"></span><br><span class="line">2）数字证书颁发过程：</span><br><span class="line"></span><br><span class="line">数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。</span><br><span class="line"></span><br><span class="line">3）内容：</span><br><span class="line"></span><br><span class="line">数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：</span><br><span class="line"></span><br><span class="line">1、证书的版本信息；</span><br><span class="line"></span><br><span class="line">2、证书的序列号，每个证书都有一个唯一的证书序列号；</span><br><span class="line"></span><br><span class="line">3、证书所使用的签名算法；</span><br><span class="line"></span><br><span class="line">4、证书的发行机构名称，命名规则一般采用X.500格式；</span><br><span class="line"></span><br><span class="line">5、证书的有效期，通用的证书一般采用UTC时间格式；</span><br><span class="line"></span><br><span class="line">6、证书所有人的名称，命名规则一般采用X.500格式；</span><br><span class="line"></span><br><span class="line">7、证书所有人的公开密钥；</span><br><span class="line"></span><br><span class="line">8、证书发行者对证书的签名。</span><br></pre></td></tr></table></figure>
<p>4.对称加密和非对称加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对称加密：加密和解密用的是同一个密码或者同一套逻辑的加密方式。对称加密的致命性缺点就是无法保证秘钥的安全性。</span><br><span class="line">非对称加密:加密和解密用的秘钥不是同一个</span><br></pre></td></tr></table></figure>
<p>5.https用的是对称加密还是非对称加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段</span><br></pre></td></tr></table></figure>
<p>6.http头部有哪些内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">包括通用头，请求头，响应头和实体头</span><br><span class="line">1.通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、 Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理</span><br><span class="line">2.请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If- Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、 Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域,一般将会作为实体头域处理。</span><br><span class="line">3.响应消息的第一行为下面的格式： </span><br><span class="line">HTTP-Version Status-Code Reason-Phrase</span><br><span class="line"></span><br><span class="line">HTTP -Version表示支持的HTTP版本，例如为HTTP/1.1。</span><br><span class="line">Status- Code是一个三个数字的结果代码。</span><br><span class="line">Reason-Phrase给Status-Code提供一个简单的文本描述。</span><br><span class="line">4.请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。</span><br><span class="line"></span><br><span class="line">实体头域包含关于实体的原信息，实体头包括Allow、Content- Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法为接受方识别。</span><br></pre></td></tr></table></figure>
<p>7.线程和进程的区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个进程可以有多个线程,至少有一个线程</span><br><span class="line">根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</span><br></pre></td></tr></table></figure>
<p>8.进程通信的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 匿名管道通信</span><br><span class="line">2 高级管道通信</span><br><span class="line">3 有名管道通信</span><br><span class="line">4 消息队列通信</span><br><span class="line">5 信号量通信</span><br><span class="line">6 信号</span><br><span class="line">7 共享内存通信</span><br><span class="line">8 套接字通信</span><br></pre></td></tr></table></figure>
<p>9.线程的状态怎样转移</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程主要分为6种状态：初始，可运行，等待，超时等待，阻塞，终止</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>10.封装继承和多态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">封装的意义：</span><br><span class="line">　　封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。</span><br><span class="line">继承主要实现重用代码，节省开发时间。</span><br><span class="line">多态：</span><br><span class="line"></span><br><span class="line">1、“一个接口，多种方法”</span><br><span class="line"></span><br><span class="line">同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</span><br><span class="line"></span><br><span class="line">  多态的三个条件:</span><br><span class="line"> </span><br><span class="line"> a.    继承的存在(继承是多态的基础,没有继承就没有多态).</span><br><span class="line"> b.    子类重写父类的方法(多态下调用子类重写的方法).</span><br><span class="line"> c.    父类引用变量指向子类对象(子类到父类的类型转换).</span><br><span class="line"></span><br><span class="line">重载（overload）和重写（override）是实现多态的两种主要方式。</span><br><span class="line"></span><br><span class="line"> 　２、实现多态：</span><br><span class="line"></span><br><span class="line">接口多态性。</span><br><span class="line">继承多态性。</span><br><span class="line">通过抽象类实现的多态性。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>11.重载和重写的区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重写： 在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</span><br><span class="line">重载：在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。</span><br></pre></td></tr></table></figure>
<p>12.垃圾回收算法了解吗？怎么判断对象需要被回收？GC ROOTS有哪些</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">垃圾：已经不再被内存使用到的空间</span><br><span class="line"></span><br><span class="line">1.标记清除</span><br><span class="line">2.标记压缩</span><br><span class="line">3.可达性分析算法</span><br><span class="line">4.GC roots</span><br><span class="line">GC roots</span><br><span class="line">--</span><br><span class="line">1.虚拟机栈中的引用对象</span><br><span class="line">2.方法区中的类静态属性引用对象</span><br><span class="line">3.方法区中常量引用的对象</span><br><span class="line">4.本地方法栈Native方法引用的对象</span><br></pre></td></tr></table></figure>
<p>算法题一，回型打印二维数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayBackPrint &#123;</span><br><span class="line"> </span><br><span class="line">    public static void arrayBackPrint(int[][] nums) &#123;</span><br><span class="line">        if (nums == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;invalid param&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int top = 0;</span><br><span class="line">        int bottom =  nums.length - 1;</span><br><span class="line">        int left =0;</span><br><span class="line">        int right = nums[0].length - 1;</span><br><span class="line">        while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            for (int i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                System.out.print(nums[top][i] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            if (top &gt; bottom || left &gt; right) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = top; i &lt;= bottom; i++) &#123;</span><br><span class="line">                System.out.print(nums[i][right] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            if (top &gt; bottom || left &gt; right) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = right; i &gt;= left; i--) &#123;</span><br><span class="line">                System.out.print(nums[bottom][i] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            if (top &gt; bottom || left &gt; right) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = bottom; i &gt;= top; i--) &#123;</span><br><span class="line">                System.out.print(nums[i][left] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void arrayPrint(int[][] nums) &#123;</span><br><span class="line">        if (nums == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;invalid param&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; nums[0].length; j++) &#123;</span><br><span class="line">                System.out.print(nums[i][j] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void arrayInnit(int[][] nums) &#123;</span><br><span class="line">        if (nums == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;invalid param&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int num = 11;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; nums[0].length; j++) &#123;</span><br><span class="line">                nums[i][j] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        int[][] nums = new int[10][7];</span><br><span class="line">        int[][] nums = new int[10][10];</span><br><span class="line">        arrayInnit(nums);</span><br><span class="line">        arrayPrint(nums);</span><br><span class="line">        arrayBackPrint(nums);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二面｜20min"><a href="#二面｜20min" class="headerlink" title="二面｜20min"></a>二面｜20min</h2><p>1.重载和重写的区别（重复<br>2.静态方法能不能重写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重写的目的在于父类引用可以根据子类对象的运行时实际类型不同而调用不同实现代码，从而表现出多态。并且，静态方法无需创建对象即可使用，而重写的方法发挥作用，需要父类引用，和（不同的）子类对象</span><br></pre></td></tr></table></figure>
<p>3.只有返回值不同算不算重载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不算,编译都通过不了</span><br></pre></td></tr></table></figure>
<p>4.类的加载过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加载--验证--准备--解析--初始化--使用--卸载</span><br></pre></td></tr></table></figure>
<p>算法一，判断A是不是B的子树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    //分为两个函数，一个用于遍历节点当做子树的根节点，另一个用于判断是否是子树（必须要root2先空）</span><br><span class="line">    public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123;</span><br><span class="line">        if(root1==null||root2==null)</span><br><span class="line">            return false;</span><br><span class="line">        //此处用到一个技巧，直接判断isSubtree(root1,root2)，并且采取||的方式确定结果。</span><br><span class="line">        return isSubtree(root1,root2)||HasSubtree(root1.left,root2)||HasSubtree(root1.right,root2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean isSubtree(TreeNode root1,TreeNode root2)&#123;</span><br><span class="line">        if(root2==null)</span><br><span class="line">            return true;</span><br><span class="line">        if(root1==null)</span><br><span class="line">            return false;</span><br><span class="line">        if(root1.val==root2.val)</span><br><span class="line">            return isSubtree(root1.left,root2.left)&amp;&amp;</span><br><span class="line">            isSubtree(root1.right,root2.right);</span><br><span class="line">        else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三面｜50min"><a href="#三面｜50min" class="headerlink" title="三面｜50min"></a>三面｜50min</h2><p>1.问了前两面的表现具体说说<br>算法题一，给一个数n，和一个数组，用数组中的数组成最大的小于n的数，数组中的数可以重复使用（贪心）<br>算法题二，一个数组求max(a[i]-a[j])其中i小于j<br>数学题一：求log2的第10000位（答：会用二分求近似，不会做这个…换了抛硬币，应该是牛顿迭代没学过。。。<br>数学题二：AB轮流抛硬币，A先抛，抛到正面胜利，抛到反面对方接着抛，问A的胜率，等比数列求和，还好还记得等比数列求和公式。。。<br>2.数据库ACID<br>3.缺页中断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。</span><br></pre></td></tr></table></figure>
<p>4.页面置换算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">未来永远不会再使用的页面 or 未来最长时间不再被访问的页面</span><br></pre></td></tr></table></figure>
<p>5.http的无状态<br>6.为什么设计成无状态<br>7.你觉得什么样的代码算好的代码（瞎说挖了好多坑。。。<br>SOLLID<br>8.什么叫可拓展性好，举个例子<br>对扩展开放，对修改关闭<br>9.为啥要降低耦合度<br>10.你提到了设计模式，设计模式的七大原则是什么（7挖的坑…不会，设计模式只会单例模式<br>单一职责原则（Single Responsibility Principle）；—-通俗地说，即一个类只负责一项职责<br>开闭原则（Open Closed Principle）；—-开放-关闭原则表示软件实体 (类、模块、函数等等) 应该是可以被扩展的，但是不可被修改<br>里氏替换原则（Liskov Substitution Principle）；—-子类可以扩展父类的功能，但不能改变父类原有的功能<br>迪米特法则（Law of Demeter），又叫“最少知道法则”；—-最少知道原则，它表示一个对象应该对其它对象保持最少的了解。通俗来说就是，只与直接的朋友通信<br>接口隔离原则（Interface Segregation Principle）；—-客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。<br>依赖倒置原则（Dependence Inversion Principle）。—面向接口编程，理解了面向接口编程，也就理解了依赖倒转<br>组合/聚合复用原则 (Composite/Aggregate Reuse Principle)—-在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分; 新的对象通过向这些对象的委派达到复用已有功能的目的。<br>11.你的优势和缺陷<br>三面当天下午收到hr面邀请</p>
<p>hr面｜20min<br>聊了一些职业规划得问题略</p>
<p>作者：匿名用户<br>链接：<a href="https://leetcode.cn/circle/discuss/eBN2jJ/">https://leetcode.cn/circle/discuss/eBN2jJ/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode每日一题之817题链表组件</title>
    <url>/posts/20221012a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><ol start="817">
<li>链表组件 中等<br>给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。同时给定列表 nums，该列表是上述链表中整型值的一个子集。</li>
</ol>
<p>返回列表 nums 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 nums 中）构成的集合。<br>*</p>
<ul>
<li>输入: head = [0,1,2,3], nums = [0,1,3]<br>输出: 2<br>解释: 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 [0, 1] 是 nums 的一个组件，同理 [3] 也是一个组件，故返回 2。</li>
<li></li>
<li>输入: head = [0,1,2,3,4], nums = [0,3,1,4]<br>输出: 2<br>解释: 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int numComponents(ListNode head, int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        int count =0;</span><br><span class="line">        while (p != null)&#123;</span><br><span class="line">            if(set.contains(p.val) &amp;&amp; (p.next == null  || !set.contains(p.next.val))) count++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ListNode head = new ListNode();</span><br><span class="line">        ListNode nextNode;</span><br><span class="line">        nextNode=head;</span><br><span class="line">        int[] nodes = &#123;0,1,2&#125;;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;nodes.length;i++)&#123;</span><br><span class="line">            ListNode node = new ListNode(nodes[i]);</span><br><span class="line">            nextNode.next=node;</span><br><span class="line">            nextNode=nextNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] nums = &#123;0,2&#125;;</span><br><span class="line">        int i = numComponents(head, nums);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/817-2.jpg" alt="817"></p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode856括号的分数</title>
    <url>/posts/20221009a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>给定一个平衡括号字符串S，按下述规则计算该字符串的分数：<br>() 得 1 分。<br>AB 得A + B分，其中 A 和 B 是平衡括号字符串。<br>(A) 得2 * A分，其中 A 是平衡括号字符串。</p>
<p>示例 1：</p>
<p>输入： “()”<br>输出： 1<br>示例 2：</p>
<p>输入： “(())”<br>输出： 2<br>示例3：</p>
<p>输入： “()()”<br>输出： 2<br>示例4：</p>
<p>输入： “(()(()))”<br>输出： 6</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/score-of-parentheses">https://leetcode.cn/problems/score-of-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95%E6%8B%AC%E5%8F%B7.png" alt="暴力解法图解"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = S.length();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    n = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    n = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    sum += n;</span><br><span class="line">                &#125;</span><br><span class="line">                n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scoreOfParentheses2</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = S.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(-<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                    Integer pop = stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> (pop != -<span class="number">1</span>) &#123;</span><br><span class="line">                        temp += pop;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (temp == <span class="number">0</span>)</span><br><span class="line">                            stack.push(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            stack.push(temp * <span class="number">2</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            res += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">	空间复杂度：O(n)</span></span><br><span class="line"><span class="comment">    */</span>	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">scoreOfParentheses3</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; st = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        st.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                st.push(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> v = st.pop();</span><br><span class="line">                <span class="keyword">int</span> top = st.pop() + Math.max(<span class="number">2</span> * v, <span class="number">1</span>);</span><br><span class="line">                st.push(top);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;((((((())))()())))&quot;</span>;</span><br><span class="line">      <span class="comment">/*  System.out.println(scoreOfParentheses(s));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(scoreOfParentheses2(s));*/</span></span><br><span class="line"></span><br><span class="line">        System.out.println(scoreOfParentheses3(s));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%8E%8B%E6%A0%88%E6%8B%AC%E5%8F%B7.png" alt="压栈图解"></p>
<h2 id="大佬实现：耗时0ms"><a href="#大佬实现：耗时0ms" class="headerlink" title="大佬实现：耗时0ms"></a>大佬实现：耗时0ms</h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题目描述，我们需要对字符串s进行解析，并利用堆栈的特点帮助我们进行计算。以下图为例，s = “(()(()))”，遍历前两个字符都是‘(’，所以我们将‘(’执行入栈操作。遍历到的第三个字符是‘)’，我们要将栈顶元素弹出，发现可以匹配成一个括号，由于题目描述，一个“()”等于1，所以，我们将字符‘1’入栈。此时堆栈中的元素为[‘(‘, ‘1’]。具体操作如下图所示<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/1665287037-XCtbhA-image.png" alt="思路"><br>我们在继续遍历，由于第4和第5个字符都是‘(’，所以我们直接入栈即可。当遍历到第6个字符的时候，由于是‘)’，所以我们再次执行将栈顶元素踢出堆栈的操作，由于题目描述，一个“()”等于1，所以，我们将字符‘1’入栈。此时堆栈中的元素为[‘(‘, ‘1’,’(‘, ‘1’]。具体操作如下图所示：<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/1665287046-XplBvJ-image.png" alt="思路"><br>当遍历到第7个字符的时候，由于是‘)’，所以我们再次执行将栈顶元素踢出堆栈的操作，由于出栈的字符不是‘(’而是‘1’，所以我们继续踢出栈顶元素，此时出栈字符为‘(’，满足匹配题目中描述的(A) 得2 * A分的情况，所以计算出来的结果为 2*1 等于2，我们将字符‘2’入栈。此时堆栈中的元素为[‘(‘, ‘1’,’2’]<br>我们在继续向后遍历，由于第8个字符是‘)’，我们执行栈顶元素出栈操作，由于栈顶和次栈顶元素分别是‘2’和‘1’，都不是‘(’,所以继续执行栈顶出栈操作。然后这次出栈的元素是‘(’，可以匹配成一个括号，同时也满足了题目中描述的 AB 得A + B分 和 (A) 得2 * A分这两种情况。所以，计算结果为：2 * (1 + 2) 等于 6，在将6入栈。此时堆栈中的元素为[‘6’]。那么遍历s字符串完毕之后，我们将堆栈中所有元素值相加就是最终结果。具体操作，如下图所示：<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/1665287052-OhodXC-image.png" alt="思路"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/1665287060-StfKtU-image.png" alt="思路"></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> ArrayDeque();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) deque.addLast(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">char</span> c = deque.removeLast();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    deque.addLast(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((c = deque.removeLast()) != <span class="string">&#x27;(&#x27;</span>)  sum += c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    deque.addLast((<span class="keyword">char</span>) ((sum &lt;&lt; <span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) result += deque.removeLast() - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作者：muse-77<br>链接：<a href="https://leetcode.cn/problems/score-of-parentheses/solution/zhua-wa-mou-si-by-muse-77-hy72/">https://leetcode.cn/problems/score-of-parentheses/solution/zhua-wa-mou-si-by-muse-77-hy72/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode870题田忌赛马</title>
    <url>/posts/20221008a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="LeetCode870题"><a href="#LeetCode870题" class="headerlink" title="LeetCode870题"></a>LeetCode870题</h2><p>给定两个大小相等的数组nums1和nums2，nums1相对于 nums2 的优势可以用满足nums1[i] &gt; nums2[i]的索引 i的数目来描述。</p>
<p>返回 nums1的任意排列，使其相对于 nums2的优势最大化</p>
<p>示例 1：</p>
<p>输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]<br>输出：[2,11,7,15]<br>示例 2：</p>
<p>输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]<br>输出：[24,32,8,12]</p>
<p>提示：</p>
<p>1 &lt;= nums1.length &lt;= 105<br>nums2.length == nums1.length<br>0 &lt;= nums1[i], nums2[i] &lt;= 109</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/advantage-shuffle">https://leetcode.cn/problems/advantage-shuffle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/leetcode870.png" alt="LeetCode870题"></p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>有数组nums1和数组nums2,先将nums2的元素按着从大到小放入队列,且放入其下标位置<br>将nums1按着从小到大排列<br>依次取出队列中的元素<br>取出数组1的最后一个元素跟队列中的第一个元素比较，如果大于队列的第一个元素则将其放入结果数组的对应下标的位置如果小于队列第1个元素则数组1的最小元素放入其对应的下标</p>
<p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(2).png" alt="思路"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">2</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2 =&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] ints = advantageCount(nums1, nums2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">            System.out.println(anInt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] advantageCount(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2[<span class="number">0</span>] - o1[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//将nums2的元素按从大到小插入到队列中,并记录其下标</span></span><br><span class="line">        <span class="comment">//11,3    10,1    4,2   1,0</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums2[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重排序nums1</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = pq.poll();</span><br><span class="line">            <span class="keyword">if</span> (nums1[hi] &gt; arr[<span class="number">0</span>]) &#123;</span><br><span class="line">                ans[arr[<span class="number">1</span>]] = nums1[hi--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[arr[<span class="number">1</span>]] = nums1[lo++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>拉出一匹马,用我自己的比当前马大的所有马中最小的马去比,比的过则放入结果集，比不过则拉一匹最小的马放入结果集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] advantageCount(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">    <span class="comment">// 给 nums2 降序排序</span></span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; maxpq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (<span class="keyword">int</span>[] pair1, <span class="keyword">int</span>[] pair2) -&gt; &#123; </span><br><span class="line">            <span class="keyword">return</span> pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        maxpq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, nums2[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 nums1 升序排序</span></span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums1[left] 是最小值，nums1[right] 是最大值</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!maxpq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pair = maxpq.poll();</span><br><span class="line">        <span class="comment">// maxval 是 nums2 中的最大值，index 是对应索引</span></span><br><span class="line">        <span class="keyword">int</span> index = pair[<span class="number">0</span>], maxval = pair[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (maxval &lt; nums1[right]) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums1[right] 能胜过 maxval，那就直接上</span></span><br><span class="line">            res[index] = nums1[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 战胜不过，就用最小值去送</span></span><br><span class="line">            res[index] = nums1[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="官网解法"><a href="#官网解法" class="headerlink" title="官网解法"></a>官网解法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] advantageCount(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int n = nums1.length;</span><br><span class="line">        Integer[] idx1 = new Integer[n];</span><br><span class="line">        Integer[] idx2 = new Integer[n];</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            idx1[i] = i;</span><br><span class="line">            idx2[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(idx1, (i, j) -&gt; nums1[i] - nums1[j]);</span><br><span class="line">        Arrays.sort(idx2, (i, j) -&gt; nums2[i] - nums2[j]);</span><br><span class="line"></span><br><span class="line">        int[] ans = new int[n];</span><br><span class="line">        int left = 0, right = n - 1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums1[idx1[i]] &gt; nums2[idx2[left]]) &#123;</span><br><span class="line">                ans[idx2[left]] = nums1[idx1[i]];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans[idx2[right]] = nums1[idx1[i]];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/advantage-shuffle/solution/you-shi-xi-pai-by-leetcode-solution-sqsf/">https://leetcode.cn/problems/advantage-shuffle/solution/you-shi-xi-pai-by-leetcode-solution-sqsf/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos源码解析</title>
    <url>/posts/20220916a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="官网：https-nacos-io-zh-cn-docs-architecture-html"><a href="#官网：https-nacos-io-zh-cn-docs-architecture-html" class="headerlink" title="官网：https://nacos.io/zh-cn/docs/architecture.html"></a>官网：<a href="https://nacos.io/zh-cn/docs/architecture.html">https://nacos.io/zh-cn/docs/architecture.html</a></h2><h2 id="官方架构原理文档：https-developer-aliyun-com-ebook-36-10664-spm-a2c6h-26392459-ebook-detail-4-31b934e2j9LrWh"><a href="#官方架构原理文档：https-developer-aliyun-com-ebook-36-10664-spm-a2c6h-26392459-ebook-detail-4-31b934e2j9LrWh" class="headerlink" title="官方架构原理文档：https://developer.aliyun.com/ebook/36/10664?spm=a2c6h.26392459.ebook-detail.4.31b934e2j9LrWh"></a>官方架构原理文档：<a href="https://developer.aliyun.com/ebook/36/10664?spm=a2c6h.26392459.ebook-detail.4.31b934e2j9LrWh">https://developer.aliyun.com/ebook/36/10664?spm=a2c6h.26392459.ebook-detail.4.31b934e2j9LrWh</a></h2><h2 id="官网架构"><a href="#官网架构" class="headerlink" title="官网架构"></a>官网架构</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/nacos%E6%9E%B6%E6%9E%84.jpg" alt="架构"></p>
<h2 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/nacos.webp" alt="流程"></p>
<h2 id="官方文档中并未着重介绍动态刷新的原理-结合-RefreshScope和ContextRefresher来引出HostReactor"><a href="#官方文档中并未着重介绍动态刷新的原理-结合-RefreshScope和ContextRefresher来引出HostReactor" class="headerlink" title="官方文档中并未着重介绍动态刷新的原理,结合@RefreshScope和ContextRefresher来引出HostReactor"></a>官方文档中并未着重介绍动态刷新的原理,结合@RefreshScope和ContextRefresher来引出HostReactor</h2><h2 id="为何要看源码"><a href="#为何要看源码" class="headerlink" title="为何要看源码"></a>为何要看源码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提升技术功底：学习源码里的优秀设计思想,比如一些疑难问题的解决思路,还有一些优秀的设计模式,整体提升自己的技术功底</span><br><span class="line">深度掌握技术框架：源码看多了,对于一个新技术或框架的掌握速度会有大幅提升,看下框架demo大致就能知道底层的实现,技术框架更新再快也不怕</span><br><span class="line">快速定位线上问题：遇到线上问题,特别是框架源码里的问题(比如bug),能够快速定位,这就是相比其他没看过源码的人的优势</span><br><span class="line">对面试大有裨益：面试一线互联网公司对于框架技术一般都会问到源码级别的实现</span><br><span class="line">知其然知其所以然：对技术有追求的人必做之事,使用了一个好的框架,很想知道底层是如何实现的</span><br><span class="line">拥抱开源社区：参与到开源项目的研发,结识更多大牛,积累更多优质人脉</span><br></pre></td></tr></table></figure>
<h2 id="一、入口分析"><a href="#一、入口分析" class="headerlink" title="一、入口分析"></a>一、入口分析</h2><p>服务注册与发现@EnableDiscoveryClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(EnableDiscoveryClientImportSelector.class)</span><span class="comment">//@Import注解用来帮助我们把一些需要定义为Bean的类导入到IOC容器里面</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDiscoveryClient &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * If true, the ServiceRegistry will automatically register the local server.默认为true</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">autoRegister</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用autoRegister()方法时默认返回true,在本接口中还引入了ImportSelector类即@Import(EnableDiscoveryClientImportSelector.class),其中selectImports调用如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">public String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">	String[] imports <span class="operator">=</span> super.selectImports(metadata);</span><br><span class="line"></span><br><span class="line">	AnnotationAttributes attributes <span class="operator">=</span> AnnotationAttributes.fromMap(</span><br><span class="line">			metadata.getAnnotationAttributes(getAnnotationClass().getName(), <span class="literal">true</span>));</span><br><span class="line">	<span class="operator">/</span><span class="operator">/</span>获取本类的autoRegister属性</span><br><span class="line">	<span class="type">boolean</span> autoRegister <span class="operator">=</span> attributes.getBoolean(&quot;autoRegister&quot;);</span><br><span class="line"></span><br><span class="line">	if (autoRegister) &#123;</span><br><span class="line">		List<span class="operator">&lt;</span>String<span class="operator">&gt;</span> importsList <span class="operator">=</span> <span class="keyword">new</span> ArrayList<span class="operator">&lt;&gt;</span>(Arrays.asList(imports));</span><br><span class="line">		importsList.add(&quot;org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationConfiguration&quot;);</span><br><span class="line">		imports <span class="operator">=</span> importsList.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Environment env <span class="operator">=</span> getEnvironment();</span><br><span class="line">		if(ConfigurableEnvironment.class.isInstance(env)) &#123;</span><br><span class="line">			ConfigurableEnvironment configEnv <span class="operator">=</span> (ConfigurableEnvironment)env;</span><br><span class="line">			LinkedHashMap<span class="operator">&lt;</span>String, Object<span class="operator">&gt;</span> map <span class="operator">=</span> <span class="keyword">new</span> LinkedHashMap<span class="operator">&lt;&gt;</span>();</span><br><span class="line">			<span class="operator">/</span><span class="operator">/</span>注入yml文件属性</span><br><span class="line">			map.put(&quot;spring.cloud.service-registry.auto-registration.enabled&quot;, <span class="literal">false</span>);</span><br><span class="line">			MapPropertySource propertySource <span class="operator">=</span> <span class="keyword">new</span> MapPropertySource(</span><br><span class="line">					&quot;springCloudDiscoveryClient&quot;, map);</span><br><span class="line">			configEnv.getPropertySources().addLast(propertySource);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> imports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、META-INF-spring-factories"><a href="#二、META-INF-spring-factories" class="headerlink" title="二、META-INF/spring.factories"></a>二、META-INF/spring.factories</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.NacosDiscoveryAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.endpoint.NacosDiscoveryEndpointAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.registry.NacosServiceRegistryAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.NacosDiscoveryClientConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.reactive.NacosReactiveDiscoveryClientConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.configclient.NacosConfigServerAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.loadbalancer.LoadBalancerNacosAutoConfiguration,\</span><br><span class="line">  com.alibaba.cloud.nacos.NacosServiceAutoConfiguration</span><br><span class="line">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.configclient.NacosDiscoveryClientConfigServiceBootstrapConfiguration</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">  com.alibaba.cloud.nacos.discovery.logging.NacosLoggingListener</span><br></pre></td></tr></table></figure>
<p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/nacosdiscovery.jpg" alt="流程"><br>NacosDiscoveryAutoConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnDiscoveryEnabled</span></span><br><span class="line"><span class="meta">@ConditionalOnNacosDiscoveryEnabled</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosDiscoveryAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> NacosDiscoveryProperties <span class="title">nacosProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> NacosDiscoveryProperties();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> NacosServiceDiscovery <span class="title">nacosServiceDiscovery</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			NacosDiscoveryProperties discoveryProperties,</span></span></span><br><span class="line"><span class="params"><span class="function">			NacosServiceManager nacosServiceManager)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> NacosServiceDiscovery(discoveryProperties, nacosServiceManager);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、服务自动注册"><a href="#三、服务自动注册" class="headerlink" title="三、服务自动注册"></a>三、服务自动注册</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/SpringCloudCommons.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/serviceregistry.jpg" alt="流程"><br>Spring Cloud 有 Euerka、ZK、Nacos 等多种注册中心的实现,想要达到实现统一必须有一套规范,而Spring Cloud Commons 就是定义了这一规范。<br>Spring Cloud Commons里面的org.springframework.cloud.client.serviceregistry包下面有 AutoServiceRegistration、Registration、ServiceRegistry这三个接口,这是服务注册的核心接口<br>其中Registration继承了ServiceInstance,在ServiceInstance中规范了一个服务实例属性<br>1、AutoServiceRegistration用于服务自动注册。自动注册的意思就是,服务启动后自动把服务信息注册到注册中心。它的存在就是要规范实现必须要有自动注册.</p>
<p>2、Registration存储服务信息,用于规范将什么信息注册到注册中心,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Registration</span> <span class="keyword">extends</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The unique instance ID as registered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//注册的唯一ID</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">getInstanceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The service ID as registered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">String <span class="title">getServiceId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The hostname of the registered service instance.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">String <span class="title">getHost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The port of the registered service instance.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Whether the port of the registered service instance uses HTTPS.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	是否使用<span class="function">HTTPS</span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The service URI address.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">URI <span class="title">getUri</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The key / value pair metadata associated with the service instance.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Map&lt;String, String&gt; <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The scheme of the service instance.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	注册服务的约束</span><br><span class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3、ServiceRegistry用来注册或者注销服务,下线服务以及心跳检测等都可在此循迹</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span>&lt;<span class="title">R</span> <span class="keyword">extends</span> <span class="title">Registration</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Registers the registration. A registration typically has information about an</span></span><br><span class="line"><span class="comment">	 * instance, such as its hostname and port.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registration registration meta data</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(R registration)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Deregisters the registration.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registration registration meta data</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(R registration)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Closes the ServiceRegistry. This is a lifecycle method.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Sets the status of the registration. The status values are determined by the</span></span><br><span class="line"><span class="comment">	 * individual implementations.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registration The registration to update.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> status The status to set.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.cloud.client.serviceregistry.endpoint.ServiceRegistryEndpoint</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(R registration, String status)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Gets the status of a particular registration.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registration The registration to query.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &lt;T&gt; The type of the status.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The status of the registration.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.cloud.client.serviceregistry.endpoint.ServiceRegistryEndpoint</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getStatus</span><span class="params">(R registration)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、Nacos实现"><a href="#三、Nacos实现" class="headerlink" title="三、Nacos实现"></a>三、Nacos实现</h2><h2 id="NacosRegistration"><a href="#NacosRegistration" class="headerlink" title="NacosRegistration"></a>NacosRegistration</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosRegistration</span> <span class="keyword">implements</span> <span class="title">Registration</span>, <span class="title">ServiceInstance</span> </span></span><br></pre></td></tr></table></figure>
<h2 id="NacosServiceRegistry"><a href="#NacosServiceRegistry" class="headerlink" title="NacosServiceRegistry"></a>NacosServiceRegistry</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceRegistry</span> <span class="keyword">implements</span> <span class="title">ServiceRegistry</span>&lt;<span class="title">Registration</span>&gt; </span></span><br></pre></td></tr></table></figure>
<p>将配置文件封装为Instance实例,调用namingService.registerInstance(serviceId, instance)方法将服务注册到注册中心,在2.1.1当中则是通过NacosServiceManager来管理NameService的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">			Properties nacosProperties = nacosDiscoveryProperties.getNacosProperties();</span><br><span class="line">			nacosServiceManager.getNamingMaintainService(nacosProperties).updateInstance(</span><br><span class="line">					serviceId, nacosDiscoveryProperties.getGroup(), instance);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;update nacos instance status fail&quot;</span>, e);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NacosAutoServiceRegistration"><a href="#NacosAutoServiceRegistration" class="headerlink" title="NacosAutoServiceRegistration"></a>NacosAutoServiceRegistration</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NacosAutoServiceRegistration extends AbstractAutoServiceRegistration&lt;Registration&gt; </span><br><span class="line">  -&gt; public abstract class AbstractAutoServiceRegistration&lt;R extends Registration&gt;implements AutoServiceRegistration, ApplicationContextAware, ApplicationListener&lt;WebServerInitializedEvent&gt; &#123;</span><br></pre></td></tr></table></figure>
<p>通过间接实现ApplicationListener在服务启动时调用onApplicationEvent将服务注册到服务中心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; ApplicationListener&lt;PayloadApplicationEvent&lt;T&gt;&gt; forPayload(Consumer&lt;T&gt; consumer) &#123;</span><br><span class="line">        <span class="keyword">return</span> (event) -&gt; &#123;</span><br><span class="line">            consumer.accept(event.getPayload());</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(WebServerInitializedEvent event)</span> </span>&#123;</span><br><span class="line">		bind(event);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(WebServerInitializedEvent event)</span> </span>&#123;</span><br><span class="line">		ApplicationContext context = event.getApplicationContext();</span><br><span class="line">		<span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableWebServerApplicationContext) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;management&quot;</span>.equals(((ConfigurableWebServerApplicationContext) context).getServerNamespace())) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.port.compareAndSet(<span class="number">0</span>, event.getWebServer().getPort());</span><br><span class="line">		<span class="keyword">this</span>.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Discovery Lifecycle disabled. Not starting&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// only initialize if nonSecurePort is greater than 0 and it isn&#x27;t already running</span></span><br><span class="line">		<span class="comment">// because of containerPortInitializer below</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.running.get()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.context.publishEvent(<span class="keyword">new</span> InstancePreRegisteredEvent(<span class="keyword">this</span>, getRegistration()));</span><br><span class="line">			register();</span><br><span class="line">			<span class="keyword">if</span> (shouldRegisterManagement()) &#123;</span><br><span class="line">				registerManagement();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.context.publishEvent(<span class="keyword">new</span> InstanceRegisteredEvent&lt;&gt;(<span class="keyword">this</span>, getConfiguration()));</span><br><span class="line">			<span class="keyword">this</span>.running.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>publishiEvent则是在AbstractApplicationContext中调用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">监听器在消息源之后初始化,以便能够以在监听器实现中访问它。因此消息源实现不能发布事件。</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">		publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端如何向服务端注册"><a href="#客户端如何向服务端注册" class="headerlink" title="客户端如何向服务端注册"></a>客户端如何向服务端注册</h2><p>com.alibaba.cloud.nacos.registry.NacosServiceRegistry#register</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Registration registration)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">			log.warn(<span class="string">&quot;No service to register for nacos client...&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		NamingService namingService = namingService();</span><br><span class="line">		String serviceId = registration.getServiceId();</span><br><span class="line">		String group = nacosDiscoveryProperties.getGroup();</span><br><span class="line"></span><br><span class="line">		Instance instance = getNacosInstanceFromRegistration(registration);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			namingService.registerInstance(serviceId, group, instance);</span><br><span class="line">			log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, group, serviceId,</span><br><span class="line">					instance.getIp(), instance.getPort());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nacosDiscoveryProperties.isFailFast()) &#123;</span><br><span class="line">				log.error(<span class="string">&quot;nacos registry, &#123;&#125; register failed...&#123;&#125;,&quot;</span>, serviceId,</span><br><span class="line">						registration.toString(), e);</span><br><span class="line">				rethrowRuntimeException(e);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				log.warn(<span class="string">&quot;Failfast is false. &#123;&#125; register failed...&#123;&#125;,&quot;</span>, serviceId,</span><br><span class="line">						registration.toString(), e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">        String groupedServiceName = NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            BeatInfo beatInfo = beatReactor.buildBeatInfo(groupedServiceName, instance);</span><br><span class="line">            beatReactor.addBeatInfo(groupedServiceName, beatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        serverProxy.registerService(groupedServiceName, groupName, instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;[REGISTER-SERVICE] &#123;&#125; registering service &#123;&#125; with instance: &#123;&#125;&quot;</span>, namespaceId, serviceName,</span><br><span class="line">                instance);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">16</span>);</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, serviceName);</span><br><span class="line">        params.put(CommonParams.GROUP_NAME, groupName);</span><br><span class="line">        params.put(CommonParams.CLUSTER_NAME, instance.getClusterName());</span><br><span class="line">        params.put(<span class="string">&quot;ip&quot;</span>, instance.getIp());</span><br><span class="line">        params.put(<span class="string">&quot;port&quot;</span>, String.valueOf(instance.getPort()));</span><br><span class="line">        params.put(<span class="string">&quot;weight&quot;</span>, String.valueOf(instance.getWeight()));</span><br><span class="line">        params.put(<span class="string">&quot;enable&quot;</span>, String.valueOf(instance.isEnabled()));</span><br><span class="line">        params.put(<span class="string">&quot;healthy&quot;</span>, String.valueOf(instance.isHealthy()));</span><br><span class="line">        params.put(<span class="string">&quot;ephemeral&quot;</span>, String.valueOf(instance.isEphemeral()));</span><br><span class="line">        params.put(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.toJson(instance.getMetadata()));</span><br><span class="line">        </span><br><span class="line">        reqApi(UtilAndComs.nacosUrlInstance, params, HttpMethod.POST);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">reqApi</span><span class="params">(String api, Map&lt;String, String&gt; params, Map&lt;String, String&gt; body, List&lt;String&gt; servers,</span></span></span><br><span class="line"><span class="params"><span class="function">            String method)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, getNamespaceId());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(servers) &amp;&amp; StringUtils.isBlank(nacosDomain)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.INVALID_PARAM, <span class="string">&quot;no server available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NacosException exception = <span class="keyword">new</span> NacosException();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(nacosDomain)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxRetry; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> callServer(api, params, body, nacosDomain, method);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, nacosDomain, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">int</span> index = random.nextInt(servers.size());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; servers.size(); i++) &#123;</span><br><span class="line">                String server = servers.get(index);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> callServer(api, params, body, server, method);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, server, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                index = (index + <span class="number">1</span>) % servers.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.error(<span class="string">&quot;request: &#123;&#125; failed, servers: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>, api, servers, exception.getErrCode(),</span><br><span class="line">                exception.getErrMsg());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(exception.getErrCode(),</span><br><span class="line">                <span class="string">&quot;failed to req API:&quot;</span> + api + <span class="string">&quot; after all servers(&quot;</span> + servers + <span class="string">&quot;) tried: &quot;</span> + exception.getMessage());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HttpRestResult&lt;String&gt; restResult = nacosRestTemplate</span><br><span class="line">                    .exchangeForm(url, header, Query.newInstance().initParams(params), body, method, String.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@CanDistro</span><span class="comment">//在Distro协议中加以判断是否处理本服务。</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@Secured(action = ActionTypes.WRITE)</span> <span class="comment">//com.alibaba.nacos.auth.annotation.Secured权限控制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> String namespaceId = WebUtils</span><br><span class="line">                .optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">        <span class="keyword">final</span> String serviceName = WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">        NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Instance instance = HttpRequestInstanceBuilder.newBuilder()</span><br><span class="line">                .setDefaultInstanceEphemeral(switchDomain.isDefaultInstanceEphemeral()).setRequest(request).build();</span><br><span class="line">        </span><br><span class="line">        getInstanceOperator().registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">        NotifyCenter.publishEvent(<span class="keyword">new</span> RegisterInstanceTraceEvent(System.currentTimeMillis(), <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="keyword">false</span>, namespaceId, NamingUtils.getGroupName(serviceName), NamingUtils.getServiceName(serviceName),</span><br><span class="line">                instance.getIp(), instance.getPort()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> ephemeral = instance.isEphemeral();</span><br><span class="line">        String clientId = IpPortBasedClient.getClientId(instance.toInetAddr(), ephemeral);</span><br><span class="line">        createIpPortClientIfAbsent(clientId);</span><br><span class="line">        Service service = getService(namespaceId, serviceName, ephemeral);</span><br><span class="line">        clientOperationService.registerInstance(service, instance, clientId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在NacosServiceRegistry实例化的时候实例化nacosServiceManager,然后调用nacosServiceManager的getNamingService方法,构造实例化参数后<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/NacosServiceRegistry.jpg" alt="流程"></p>
<p>把服务放入serviceMap服务注册表中</p>
<p>初始化服务,创建一个健康检查的任务（主线–健康检查代码）</p>
<p>向一个队列中添加一个监听器（RecordListener类型）当监听到某些事件时会执行里面的onChange方法,Nacos大量运用了观察者设计模式,比如实例的注册、剔除等会被抽象成一个个的任务放到一个阻塞队列中,当监听到有任务时进来时,监听器会处理这些任务,执行onChange方法</p>
<p>com.alibaba.nacos.naming.consistency.RecordListener#onChange</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(String key, Service service)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Loggers.SRV_LOG.warn(<span class="string">&quot;received empty push from raft, key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(service.getNamespaceId())) &#123;</span><br><span class="line">                service.setNamespaceId(Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Loggers.RAFT.info(<span class="string">&quot;[RAFT-NOTIFIER] datum is changed, key: &#123;&#125;, value: &#123;&#125;&quot;</span>, key, service);</span><br><span class="line">            </span><br><span class="line">            Service oldDom = getService(service.getNamespaceId(), service.getName());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (oldDom != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldDom.update(service);</span><br><span class="line">                <span class="comment">// re-listen to handle the situation when the underlying listener is removed:</span></span><br><span class="line">                consistencyService</span><br><span class="line">                        .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">true</span>),</span><br><span class="line">                                oldDom);</span><br><span class="line">                consistencyService</span><br><span class="line">                        .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">false</span>),</span><br><span class="line">                                oldDom);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                putServiceAndInit(service);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Loggers.SRV_LOG.error(<span class="string">&quot;[NACOS-SERVICE] error while processing service update&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="addInstance"><a href="#addInstance" class="headerlink" title="addInstance"></a>addInstance</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="keyword">boolean</span> ephemeral, Instance... ips)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">       </span><br><span class="line">       String key = KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line">       </span><br><span class="line">       Service service = getService(namespaceId, serviceName);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">           List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line">           </span><br><span class="line">           Instances instances = <span class="keyword">new</span> Instances();</span><br><span class="line">           instances.setInstanceList(instanceList);</span><br><span class="line">           </span><br><span class="line">           consistencyService.put(key, instances);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="consistencyService"><a href="#consistencyService" class="headerlink" title="consistencyService"></a>consistencyService</h2><h3 id="AP"><a href="#AP" class="headerlink" title="AP"></a>AP</h3><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/ConsistencyService.jpg" alt="流程"><br>clientOperationService.registerInstance(service, instance, clientId)中调用了ServiceManager</p>
<h3 id="CP"><a href="#CP" class="headerlink" title="CP"></a>CP</h3><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/PersistentConsistencyServiceDelegateImpl.png" alt="流程"></p>
<p>Service:主要关心实例的变动</p>
<p>ServiceManager:主要关心服务的变动</p>
<p>SwitchManager:主要关心AP模型、CP模型的切换</p>
<h2 id="重要切换AP-CP命令"><a href="#重要切换AP-CP命令" class="headerlink" title="重要切换AP,CP命令"></a>重要切换AP,CP命令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">&#x27;$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Nacos-2-0源码分析-健康检查机制"><a href="#Nacos-2-0源码分析-健康检查机制" class="headerlink" title="Nacos 2.0源码分析-健康检查机制"></a>Nacos 2.0源码分析-健康检查机制</h2><p><font color="green">Nacos支持众多健康检查类型,心跳、HTTP、TCP、MySQL等类型</font><br>验证来自com.alibaba.nacos.api.naming.pojo.healthcheck.HealthCheckType</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * TCP type.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   TCP(Tcp.class),</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * HTTP type.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   HTTP(Http.class),</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * MySQL type.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   MYSQL(Mysql.class),</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * No check.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   NONE(AbstractHealthChecker.None.class);</span><br></pre></td></tr></table></figure>

<p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.jpg" alt="流程"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      BeatInfo beatInfo;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">BeatTask</span><span class="params">(BeatInfo beatInfo)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.beatInfo = beatInfo;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (beatInfo.isStopped()) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">long</span> nextTime = beatInfo.getPeriod();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//发送心跳续约</span></span><br><span class="line">          	<span class="comment">//lightBeatEnabled默认值为false</span></span><br><span class="line">              JsonNode result = serverProxy.sendBeat(beatInfo, BeatReactor.<span class="keyword">this</span>.lightBeatEnabled);</span><br><span class="line">              <span class="keyword">long</span> interval = result.get(CLIENT_BEAT_INTERVAL_FIELD).asLong();</span><br><span class="line">              <span class="keyword">boolean</span> lightBeatEnabled = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">if</span> (result.has(CommonParams.LIGHT_BEAT_ENABLED)) &#123;</span><br><span class="line">                  lightBeatEnabled = result.get(CommonParams.LIGHT_BEAT_ENABLED).asBoolean();</span><br><span class="line">              &#125;</span><br><span class="line">              BeatReactor.<span class="keyword">this</span>.lightBeatEnabled = lightBeatEnabled;</span><br><span class="line">              <span class="keyword">if</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  nextTime = interval;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">int</span> code = NamingResponseCode.OK;</span><br><span class="line">              <span class="keyword">if</span> (result.has(CommonParams.CODE)) &#123;</span><br><span class="line">                  code = result.get(CommonParams.CODE).asInt();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (code == NamingResponseCode.RESOURCE_NOT_FOUND) &#123;</span><br><span class="line">                  Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">                  instance.setPort(beatInfo.getPort());</span><br><span class="line">                  instance.setIp(beatInfo.getIp());</span><br><span class="line">                  instance.setWeight(beatInfo.getWeight());</span><br><span class="line">                  instance.setMetadata(beatInfo.getMetadata());</span><br><span class="line">                  instance.setClusterName(beatInfo.getCluster());</span><br><span class="line">                  instance.setServiceName(beatInfo.getServiceName());</span><br><span class="line">                  instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">                  instance.setEphemeral(<span class="keyword">true</span>);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      serverProxy.registerService(beatInfo.getServiceName(),</span><br><span class="line">                              NamingUtils.getGroupName(beatInfo.getServiceName()), instance);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (NacosException ex) &#123;</span><br><span class="line">              NAMING_LOGGER.error(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                      JacksonUtils.toJson(beatInfo), ex.getErrCode(), ex.getErrMsg());</span><br><span class="line">  </span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception unknownEx) &#123;</span><br><span class="line">              NAMING_LOGGER.error(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, unknown exception msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                      JacksonUtils.toJson(beatInfo), unknownEx.getMessage(), unknownEx);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              executorService.schedule(<span class="keyword">new</span> BeatTask(beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JsonNode <span class="title">sendBeat</span><span class="params">(BeatInfo beatInfo, <span class="keyword">boolean</span> lightBeatEnabled)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">          NAMING_LOGGER.debug(<span class="string">&quot;[BEAT] &#123;&#125; sending beat to server: &#123;&#125;&quot;</span>, namespaceId, beatInfo.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">      Map&lt;String, String&gt; bodyMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (!lightBeatEnabled) &#123;</span><br><span class="line">          bodyMap.put(<span class="string">&quot;beat&quot;</span>, JacksonUtils.toJson(beatInfo));</span><br><span class="line">      &#125;</span><br><span class="line">      params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">      params.put(CommonParams.SERVICE_NAME, beatInfo.getServiceName());</span><br><span class="line">      params.put(CommonParams.CLUSTER_NAME, beatInfo.getCluster());</span><br><span class="line">      params.put(IP_PARAM, beatInfo.getIp());</span><br><span class="line">      params.put(PORT_PARAM, String.valueOf(beatInfo.getPort()));</span><br><span class="line">      String result = reqApi(UtilAndComs.nacosUrlBase + <span class="string">&quot;/instance/beat&quot;</span>, params, bodyMap, HttpMethod.PUT);</span><br><span class="line">      <span class="keyword">return</span> JacksonUtils.toObj(result);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务端处理心跳续约"><a href="#服务端处理心跳续约" class="headerlink" title="服务端处理心跳续约"></a>服务端处理心跳续约</h2><p>com.alibaba.nacos.naming.controllers.InstanceController#beat</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ObjectNode <span class="title">beat</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       </span><br><span class="line">       ObjectNode result = JacksonUtils.createEmptyJsonNode();</span><br><span class="line">       result.put(SwitchEntry.CLIENT_BEAT_INTERVAL, switchDomain.getClientBeatInterval());</span><br><span class="line">       </span><br><span class="line">       String beat = WebUtils.optional(request, <span class="string">&quot;beat&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">       RsInfo clientBeat = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isNotBlank(beat)) &#123;</span><br><span class="line">           clientBeat = JacksonUtils.toObj(beat, RsInfo.class);</span><br><span class="line">       &#125;</span><br><span class="line">       String clusterName = WebUtils</span><br><span class="line">               .optional(request, CommonParams.CLUSTER_NAME, UtilsAndCommons.DEFAULT_CLUSTER_NAME);</span><br><span class="line">       String ip = WebUtils.optional(request, <span class="string">&quot;ip&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">       <span class="keyword">int</span> port = Integer.parseInt(WebUtils.optional(request, <span class="string">&quot;port&quot;</span>, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">       <span class="keyword">if</span> (clientBeat != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isNotBlank(clientBeat.getCluster())) &#123;</span><br><span class="line">               clusterName = clientBeat.getCluster();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// fix #2533</span></span><br><span class="line">               clientBeat.setCluster(clusterName);</span><br><span class="line">           &#125;</span><br><span class="line">           ip = clientBeat.getIp();</span><br><span class="line">           port = clientBeat.getPort();</span><br><span class="line">       &#125;</span><br><span class="line">       String namespaceId = WebUtils.optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">       String serviceName = WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">       <span class="comment">//校验服务名格式</span></span><br><span class="line">       NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">       Loggers.SRV_LOG.debug(<span class="string">&quot;[CLIENT-BEAT] full arguments: beat: &#123;&#125;, serviceName: &#123;&#125;, namespaceId: &#123;&#125;&quot;</span>, clientBeat,</span><br><span class="line">               serviceName, namespaceId);</span><br><span class="line">       BeatInfoInstanceBuilder builder = BeatInfoInstanceBuilder.newBuilder();</span><br><span class="line">       builder.setRequest(request);</span><br><span class="line">       <span class="comment">//获取实例信息</span></span><br><span class="line">       <span class="keyword">int</span> resultCode = getInstanceOperator()</span><br><span class="line">               .handleBeat(namespaceId, serviceName, ip, port, clusterName, clientBeat, builder);</span><br><span class="line">       result.put(CommonParams.CODE, resultCode);</span><br><span class="line">       result.put(SwitchEntry.CLIENT_BEAT_INTERVAL,</span><br><span class="line">               getInstanceOperator().getHeartBeatInterval(namespaceId, serviceName, ip, port, clusterName));</span><br><span class="line">       result.put(SwitchEntry.LIGHT_BEAT_ENABLED, switchDomain.isLightBeatEnabled());</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在2.1.1当中getInstanceOperator().handleBeat(namespaceId, serviceName, ip, port, clusterName, clientBeat, builder);封装了对Service的处理包含开启续约,更新客户端心跳时间<br>分为客户端和服务端<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/handleBeat.png" alt="流程"><br>对于服务端我们看下service#handleBeat</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">handleBeat</span><span class="params">(String namespaceId, String serviceName, String ip, <span class="keyword">int</span> port, String cluster,</span></span></span><br><span class="line"><span class="params"><span class="function">            RsInfo clientBeat, BeatInfoInstanceBuilder builder)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        com.alibaba.nacos.naming.core.Instance instance = serviceManager</span><br><span class="line">                .getInstance(namespaceId, serviceName, cluster, ip, port);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clientBeat == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> NamingResponseCode.RESOURCE_NOT_FOUND;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Loggers.SRV_LOG.warn(<span class="string">&quot;[CLIENT-BEAT] The instance has been removed for health mechanism, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;perform data compensation operations, beat: &#123;&#125;, serviceName: &#123;&#125;&quot;</span>, clientBeat, serviceName);</span><br><span class="line">            instance = parseInstance(builder.setBeatInfo(clientBeat).setServiceName(serviceName).build());</span><br><span class="line">            serviceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取服务实例</span></span><br><span class="line">        Service service = serviceManager.getService(namespaceId, serviceName);</span><br><span class="line">        <span class="comment">//检查服务是否为空</span></span><br><span class="line">        serviceManager.checkServiceIsNull(service, namespaceId, serviceName);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (clientBeat == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clientBeat = <span class="keyword">new</span> RsInfo();</span><br><span class="line">            clientBeat.setIp(ip);</span><br><span class="line">            clientBeat.setPort(port);</span><br><span class="line">            clientBeat.setCluster(cluster);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//服务续约</span></span><br><span class="line">        service.processClientBeat(clientBeat);</span><br><span class="line">        <span class="keyword">return</span> NamingResponseCode.OK;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedule client beat check task without a delay.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task health check task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> scheduled future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledFuture&lt;?&gt; scheduleNow(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">return</span> GlobalExecutor.scheduleNamingHealth(task, <span class="number">0</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    将心跳时间设置为当前时间</span><br></pre></td></tr></table></figure>
<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>com.alibaba.nacos.naming.core.ServiceManager#putServiceAndInit</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putServiceAndInit</span><span class="params">(Service service)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        putService(service);</span><br><span class="line">        service = getService(service.getNamespaceId(), service.getName());</span><br><span class="line">        service.init();</span><br><span class="line">        consistencyService</span><br><span class="line">                .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">true</span>), service);</span><br><span class="line">        consistencyService</span><br><span class="line">                .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">false</span>), service);</span><br><span class="line">        Loggers.SRV_LOG.info(<span class="string">&quot;[NEW-SERVICE] &#123;&#125;&quot;</span>, service.toJson());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Init service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HealthCheckReactor.scheduleCheck(clientBeatCheckTask);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Cluster&gt; entry : clusterMap.entrySet()) &#123;</span><br><span class="line">            entry.getValue().setService(<span class="keyword">this</span>);</span><br><span class="line">            entry.getValue().init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="健康检查任务"><a href="#健康检查任务" class="headerlink" title="健康检查任务"></a>健康检查任务</h2><h3 id="ClientBeatCheckTask"><a href="#ClientBeatCheckTask" class="headerlink" title="ClientBeatCheckTask"></a>ClientBeatCheckTask</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getInstanceHeartBeatTimeOut()) </span><br><span class="line">getInstanceHeartBeatTimeOut</span><br><span class="line">15秒</span><br><span class="line"></span><br><span class="line">public static final long DEFAULT_HEART_BEAT_TIMEOUT = TimeUnit.SECONDS.toMillis(15);</span><br><span class="line">    </span><br><span class="line">public static final long DEFAULT_IP_DELETE_TIMEOUT = TimeUnit.SECONDS.toMillis(30);</span><br><span class="line">    </span><br><span class="line">public static final long DEFAULT_HEART_BEAT_INTERVAL = TimeUnit.SECONDS.toMillis(5);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// If upgrade to 2.0.X stop health check with v1</span></span><br><span class="line">            <span class="keyword">if</span> (ApplicationUtils.getBean(UpgradeJudgement.class).isUseGrpcFeatures()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!getDistroMapper().responsible(service.getName())) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!getSwitchDomain().isHealthCheckEnabled()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            List&lt;Instance&gt; instances = service.allIPs(<span class="keyword">true</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// first set health status of instances:</span></span><br><span class="line">            <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getInstanceHeartBeatTimeOut()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!instance.isMarked()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (instance.isHealthy()) &#123;</span><br><span class="line">                            instance.setHealthy(<span class="keyword">false</span>);</span><br><span class="line">                            Loggers.EVT_LOG</span><br><span class="line">                                    .info(<span class="string">&quot;&#123;POS&#125; &#123;IP-DISABLED&#125; valid: &#123;&#125;:&#123;&#125;@&#123;&#125;@&#123;&#125;, region: &#123;&#125;, msg: client timeout after &#123;&#125;, last beat: &#123;&#125;&quot;</span>,</span><br><span class="line">                                            instance.getIp(), instance.getPort(), instance.getClusterName(),</span><br><span class="line">                                            service.getName(), UtilsAndCommons.LOCALHOST_SITE,</span><br><span class="line">                                            instance.getInstanceHeartBeatTimeOut(), instance.getLastBeat());</span><br><span class="line">                            getPushService().serviceChanged(service);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!getGlobalConfig().isExpireInstance()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// then remove obsolete instances:</span></span><br><span class="line">            <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (instance.isMarked()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当超过30秒无响应则删除</span></span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getIpDeleteTimeout()) &#123;</span><br><span class="line">                    <span class="comment">// delete instance</span></span><br><span class="line">                    Loggers.SRV_LOG.info(<span class="string">&quot;[AUTO-DELETE-IP] service: &#123;&#125;, ip: &#123;&#125;&quot;</span>, service.getName(),</span><br><span class="line">                            JacksonUtils.toJson(instance));</span><br><span class="line">                    deleteIp(instance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.SRV_LOG.warn(<span class="string">&quot;Exception while processing client beat time out.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>总结：Zookeeper中在进行服务注册的时候,发起一个长连接,比如用Nio或者Netty,会一直占用管道,而Nacos只是发起一个http请求,发起请求后就结束了,Nacos在1.4.x版本中是典型的短链接（当然2.0后改用gRpc长连接）,而Zk采用长连接方式建立通道,如果在客户端服务器非常非常多,会比较耗性能的,Nacos相比会轻量不少哦,Zk为了保证服务变动的一致性,监听回调机制就会立刻通知到客户端,响应是很及时的,所以Zk保证了Cp,Nacos有两块保证了心跳,一块是客户端的定时拉取,一块是udp反向推送,即便udp丢失了,也有定时任务兜底。</p>
<h2 id="TcpHealthCheckProcessor"><a href="#TcpHealthCheckProcessor" class="headerlink" title="TcpHealthCheckProcessor"></a>TcpHealthCheckProcessor</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/HealthCheckProcess.png" alt="HealthCheckProcess"><br>com.alibaba.nacos.naming.healthcheck.v2.processor.TcpHealthCheckProcessor </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpSuperSenseProcessor</span> <span class="keyword">implements</span> <span class="title">HealthCheckProcessor</span>, <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE = <span class="string">&quot;TCP&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HealthCheckCommon healthCheckCommon;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SwitchDomain switchDomain;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了定义类型之外都会有的共同属性healthCheckCommon和switchDomain,其实现实在内部类的Beat.finishCheck方法中<br>判断是否健康</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHealthy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis() - startTime &lt; TimeUnit.SECONDS.toMillis(<span class="number">30L</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里checkok的方法也是调用Distro协议来判断当前ip在集群中的服务是否需要处理,当需要时返回true,此时就会将ip设置为健康,并将服务的最后一次修改时间设置为当前时间,服务监听器推送当前服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NotifyCenter.publishEvent(<span class="keyword">new</span> HealthStateChangeTraceEvent(System.currentTimeMillis(),</span><br><span class="line">                                service.getNamespaceId(), service.getGroupName(), service.getName(), ip.getIp(), ip.getPort(),</span><br><span class="line">                                <span class="keyword">true</span>, msg));</span><br></pre></td></tr></table></figure>



<h1 id="Nacos一致性协议"><a href="#Nacos一致性协议" class="headerlink" title="Nacos一致性协议"></a>Nacos一致性协议</h1><p><font color="red">分布式一致性协议有很多,例如Paxos协议,Zab协议,Raft协议,而Nacos采用的是Distro协议和Raft协议。对于非临时数据,Nacos采用的是Raft协议,而临时数据Nacos采用的是Distro协议。简单说一下Distro,Distro协议被定位为临时数据的一致性协议：该类型协议不需要把数据存储到磁盘或者数据库,因为临时数据通常和服务器保持一个session会话,该会话只要存在,数据就不会丢失</font></p>
<h2 id="Distro协议"><a href="#Distro协议" class="headerlink" title="Distro协议"></a>Distro协议</h2><p>Distro 协议是 Nacos 对于临时实例数据开发的一致性协议。其数据存储在缓存中,并且会在启动时进行全量数据同步,并定期进行数据校验。</p>
<p>在 Distro 协议的设计思想下,每个 Distro 节点都可以接收到读写请求。所有的 Distro 协议的请求场景主要分为三种情况：</p>
<p>1、当该节点接收到属于该节点负责的实例的写请求时,直接写入。</p>
<p>2、当该节点接收到不属于该节点负责的实例的写请求时,将在集群内部路由,转发给对应的节点,从而完成读写。</p>
<p>3、当该节点接收到任何读请求时,都直接在本机查询并返回（因为所有实例都被同步到了每台机器上）。</p>
<p>Distro 协议作为 Nacos 的内嵌临时实例一致性协议,保证了在分布式环境下每个节点上面的服务信息的状态都能够及时地通知其他节点,可以维持数十万量级服务实例的存储和一致性。</p>
<p>Nacos中有CP和AP两种模式,而这两种模式在实现数据一致性方案上面是完全不一样的,对于CP模式而言,使用的是raft这种强一致性协议,对于AP模式而言,则是使用阿里自创的Distro协议<br>在上文中对服务的注册中,调用instanceController当中的register方法时实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CanDistro</span><span class="comment">//在Distro协议中加以判断是否处理本服务。</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@Secured(action = ActionTypes.WRITE)</span><span class="comment">//com.alibaba.nacos.auth.annotation.Secured权限控制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> String namespaceId = WebUtils</span><br><span class="line">            .optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">    <span class="keyword">final</span> String serviceName = WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">    <span class="comment">//服务名中不能带有@@,服务名不能为空</span></span><br><span class="line">    NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Instance instance = HttpRequestInstanceBuilder.newBuilder()</span><br><span class="line">            .setDefaultInstanceEphemeral(switchDomain.isDefaultInstanceEphemeral()).setRequest(request).build();</span><br><span class="line">    </span><br><span class="line">    getInstanceOperator().registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">    NotifyCenter.publishEvent(<span class="keyword">new</span> RegisterInstanceTraceEvent(System.currentTimeMillis(), <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="keyword">false</span>, namespaceId, NamingUtils.getGroupName(serviceName), NamingUtils.getServiceName(serviceName),</span><br><span class="line">            instance.getIp(), instance.getPort()));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> ephemeral = instance.isEphemeral();</span><br><span class="line">    String clientId = IpPortBasedClient.getClientId(instance.toInetAddr(), ephemeral);</span><br><span class="line">    createIpPortClientIfAbsent(clientId);</span><br><span class="line">    Service service = getService(namespaceId, serviceName, ephemeral);</span><br><span class="line">    clientOperationService.registerInstance(service, instance, clientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中CanDistro则是跟Distro协议有关<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/DistroFilter.jpg" alt="DistroFilter"><br>来自nacos2.1.1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">       ReuseHttpServletRequest req = <span class="keyword">new</span> ReuseHttpServletRequest((HttpServletRequest) servletRequest);</span><br><span class="line">       HttpServletResponse resp = (HttpServletResponse) servletResponse;</span><br><span class="line">       </span><br><span class="line">       String urlString = req.getRequestURI();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isNotBlank(req.getQueryString())) &#123;</span><br><span class="line">           urlString += <span class="string">&quot;?&quot;</span> + req.getQueryString();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       	  <span class="comment">//获取方法</span></span><br><span class="line">           Method method = controllerMethodsCache.getMethod(req);</span><br><span class="line">           </span><br><span class="line">           String path = <span class="keyword">new</span> URI(req.getRequestURI()).getPath();</span><br><span class="line">           <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(req.getMethod() + <span class="string">&quot; &quot;</span> + path);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//是否有CanDistro注解</span></span><br><span class="line">           <span class="keyword">if</span> (!method.isAnnotationPresent(CanDistro.class)) &#123;</span><br><span class="line">               filterChain.doFilter(req, resp);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           String distroTag = distroTagGenerator.getResponsibleTag(req);</span><br><span class="line">           <span class="comment">//判断是否处理这个请求,需要处理则直接放行</span></span><br><span class="line">           <span class="keyword">if</span> (distroMapper.responsible(distroTag)) &#123;</span><br><span class="line">               filterChain.doFilter(req, resp);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// proxy request to other server if necessary:</span></span><br><span class="line">           String userAgent = req.getHeader(HttpHeaderConsts.USER_AGENT_HEADER);</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isNotBlank(userAgent) &amp;&amp; userAgent.contains(UtilsAndCommons.NACOS_SERVER_HEADER)) &#123;</span><br><span class="line">               <span class="comment">// This request is sent from peer server, should not be redirected again:</span></span><br><span class="line">               Loggers.SRV_LOG.error(<span class="string">&quot;receive invalid redirect request from peer &#123;&#125;&quot;</span>, req.getRemoteAddr());</span><br><span class="line">               resp.sendError(HttpServletResponse.SC_BAD_REQUEST,</span><br><span class="line">                       <span class="string">&quot;receive invalid redirect request from peer &quot;</span> + req.getRemoteAddr());</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">final</span> String targetServer = distroMapper.mapSrv(distroTag);</span><br><span class="line">           </span><br><span class="line">           List&lt;String&gt; headerList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">           Enumeration&lt;String&gt; headers = req.getHeaderNames();</span><br><span class="line">           <span class="keyword">while</span> (headers.hasMoreElements()) &#123;</span><br><span class="line">               String headerName = headers.nextElement();</span><br><span class="line">               headerList.add(headerName);</span><br><span class="line">               headerList.add(req.getHeader(headerName));</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">final</span> String body = IoUtils.toString(req.getInputStream(), StandardCharsets.UTF_8.name());</span><br><span class="line">           <span class="keyword">final</span> Map&lt;String, String&gt; paramsValue = HttpClient.translateParameterMap(req.getParameterMap());</span><br><span class="line">           </span><br><span class="line">           RestResult&lt;String&gt; result = HttpClient</span><br><span class="line">                   .request(HTTP_PREFIX + targetServer + req.getRequestURI(), headerList, paramsValue, body,</span><br><span class="line">                           PROXY_CONNECT_TIMEOUT, PROXY_READ_TIMEOUT, StandardCharsets.UTF_8.name(), req.getMethod());</span><br><span class="line">           String data = result.ok() ? result.getData() : result.getMessage();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               WebUtils.response(resp, data, result.getCode());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">               Loggers.SRV_LOG.warn(<span class="string">&quot;[DISTRO-FILTER] request failed: &quot;</span> + distroMapper.mapSrv(distroTag) + urlString);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (AccessControlException e) &#123;</span><br><span class="line">           resp.sendError(HttpServletResponse.SC_FORBIDDEN, <span class="string">&quot;access denied: &quot;</span> + ExceptionUtil.getAllExceptionMsg(e));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">           resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED,</span><br><span class="line">                   <span class="string">&quot;no such api:&quot;</span> + req.getMethod() + <span class="string">&quot;:&quot;</span> + req.getRequestURI());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Loggers.SRV_LOG.warn(<span class="string">&quot;[DISTRO-FILTER] Server failed: &quot;</span>, e);</span><br><span class="line">           resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,</span><br><span class="line">                   <span class="string">&quot;Server failed, &quot;</span> + ExceptionUtil.getAllExceptionMsg(e));</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DistroFilter这个类是实现了Filter接口,所以表明了它是一个过滤器,在请求来的时候,会经过doFilter方法,在doFilter方法中大概有下面4个过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>根据请求路径从controllerMethodsCache中获取到对应的controller方法</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>判断这个controller方法是否有<span class="meta">@CanDistro</span>注解,如果有的话再调用distroMapper.responsible()方法去判断当前nacos节点是否需要处理这个请求</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>如果controller方法没有<span class="meta">@CanDistro</span>注解,或者有<span class="meta">@CanDistro</span>注解并且当前nacos节点需要处理这个请求,那么就直接放行这个请求到controller端</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>反之如果controller方法有<span class="meta">@CanDistro</span>注解并且当前nacos节点不需要处理这个请求,那么就会把这个请求转发到对应的其他节点去处理</span><br></pre></td></tr></table></figure>
<p>其中第一点中从controllerMethodsCache中获取对应的controller方法,那么是怎么获取的呢？所以我们要看下ControllerMethodsCache中的getMethod方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">private static final Logger LOGGER = LoggerFactory.getLogger(ControllerMethodsCache.<span class="keyword">class</span>);</span><br><span class="line">    </span><br><span class="line">    private ConcurrentMap&lt;RequestMappingInfo, Method&gt; methods = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    private final ConcurrentMap&lt;String, <span class="type">List</span>&lt;RequestMappingInfo&gt;&gt; urlLookup = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public Method getMethod(HttpServletRequest request) &#123;</span><br><span class="line">        String path = getPath(request);</span><br><span class="line">        String httpMethod = request.getMethod();</span><br><span class="line">        String urlKey = httpMethod + REQUEST_PATH_SEPARATOR + path.replaceFirst(EnvUtil.getContextPath(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">List</span>&lt;RequestMappingInfo&gt; requestMappingInfos = urlLookup.get(urlKey);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(requestMappingInfos)) &#123;</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">List</span>&lt;RequestMappingInfo&gt; matchedInfo = findMatchedInfo(requestMappingInfos, request);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(matchedInfo)) &#123;</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        RequestMappingInfo bestMatch = matchedInfo.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (matchedInfo.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            RequestMappingInfoComparator comparator = new RequestMappingInfoComparator();</span><br><span class="line">            matchedInfo.sort(comparator);</span><br><span class="line">            bestMatch = matchedInfo.get(<span class="number">0</span>);</span><br><span class="line">            RequestMappingInfo secondBestMatch = matchedInfo.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">                throw new IllegalStateException(</span><br><span class="line">                        <span class="string">&quot;Ambiguous methods mapped for &#x27;&quot;</span> + request.getRequestURI() + <span class="string">&quot;&#x27;: &#123;&quot;</span> + bestMatch + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + secondBestMatch + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methods.get(bestMatch);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用链如下<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/ConsoleConfig.jpg" alt="ConsoleConfig"><br>可以看到源头是在一个叫ConsoleConfig的类的init方法开始的,并且这个init方法加了@PostConstruct注解,表示在spring容器启动的时候就能够被调用该方法,在init方法中,调用了4次ControllerMethodsCache的initClassMethod方法,分别传了不同的包名,在initClassMethod方法中会根据传入的包名然后找到加了@RequestMapping注解的类,然后寻找每一个类中加了@RequestMapping注解的方法,然后构造出一个RequestMappingInfo对象,其中给这个RequestMappingInfo对象设置两个校验,一个是请求路径的校验,一个是请求参数的校验,然后把urlKey和RequestMappingInfo对象放到urlLookup这个map中,再把RequestMappingInfo对象和controller方法放到methods这个map中。所以经过上面的分析,我们可以做一个小总结,在spring容器启动的时候,nacos就会在指定的几个包名下找到所有加了@RequestMapping注解的controller类,然后再找到这些类下面加了@RequestMapping注解的方法,再构造出一个RequestMappingInfo校验对象用来对请求路径和请求参数进行校验匹配,而请求路径的检验是根据@RequestMapping注解指定的请求方式以及请求路径去构造出一个urlKey作为校验匹配的条件,请求参数校验则是根据@RequestMapping注解中的params属性作为检验匹配的条件,最终就会把这个RequestMappingInfo校验对象和对应的controller方法放到methods这个map中了。所以当有请求过来的时候,DistroFilter会进行拦截,首先会根据请求路径构造出urlKey,再根据urlKey找到对应的RequestMappingInfo检验对象,然后使用这个RequestMappingInfo校验对象对这个请求参数进行校验,如果校验不通过则返回null,校验通过则再根据这个RequestMappingInfo对象找到对应的controller方法</p>
<h2 id="Distro弱一致性协议实现原理"><a href="#Distro弱一致性协议实现原理" class="headerlink" title="Distro弱一致性协议实现原理"></a>Distro弱一致性协议实现原理</h2><p>String distroTag = distroTagGenerator.getResponsibleTag(req);<br>通过上面我们知道在DistroFilter中会根据请求找到对应的controller方法,然后会去判断这个controller方法上是否有@CanDistro注解,如果有的话会再判断当前的nacos节点是否需要对这个请求进行处理,而这个判断就是通过distroMapper.responsible()这个方法去判断的,那么这个方法具体是干什么的呢？其实这个方法就是实现distro弱一致性协议的核心,我们看下这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">responsible</span><span class="params">(String responsibleTag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; servers = healthyList;</span><br><span class="line">        <span class="comment">// 条件成立：没有开启distro协议,或者是nacos服务是单机模式</span></span><br><span class="line">        <span class="keyword">if</span> (!switchDomain.isDistroEnabled() || EnvUtil.getStandaloneMode()) &#123;</span><br><span class="line">        	<span class="comment">// 返回true表示需要响应处理这个service</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(servers)) &#123;</span><br><span class="line">            <span class="comment">// means distro config is not ready yet</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取到当前nacos服务在集群中的位置索引</span></span><br><span class="line">    <span class="comment">// index和lastIndex通常都会相等</span></span><br><span class="line">        String localAddress = EnvUtil.getLocalAddress();</span><br><span class="line">        <span class="keyword">int</span> index = servers.indexOf(localAddress);</span><br><span class="line">        <span class="keyword">int</span> lastIndex = servers.lastIndexOf(localAddress);</span><br><span class="line">        <span class="keyword">if</span> (lastIndex &lt; <span class="number">0</span> || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> target = distroHash(responsibleTag) % servers.size();</span><br><span class="line">        <span class="keyword">return</span> target &gt;= index &amp;&amp; target &lt;= lastIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先这个方法的作用是判断当前nacos节点是否需要负责处理指定的服务,如果不负责处理就返回true,反之就返回false。在开始的时候会去判断当前是否开启了distro协议,如果没有开启就返回true,以及会去判断这个nacos节点是否是单机模式,如果是单机模式就返回true,也就是说在单机模式下,distro协议是不起作用的,很好理解,因为distro协议就是解决了集群之间数据同步一致性的一种方案,而单机模式也没有所谓的数据同步,自然distro协议是不需要的。然后就是会去获取到当前nacos节点在整个nacos集群中的索引位置,并且对指定的服务名通过distroHash方法获取到一个值,把这个值与整个nacos集群节点数进行取模得到一个target值,如果这个target值是等于当前nacos节点所在集群的索引位置值,那么就返回true,反之就返回false。所以对于每一个服务,它都会通过上面这种方式分配到具体的nacos节点,也就是说每一个nacos节点都会负责一部分的服务,那么这这难道nacos集群是分布式集群吗 ？很显然不是的,虽然说每一个nacos节点只会负责一部分的服务请求,但是nacos之间会进行数据的同步,也就是nacos集群的每一个节点数据是最终一致性的,所以这也就是什么说distro协议是一个弱一致性的协议了。而如果这个服务请求根据distro协议的规则判断之后发现不归当前这个nacos节点负责处理怎么办呢？这时候就需要对这个服务请求进行转发了,此时会通过distro协议的规则重新计算找出负责处理这个服务请求的nacos节点,然后当前nacos节点就把这个请求重转发到指定的nacos节点,这样整个distro协议的实现流程就完成了</p>
<h1 id="Nacos集群选举"><a href="#Nacos集群选举" class="headerlink" title="Nacos集群选举"></a>Nacos集群选举</h1><p>Raft协议演示地址：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
<h2 id="Raft一致性协议"><a href="#Raft一致性协议" class="headerlink" title="Raft一致性协议"></a>Raft一致性协议</h2><p>Nacos支持集群模式,很显然。 而一旦涉及到集群,就涉及到主从,那么nacos是一种什么样的机制来实现的集群呢？</p>
<p>nacos的集群类似于zookeeper,它分为leader角色和follower角色,那么从这个角色的名字可以看出来,这个集群存在选举的机制。 因为如果自己不具备选举功能,角色的命名可能就是master/slave了,当然这只是我基于这么多组件的命名的一个猜测。</p>
<p>Raft协议是一种强一致性、去中心化、高可用的分布式协议,它是用来解决分布式一致性问题的,相对于大名鼎鼎的Paxos协议,Raft协议更容易理解,并且在性能、可靠性、可用性方面是不输于Paxos协议的。许多中间件都是利用Raft协议来保证分布式一致性的,例如Redis的sentinel,CP模式的Nacos的leader选举都是通过Raft协议来实现的。因为Nacos的一致性协议是采用的Raft协议。</p>
<p>在Raft中,节点有三种角色：</p>
<p>Leader：负责接收客户端的请求<br>Candidate：用于选举Leader的一种角色<br>Follower：负责响应来自Leader或者Candidate的请求<br>选举分为两个时间点:</p>
<p>服务启动的时候<br>leader挂了的时候<br>所有节点启动的时候,都是follower状态。 如果在一段时间内如果没有收到leader的心跳（可能是没有 leader,也可能是leader挂了）,那么follower会变成Candidate。然后发起选举,选举之前,会增加 term,这个term和zookeeper中的epoch的道理是一样的。</p>
<p>follower会投自己一票,并且给其他节点发送票据vote,等到其他节点回复</p>
<p>在这个过程中,可能出现几种情况</p>
<p>收到过半的票数通过,则成为leader<br>被告知其他节点已经成为leader,则自己切换为follower<br>一段时间内没有收到过半的投票,则重新发起选举<br>选举的几种情况:</p>
<p>第一种情况,赢得选举之后,leader会给所有节点发送消息,避免其他节点触发新的选举<br>第二种情况,比如有三个节点A B C。A B同时发起选举,而A的选举消息先到达C,C给A投了一 票,当B的消息到达C时,已经不能满足上面提到的第一个约束,即C不会给B投票,而A和B显然都不会给对方投票。A胜出之后,会给B,C发心跳消息,节点B发现节点A的term不低于自己的term,知道有已经有Leader了,于是转换成follower。<br>第三种情况,没有任何节点获得majority(超过半数的)投票,可能是平票的情况。加入总共有四个节点 （A/B/C/D）,Node C、Node D同时成为了candidate,但Node A投了NodeD一票,NodeB投 了Node C一票,这就出现了平票 split vote的情况。这个时候大家都在等啊等,直到超时后重新发 起选举。如果出现平票的情况,那么就延长了系统不可用的时间,因此raft引入了randomized election timeouts来尽量避免平票情况.</p>
<h2 id="RaftCore初始化"><a href="#RaftCore初始化" class="headerlink" title="RaftCore初始化"></a>RaftCore初始化</h2><p>这里有几个核心概念或组件：</p>
<p>1.peer：代表每台nocas机器,记录着一台server的投票相关的元数据信息,比如本机的ip,投票给谁（votefor）,AtomicLong类型的term,记录本地服务第几次发起的投票,状体（leader/follower）,leader选举间隔时间等。</p>
<p>2.peers:是个RaftPeerSet类型,实际上记录了整个集群所有peer的信息。</p>
<p>3.notifier：一个线程,用作事件通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DependsOn(&quot;ProtocolManager&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RaftCore</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建一个单线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor = ExecutorFactory.Managed</span><br><span class="line">            .newSingleScheduledExecutorService(ClassUtils.getCanonicalName(NamingApp.class),</span><br><span class="line">                    <span class="keyword">new</span> NameThreadFactory(<span class="string">&quot;com.alibaba.nacos.naming.raft.notifier&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Loggers.RAFT.info(<span class="string">&quot;initializing Raft sub-system&quot;</span>);</span><br><span class="line">		<span class="comment">//开启一个notifier监听,这个线程中会遍历listeners,根据ApplyAction执行相应的逻辑</span></span><br><span class="line">        </span><br><span class="line">        executor.submit(notifier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//启动的时候先加载本地日志</span></span><br><span class="line">        <span class="comment">//遍历/nacos/data/naming/data/文件件,也就是从磁盘中加载Datum到内存,用来做数据恢复。(数据同步采用2pc协议,leader收到请求会写写入到磁盘日志,然后再进行数据同步)</span></span><br><span class="line">        <span class="comment">//Datum：kv对</span></span><br><span class="line">        <span class="comment">//datums：ConcurrentMap&lt;String, Datum&gt;内存数据存储</span></span><br><span class="line">        raftStore.loadDatums(notifier, datums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置term值,从/nacos/data/naming/meta.properties本地磁盘中读取term的值,如果为null,默认为0</span></span><br><span class="line">        setTerm(NumberUtils.toLong(raftStore.loadMeta().getProperty(<span class="string">&quot;term&quot;</span>), <span class="number">0L</span>));</span><br><span class="line"></span><br><span class="line">        Loggers.RAFT.info(<span class="string">&quot;cache loaded, datum count: &#123;&#125;, current term: &#123;&#125;&quot;</span>, datums.size(), peers.getTerm());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (notifier.tasks.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Loggers.RAFT.info(<span class="string">&quot;finish to load data from disk, cost: &#123;&#125; ms.&quot;</span>, (System.currentTimeMillis() - start));</span><br><span class="line">		<span class="comment">//开启定时任务,每500ms执行一次,用来判断是否需要发起leader选举</span></span><br><span class="line">        GlobalExecutor.registerMasterElection(<span class="keyword">new</span> MasterElection());</span><br><span class="line">        <span class="comment">//每500ms发起一次心跳</span></span><br><span class="line">        GlobalExecutor.registerHeartbeat(<span class="keyword">new</span> HeartBeat());</span><br><span class="line"></span><br><span class="line">        Loggers.RAFT.info(<span class="string">&quot;timer started: leader timeout ms: &#123;&#125;, heart-beat timeout ms: &#123;&#125;&quot;</span>,</span><br><span class="line">                          GlobalExecutor.LEADER_TIMEOUT_MS, GlobalExecutor.HEARTBEAT_INTERVAL_MS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="RaftCore-MasterElection"><a href="#RaftCore-MasterElection" class="headerlink" title="RaftCore.MasterElection"></a>RaftCore.MasterElection</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterElection</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果还没有初始化完成</span></span><br><span class="line">            <span class="keyword">if</span> (!peers.isReady()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//获取当前机器上跑的这个peer节点信息</span></span><br><span class="line">            RaftPeer local = peers.local();</span><br><span class="line">            <span class="comment">//leader选举触发间隔时间,第一次进来,会生成（0~15000毫秒）之间的一个随机数-500.</span></span><br><span class="line">			<span class="comment">//后面由于500ms调度一次,所以每次该线程被调起,会将该leaderDueMs减去TICK_PERIOD_MS(500ms),直到小于0的时候会触发选举</span></span><br><span class="line">			<span class="comment">//后面每次收到一次leader的心跳就会重置leaderDueMs = 15s+（随机0-5s）</span></span><br><span class="line">            local.leaderDueMs -= GlobalExecutor.TICK_PERIOD_MS;</span><br><span class="line">			<span class="comment">//当间隔时间&gt;0,直接返回,等到下一次500ms后再调用</span></span><br><span class="line">            <span class="keyword">if</span> (local.leaderDueMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reset timeout</span></span><br><span class="line">            <span class="comment">//重置选举间隔时间</span></span><br><span class="line">            local.resetLeaderDue();</span><br><span class="line">            <span class="comment">//重置心跳间隔时间</span></span><br><span class="line">            local.resetHeartbeatDue();</span><br><span class="line">			<span class="comment">//将本地选举投票通过http发送其他几台服务器</span></span><br><span class="line">            sendVote();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.RAFT.warn(<span class="string">&quot;[RAFT] error while master election &#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendVote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取本机的节点信息</span></span><br><span class="line">        RaftPeer local = peers.get(NetUtils.localServer());</span><br><span class="line">        Loggers.RAFT.info(<span class="string">&quot;leader timeout, start voting,leader: &#123;&#125;, term: &#123;&#125;&quot;</span>, JacksonUtils.toJson(getLeader()),</span><br><span class="line">                          local.term);</span><br><span class="line">		<span class="comment">//重置peers,各个peer的voteFor与leader设为null</span></span><br><span class="line">        peers.reset();</span><br><span class="line">		<span class="comment">//每一次投票,都累加一次term,表示当前投票的轮数,选举计数器,记录本地发起的是第几轮选举</span></span><br><span class="line">        local.term.incrementAndGet();</span><br><span class="line">        <span class="comment">//投票选自己,此时peers中有一个votefor就是自己</span></span><br><span class="line">        local.voteFor = local.ip;</span><br><span class="line">        <span class="comment">//本地server状态设置为CANDIDATE竞选状态</span></span><br><span class="line">        local.state = RaftPeer.State.CANDIDATE;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        params.put(<span class="string">&quot;vote&quot;</span>, JacksonUtils.toJson(local));<span class="comment">//设置本机请求参数</span></span><br><span class="line">        <span class="comment">//遍历除了本机ip之外的其他节点,把自己的票据发送给所有节点,将选自己的投票发送给其他servers,获取其他机器的选票信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> String server : peers.allServersWithoutMySelf()) &#123;</span><br><span class="line">            <span class="comment">//API_VOTE:  /raft/vote</span></span><br><span class="line">            <span class="keyword">final</span> String url = buildUrl(server, API_VOTE);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//发起投票</span></span><br><span class="line">                HttpClient.asyncHttpPost(url, <span class="keyword">null</span>, params, <span class="keyword">new</span> AsyncCompletionHandler&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">onCompleted</span><span class="params">(Response response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (response.getStatusCode() != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                            Loggers.RAFT</span><br><span class="line">                                .error(<span class="string">&quot;NACOS-RAFT vote failed: &#123;&#125;, url: &#123;&#125;&quot;</span>, response.getResponseBody(), url);</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">						<span class="comment">//获取其他server的响应</span></span><br><span class="line">                        RaftPeer peer = JacksonUtils.toObj(response.getResponseBody(), RaftPeer.class);</span><br><span class="line"></span><br><span class="line">                        Loggers.RAFT.info(<span class="string">&quot;received approve from peer: &#123;&#125;&quot;</span>, JacksonUtils.toJson(peer));</span><br><span class="line">						<span class="comment">//计算leader</span></span><br><span class="line">                        peers.decideLeader(peer);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Loggers.RAFT.warn(<span class="string">&quot;error while sending vote to server: &#123;&#125;&quot;</span>, server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="RaftController-vote"><a href="#RaftController-vote" class="headerlink" title="RaftController.vote"></a>RaftController.vote</h2><p>收到投票的票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/vote&quot;)</span><br><span class="line">public JsonNode vote(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    RaftPeer peer = raftCore.receivedVote(JacksonUtils.toObj(WebUtils.required(request, &quot;vote&quot;), RaftPeer.class));</span><br><span class="line"></span><br><span class="line">    return JacksonUtils.transferToJsonNode(peer);</span><br></pre></td></tr></table></figure>
<h2 id="RaftCore-receivedVote"><a href="#RaftCore-receivedVote" class="headerlink" title="RaftCore.receivedVote"></a>RaftCore.receivedVote</h2><p>这个方法主要就是处理自己的选票的,当收到其他机器拉票的请求的时候,会比较term,如果自身的term大于全程请求机器的term,并且自己的选票没有还没投出去的时候,就把选票投给自己。<br>否则将选票投给远程请求的机器,并且把自己的状态设置为follower,并且把信息返回出去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized RaftPeer receivedVote(RaftPeer remote) &#123;</span><br><span class="line">    if (!peers.contains(remote)) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;can not find peer: &quot; + remote.ip);</span><br><span class="line">    &#125;</span><br><span class="line">	//获取本机的节点信息</span><br><span class="line">    RaftPeer local = peers.get(NetUtils.localServer());</span><br><span class="line">    //如果请求的任期小于自己的任期并且还没有投出选票,那么将票投给自己</span><br><span class="line">    if (remote.term.get() &lt;= local.term.get()) &#123;</span><br><span class="line">        String msg = &quot;received illegitimate vote&quot; + &quot;, voter-term:&quot; + remote.term + &quot;, votee-term:&quot; + local.term;</span><br><span class="line"></span><br><span class="line">        Loggers.RAFT.info(msg);</span><br><span class="line">        //如果voteFor为空,表示在此之前没有收到其他节点的票据。则把remote节点的票据设置到自己的节点上</span><br><span class="line">        if (StringUtils.isEmpty(local.voteFor)) &#123;</span><br><span class="line">            local.voteFor = local.ip;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return local;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果上面if不成立,说明请求的任期&gt;本地的任期 ,remote机器率先发起的投票,那么就认同他的投票</span><br><span class="line">    local.resetLeaderDue(); //重置本地机器的选举间隔时间	</span><br><span class="line"></span><br><span class="line">    local.state = RaftPeer.State.FOLLOWER; //设置本机机器为follower,并且为请求过来的机器投票</span><br><span class="line">    local.voteFor = remote.ip;//本地机器投票给remote的机器</span><br><span class="line">    local.term.set(remote.term.get());;//同步remote的term</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Loggers.RAFT.info(&quot;vote &#123;&#125; as leader, term: &#123;&#125;&quot;, remote.ip, remote.term);</span><br><span class="line"></span><br><span class="line">    return local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="decideLeader"><a href="#decideLeader" class="headerlink" title="decideLeader"></a>decideLeader</h2><p>decideLeader,表示用来决策谁能成为leader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RaftPeer <span class="title">decideLeader</span><span class="params">(RaftPeer candidate)</span> </span>&#123;</span><br><span class="line">    peers.put(candidate.ip, candidate);</span><br><span class="line"></span><br><span class="line">    SortedBag ips = <span class="keyword">new</span> TreeBag();</span><br><span class="line">    <span class="comment">//选票最多的票数</span></span><br><span class="line">    <span class="keyword">int</span> maxApproveCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//选票最多的ip</span></span><br><span class="line">    String maxApprovePeer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 假设3个节点：A,B,C</span></span><br><span class="line"><span class="comment">	* local节点为A,假设A,B,C第一轮同时发起选举请求</span></span><br><span class="line"><span class="comment">	* 第一轮投票结果：</span></span><br><span class="line"><span class="comment">    * 第一次for循环是A自己的投票(投票给自己)：maxApproveCount = 1,maxApprovePeer = A</span></span><br><span class="line"><span class="comment">	* 第二次for循环是B服务器返回的投票,该投票投向B：</span></span><br><span class="line"><span class="comment">	* 此时 if (ips.getCount(peer.voteFor) &gt; maxApproveCount) 条件不成立,maxApproveCount = 1,maxApprovePeer = A</span></span><br><span class="line"><span class="comment">	* 第三次for循环是C服务器返回的投票,该投票投向C</span></span><br><span class="line"><span class="comment">	* 此时 if (ips.getCount(peer.voteFor) &gt; maxApproveCount) 条件不成立,maxApproveCount = 1,maxApprovePeer = A</span></span><br><span class="line"><span class="comment">	* 第二轮投票结果：</span></span><br><span class="line"><span class="comment">    * 第一次for循环是A自己的投票(投票给自己)：maxApproveCount = 1,maxApprovePeer = A</span></span><br><span class="line"><span class="comment">	* 第二次for循环是B服务器返回的投票,该投票投向A：</span></span><br><span class="line"><span class="comment">	* 此时 if (ips.getCount(peer.voteFor) &gt; maxApproveCount) 条件成立,maxApproveCount = 2,maxApprovePeer = A</span></span><br><span class="line"><span class="comment">	* 第三次for循环是C服务器返回的投票,该投票投向C</span></span><br><span class="line"><span class="comment">	* 此时 if (ips.getCount(peer.voteFor) &gt; maxApproveCount) 条件不成立,maxApproveCount = 1,maxApprovePeer = A</span></span><br><span class="line"><span class="comment">	* </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">for</span> (RaftPeer peer : peers.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(peer.voteFor)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//收集选票</span></span><br><span class="line">        ips.add(peer.voteFor);</span><br><span class="line">        <span class="keyword">if</span> (ips.getCount(peer.voteFor) &gt; maxApproveCount) &#123;</span><br><span class="line">            maxApproveCount = ips.getCount(peer.voteFor);</span><br><span class="line">            maxApprovePeer = peer.voteFor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//majorityCount()过半节点数：2（假设3个节点）</span></span><br><span class="line">	<span class="comment">//第一轮：maxApproveCount = 1 if条件不成立,返回leader,此时leader为null,没有选举成功</span></span><br><span class="line">	<span class="comment">//第二轮：maxApproveCount = 2 if条件成立,返回leader,此时leader为A,没有选举成功</span></span><br><span class="line">    <span class="keyword">if</span> (maxApproveCount &gt;= majorityCount()) &#123;</span><br><span class="line">        RaftPeer peer = peers.get(maxApprovePeer);</span><br><span class="line">        peer.state = RaftPeer.State.LEADER;<span class="comment">//成为Leader</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(leader, peer)) &#123;</span><br><span class="line">            leader = peer;</span><br><span class="line">            <span class="comment">// 如果当前leader和选举出来的leader不是同一个,那么将选举的leader重置并且发布一个leader选举完成的事件</span></span><br><span class="line">            ApplicationUtils.publishEvent(<span class="keyword">new</span> LeaderElectFinishedEvent(<span class="keyword">this</span>, leader, local()));</span><br><span class="line">            Loggers.RAFT.info(<span class="string">&quot;&#123;&#125; has become the LEADER&quot;</span>, leader.ip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//返回Leader</span></span><br><span class="line">    <span class="keyword">return</span> leader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据同步</p>
<h2 id="addInstance-1"><a href="#addInstance-1" class="headerlink" title="addInstance"></a>addInstance</h2><p>比如我们在注册服务时,调用addInstance之后,最后会调用 consistencyService.put(key, instances); 这个方法,来实现数据一致性的同步。</p>
<p>InstanceController.register—-&gt;registerInstance—–&gt;addInstance——&gt;consistencyService.put(key, instances);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="keyword">boolean</span> ephemeral, Instance... ips)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String key = KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line"></span><br><span class="line">    Service service = getService(namespaceId, serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">        List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line"></span><br><span class="line">        Instances instances = <span class="keyword">new</span> Instances();</span><br><span class="line">        instances.setInstanceList(instanceList);</span><br><span class="line">		<span class="comment">//数据同步</span></span><br><span class="line">        consistencyService.put(key, instances);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RaftConsistencyServiceImpl-put"><a href="#RaftConsistencyServiceImpl-put" class="headerlink" title="RaftConsistencyServiceImpl.put"></a>RaftConsistencyServiceImpl.put</h2><p>调用 consistencyService.put 用来发布类容,也就是实现数据的一致性同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raftCore.signalPublish(key, value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Loggers.RAFT.error(<span class="string">&quot;Raft put failed.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.SERVER_ERROR, <span class="string">&quot;Raft put failed, key:&quot;</span> + key + <span class="string">&quot;, value:&quot;</span> + value,</span><br><span class="line">                                 e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RaftCore-signalPublish"><a href="#RaftCore-signalPublish" class="headerlink" title="RaftCore.signalPublish"></a>RaftCore.signalPublish</h2><p>public static final Lock OPERATE_LOCK = new ReentrantLock();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalPublish</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//如果接受的节点不是Leader节点</span></span><br><span class="line">    <span class="keyword">if</span> (!isLeader()) &#123;</span><br><span class="line">        ObjectNode params = JacksonUtils.createEmptyJsonNode();</span><br><span class="line">        params.put(<span class="string">&quot;key&quot;</span>, key);</span><br><span class="line">        params.replace(<span class="string">&quot;value&quot;</span>, JacksonUtils.transferToJsonNode(value));</span><br><span class="line">        Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        parameters.put(<span class="string">&quot;key&quot;</span>, key);</span><br><span class="line">		<span class="comment">//获取Leader节点</span></span><br><span class="line">        <span class="keyword">final</span> RaftPeer leader = getLeader();</span><br><span class="line">        <span class="comment">//转发到Leader节点</span></span><br><span class="line">        raftProxy.proxyPostLarge(leader.ip, API_PUB, params.toString(), parameters);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果自己是leader,则向所有节点发送onPublish请求。这个所有节点包含自己</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        OPERATE_LOCK.lock();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> Datum datum = <span class="keyword">new</span> Datum();</span><br><span class="line">        datum.key = key;</span><br><span class="line">        datum.value = value;</span><br><span class="line">        <span class="keyword">if</span> (getDatum(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            datum.timestamp.set(<span class="number">1L</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            datum.timestamp.set(getDatum(key).timestamp.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectNode json = JacksonUtils.createEmptyJsonNode();</span><br><span class="line">        json.replace(<span class="string">&quot;datum&quot;</span>, JacksonUtils.transferToJsonNode(datum));</span><br><span class="line">        json.replace(<span class="string">&quot;source&quot;</span>, JacksonUtils.transferToJsonNode(peers.local()));</span><br><span class="line">		<span class="comment">//onPublish可以当做是一次心跳了,更新选举检查时间,然后一个重点就是term增加100了。</span></span><br><span class="line">		<span class="comment">//当然还是就是更新内容了,先写文件,再更新内存缓存。(也就是先记录本地日志)</span></span><br><span class="line">        onPublish(datum, peers.local()); <span class="comment">//发送数据到所有节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String content = json.toString();</span><br><span class="line">		 <span class="comment">//CountDownLatch 用于控制过半提交</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(peers.majorityCount());</span><br><span class="line">        <span class="comment">//遍历所有节点,发送事务提交请求,把记录在本地日志中的数据进行提交</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> String server : peers.allServersIncludeMyself()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeader(server)) &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//API_ON_PUB: /raft/datum/commit  采用的是二阶段提交</span></span><br><span class="line">            <span class="keyword">final</span> String url = buildUrl(server, API_ON_PUB);</span><br><span class="line">            HttpClient.asyncHttpPostLarge(url, Arrays.asList(<span class="string">&quot;key=&quot;</span> + key), content,</span><br><span class="line">                                          <span class="keyword">new</span> AsyncCompletionHandler&lt;Integer&gt;() &#123;</span><br><span class="line">                                              <span class="meta">@Override</span></span><br><span class="line">                                              <span class="function"><span class="keyword">public</span> Integer <span class="title">onCompleted</span><span class="params">(Response response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                                  <span class="keyword">if</span> (response.getStatusCode() != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                                                      Loggers.RAFT</span><br><span class="line">                                                          .warn(<span class="string">&quot;[RAFT] failed to publish data to peer, datumId=&#123;&#125;, peer=&#123;&#125;, http code=&#123;&#125;&quot;</span>,</span><br><span class="line">                                                                datum.key, server, response.getStatusCode());</span><br><span class="line">                                                      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                                                  &#125;</span><br><span class="line">                                                  latch.countDown();</span><br><span class="line">                                                  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                                              &#125;</span><br><span class="line"></span><br><span class="line">                                              <span class="meta">@Override</span></span><br><span class="line">                                              <span class="function"><span class="keyword">public</span> STATE <span class="title">onContentWriteCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                                  <span class="keyword">return</span> STATE.CONTINUE;</span><br><span class="line">                                              &#125;</span><br><span class="line">                                          &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!latch.await(UtilsAndCommons.RAFT_PUBLISH_TIMEOUT, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            <span class="comment">// only majority servers return success can we consider this update success</span></span><br><span class="line">            Loggers.RAFT.error(<span class="string">&quot;data publish failed, caused failed to notify majority, key=&#123;&#125;&quot;</span>, key);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;data publish failed, caused failed to notify majority, key=&quot;</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        Loggers.RAFT.info(<span class="string">&quot;signalPublish cost &#123;&#125; ms, key: &#123;&#125;&quot;</span>, (end - start), key);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        OPERATE_LOCK.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="onPublish"><a href="#onPublish" class="headerlink" title="onPublish"></a>onPublish</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ConcurrentMap&lt;String, Datum&gt; datums = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPublish</span><span class="params">(Datum datum, RaftPeer source)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    RaftPeer local = peers.local();</span><br><span class="line">    <span class="keyword">if</span> (datum.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Loggers.RAFT.warn(<span class="string">&quot;received empty datum&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;received empty datum&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!peers.isLeader(source.ip)) &#123;</span><br><span class="line">        Loggers.RAFT</span><br><span class="line">            .warn(<span class="string">&quot;peer &#123;&#125; tried to publish data but wasn&#x27;t leader, leader: &#123;&#125;&quot;</span>, JacksonUtils.toJson(source),</span><br><span class="line">                  JacksonUtils.toJson(getLeader()));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;peer(&quot;</span> + source.ip + <span class="string">&quot;) tried to publish &quot;</span> + <span class="string">&quot;data but wasn&#x27;t leader&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (source.term.get() &lt; local.term.get()) &#123;</span><br><span class="line">        Loggers.RAFT.warn(<span class="string">&quot;out of date publish, pub-term: &#123;&#125;, cur-term: &#123;&#125;&quot;</span>, JacksonUtils.toJson(source),</span><br><span class="line">                          JacksonUtils.toJson(local));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;out of date publish, pub-term:&quot;</span> + source.term.get() + <span class="string">&quot;, cur-term: &quot;</span> + local.term.get());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//重置选举间隔时间</span></span><br><span class="line">    local.resetLeaderDue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if data should be persisted, usually this is true:</span></span><br><span class="line">    <span class="keyword">if</span> (KeyBuilder.matchPersistentKey(datum.key)) &#123;</span><br><span class="line">        <span class="comment">//存储到本地磁盘中</span></span><br><span class="line">        raftStore.write(datum);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//并且存储到内存中</span></span><br><span class="line">    datums.put(datum.key, datum);</span><br><span class="line">	<span class="comment">//如果是leader,term增加100</span></span><br><span class="line">    <span class="keyword">if</span> (isLeader()) &#123;</span><br><span class="line">        local.term.addAndGet(PUBLISH_TERM_INCREASE_COUNT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (local.term.get() + PUBLISH_TERM_INCREASE_COUNT &gt; source.term.get()) &#123;</span><br><span class="line">            <span class="comment">//set leader term:</span></span><br><span class="line">            getLeader().term.set(source.term.get());</span><br><span class="line">            local.term.set(getLeader().term.get());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            local.term.addAndGet(PUBLISH_TERM_INCREASE_COUNT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新本地磁盘文件meta.properties下的term值</span></span><br><span class="line">    raftStore.updateTerm(local.term.get());</span><br><span class="line">    </span><br><span class="line">    notifier.addTask(datum.key, ApplyAction.CHANGE);</span><br><span class="line"></span><br><span class="line">    Loggers.RAFT.info(<span class="string">&quot;data added/updated, key=&#123;&#125;, term=&#123;&#125;&quot;</span>, datum.key, local.term);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看其他节点在接受到leader请求时是如何处理的,我们查看/v1/ns/raft/datum/commit接口的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/datum/commit&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">onPublish</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    response.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=&quot;</span> + getAcceptEncoding(request));</span><br><span class="line">    response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Content-Encode&quot;</span>, <span class="string">&quot;gzip&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String entity = IoUtils.toString(request.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    String value = URLDecoder.decode(entity, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    JsonNode jsonObject = JacksonUtils.toObj(value);</span><br><span class="line">    String key = <span class="string">&quot;key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    RaftPeer source = JacksonUtils.toObj(jsonObject.get(<span class="string">&quot;source&quot;</span>).toString(), RaftPeer.class);</span><br><span class="line">    JsonNode datumJson = jsonObject.get(<span class="string">&quot;datum&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Datum datum = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//根据不同数据类型进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (KeyBuilder.matchInstanceListKey(datumJson.get(key).asText())) &#123;</span><br><span class="line">        datum = JacksonUtils.toObj(jsonObject.get(<span class="string">&quot;datum&quot;</span>).toString(), <span class="keyword">new</span> TypeReference&lt;Datum&lt;Instances&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (KeyBuilder.matchSwitchKey(datumJson.get(key).asText())) &#123;</span><br><span class="line">        datum = JacksonUtils.toObj(jsonObject.get(<span class="string">&quot;datum&quot;</span>).toString(), <span class="keyword">new</span> TypeReference&lt;Datum&lt;SwitchDomain&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (KeyBuilder.matchServiceMetaKey(datumJson.get(key).asText())) &#123;</span><br><span class="line">        datum = JacksonUtils.toObj(jsonObject.get(<span class="string">&quot;datum&quot;</span>).toString(), <span class="keyword">new</span> TypeReference&lt;Datum&lt;Service&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raftConsistencyService.onPut(datum, source);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的核心在于 raftConsistencyService.onPut(datum, source);我们进入到该方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPut</span><span class="params">(Datum datum, RaftPeer source)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//在本地写入数据</span></span><br><span class="line">        raftCore.onPublish(datum, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Loggers.RAFT.error(<span class="string">&quot;Raft onPut failed.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.SERVER_ERROR,</span><br><span class="line">                                 <span class="string">&quot;Raft onPut failed, datum:&quot;</span> + datum + <span class="string">&quot;, source: &quot;</span> + source, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/raft.jpg" alt="raft"></p>
<h2 id="SpringcloudConfigServer"><a href="#SpringcloudConfigServer" class="headerlink" title="SpringcloudConfigServer"></a>SpringcloudConfigServer</h2><p>SpringCloudConfigServer为外部配置（名称-值对或等效的YAML内容）提供了基于HTTP的API。通过使用@EnableConfigServer注释，服务器可以嵌入到Spring Boot应用程序中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring Cloud Config Server provides an HTTP resource-based API for external configuration (name-value pairs or equivalent YAML content). The server is embeddable in a Spring Boot application, by using the @EnableConfigServer annotation. Consequently, the following application is a config server:</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigServer.java</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ConfigServer.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Cloud-Config-Client"><a href="#Spring-Cloud-Config-Client" class="headerlink" title="Spring Cloud Config Client"></a>Spring Cloud Config Client</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spring Boot application can take immediate advantage of the Spring Config Server (or other external property sources provided by the application developer). It also picks up some additional useful features related to Environment change events.</span><br></pre></td></tr></table></figure>
<h3 id="RefreshScope和ContextRefresher"><a href="#RefreshScope和ContextRefresher" class="headerlink" title="@RefreshScope和ContextRefresher"></a>@RefreshScope和ContextRefresher</h3><p>通过外部化配置（.properties）的刷新，在应用不需要重启的情况下热加载新的外部化配置的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过 Spring Cloud 原生注解 @RefreshScope 实现配置自动更新：</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/config&quot;)</span><br><span class="line">@RefreshScope</span><br><span class="line">public class ConfigController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;useLocalCache:false&#125;&quot;)</span><br><span class="line">    private boolean useLocalCache;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/get&quot;)</span><br><span class="line">    public boolean get() &#123;</span><br><span class="line">        return useLocalCache;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>单独管理Bean生命周期<br>创建Bean的时候如果是RefreshScope就缓存在一个专门管理的ScopeMap中，这样就可以管理Scope是Refresh的Bean的生命周期了（所以含RefreshScope的其实一共创建了两个bean）。<br>重新创建Bean<br>外部化配置刷新之后，会触发一个动作，这个动作将上面的ScopeMap中的Bean清空，这样这些Bean就会重新被IOC容器创建一次，使用最新的外部化配置的值注入类中，达到热加载新值的效果。</p>
<p>在SpringIOC中，BeanScope（Bean的作用域）影响了Bean的管理方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ManagedResource</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefreshScope</span> <span class="keyword">extends</span> <span class="title">GenericScope</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">Ordered</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">enum</span> <span class="title">ScopedProxyMode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Default typically equals &#123;<span class="doctag">@link</span> #NO&#125;, unless a different default</span></span><br><span class="line"><span class="comment">	 * has been configured at the component-scan instruction level.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	DEFAULT,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Do not create a scoped proxy.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This proxy-mode is not typically useful when used with a</span></span><br><span class="line"><span class="comment">	 * non-singleton scoped instance, which should favor the use of the</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> #INTERFACES&#125; or &#123;<span class="doctag">@link</span> #TARGET_CLASS&#125; proxy-modes instead if it</span></span><br><span class="line"><span class="comment">	 * is to be used as a dependency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NO,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a JDK dynamic proxy implementing &lt;i&gt;all&lt;/i&gt; interfaces exposed by</span></span><br><span class="line"><span class="comment">	 * the class of the target object.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	INTERFACES,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a class-based proxy (uses CGLIB).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	TARGET_CLASS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">作用域</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton（单例）</td>
<td align="left"><font color="blue">每一个Spring IoC容器都拥有唯一的一个实例对象（默认作用域）</font> 。</td>
</tr>
<tr>
<td align="left">prototype（原型）</td>
<td align="left"><font color="blue">一个Bean定义，任意多个对象</font></td>
</tr>
<tr>
<td align="left">request（请求）</td>
<td align="left"><font color="blue">每一个HTTP请求都有自己的Bean实例（只在基于web的Spring ApplicationContext中可用）</font></td>
</tr>
<tr>
<td align="left">session（会话）</td>
<td align="left"><font color="blue">一个Bean的作用域为HTTPsession的生命周期（只有基于web的Spring ApplicationContext才能使用） </font></td>
</tr>
<tr>
<td align="left">global session（全局会话）</td>
<td align="left"><font color="blue">一个Bean的作用域为全局HTTPSession的生命周期。通常用于门户网站场景（只有基于web的Spring ApplicationContext才能使用）</font>。</td>
</tr>
</tbody></table>
<h2 id="Nacos动态更新地址原理"><a href="#Nacos动态更新地址原理" class="headerlink" title="Nacos动态更新地址原理"></a>Nacos动态更新地址原理</h2><p>Nacos客户端中有一个HostReactor类，它的功能是实现服务的动态更新，基本原理是：</p>
<p>客户端发起时间订阅后，在HostReactor中有一个UpdateTask线程，每10s发送一次Pull请求，获得服务端最新的地址列表<br>对于服务端，它和服务提供者的实例之间维持了心跳检测，一旦服务提供者出现异常，则会发送一个Push消息给Nacos客户端，也就是服务端消费者<br>服务消费者收到请求之后，使用HostReactor中提供的processServiceJSON解析消息，并更新本地服务地址列表</p>
<ol>
<li>@RefreshScope使用注意事项<br>@RefreshScope作用的类，不能是final类，否则启动时会报错。<br>@RefreshScope不能单独使用，需要和其他其他bean注解结合使用，如：@Controller、@Service、@Component、@Repository、@Configuration等。<br>@RefreshScope 最好不要修饰在 @Scheduled、listener、Timmer等类中,因为配置的刷新会导致原来的对象被清除，需要重新使用对象才能出发生成新对象（但因为对象没了，又没法重新使用对象，死循环）</li>
<li>@RefreshScope动态刷新失效<br>考虑使用的bean是否是@RefreshScope生成的那个scopedTarget.beanName的 bean<br>springboot某些低版本貌似有问题，在Controller类上使用不会生效（网上有这么说的，没具体研究）<br>解决方法1：注解上加属性@RefreshScope(proxyMode = ScopedProxyMode.DEFAULT)<br>解决方法2：直接使用其他类单独封装配置参数，使用@RefreshScope+@Value方式<br>解决方法3：直接使用@ConfigurationProperties</li>
<li>不使用@RefreshScope也能实现动态刷新<br>直接使用@ConfigurationProperties，并不需要加@RefreshScope就能实现动态更新。</li>
</ol>
<p>@ConfigurationProperties实现动态刷新的原理：<br>@ConfigurationProperties有ConfigurationPropertiesRebinder这个监听器，监听着EnvironmentChangeEvent事件。当发生EnvironmentChange事件后，会重新构造原来的加了@ConfigurationProperties注解的Bean对象。这个是Spring Cloud的默认实现。</p>
<p>@Autowired方式注入的是代理对象<br>beanName的得到的是代理对象<br>scopedTarget.beanName的得到的@RefreshScope生成的那个原类对象<br>代理对象不会随着配置刷新而更新<br>@RefreshScope生成的那个原类对象会随着配置的刷新而更新（属性时清除原来的，使用时才生成新的）</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>SpringCloud Nacos</category>
      </categories>
      <tags>
        <tag>SpringCloud Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql保留关键字</title>
    <url>/posts/20220830a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>MySQL关键字（保留字）列表<br>在使用MySQL的时候，一般尽量避免用关键字作为表名，如使用关键字做表名，需要按标准写法给SQL语句加<a href="%E6%88%96%E6%98%AF%E2%80%9C"></a>区分字段名和表名。</p>
<p>下面列出MySQL所有关键字，希望给使用MySQL的朋友提供一些参考帮助。</p>
<p>ADD    ALL    ALTER<br>ANALYZE    AND    AS<br>ASC    ASENSITIVE    BEFORE<br>BETWEEN    BIGINT    BINARY<br>BLOB    BOTH    BY<br>CALL    CASCADE    CASE<br>CHANGE    CHAR    CHARACTER<br>CHECK    COLLATE    COLUMN<br>CONDITION    CONNECTION    CONSTRAINT<br>CONTINUE    CONVERT    CREATE<br>CROSS    CURRENT_DATE    CURRENT_TIME<br>CURRENT_TIMESTAMP    CURRENT_USER    CURSOR<br>DATABASE    DATABASES    DAY_HOUR<br>DAY_MICROSECOND    DAY_MINUTE    DAY_SECOND<br>DEC    DECIMAL    DECLARE<br>DEFAULT    DELAYED    DELETE<br>DESC    DESCRIBE    DETERMINISTIC<br>DISTINCT    DISTINCTROW    DIV<br>DOUBLE    DROP    DUAL<br>EACH    ELSE    ELSEIF<br>ENCLOSED    ESCAPED    EXISTS<br>EXIT    EXPLAIN    FALSE<br>FETCH    FLOAT    FLOAT4<br>FLOAT8    FOR    FORCE<br>FOREIGN    FROM    FULLTEXT<br>GOTO    GRANT    GROUP<br>HAVING    HIGH_PRIORITY    HOUR_MICROSECOND<br>HOUR_MINUTE    HOUR_SECOND    IF<br>IGNORE    IN    INDEX<br>INFILE    INNER    INOUT<br>INSENSITIVE    INSERT    INT<br>INT1    INT2    INT3<br>INT4    INT8    INTEGER<br>INTERVAL    INTO    IS<br>ITERATE    JOIN    KEY<br>KEYS    KILL    LABEL<br>LEADING    LEAVE    LEFT<br>LIKE    LIMIT    LINEAR<br>LINES    LOAD    LOCALTIME<br>LOCALTIMESTAMP    LOCK    LONG<br>LONGBLOB    LONGTEXT    LOOP<br>LOW_PRIORITY    MATCH    MEDIUMBLOB<br>MEDIUMINT    MEDIUMTEXT    MIDDLEINT<br>MINUTE_MICROSECOND    MINUTE_SECOND    MOD<br>MODIFIES    NATURAL    NOT<br>NO_WRITE_TO_BINLOG    NULL    NUMERIC<br>ON    OPTIMIZE    OPTION<br>OPTIONALLY    OR    ORDER<br>OUT    OUTER    OUTFILE<br>PRECISION    PRIMARY    PROCEDURE<br>PURGE    RAID0    RANGE<br>READ    READS    REAL<br>REFERENCES    REGEXP    RELEASE<br>RENAME    REPEAT    REPLACE<br>REQUIRE    RESTRICT    RETURN<br>REVOKE    RIGHT    RLIKE<br>SCHEMA    SCHEMAS    SECOND_MICROSECOND<br>SELECT    SENSITIVE    SEPARATOR<br>SET    SHOW    SMALLINT<br>SPATIAL    SPECIFIC    SQL<br>SQLEXCEPTION    SQLSTATE    SQLWARNING<br>SQL_BIG_RESULT    SQL_CALC_FOUND_ROWS    SQL_SMALL_RESULT<br>SSL    STARTING    STRAIGHT_JOIN<br>TABLE    TERMINATED    THEN<br>TINYBLOB    TINYINT    TINYTEXT<br>TO    TRAILING    TRIGGER<br>TRUE    UNDO    UNION<br>UNIQUE    UNLOCK    UNSIGNED<br>UPDATE    USAGE    USE<br>USING    UTC_DATE    UTC_TIME<br>UTC_TIMESTAMP    VALUES    VARBINARY<br>VARCHAR    VARCHARACTER    VARYING<br>WHEN    WHERE    WHILE<br>WITH    WRITE    X509<br>XOR    YEAR_MONTH    ZEROFILL</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>1000万数据对比ContainsAll实测</title>
    <url>/posts/20220812clhk6ptdl0007csuj9xcyhcey.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutReminder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            list.add(getRandomString(random.nextInt(<span class="number">100</span>)));</span><br><span class="line">            list2.add(getRandomString(random.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        list.containsAll(list2);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(stopWatch.getTotalTimeSeconds());</span><br><span class="line">        StopWatch stopWatch2 = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch2.start();</span><br><span class="line">        CollectionUtils.containsAll(list, list2);</span><br><span class="line">        stopWatch2.stop();</span><br><span class="line">        System.out.println(stopWatch2.getTotalTimeSeconds());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">0.571</span></span><br><span class="line"><span class="number">17.27</span></span><br><span class="line"></span><br><span class="line">源码 java.util.List#<span class="function">containsAll</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = es.length;</span><br><span class="line">        <span class="keyword">for</span> (Object e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexOfRange(e, es, <span class="number">0</span>, len) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOfRange</span><span class="params">(Object o, Object[] es, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt; to; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt; to; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">源码org.apache.commons.collections4.CollectionUtils#containsAll</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;code&gt;true&lt;/code&gt; iff all elements of &#123;<span class="doctag">@code</span> coll2&#125; are also contained</span></span><br><span class="line"><span class="comment">     * in &#123;<span class="doctag">@code</span> coll1&#125;. The cardinality of values in &#123;<span class="doctag">@code</span> coll2&#125; is not taken into account,</span></span><br><span class="line"><span class="comment">     * which is the same behavior as &#123;<span class="doctag">@link</span> Collection#containsAll(Collection)&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * In other words, this method returns &lt;code&gt;true&lt;/code&gt; iff the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #intersection&#125; of &lt;i&gt;coll1&lt;/i&gt; and &lt;i&gt;coll2&lt;/i&gt; has the same cardinality as</span></span><br><span class="line"><span class="comment">     * the set of unique values from &#123;<span class="doctag">@code</span> coll2&#125;. In case &#123;<span class="doctag">@code</span> coll2&#125; is empty, &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * will be returned.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method is intended as a replacement for &#123;<span class="doctag">@link</span> Collection#containsAll(Collection)&#125;</span></span><br><span class="line"><span class="comment">     * with a guaranteed runtime complexity of &#123;<span class="doctag">@code</span> O(n + m)&#125;. Depending on the type of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Collection&#125; provided, this method will be much faster than calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Collection#containsAll(Collection)&#125; instead, though this will come at the</span></span><br><span class="line"><span class="comment">     * cost of an additional space complexity O(n).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coll1  the first collection, must not be null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coll2  the second collection, must not be null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;code&gt;true&lt;/code&gt; iff the intersection of the collections has the same cardinality</span></span><br><span class="line"><span class="comment">     *   as the set of unique elements from the second collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(<span class="keyword">final</span> Collection&lt;?&gt; coll1, <span class="keyword">final</span> Collection&lt;?&gt; coll2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coll2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Iterator&lt;?&gt; it = coll1.iterator();</span><br><span class="line">            <span class="keyword">final</span> Set&lt;Object&gt; elementsAlreadySeen = <span class="keyword">new</span> HashSet&lt;Object&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> Object nextElement : coll2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (elementsAlreadySeen.contains(nextElement)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> foundCurrentElement = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Object p = it.next();</span><br><span class="line">                    elementsAlreadySeen.add(p);</span><br><span class="line">                    <span class="keyword">if</span> (nextElement == <span class="keyword">null</span> ? p == <span class="keyword">null</span> : nextElement.equals(p)) &#123;</span><br><span class="line">                        foundCurrentElement = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (foundCurrentElement) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>ContainsAll</tag>
      </tags>
  </entry>
  <entry>
    <title>面向面试编程</title>
    <url>/posts/20220802clhk6pter002scsujg25f6l26.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="2023年2月2日09-58-57更新"><a href="#2023年2月2日09-58-57更新" class="headerlink" title="2023年2月2日09:58:57更新"></a>2023年2月2日09:58:57更新</h2><p>提问：请问什么是java中函数式接口？<br>回答：只定义了一个抽象方法的接口。(如果你也是这个回答，很遗憾肯定是不及格的)</p>
<p>原答案中对于此回答不是很认可，我不知道是处于语法的严谨还是个人角度理解的不同，在官方文档中如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Package java.util.function Description</span><br><span class="line">Functional interfaces provide target types for lambda expressions and method references. Each functional interface has a single abstract method, called the functional method for that functional interface, to which the lambda expression&#x27;s parameter and return types are matched or adapted. Functional interfaces can provide a target type in multiple contexts, such as assignment context, method invocation, or cast context:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>译文如下：<br>函数接口为 lambda 表达式和方法引用提供目标类型。每个函数接口都有一个抽象方法，称为该函数接口的函数方法，lambda 表达式的参数和返回类型与该方法匹配或调整。函数接口可以在多个上下文中提供目标类型，例如赋值上下文、方法调用或强制转换上下文</p>
<h2 id="jdk哪个方法是用堆实现的"><a href="#jdk哪个方法是用堆实现的" class="headerlink" title="jdk哪个方法是用堆实现的"></a>jdk哪个方法是用堆实现的</h2><p>PriorityQueue</p>
<h2 id="函数式编程的本质是什么？"><a href="#函数式编程的本质是什么？" class="headerlink" title="函数式编程的本质是什么？"></a>函数式编程的本质是什么？</h2><p>函数式编程的本质是：把函数看作是数据。</p>
<h2 id="Stream-foreach中类型是什么"><a href="#Stream-foreach中类型是什么" class="headerlink" title="Stream.foreach中类型是什么?"></a>Stream.foreach中类型是什么?</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-请介绍下java中基本数据类型以及它们的使用场景"><a href="#1-请介绍下java中基本数据类型以及它们的使用场景" class="headerlink" title="1.请介绍下java中基本数据类型以及它们的使用场景"></a>1.请介绍下java中基本数据类型以及它们的使用场景</h2><p>Java八大数据类型：<br>（1）整数类型：byte、short、int、long<br>（2）小数类型：float、double<br>（3）字符类型：char<br>（4）布尔类型：boolean<br>引用数据类型<br>String</p>
<h2 id="2-为什么定义了这些基本数据类型后还要定义包装类？"><a href="#2-为什么定义了这些基本数据类型后还要定义包装类？" class="headerlink" title="2.为什么定义了这些基本数据类型后还要定义包装类？"></a>2.为什么定义了这些基本数据类型后还要定义包装类？</h2><p>之所以需要包装类型，就是因为java是一个面向对象的语言，然而基本数据类型不具备面向对象的特性，当我们把基本数据类型包装成包装类型之后，它就具有了面向对象的特性。而且，在往ArrayList、HashMap这些容器传数据的时候，基本类型int和double是传输不进去的，因为容器都是装object类型的，所以需要转为包装类型进行传输。每一个基本数据类型都有对应的包装类型.</p>
<h2 id="3-包装类和String类有什么相同点吗？"><a href="#3-包装类和String类有什么相同点吗？" class="headerlink" title="3.包装类和String类有什么相同点吗？"></a>3.包装类和String类有什么相同点吗？</h2><p>都允许为null或空,<br>包装类除Float,Double并没有实现常量池技术,其他的和String类都存放在常量池中。</p>
<h2 id="4-包装类是否重写了equals方法，为什么？"><a href="#4-包装类是否重写了equals方法，为什么？" class="headerlink" title="4.包装类是否重写了equals方法，为什么？"></a>4.包装类是否重写了equals方法，为什么？</h2><p>是的,先看他是否内存相等,如果不相等</p>
<h2 id="5-请问我使用Integer定义两个数字，它们值都等于100，使用-和equals方式分别比较它们是否相等？"><a href="#5-请问我使用Integer定义两个数字，它们值都等于100，使用-和equals方式分别比较它们是否相等？" class="headerlink" title="5.请问我使用Integer定义两个数字，它们值都等于100，使用 == 和equals方式分别比较它们是否相等？"></a>5.请问我使用Integer定义两个数字，它们值都等于100，使用 == 和equals方式分别比较它们是否相等？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">都是<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">Integer a =<span class="number">100</span>;</span><br><span class="line">Integer b =<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(a.equals(b));</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">-------</span><br><span class="line">Integer a =<span class="number">200</span>;</span><br><span class="line">Integer b =<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(a.equals(b));</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h2 id="6-导致上面结果原因是什么？如果我把值都改成200呢，结果会发生什么改变？"><a href="#6-导致上面结果原因是什么？如果我把值都改成200呢，结果会发生什么改变？" class="headerlink" title="6.导致上面结果原因是什么？如果我把值都改成200呢，结果会发生什么改变？"></a>6.导致上面结果原因是什么？如果我把值都改成200呢，结果会发生什么改变？</h2><p>在内存中的缓存值是相等的。优先比较内存，200超过127的大小范围==是不相等的</p>
<h2 id="7-我如何验证上述结果原因？"><a href="#7-我如何验证上述结果原因？" class="headerlink" title="7.我如何验证上述结果原因？"></a>7.我如何验证上述结果原因？</h2><p>Integer的缓存机制：为了节省内存和提高性能，Integer类在内部通过使用相同的对象引用实现缓存和重用，Integer类默认在-128 ~ 127 之间，可以通过 -XX:AutoBoxCacheMax进行修改，且这种机制仅在自动装箱的时候有用，在使用构造器创建Integer对象时无用。</p>
<h2 id="8-哪些包装类是带缓存的？默认值是多少？"><a href="#8-哪些包装类是带缓存的？默认值是多少？" class="headerlink" title="8.哪些包装类是带缓存的？默认值是多少？"></a>8.哪些包装类是带缓存的？默认值是多少？</h2><p>Integer 、Byte 、Short 、Long 、Character 五大包装类都有缓冲机制，且缓冲的默认值范围都是-128~127</p>
<p>而Float,Double,Boolean 三大包装类并没有缓冲机制。</p>
<h2 id="9-我是否可以改变缓存值区间？怎么做？"><a href="#9-我是否可以改变缓存值区间？怎么做？" class="headerlink" title="9.我是否可以改变缓存值区间？怎么做？"></a>9.我是否可以改变缓存值区间？怎么做？</h2><p>可以通过 -XX:AutoBoxCacheMax进行修改，且这种机制仅在自动装箱的时候有用，在使用构造器创建Integer对象时无用。</p>
<h2 id="1-请简单说下mysql常用索引类型"><a href="#1-请简单说下mysql常用索引类型" class="headerlink" title="1.请简单说下mysql常用索引类型"></a>1.请简单说下mysql常用索引类型</h2><p>主键索引、唯一索引、普通索引、全文索引、组合索引（联合索引，多列索引）</p>
<h2 id="2-组合索引使用时有什么需要特别注意的？"><a href="#2-组合索引使用时有什么需要特别注意的？" class="headerlink" title="2.组合索引使用时有什么需要特别注意的？"></a>2.组合索引使用时有什么需要特别注意的？</h2><p>1、对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高;     select * from table1 where col1=A AND col2=B AND col3=D     如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引<br>2、何时是用复合索引     根据where条件建索引是极其重要的一个原则;     注意不要过多用索引,否则对表更新的效率有很大的影响,因为在操作表的时候要化大量时间花在创建索引中<br>3、复合索引会替代单一索引么     如果索引满足窄索引的情况下可以建立复合索引,这样可以节约空间和时间</p>
<h2 id="3-为哪个表哪个字段需要添加索引有什么依据吗？"><a href="#3-为哪个表哪个字段需要添加索引有什么依据吗？" class="headerlink" title="3.为哪个表哪个字段需要添加索引有什么依据吗？"></a>3.为哪个表哪个字段需要添加索引有什么依据吗？</h2><p>1、表的主键、外键必须有索引；<br>2、数据量超过300的表应该有索引；<br>3、经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>5、索引应该建在选择性高的字段上；<br>6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；<br>7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：<br>A、正确选择复合索引中的主列字段，一般是选择性较好的字段；<br>B、复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；<br>C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；<br>D、如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；<br>E、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；<br>8、频繁进行数据操作的表，不要建立太多的索引；<br>9、删除无用的索引，避免对执行计划造成负面影响；<br>以上是一些普遍的建立索引时的判断依据。一言以蔽之，索引的建立必须慎重，对每个索引的必要性都应该经过仔细分析，要有建立的依据。因为太多的索引与不充分、不正确的索引对性能都毫无益处：在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大</p>
<h2 id="4-能为较长的varchar类型字段建立索引吗？建立哪种索引？"><a href="#4-能为较长的varchar类型字段建立索引吗？建立哪种索引？" class="headerlink" title="4.能为较长的varchar类型字段建立索引吗？建立哪种索引？"></a>4.能为较长的varchar类型字段建立索引吗？建立哪种索引？</h2><p>其中M指的是可存储的字符长度(或字符数)，而MySQL实际是按字节存储的，在不同的字符集下一个字符的字节长不同，因此这个M最大值在不同的字符集下值不同：</p>
<p>对于latin字符集下，因为一个字符占一个字节，所以M的最大值为65535(但实际只有65532)；对于gbk字符集，因为一个字符占两个字节，所以M的最大值为32767；对于utf8字符集，因为一个字符占两到三个字节，所以M的最大值为21845。</p>
<p>此外，mysql官方文档中定义的65535长度是指同一行的所有varchar列的长度总和。如果列的长度总和超出这个长度，依然无法创建。</p>
<p>1、MySQL5.6的限制方式：</p>
<p>在MySQL5.6版本中，当某个列的varchar长度定义超过相应字符集下的最大长度时，会自动将该列转存为mediumtext类型。例如，在utf8字符集下，定义ecs_payment表test2字段长度为21846：</p>
<p>假如再存储一个字段test3，定义varchar长度为21845，这时没有超过最大长度限制，但在存储test3 varchar(21845)列时，发现该表上所有varchar行的总长度将会超过65535字节，因此会发生如下报错：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> ecs_payment <span class="keyword">add</span> test3 <span class="type">varchar</span>(<span class="number">21845</span>);</span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): <span class="type">Row</span> size too large. The maximum <span class="type">row</span> size <span class="keyword">for</span> the used <span class="keyword">table</span> type, <span class="keyword">not</span> counting BLOBs, <span class="keyword">is</span> <span class="number">65535.</span> This includes storage overhead, <span class="keyword">check</span> the manual. You have <span class="keyword">to</span> change <span class="keyword">some</span> columns <span class="keyword">to</span> TEXT <span class="keyword">or</span> BLOBs</span><br></pre></td></tr></table></figure>
<p>2、MySQL5.7的限制方式：</p>
<p>在MySQL5.7版本下，只要列的varchar长度超过相应字符集下的最大限制，或者表上所有varchar列总长度将会超过65535字节时，MySQL都会抛出错误提示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> c1 <span class="type">varchar</span>(<span class="number">21846</span>);</span><br><span class="line">ERROR <span class="number">1074</span> (<span class="number">42000</span>): <span class="keyword">Column</span> length too big <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;c1&#x27;</span> (max <span class="operator">=</span> <span class="number">21845</span>); use <span class="type">BLOB</span> <span class="keyword">or</span> TEXT instead</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> c1 <span class="type">varchar</span>(<span class="number">21844</span>);</span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): <span class="type">Row</span> size too large. The maximum <span class="type">row</span> size <span class="keyword">for</span> the used <span class="keyword">table</span> type, <span class="keyword">not</span> counting BLOBs, <span class="keyword">is</span> <span class="number">65535.</span> This includes storage overhead, <span class="keyword">check</span> the manual. You have <span class="keyword">to</span> change <span class="keyword">some</span> columns <span class="keyword">to</span> TEXT <span class="keyword">or</span> BLOBs</span><br></pre></td></tr></table></figure>
<p>二、创建索引的限制<br>对于varchar列，当varchar长度过长时，会对索引的创建有限制，在MySQL5.6和5.7下的限制行为的表现形式不同。</p>
<p>1、MySQL5.6的限制</p>
<p>在MySQL5.6中，对ecs_payment表的test varchar(1024)列创建索引，并查看创建后的情况：</p>
<p>可以看到test列上建立了一个前缀索引，前缀长度为255字节。在MySQL5.6下，varchar长度超过255字节时是不适合建立索引的，MySQL会自动只建立255字节长的前缀索引，而不是抛出错误。</p>
<p>2、MySQL5.7的限制</p>
<p>在MySQL5.7版本下，varchar列上可建索引的最大长度是3072字节，超过此长度在建索引时会报错：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">column</span> c4 <span class="type">varchar</span>(<span class="number">1025</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.04</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> index i_2 <span class="keyword">on</span> t1(c4);</span><br><span class="line">ERROR <span class="number">1071</span> (<span class="number">42000</span>): Specified key was too long; max key length <span class="keyword">is</span> <span class="number">3072</span> bytes</span><br></pre></td></tr></table></figure>
<p>表t1是utf8字符集。</p>
<h2 id="5-在你之前开发经验中，你还有哪些索引使用规范？"><a href="#5-在你之前开发经验中，你还有哪些索引使用规范？" class="headerlink" title="5.在你之前开发经验中，你还有哪些索引使用规范？"></a>5.在你之前开发经验中，你还有哪些索引使用规范？</h2><p>1、 只为用于搜索、排序或分组的列创建索引。<br>重点关注 where 语句后边的情况</p>
<p>2、 当列中不重复值的个数在总记录条数中的占比很大时，才为列建立索引。<br>例如手机号、用户 ID、班级等，但是比如一张全校学生表，每条记录是一名学生，where 语句是查询所有’某学校‘的学生，那么其实也不会提高性能。</p>
<p>3、 索引列的类型尽量小。<br>无论是主键还是索引列都尽量选择小的，如果很大则会占据很大的索引空间。</p>
<p>4、 可以只为索引列前缀创建索引，减少索引占用的存储空间。<br>alter table single_table add index idx_key1(key1(10))<br>5、 尽量使用覆盖索引进行查询，以避免回表操作带来的性能损耗。<br>select key1 from single_table order by key1</p>
<p>6、 为了尽可能的少的让聚簇索引发生页面分裂的情况，建议让主键自增。<br>7、 定位并删除表中的冗余和重复索引。</p>
<p>冗余索引： 指的是不同的联合索引组合，某一列或者几列字段被多组索引覆盖，一般称这些列存在冗余索引</p>
<p>查询冗余索引SQL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT a.TABLE_SCHEMA, a.TABLE_NAME, a.COLUMN_NAME, </span><br><span class="line">a.INDEX_NAME AS &#x27;index1&#x27;, b.INDEX_NAME AS &#x27;index2&#x27;</span><br><span class="line">FROM information_schema.STATISTICS a </span><br><span class="line">JOIN information_schema.STATISTICS b </span><br><span class="line">ON a.TABLE_SCHEMA = b.TABLE_SCHEMA    </span><br><span class="line">AND a.TABLE_NAME = b.TABLE_NAME </span><br><span class="line">AND a.SEQ_IN_INDEX = b.SEQ_IN_INDEX   </span><br><span class="line">AND a.COLUMN_NAME = b.COLUMN_NAME </span><br><span class="line">WHERE a.SEQ_IN_INDEX = 1 AND a.INDEX_NAME &lt;&gt; b.INDEX_NAME</span><br></pre></td></tr></table></figure>
<p>单列索引：（字段 1）</p>
<p>联合索引：（字段 1 字段 2）</p>
<p>重复索引：在一个字段上添加了普通索引、唯一索引、主键等多个索引</p>
<h2 id="6-一般我们是如何查看一条sql语句索引有没有起作用的？"><a href="#6-一般我们是如何查看一条sql语句索引有没有起作用的？" class="headerlink" title="6.一般我们是如何查看一条sql语句索引有没有起作用的？"></a>6.一般我们是如何查看一条sql语句索引有没有起作用的？</h2><p>explain执行分析计划<br>我们只需要注意一个最重要的type 的信息很明显的提现是否用到索引：</p>
<p>type结果值从好到坏依次是：</p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。</p>
<p>possible_keys：sql所用到的索引</p>
<p>key：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL</p>
<p>rows: 显示MySQL认为它执行查询时必须检查的行数</p>
<p>3、profiling分析<br>想要优化一条query sql ，就要清楚这条query的性能瓶颈在哪里，mysql的profiler是一个非常方便的查询诊断分析工具，通过该工具可以获取一条查询在整个执行过程中多种资源的消耗情况，例如内存消耗、I/O消耗和CPU消耗<br>profile的语法结构：<br>show profile [type [,type] …]<br>[for query n]<br>[limit row_count [offset offset]]<br>其中type参数可选含义如下：<br>all：显示所有信息<br>block io：显示输入输出操作阻塞的数量<br>context switches：显示自动或非自动context switches的数量<br>cpu：显示系统和用户CPU使用的时间<br>ipc：显示信息发送和接受的数量<br>memory：内存的信息<br>page faults：显示主要的page faults数量<br>source：显示函数的名称，并且是那些函数所在文件的名字和行数<br>swaps：显示swap数量</p>
<p>开启profile<br>set profiling = 1;</p>
<p>开启query profiler功能之后，MySQL就会自动记录所有执行的query的profile信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> customers1;</span><br></pre></td></tr></table></figure>
<p>通过执行show profiles 命令获取当前系统中保存的多个query的profile的概要信息</p>
<p>针对单个query获取详细的profile信息（根据概要信息中的query_id来获取）<br>show profile for query 5;</p>
<h2 id="7-有没有了解过为什么添加索引可以加快查询速度？-数据结构B树和B-树"><a href="#7-有没有了解过为什么添加索引可以加快查询速度？-数据结构B树和B-树" class="headerlink" title="7.有没有了解过为什么添加索引可以加快查询速度？(数据结构B树和B+树)"></a>7.有没有了解过为什么添加索引可以加快查询速度？(数据结构B树和B+树)</h2><p>首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。<br>MySQL官方对于索引的定义为：索引是帮助MySQL高效获取数据的数据结构。即可以理解为：索引是数据结构。</p>
<p>我们知道，数据库查询是数据库最主要的功能之一，我们都希望查询数据的速度尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找，当然这种时间复杂度为O(n)的算法在数据量很大时显然是糟糕的，于是有了二分查找、二叉树查找等。但是二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树，但是数据本身的组织结构不可能完全满足各种数据结构。所以，在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。<br>数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）</p>
<h2 id="8-二者有什么区别？-可以给一个例子让其画出来"><a href="#8-二者有什么区别？-可以给一个例子让其画出来" class="headerlink" title="8.二者有什么区别？(可以给一个例子让其画出来)"></a>8.二者有什么区别？(可以给一个例子让其画出来)</h2><p>缺页查询，减少io</p>
<h2 id="9-结合树的特点说说，为什么推荐使用自增ID来做索引？为什么不使用红黑树、hash树？"><a href="#9-结合树的特点说说，为什么推荐使用自增ID来做索引？为什么不使用红黑树、hash树？" class="headerlink" title="9.结合树的特点说说，为什么推荐使用自增ID来做索引？为什么不使用红黑树、hash树？"></a>9.结合树的特点说说，为什么推荐使用自增ID来做索引？为什么不使用红黑树、hash树？</h2><p>自增主键的插入数据模式，正符合了递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。<br>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<h2 id="Service-和-Component-注解的差别？"><a href="#Service-和-Component-注解的差别？" class="headerlink" title="@Service 和@Component 注解的差别？"></a>@Service 和@Component 注解的差别？</h2><p>@Component spring基础的注解,被spring管理的组件或bean,用于将对象实例化到Spring容器中<br>而@Service源码中是包含@Component注解的,也就是说service实现component的功能,但service用于服务层,处理业务逻辑</p>
<h2 id="各种-Restful-请求格式以及各种-http-请求返回码。"><a href="#各种-Restful-请求格式以及各种-http-请求返回码。" class="headerlink" title="各种 Restful 请求格式以及各种 http 请求返回码。"></a>各种 Restful 请求格式以及各种 http 请求返回码。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">API,英文全称Application Programming Interface,翻译为“应用程序编程接口”。就是将一些功能（逻辑）封装成组件,目的是提供一个应用程序接口给其它程序与开发人员访问,而这些访问人员不需要访问源码以及理解内部工作原理就可以直接使用</span><br><span class="line">RESTFUL是一种网络应用程序的设计风格和开发方式,基于HTTP,可以使用 XML 格式定义或 JSON 格式定义。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取,所以,使用JSON格式的REST风格的API具有简单、易读、易用的特点。</span><br><span class="line">而http返回状态码常见200.400.500等</span><br></pre></td></tr></table></figure>

<h2 id="1-请说下Springboot相比较Spring来说，你认为的最重要的三个特点是什么？"><a href="#1-请说下Springboot相比较Spring来说，你认为的最重要的三个特点是什么？" class="headerlink" title="1.请说下Springboot相比较Spring来说，你认为的最重要的三个特点是什么？"></a>1.请说下Springboot相比较Spring来说，你认为的最重要的三个特点是什么？</h2><p>自动化装配（以规约大于配置思想，做到了很多功能模块的自动化装配）、内嵌容器化（可以独立以jar包方式运行无需外部web容器支持）、开发运维化（基于一些devops思想做了一些endpoint来支持监控管理化）</p>
<h2 id="2-请问springboot的自动化装配技术，哪些技术来源与spring体系，哪些是自己新增的？"><a href="#2-请问springboot的自动化装配技术，哪些技术来源与spring体系，哪些是自己新增的？" class="headerlink" title="2.请问springboot的自动化装配技术，哪些技术来源与spring体系，哪些是自己新增的？"></a>2.请问springboot的自动化装配技术，哪些技术来源与spring体系，哪些是自己新增的？</h2><p>SpringBoot中的一些特征：</p>
<p>1、创建独立的 Spring应用。</p>
<p>2、嵌入式 Tomcat、 Jetty、 Undertow容器（无需部署war文件）。</p>
<p>3、提供的 starters 简化构建配置</p>
<p>4、尽可能自动配置 spring应用。 5、提供生产指标,例如指标、健壮检查和外部化配置</p>
<p>6、完全没有代码生成和 XML配置要求</p>
<h2 id="3-N：对上文的模式注解、模块装配、条件装配知识点进行具体有层次的提问"><a href="#3-N：对上文的模式注解、模块装配、条件装配知识点进行具体有层次的提问" class="headerlink" title="3-N：对上文的模式注解、模块装配、条件装配知识点进行具体有层次的提问"></a>3-N：对上文的模式注解、模块装配、条件装配知识点进行具体有层次的提问</h2><p>Spirng模式注解装配<br>@Component作为一种由Spirng容器托管的通用模式组件,任何被@Component标准的组件均为组件扫描的候选对象.类似的,凡是被@Component原标注的注解,如@Service,任何组件标注它时,也将被是做组件扫描的候选对象.</p>
<p>Spring @Enable模块装配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients(basePackages = &#123;&quot;&quot;&#125;)</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">@SpringBootApplication(scanBasePackages = &#123;&quot;&quot;&#125;)</span><br><span class="line">@EnableScheduling</span><br><span class="line">@ServletComponentScan</span><br><span class="line">@EnableAsync(proxyTargetClass = true)</span><br></pre></td></tr></table></figure>
<p>Spirng条件装配 </p>
<h2 id="Spring-Boot-提供的条件注解"><a href="#Spring-Boot-提供的条件注解" class="headerlink" title="Spring Boot 提供的条件注解"></a>Spring Boot 提供的条件注解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConditionalOnBean：当容器里有指定 Bean 的条件下</span><br><span class="line">@ConditionalOnMissingBean：当容器里没有指定 Bean 的情况下</span><br><span class="line">@ConditionalOnSingleCandidate：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</span><br><span class="line">@ConditionalOnClass：当类路径下有指定类的条件下</span><br><span class="line">@ConditionalOnMissingClass：当类路径下没有指定类的条件下</span><br><span class="line">@ConditionalOnProperty：指定的属性是否有指定的值</span><br><span class="line">@ConditionalOnResource：类路径是否有指定的值</span><br><span class="line">@ConditionalOnExpression：基于 SpEL 表达式作为判断条件</span><br><span class="line">@ConditionalOnJava：基于 Java 版本作为判断条件</span><br><span class="line">@ConditionalOnJndi：在 JNDI 存在的条件下差在指定的位置</span><br><span class="line">@ConditionalOnNotWebApplication：当前项目不是 Web 项目的条件下</span><br><span class="line">@ConditionalOnWebApplication：当前项目是 Web 项 目的条件下</span><br></pre></td></tr></table></figure>
<h2 id="拿模块装配为例子可以继续提问：自定义的模块装配有几种实现方式？-自动化注解方式和selector接口编程的方式这两种比较各有什么特点？我们如何选择？-可以各举个spring中实际实现的例子吗？"><a href="#拿模块装配为例子可以继续提问：自定义的模块装配有几种实现方式？-自动化注解方式和selector接口编程的方式这两种比较各有什么特点？我们如何选择？-可以各举个spring中实际实现的例子吗？" class="headerlink" title="拿模块装配为例子可以继续提问：自定义的模块装配有几种实现方式？ 自动化注解方式和selector接口编程的方式这两种比较各有什么特点？我们如何选择？ 可以各举个spring中实际实现的例子吗？"></a>拿模块装配为例子可以继续提问：自定义的模块装配有几种实现方式？ 自动化注解方式和selector接口编程的方式这两种比较各有什么特点？我们如何选择？ 可以各举个spring中实际实现的例子吗？</h2><p>关于Java的Selector，其实也没什么好说的。说高级点就是就是多路复用。而多路复用是由于操作系统的支持，才能得以实现。适合实时性要求高的场景<br>而对于自动化注解则是常用的驱动方式，适合方面是编码以及优化方面的</p>
<h2 id="Transactional-事务里的事务隔离级别和事务传播机制概念。"><a href="#Transactional-事务里的事务隔离级别和事务传播机制概念。" class="headerlink" title="@Transactional 事务里的事务隔离级别和事务传播机制概念。"></a>@Transactional 事务里的事务隔离级别和事务传播机制概念。</h2><p>定义一个事务受其他并发事务影响程度。事务并发引发的问题。</p>
<p>脏读：一个事务读取到另一个事务修改但还未提交的数据<br>不可重复读：一个事务读取数据之后,该数据被其他事务修改,此时第一个事务读取到的事务就是错误的（强调修改）<br>幻读：一个事务读取了某些数据,没提交再读取时数据多了或者少了,类似幻觉（强调增删）<br>丢失修改：两个事务都读取了数据,其中一个事务修改之后,另一个事务也做了修改,前者的修改丢失</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以放在 类上 或者 方法上。 </span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 区别于 transactionManager属性</span></span><br><span class="line"><span class="comment">	 * 查看 transactionManager</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 选定特定的 事务管理器 SpringBoot中默认不用配置 可以是beanName或者特定的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">	<span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置传播级别</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置事务隔离级别</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 事务超时</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 事务只读 默认是可以修改的 如果设置为true只能执行查询相关</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 指定错误回滚 当未抛出该类型的错误或者其子类的错误时 不会回滚 默认是任何错误（异常）都会回滚</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 略 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 如果配置这个 如果抛出此异常将不会回滚</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 略 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Isolation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用默认的隔离级别</span></span><br><span class="line"><span class="comment">	 * 所有其他级别对应于JDBC隔离级别</span></span><br><span class="line"><span class="comment">	 * 具体隔离级别 查看 java.sql.Connection</span></span><br><span class="line"><span class="comment">	 * Mysql 默认 RR(REPEATABLE_READ)</span></span><br><span class="line"><span class="comment">	 * Oracle 默认 RC(READ_COMMITTED)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 未提交读 什么问题都不解决</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_READ_UNCOMMITTED</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交读 解决脏读</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_READ_COMMITTED</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重复读 解决脏读和不可重复读 不解决幻读</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 串行读 解决所有的事务隔离问题</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Isolation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Support a current transaction, create a new one if none exists.</span></span><br><span class="line"><span class="comment">	 * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This is the default setting of a transaction annotation.</span></span><br><span class="line"><span class="comment">	 * 外围有事务则加入形成同一个事务,外围无事务则新开启,内部事务之间相互独立</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Support a current transaction, execute non-transactionally if none exists.</span></span><br><span class="line"><span class="comment">	 * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note: For transaction managers with transaction synchronization,</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> SUPPORTS&#125; is slightly different from no transaction at all,</span></span><br><span class="line"><span class="comment">	 * as it defines a transaction scope that synchronization will apply for.</span></span><br><span class="line"><span class="comment">	 * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc)</span></span><br><span class="line"><span class="comment">	 * will be shared for the entire specified scope. Note that this depends on</span></span><br><span class="line"><span class="comment">	 * the actual synchronization configuration of the transaction manager.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization</span></span><br><span class="line"><span class="comment">	 * 若外围没有事务则非事务执行,有事务则同 REQUIRED</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Support a current transaction, throw an exception if none exists.</span></span><br><span class="line"><span class="comment">	 * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">	 * 使用外围事务,若外围无事务则抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new transaction, and suspend the current transaction if one exists.</span></span><br><span class="line"><span class="comment">	 * Analogous to the EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span></span><br><span class="line"><span class="comment">	 * on all transaction managers. This in particular applies to</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span></span><br><span class="line"><span class="comment">	 * which requires the &#123;<span class="doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span></span><br><span class="line"><span class="comment">	 * made available to it (which is server-specific in standard Java EE).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span></span><br><span class="line"><span class="comment">	 * 外围有无事务都开启新事务,相互独立,且与外围事务相互独立开 如果当前有事务,就把当前的事务挂起</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Execute non-transactionally, suspend the current transaction if one exists.</span></span><br><span class="line"><span class="comment">	 * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span></span><br><span class="line"><span class="comment">	 * on all transaction managers. This in particular applies to</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span></span><br><span class="line"><span class="comment">	 * which requires the &#123;<span class="doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span></span><br><span class="line"><span class="comment">	 * made available to it (which is server-specific in standard Java EE).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span></span><br><span class="line"><span class="comment">	 * 非事务执行,若外围存在事务则挂起该事务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Execute non-transactionally, throw an exception if a transaction exists.</span></span><br><span class="line"><span class="comment">	 * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">	 * 非事务执行,当外围有事务则抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Execute within a nested transaction if a current transaction exists,</span></span><br><span class="line"><span class="comment">	 * behave like &#123;<span class="doctag">@code</span> REQUIRED&#125; otherwise. There is no analogous feature in EJB.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific</span></span><br><span class="line"><span class="comment">	 * transaction managers. Out of the box, this only applies to the JDBC</span></span><br><span class="line"><span class="comment">	 * DataSourceTransactionManager. Some JTA providers might support nested</span></span><br><span class="line"><span class="comment">	 * transactions as well.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.jdbc.datasource.DataSourceTransactionManager</span></span><br><span class="line"><span class="comment">	 * 外围无事务,则同 REQUIRED 内部开启新事务相互独立。外围有事务,则内部事务是其子事务,主事务回滚则子事务全部回滚,子事务回滚不影响其他子事务和主事务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Propagation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Spring-依赖注入概念和-Autowired-的用法。"><a href="#Spring-依赖注入概念和-Autowired-的用法。" class="headerlink" title="Spring 依赖注入概念和@Autowired 的用法。"></a>Spring 依赖注入概念和@Autowired 的用法。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">概念：实例不再由程序员实例化,而是通过spring容器帮我们<span class="keyword">new</span>指定实例并且将实例注入到需要该对象的类。</span><br><span class="line">依赖注入能够让相互协作的软件组件保持松散耦合</span><br><span class="line"><span class="meta">@Autowired</span> 注释,它可以对类成员变量、方法及构造函数进行标注,完成自动装配的工作。 通过 <span class="meta">@Autowired</span>的使用来消除 set ,get方法。也可作用与集合上</span><br><span class="line">这里授权服务配置类是继承了AuthorizationServerConfigurerAdapter,而AuthorizationServerConfigurerAdapter又实现了AuthorizationServerConfigurer接口！</span><br><span class="line">源码AuthorizationServerConfigurer</span><br><span class="line"><span class="meta">@Autowired</span>对List自动注入</span><br><span class="line"><span class="comment">//@Autowired注解用在接口的集合上面,所有实现该接口的实现类都会在该集合中</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;IAsynTask&gt; tasks = Collections.emptyList();</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Bean-的生命周期。"><a href="#Spring-Bean-的生命周期。" class="headerlink" title="Spring Bean 的生命周期。"></a>Spring Bean 的生命周期。</h2><p>Bean 的生命周期概括起来就是 4 个阶段：</p>
<p>实例化（Instantiation）<br>属性赋值（Populate）<br>初始化（Initialization）<br>销毁（Destruction）<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/374544735d0dd4104601ef98749c7f89.jpg" alt="流程"></p>
<h2 id="Spring-Boot-启动流程以及底层源码"><a href="#Spring-Boot-启动流程以及底层源码" class="headerlink" title="Spring Boot 启动流程以及底层源码"></a>Spring Boot 启动流程以及底层源码</h2><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/05-305138350.jpg" alt="流程"></p>
<h2 id="索引的数据结构（比如-B-树）"><a href="#索引的数据结构（比如-B-树）" class="headerlink" title="索引的数据结构（比如 B+树）"></a>索引的数据结构（比如 B+树）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">B+Tree</span><br><span class="line">B+Tree相对于B-Tree有几点不同：</span><br><span class="line">非叶子节点只存储键值信息。</span><br><span class="line">所有叶子节点之间都有一个链指针。</span><br><span class="line">数据记录都存放在叶子节点中。</span><br><span class="line">查询速度快,但是占用空间</span><br><span class="line">索引结构：B-Tree B+Tree B：balance</span><br><span class="line">B-Tree：平衡二叉树</span><br><span class="line">特点：</span><br><span class="line"><span class="number">1.</span>具有数据节点</span><br><span class="line"><span class="number">2.</span>指向下层指针</span><br><span class="line"><span class="number">3.</span>指向数据指针</span><br><span class="line">缺页查询,产生IO</span><br><span class="line">B+Tree：</span><br><span class="line">特点:</span><br><span class="line"><span class="number">1.</span>具有数据节点</span><br><span class="line"><span class="number">2.</span>指向下层指针</span><br><span class="line">命中数据<span class="number">3</span>层查找后查询数据指针</span><br><span class="line">加载更快,产生更少IO</span><br><span class="line">效率：BTree更高,但从IO角度,Mysql选择B+Tree</span><br><span class="line"></span><br><span class="line">Hash 索引的特点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hash 索引只能够用于使用 = 或者 &lt;=&gt; 运算符的相等比较(但是速度更快)。Hash 索引不能够用于诸如 &lt; 等</span><br><span class="line">用于查找一个范围值的比较运算符。依赖于这种单值查找的系统被称为 “键-值存储”；对于这种系统,尽可能地使用 hash 索引。</span><br><span class="line">优化器不能够使用 hash 索引来加速 ORDER BY 操作。这种类型的索引不能够用于按照顺序查找下一个条目。</span><br><span class="line">MySql 无法使用 hash 索引估计两个值之间有多少行(这种情况由范围优化器来决定使用哪个索引)。如果你将一张 MyISAM 或 InnoDB 表转换成一个 hash 索引的内存表时,一些查询可能会受此影响。</span><br><span class="line">查找某行记录必须进行全键匹配。而 B-tree 索引,任何该键的左前缀都可用以查找记录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color="red">索引是为了加速对表中数据行的检索而创建的一种分散的存储结构</font><br>建索引的语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_xxx <span class="keyword">USING</span> BTREE <span class="keyword">ON</span> tablename (字段,字段,字段);</span><br></pre></td></tr></table></figure>
<p>索引的种类尤其是复合索引以及对应的回表和最左匹配原则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">普通索引：最基本的索引,没有任何约束限制。</span><br><span class="line">唯一索引：和普通索引类似,但是具有唯一性约束,可以有 <span class="keyword">null</span></span><br><span class="line">主键索引：特殊的唯一索引,不允许有 <span class="keyword">null</span>,一张表最多一个主键索引</span><br><span class="line">组合索引：多列值组成一个索引,用于组合搜索,效率大于索引合并</span><br><span class="line">全文索引：对文本的内容进行分词、搜索</span><br><span class="line">覆盖索引：查询列要被所建的索引覆盖,不必读取数据行</span><br><span class="line"><span class="number">1</span>、复合索引绑定的第一个列,没有出现在查询条件中;</span><br><span class="line">举例说明：为emp表插入索引idx_age_deptid_name(age,deptid,name),但是在查询条件中未使用age,导致复合索引全部失效。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、复合索引绑定的多个列是有顺序的,某一个列没有出现在查询条件中,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里没有deptid列,会导致复合索引中的deptid及其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>查询条件中出现某个列是范围查询的,存储引擎不能使用复合索引中该列其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里deptid列使用到了范围查询,会导致复合索引中的deptid其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>查询条件中某列使用否定条件的（!= &lt;&gt; IS NOT NULL）,存储引擎不能使用索引中该列其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里deptid列使用到了否定条件,会导致复合索引中的deptid其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>查询条件中某列使用LIKE条件后的字段是以%开头的（如：’%ABC’）,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里name列使用到了like ‘%a’,会导致复合索引中的name及其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>查询条件中某列使用函数的,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里name列使用到了like ‘%a’,会导致复合索引中的name及其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>查询条件中某列使用类型转换的（包括显示的和隐示的）,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">如：字符串类型的列NAME=<span class="number">3</span>,就是隐示的类型转换,将INT型转换为字符串类型。如果写为NAME=’<span class="number">3</span>’,就不是类型转换。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件name=<span class="number">3</span>,会导致复合索引中的name及其后的索引失效。条件写成name=‘<span class="number">3</span>’,索引就不会失效。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>如果索引的列在 select 所需获得的列中（因为在 mysql 中索引是根据索引列的值进行排序的,所以索引节点中存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表,如果 select 所需获得列中有大量的非索引列,索引就需要到表中找到相应的列的信息,这就叫回表。<br>使用聚集索引（主键或第一个唯一索引）就不会回表,普通索引就会回表</p>
<h2 id="索引下推优化"><a href="#索引下推优化" class="headerlink" title="索引下推优化,"></a>索引下推优化,</h2><p>可以在索引遍历过程中,对索引中包含的字段先做判断,过滤掉不符合条件的记录,减少回表字数。<br>最左匹配原则<br>带头大哥不能死,中间兄弟不能断</p>
<h2 id="Spring-AOP-底层原理"><a href="#Spring-AOP-底层原理" class="headerlink" title="Spring AOP 底层原理"></a>Spring AOP 底层原理</h2><p>AOP 底层是采用动态代理机制实现的：接口+实现类</p>
<h2 id="如果要代理的对象-实现了某个接口-那么-Spring-AOP-会使用-JDK-Proxy-去创建代"><a href="#如果要代理的对象-实现了某个接口-那么-Spring-AOP-会使用-JDK-Proxy-去创建代" class="headerlink" title="如果要代理的对象,实现了某个接口,那么 Spring AOP 会使用 JDK Proxy,去创建代"></a>如果要代理的对象,实现了某个接口,那么 Spring AOP 会使用 JDK Proxy,去创建代</h2><p>理对象。</p>
<h2 id="没有实现接口的对象-就无法使用-JDK-Proxy-去进行代理了-这时候-Spring-AOP-会使用"><a href="#没有实现接口的对象-就无法使用-JDK-Proxy-去进行代理了-这时候-Spring-AOP-会使用" class="headerlink" title="没有实现接口的对象,就无法使用 JDK Proxy 去进行代理了,这时候 Spring AOP 会使用"></a>没有实现接口的对象,就无法使用 JDK Proxy 去进行代理了,这时候 Spring AOP 会使用</h2><p>Cglib 生成一个被代理对象的子类来作为代理。<br>就是由代理创建出一个和 impl 实现类平级的一个对象,但是这个对象不是一个真正的对象,<br>只是一个代理对象,但它可以实现和 impl 相同的功能,这个就是 aop 的横向机制原理,这<br>样就不需要修改源代码。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><p>HashMap在java1.7之前底层数据结构是数组+链表,1.8之后是数组+链表+红黑树,<br>在1.7以前的put方法采用的是头插法,当hash碰撞次数到达8,且桶内元素到达64个的时候形成链表,但是在极端情况下会造成链表过长,效率变低,并且在rehash的时候,头插法会造成回环链首尾相连,形成死锁,在java1.8以后采用红黑树,除了添加效率都高,是线程不安全的,不安全示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HashMapTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMapThread thread0 = new HashMapThread();</span><br><span class="line">        HashMapThread thread1 = new HashMapThread();</span><br><span class="line">        HashMapThread thread2 = new HashMapThread();</span><br><span class="line">        HashMapThread thread3 = new HashMapThread();</span><br><span class="line">        HashMapThread thread4 = new HashMapThread();</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HashMapThread extends Thread &#123;</span><br><span class="line">    private static AtomicInteger ai = new AtomicInteger();</span><br><span class="line">    private static Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (ai.get() &lt; 1000000) &#123;</span><br><span class="line">            map.put(ai.get(), ai.get());</span><br><span class="line">            ai.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h2><p>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。 ## HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值,然后通过 (n -</p>
<ol>
<li>&amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度）,如果当前位置存在<br>元素的话,就判断该元素与要存入的元素的 hash 值以及 key 是否相同,如果相同的话,<br>直接覆盖,不相同就通过拉链法解决冲突。<br>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了<br>防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。<h2 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h2>当链表长度大于阈值（默认为 8）时,会首先调用 treeifyBin()方法。这个方法会根据<br>HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下,才会<br>执行转换红黑树操作,以减少搜索时间。否则,就是只是执行 resize() 方法对数组扩容。</li>
</ol>
<p>1.通常代替HashMap的安全由HashTable代替,但是多线程下他的put.get方法都是synchronized,效率太低,<br>2.Collections.synchronizedMap(),底层仍是synchronized<br>3.java9实现Collections.of()<br>ConcurrentHashMap 与 ConcurrentSkipListMap<br>ConcurrentHashMap 加锁<br>ConcurrentSkipListMap 不需要加锁,浪费空间,<br>4.ConcurrentHashMap<br>ConcurrentHashMap如何保证线程安全,在1.7以前由划分segment分段锁机制,共计16个并发级别,隔离级别太大,有很多空间就浪费了,太小就段内的元素过多<br>1.8以后是cas算法C语言写得,无锁算法,put添加的时候,链表+红黑树<br>put方法（无锁添加）</p>
<h2 id="3、HashMap-的扩容机制是怎样的？"><a href="#3、HashMap-的扩容机制是怎样的？" class="headerlink" title="3、HashMap 的扩容机制是怎样的？"></a>3、HashMap 的扩容机制是怎样的？</h2><p>一般情况下,当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的 2 倍。<br>HashMap 的容量是有上限的,必须小于 1&lt;&lt;30,即 1073741824。如果容量超出了这个<br>数,则不再增长,且阈值会被设置为 Integer.MAX_VALUE。<br>JDK7 中的扩容机制<br>空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是空数<br>组。<br>有参构造函数：根据参数确定容量、负载因子、阈值等。<br>第一次 put 时会初始化数组,其容量变为不小于指定容量的 2 的幂数,然后根据负载因子<br>确定阈值。<br>如果不是第一次扩容,则 新容量=旧容量 x 2 ,新阈值=新容量 x 负载因子 。<br>JDK8 的扩容机制<br>空参数的构造函数：实例化的 HashMap 默认内部数组是 null,即没有实例化。第一次调<br>用 put 方法时,则会开始第一次初始化扩容,长度为 16。 ## 有参构造函数：用于指定容量。会根据指定的正整数找到不小于指定容量的 2 的幂数,将<br>这个数设置赋值给阈值（threshold）。第一次调用 put 方法时,会将阈值赋值给容量,<br>然后让 阈值 = 容量 x 负载因子。 ## 如果不是第一次扩容,则容量变为原来的 2 倍,阈值也变为原来的 2 倍。（容量和阈值都<br>变为原来的 2 倍时,负载因子还是不变）。<br>此外还有几个细节需要注意：<br>首次 put 时,先会触发扩容（算是初始化）,然后存入数据,然后判断是否需要扩容；<br>不是首次 put,则不再初始化,直接存入数据,然后判断是否需要扩容；</p>
<h2 id="4、ConcurrentHashMap-的存储结构是怎样的？"><a href="#4、ConcurrentHashMap-的存储结构是怎样的？" class="headerlink" title="4、ConcurrentHashMap 的存储结构是怎样的？"></a>4、ConcurrentHashMap 的存储结构是怎样的？</h2><p>Java7 中 ConcurrnetHashMap 使用的分段锁,也就是每一个 Segment 上同时只有一个<br>线程可以操作,每一个 Segment 都是一个类似 HashMap 数组的结构,它可以扩容,它<br>的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变,默认 Segment 的<br>个数是 16 个。<br>Java8 中的 ConcurrnetHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由<br>Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红<br>黑树,Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红<br>黑树,在冲突小于一定数量时又退回链表。</p>
<h2 id="5、线程池大小如何设置？"><a href="#5、线程池大小如何设置？" class="headerlink" title="5、线程池大小如何设置？"></a>5、线程池大小如何设置？</h2><p>CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源,可以将线程数设置为 N （CPU 核心数）+1,比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断,<br>或者其它原因导致的任务暂停而带来的影响。一旦任务暂停,CPU 就会处于空闲状态,而<br>在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。<br>I/O 密集型任务(2N)： 这种任务应用起来,系统会用大部分的时间来处理 I/O 交互,而<br>线程在处理 I/O 的时间段内不会占用 CPU 来处理,这时就可以将 CPU 交出给其它线程<br>使用。因此在 I/O 密集型任务的应用中,我们可以多配置一些线程,具体的计算方法是<br>2N。</p>
<h2 id="如何判断是-CPU-密集任务还是-IO-密集任务？"><a href="#如何判断是-CPU-密集任务还是-IO-密集任务？" class="headerlink" title="如何判断是 CPU 密集任务还是 IO 密集任务？"></a>如何判断是 CPU 密集任务还是 IO 密集任务？</h2><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单<br>凡涉及到网络读取,文件读取这类都是 IO 密集型,这类任务的特点是 CPU 计算耗费时间相<br>比于等待 IO 操作完成的时间来说很少,大部分时间都花在了等待 IO 操作完成上。<br>6、IO 密集=Ncpu*2 是怎么计算出来？</p>
<p>I/O 密集型任务任务应用起来,系统会用大部分的时间来处理 I/O 交互,而线程在处理<br>I/O 的时间段内不会占用 CPU 来处理,这时就可以将 CPU 交出给其它线程使用。因此在<br>I/O 密集型任务的应用中,我们可以多配置一些线程。例如：数据库交互,文件上传下<br>载,网络传输等。IO 密集型,即该任务需要大量的 IO,即大量的阻塞,故需要多配置线<br>程数。</p>
<h2 id="7、G1-收集器有哪些特点？"><a href="#7、G1-收集器有哪些特点？" class="headerlink" title="7、G1 收集器有哪些特点？"></a>7、G1 收集器有哪些特点？</h2><p>G1 的全称是 Garbage-First,意为垃圾优先,哪一块的垃圾最多就优先清理它。<br>G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布,变成可预期且可配置的。<br>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：<br>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势,使用多个 CPU（CPU 或者<br>CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程<br>执行的 GC 动作,G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</p>
<h2 id="分代收集：虽然-G1-可以不需要其他收集器配合就能独立管理整个-GC-堆-但是还是保留"><a href="#分代收集：虽然-G1-可以不需要其他收集器配合就能独立管理整个-GC-堆-但是还是保留" class="headerlink" title="分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆,但是还是保留"></a>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆,但是还是保留</h2><p>了分代的概念。<br>空间整合：与 CMS 的“标记-清理”算法不同,G1 从整体来看是基于“标记-整理”算法<br>实现的收集器；从局部上来看是基于“标记-复制”算法实现的。<br>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势,降低停顿时间是 G1 和 CMS 共<br>同的关注点,但 G1 除了追求低停顿外,还能建立可预测的停顿时间模型,能让使用者明<br>确指定在一个长度为 M 毫秒的时间片段内。<br>G1 收集器在后台维护了一个优先列表,每次根据允许的收集时间,优先选择回收价值最大的<br>Region（这也就是它的名字 Garbage-First 的由来）</p>
<h2 id="8、你有哪些手段来排查-OOM-的问题？"><a href="#8、你有哪些手段来排查-OOM-的问题？" class="headerlink" title="8、你有哪些手段来排查 OOM 的问题？"></a>8、你有哪些手段来排查 OOM 的问题？</h2><p>增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -<br>XX:HeapDumpPath=/tmp/heapdump.hprof,当 OOM 发生时自动 dump 堆内存信<br>息到指定目录。<br>同时 jstat 查看监控 JVM 的内存和 GC 情况,先观察问题大概出在什么区域。<br>使用 MAT 工具载入到 dump 文件,分析大对象的占用情况,比如 HashMap 做缓存未<br>清理,时间长了就会内存溢出,可以把改为弱引用。</p>
<h2 id="9、请你谈谈-MySQL-事务隔离级别-MySQL-的默认隔离级别是什么？"><a href="#9、请你谈谈-MySQL-事务隔离级别-MySQL-的默认隔离级别是什么？" class="headerlink" title="9、请你谈谈 MySQL 事务隔离级别,MySQL 的默认隔离级别是什么？"></a>9、请你谈谈 MySQL 事务隔离级别,MySQL 的默认隔离级别是什么？</h2><p>为了达到事务的四大特性,数据库定义了 4 种不同的事务隔离级别：<br> READ-UNCOMMITTED（读取未提交）：最低的隔离级别,允许脏读,也就是可能读取<br>到其他会话中未提交事务修改的数据,可能会导致脏读、幻读或不可重复读。<br> READ-COMMITTED（读取已提交）： 只能读取到已经提交的数据。Oracle 等多数数据<br>库默认都是该级别 （不重复读）,可以阻止脏读,但是幻读或不可重复读仍有可能发生。<br>REPEATABLE-READ（可重复读）：对同一字段的多次读取结果都是一致的,除非数据是<br>被本身事务自己所修改,可以阻止脏读和不可重复读,但幻读仍有可能发生。<br>SERIALIZABLE（可串行化）：最高的隔离级别,完全服从 ACID 的隔离级别。所有的事<br>务依次逐个执行,这样事务之间就完全不可能产生干扰,也就是说,该级别可以防止脏<br>读、不可重复读以及幻读。<br> MySQL 默认采用的 REPEATABLE_READ 隔离级别。</p>
<h2 id="可重复读解决了哪些问题？"><a href="#可重复读解决了哪些问题？" class="headerlink" title="可重复读解决了哪些问题？"></a>可重复读解决了哪些问题？</h2><p> 可重复读的核心就是一致性读(consistent read);保证多次读取同一个数据时,其值都和事<br>务开始时候的内容是一致,禁止读取到别的事务未提交的数据,会造成幻读。<br> 而事务更新数据的时候,只能用当前读。如果当前的记录的行锁被其他事务占用的话,就<br>需要进入锁等待。<br>32<br> 查询只承认在事务启动前就已经提交完成的数据。<br> 可重复读解决的是重复读的问题,可重复读在快照读的情况下是不会有幻读,但当前读的<br>时候会有幻读。</p>
<h2 id="11、对-SQL-慢查询会考虑哪些优化-？"><a href="#11、对-SQL-慢查询会考虑哪些优化-？" class="headerlink" title="11、对 SQL 慢查询会考虑哪些优化 ？"></a>11、对 SQL 慢查询会考虑哪些优化 ？</h2><p> 分析语句,是否加载了不必要的字段/数据。<br> 分析 SQL 执行计划（explain extended）,思考可能的优化点,是否命中索引等。<br> 查看 SQL 涉及的表结构和索引信息。<br> 如果 SQL 很复杂,优化 SQL 结构。<br> 按照可能的优化点执行表结构变更、增加索引、SQL 改写等操作。<br> 查看优化后的执行时间和执行计划。<br> 如果表数据量太大,考虑分表。<br> 利用缓存,减少查询次数</p>
<h2 id="12、谈一谈缓存穿透、缓存击穿和缓存雪崩-以及解决办法？"><a href="#12、谈一谈缓存穿透、缓存击穿和缓存雪崩-以及解决办法？" class="headerlink" title="12、谈一谈缓存穿透、缓存击穿和缓存雪崩,以及解决办法？"></a>12、谈一谈缓存穿透、缓存击穿和缓存雪崩,以及解决办法？</h2><p>缓存穿透<br> 问题：大量并发查询不存在的 KEY,在缓存和数据库中都不存在,同时给缓存和数据库带<br>来压力。<br> 原因：一般而言,缓存穿透有 2 种可能性：业务数据被误删,导致缓存和数据库中都没有<br>数据。恶意进行 ddos 攻击。<br> 分析：为什么会多次透传呢？不存在 一直为空,需要注意让缓存能够区分 KEY 不存在和<br>查询到一个空值。<br> 解决办法：缓存空值的 KEY,这样第一次不存在也会被加载会记录,下次拿到有这个<br>KEY。Bloom 过滤或 RoaingBitmap 判断 KEY 是否存在,如果布隆过滤器中没有查到这<br>个数据,就不去数据库中查。在处理请求前增加恶意请求检查,如果检测到是恶意攻击,<br>则拒绝进行服务。完全以缓存为准,使用延迟异步加载的策略（异步线程负责维护缓存的<br>数据,定期或根据条件触发更新）,这样就不会触发更新。<br>缓存击穿<br> 问题：某个 KEY 失效的时候,正好有大量并发请求访问这个 KEY。  分析：跟穿透其实很像,属于比较偶然的。<br> 解决办法：KEY 的更新操作添加全局互斥锁。完全以缓存为准,使用延迟异步加载的策略<br>（异步线程负责维护缓存的数据,定期或根据条件触发更新）,这样就不会触发更新。<br>缓存雪崩<br> 问题：当某一时刻发生大规模的缓存失效的情况,导致大量的请求无法获取数据,从而将<br>流量压力传导到数据库上,导致数据库压力过大甚至宕机。<br> 原因：一般而言,缓存雪崩有 2 种可能性：大量的数据同一个时间失效：比如业务关系强<br>相关的数据要求同时失效 Redis 宕机<br> 分析：一般来说,由于更新策略、或者数据热点、缓存服务宕机等原因,可能会导致缓存<br>数据同一个时间点大规模不可用,或者都更新。所以,需要我们的更新策略要在时间上合<br>适,数据要均匀分享,缓存服务器要多台高可用。<br> 解决办法：更新策略在时间上做到比较平均。如果数据需要同一时间失效,可以给这批数<br>据加上一些随机值,使得这批数据不要在同一个时间过期,降低数据库的压力。使用的热<br>数据尽量分散到不同的机器上。多台机器做主从复制或者多副本,实现高可用。做好主从<br>的部署,当主节点挂掉后,能快速的使用从结点顶上。实现熔断限流机制,对系统进行负<br>载能力控制。对于非核心功能的业务,拒绝其请求,只允许核心功能业务访问数据库获取<br>数据。服务降价：提供默认返回值,或简单的提示信息。</p>
<h2 id="13、LRU-是什么？如何实现？"><a href="#13、LRU-是什么？如何实现？" class="headerlink" title="13、LRU 是什么？如何实现？"></a>13、LRU 是什么？如何实现？</h2><p>最近最少使用策略 LRU（Least Recently Used）是一种缓存淘汰算法,是一种缓存淘汰机<br>制。<br> 使用双向链表实现的队列,队列的最大容量为缓存的大小。在使用过程中,把最近使用的<br>页面移动到队列头,最近没有使用的页面将被放在队列尾的位置<br> 使用一个哈希表,把页号作为键,把缓存在队列中的节点的地址作为值,只需要把这个页<br>对应的节点移动到队列的前面,如果需要的页面在内存中,此时需要把这个页面加载到内<br>存中,简单的说,就是将一个新节点添加到队列前面,并在哈希表中跟新相应的节点地<br>址,如果队列是满的,那么就从队尾移除一个节点,并将新节点添加到队列的前面。</p>
<h2 id="14、什么是堆内存？参数如何设置？"><a href="#14、什么是堆内存？参数如何设置？" class="headerlink" title="14、什么是堆内存？参数如何设置？"></a>14、什么是堆内存？参数如何设置？</h2><p>堆内存是指由程序代码自由分配的内存,与栈内存作区分。<br>在 Java 中,堆内存主要用于分配对象的存储空间,只要拿到对象引用,所有线程都可<br>以访问堆内存。<br> -Xmx, 指定最大堆内存。 如 -Xmx4g. 这只是限制了 Heap 部分的最大值为 4g。这个内<br>存不包括栈内存,也不包括堆外使用的内存。<br> -Xms, 指定堆内存空间的初始大小。 如 -Xms4g。 而且指定的内存大小,并不是操作系<br>统实际分配的初始值,而是 GC 先规划好,用到才分配。 专用服务器上需要保持 –Xms<br>和 –Xmx 一致,否则应用刚启动可能就有好几个 FullGC。当两者配置不一致时,堆内存<br>扩容可能会导致性能抖动。<br>34<br> -Xmn, 等价于 -XX:NewSize,使用 G1 垃圾收集器 不应该 设置该选项,在其他的某些业<br>务场景下可以设置。官方建议设置为 -Xmx 的 1/2 ~ 1/4.<br> -XX：MaxPermSize=size, 这是 JDK1.7 之前使用的。Java8 默认允许的 Meta 空间无限<br>大,此参数无效。<br> -XX：MaxMetaspaceSize=size, Java8 默认不限制 Meta 空间, 一般不允许设置该选<br>项。<br> -XX：MaxDirectMemorySize=size,系统可以使用的最大堆外内存,这个参数跟 -<br>Dsun.nio.MaxDirectMemorySize 效果相同。<br> -Xss, 设置每个线程栈的字节数。 例如 -Xss1m 指定线程栈为 1MB,与-<br>XX:ThreadStackSize=1m 等价</p>
<h2 id="15、栈和队列-举个使用场景例子？"><a href="#15、栈和队列-举个使用场景例子？" class="headerlink" title="15、栈和队列,举个使用场景例子？"></a>15、栈和队列,举个使用场景例子？</h2><p> 栈（后进先出）可以用于字符匹配,数据反转等场景<br> 队列（先进先出）可以用于任务队列,共享打印机等场景</p>
<h2 id="16、MySQL-为什么-InnoDB-是默认引擎？"><a href="#16、MySQL-为什么-InnoDB-是默认引擎？" class="headerlink" title="16、MySQL 为什么 InnoDB 是默认引擎？"></a>16、MySQL 为什么 InnoDB 是默认引擎？</h2><p>MyISAM与InnoDB 的区别（9个不同点）<br>区别：</p>
<ol>
<li><p>InnoDB支持事务,MyISAM不支持,对于InnoDB每一条SQL语言都默认封装成事务,自动提交,这样会影响速度,所以最好把多条SQL语言放在begin和commit之间,组成一个事务； </p>
</li>
<li><p>InnoDB支持外键,而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； </p>
</li>
<li><p>InnoDB是聚集索引,使用B+Tree作为索引结构,数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构）,必须要有主键,通过主键索引效率很高。但是辅助索引需要两次查询,先查询到主键,然后再通过主键查询到数据。因此,主键不应该过大,因为主键太大,其他索引也都会很大。</p>
<pre><code>MyISAM是非聚集索引,也是使用B+Tree作为索引结构,索引和数据文件是分离的,索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件,辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。
</code></pre>
</li>
<li><p>InnoDB不保存表的具体行数,执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数,执行上述语句时只需要读出该变量即可,速度很快（注意不能加有任何WHERE条件）；</p>
</li>
</ol>
<p>那么为什么InnoDB没有了这个变量呢？</p>
<pre><code>因为InnoDB的事务特性,在同一时刻表中的行数对于不同的事务而言是不一样的,因此count统计会计算对于当前事务而言可以统计到的行数,而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在,InnoDB还会尝试去遍历其他聚簇索引。
如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中,count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样,如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS
</code></pre>
<ol start="5">
<li><p>Innodb不支持全文索引,而MyISAM支持全文索引,在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了</p>
</li>
<li><p>MyISAM表格可以被压缩后进行查询操作</p>
</li>
<li><p>InnoDB支持表、行(默认)级锁,而MyISAM支持表级锁</p>
<pre><code>InnoDB的行锁是实现在索引上的,而不是锁在物理行记录上。潜台词是,如果访问没有命中索引,也无法使用行锁,将要退化为表锁。
</code></pre>
</li>
</ol>
<p>例如：</p>
<pre><code>t_user(uid, uname, age, sex) innodb;

uid PK
无其他索引
update t_user set age=10 where uid=1;             命中索引,行锁。

update t_user set age=10 where uid != 1;           未命中索引,表锁。

update t_user set age=10 where name=&#39;chackca&#39;;    无索引,表锁。
</code></pre>
<p>8、InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键）,而Myisam可以没有</p>
<p>9、Innodb存储文件有frm、ibd,而Myisam是frm、MYD、MYI</p>
<pre><code>    Innodb：frm是表定义文件,ibd是数据文件

    Myisam：frm是表定义文件,myd是数据文件,myi是索引文件
</code></pre>
<p>如何选择：<br>    1. 是否要支持事务,如果要请选择innodb,如果不需要可以考虑MyISAM；</p>
<pre><code>2. 如果表中绝大多数都只是读查询,可以考虑MyISAM,如果既有读也有写,请使用InnoDB。

3. 系统奔溃后,MyISAM恢复起来更困难,能否接受；

4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM),说明其优势是有目共睹的,如果你不知道用什么,那就用InnoDB,至少不会差。
</code></pre>
<p>InnoDB为什么推荐使用自增ID作为主键？</p>
<pre><code>答：自增ID可以保证每次插入时B+索引是从右边扩展的,可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键,会使得数据随机插入,效率比较差。
</code></pre>
<p>innodb引擎的4大特性</p>
<pre><code>   插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)
</code></pre>
<h2 id="19、MVCC-是什么？它的底层原理是什么？"><a href="#19、MVCC-是什么？它的底层原理是什么？" class="headerlink" title="19、MVCC 是什么？它的底层原理是什么？"></a>19、MVCC 是什么？它的底层原理是什么？</h2><p>MVCC,多版本并发控制,它是通过读取历史版本的数据,来降低并发事务冲突,从而提高并<br>发性能的一种机制。<br> 事务版本号<br> 表的隐藏列<br> undo log<br> read view</p>
<h2 id="20、undo-log-具体怎么回滚事务-？"><a href="#20、undo-log-具体怎么回滚事务-？" class="headerlink" title="20、undo log 具体怎么回滚事务 ？"></a>20、undo log 具体怎么回滚事务 ？</h2><p>举个例子：<br> 对于 insert 类型的 sql,会在 undo log 中记录下方才你 insert 进来的数据的 ID,当你想<br>roll back 时,根据 ID 完成精准的删除。<br> 对于 delete 类型的 sql,会在 undo log 中记录方才你删除的数据,当你回滚时会将删除<br>前的数据 insert 进去。<br> 对于 update 类型的 sql,会在 undo log 中记录下修改前的数据,回滚时只需要反向<br>update 即可。<br> 对于 select 类型的 sql,别费心了,select 不需要回滚。</p>
<h2 id="22、索引失效的情况有哪些？"><a href="#22、索引失效的情况有哪些？" class="headerlink" title="22、索引失效的情况有哪些？"></a>22、索引失效的情况有哪些？</h2><p> like 以%开头索引无效,当 like 以&amp;结尾,索引有效。<br> or 语句前后没有同事使用索引,当且仅当 or 语句查询条件的前后列均为索引时,索引生<br>效。<br> 组合索引,使用的不是第一列索引时候,索引失效,即最左匹配规则。<br> 数据类型出现隐式转换,如 varchar 不加单引号的时候可能会自动转换为 int 类型,这个<br>时候索引失效。<br> 在索引列上使用 IS NULL 或者 IS NOT NULL 时候,索引失效,因为索引是不索引空值<br>得。<br> 在索引字段上使用,NOT、 &lt;&gt;、！= 、时候是不会使用索引的,对于这样的处理只会进<br>行全表扫描。<br> 对索引字段进行计算操作,函数操作时不会使用索引。<br> 当全表扫描速度比索引速度快的时候不会使用索引。<br>索引失效场景一：带头大哥不能死,中间兄弟不能断</p>
<p>索引失效场景二：在索引列上做操作</p>
<p>索引失效场景三：范围条件右边全失效</p>
<p>索引低效场景四：select * 会降低索引的效率</p>
<p>索引失效场景五：使用!=或&lt;&gt;会导致索引失效</p>
<p>索引失效场景六、isnull和is not null字段无法使用索引</p>
<p>索引失效场景七、%like%查询时的索引失效问题</p>
<p>索引失效场景八、字符串不加单引号索引失效</p>
<p>索引失效场景九、少用or,用or连接索引会失效</p>
<h2 id="Spring-Bean-容器的生命周期是什么样的？"><a href="#Spring-Bean-容器的生命周期是什么样的？" class="headerlink" title="Spring Bean 容器的生命周期是什么样的？"></a>Spring Bean 容器的生命周期是什么样的？</h2><p> Bean 容器找到配置文件中 Spring Bean 的定义。<br> Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。<br> 如果涉及到一些属性值 利用 set()方法设置一些属性值。<br> 如果 Bean 实现了 BeanNameAware 接口,调用 setBeanName()方法,传入 Bean 的名<br>字。<br> 如果 Bean 实现了 BeanClassLoaderAware 接口,调用 setBeanClassLoader()方法,传<br>入 ClassLoader 对象的实例。<br> 如果 Bean 实现了 BeanFactoryAware 接口,调用 setBeanFactory()方法,传入<br>BeanFactory 对象的实例。<br> 与上面的类似,如果实现了其他 <code>*</code>.Aware 接口,就调用相应的方法。<br> 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象,执行<br>postProcessBeforeInitialization() 方法<br>39<br> 如果 Bean 实现了 InitializingBean 接口,执行 afterPropertiesSet()方法。<br> 如果 Bean 在配置文件中的定义包含 init-method 属性,执行指定的方法。<br> 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象,执行<br>postProcessAfterInitialization() 方法<br> 当要销毁 Bean 的时候,如果 Bean 实现了 DisposableBean 接口,执行 destroy() 方<br>法。<br> 当要销毁 Bean 的时候,如果 Bean 在配置文件中的定义包含 destroy-method 属性,执<br>行指定的方法。</p>
<h2 id="Redis-数据结构-压缩列表和跳跃表的区别"><a href="#Redis-数据结构-压缩列表和跳跃表的区别" class="headerlink" title="Redis 数据结构 压缩列表和跳跃表的区别"></a>Redis 数据结构 压缩列表和跳跃表的区别</h2><p>压缩列表（ziplist）本质上就是一个字节数组,是 Redis 为了节约内存而设计的一种线性<br>数据结构,可以包含多个元素,每个元素可以是一个字节数组或一个整数。<br> 跳跃表（skiplist）是一种有序数据结构,它通过在每个节点中维持多个指向其他节点的指<br>针,从而达到快速访问节点的目的。跳跃表支持平均 O（logN）、最坏 O（N）复杂度的<br>节点查找,还可以通过顺序性操作来批量处理节点</p>
<h2 id="1-redis的hash怎么实现的？-实现原理-rehash过程"><a href="#1-redis的hash怎么实现的？-实现原理-rehash过程" class="headerlink" title="1.redis的hash怎么实现的？(实现原理)rehash过程"></a>1.redis的hash怎么实现的？(实现原理)rehash过程</h2><p>redis初始创建hash表,有序集合,链表时, 存储结构采用一种ziplist的存储结构, 这种结构内存排列更紧密, 能提高访存性能.<br>hash_max_ziplist_entries和hash_max_ziplist_value值作为阀值,hash_max_ziplist_entries表示一旦ziplist中元素数量超过该值,则需要转换为dict结构；hash_max_ziplist_value表示一旦ziplist中数据长度大于该值,则需要转换为dict结构。<br>哈希等价于Java语言的HashMap或者是Python语言的字典（Dict）<br>redis hash 的内部结构.第一维是数组,第二维是链表.组成一个 hashtable.<br>在 Java 中 HashMap 扩容是个很耗时的操作,需要去申请新的数组,为了追求高性能,Redis 采用了渐进式 rehash 策略.这也是 hash 中最重要的部分.<br>在扩容的时候 rehash 策略会保留新旧两个 hashtable 结构,查询时也会同时查询两个 hashtable.Redis会将旧 hashtable 中的内容一点一点的迁移到新的 hashtable 中,当迁移完成时,就会用新的 hashtable 取代之前的.当 hashtable 移除了最后一个元素之后,这个数据结构将会被删除.<br><a href="https://juejin.im/post/5cfe6383e51d45599e019d8f">https://juejin.im/post/5cfe6383e51d45599e019d8f</a><br>与java的hashmap的rehash区别<br>个人理解：hashmap的rehash是一次性拷贝的,不同的是,Redis的字典只能是字符串,另外他们rehash的方式不一样,因为Java的HashMap的字典很大时,rehash是个耗时的操作,需要一次全部rehash。Redis为了追求高性能,不能堵塞服务,所以采用了渐进式rehash策略。<br>rehash的详细步骤<br><a href="https://www.cnblogs.com/meituantech/p/9376472.html">https://www.cnblogs.com/meituantech/p/9376472.html</a><br>与ConcurrentHashMap扩容的策略比较？<br>ConcurrentHashMap采用的扩容策略为： “多线程协同式rehash“。<br>1.扩容所花费的时间对比： 一个单线程渐进扩容,一个多线程协同扩容。在平均的情况下,是ConcurrentHashMap 快。这也意味着,扩容时所需要 花费的空间能够更快的进行释放。<br>2.读操作,两者性能相差不多。<br>3.写操作,Redis的字典返回更快些,因为它不像ConcurrentHashMap那样去帮着扩容(当要写的桶位已经搬到了newTable时),等扩容完才能进行操作。<br>4.删除操作,与写一样。<br><a href="http://xytschool.com/resource/236.html">http://xytschool.com/resource/236.html</a></p>
<h2 id="redis如何保证高可用"><a href="#redis如何保证高可用" class="headerlink" title="redis如何保证高可用"></a>redis如何保证高可用</h2><p>保证redis高可用机制需要redis主从复制、redis持久化机制、哨兵机制、keepalived等的支持。<br>主从复制的作用：数据备份、读写分离、分布式集群、实现高可用、宕机容错机制等。</p>
<h2 id="redis主从复制原理"><a href="#redis主从复制原理" class="headerlink" title="redis主从复制原理"></a>redis主从复制原理</h2><p>首先主从复制需要分为两个角色：master(主) 和 slave(从) ,注意：redis里面只支持一个主,不像Mysql、Nginx主从复制可以多主多从。</p>
<p>(1)redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave）,主数据库可以进行读写操作,当发生写操作的时候自动将数据同步到从数据库,而从数据库一般是只读的,并接收主数据库同步过来的数据,一个主数据库可以有多个从数据库,而一个从数据库只能有一个主数据库。</p>
<p>(2)通过redis的复制功能可以很好的实现数据库的读写分离,提高服务器的负载能力。主数据库主要进行写操作,而从数据库负责读操作。</p>
<p><a href="https://blog.csdn.net/itcats_cn/article/details/82428716">https://blog.csdn.net/itcats_cn/article/details/82428716</a></p>
<h1 id="说说redis的持久化机制-为啥不能用redis做专门的持久化数据库存储？"><a href="#说说redis的持久化机制-为啥不能用redis做专门的持久化数据库存储？" class="headerlink" title="说说redis的持久化机制,为啥不能用redis做专门的持久化数据库存储？"></a>说说redis的持久化机制,为啥不能用redis做专门的持久化数据库存储？</h1><p>个人理解：强一致性的数据是不适合放在缓存中的。另外MySQL对事务的支持也是redis本身不能达到的,需要单独实现<br>一般不是说redis or  MySQL,而是redis+MySQL<br><a href="https://blog.csdn.net/u011784767/article/details/76824822">https://blog.csdn.net/u011784767/article/details/76824822</a><br>为什么Redis进行RDB持久化数据时,新起一个进程而不是在原进程中起一个线程来持久化数据<br>(1)Redis RDB持久化机制会阻塞主进程,这样主进程就无法响应客户端请求。<br>(2)我们知道Redis对客户端响应请求的工作模型是单进程和单线程的,如果在主进程内启动一个线程,这样会造成对数据的竞争条件,为了避免使用锁降低性能。基于以上两点这就是为什么Redis通过启动一个进程来执行RDB了<br>—单线程的redis为什么这么快<br>(1)纯内存操作<br>(2)单线程操作,避免了频繁的上下文切换<br>(3)采用了非阻塞I/O多路复用机制</p>
<p>1</p>
<h2 id="Redis的数据类型以及使用场景"><a href="#Redis的数据类型以及使用场景" class="headerlink" title="Redis的数据类型以及使用场景"></a>Redis的数据类型以及使用场景</h2><p>(1)String<br>这个其实没啥好说的,最常规的set/get操作,value可以是String也可以是数字。<br>一般做一些复杂的计数功能的缓存。</p>
<p>(2)hash<br>这里value存放的是结构化的对象,比较方便的就是操作其中的某个字段。博主在做单点登录的时候,<br>就是用这种数据结构存储用户信息,以cookieId作为key,设置30分钟为缓存过期时间,能很好的模拟出类似session的效果。</p>
<p>(3)list<br>使用List的数据结构,可以做简单的消息队列的功能。另外还有一个就是,可以利用lrange命令,<br>做基于redis的分页功能,性能极佳,用户体验好。</p>
<p>(4)set<br>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？<br>因为我们的系统一般都是集群部署,使用JVM自带的Set,比较麻烦,难道为了一个做一个全局去重,再启一个公共服务,太麻烦了。</p>
<p>另外,就是利用交集、并集、差集等操作,可以计算共同喜好,全部的喜好,自己独有的喜好等功能。</p>
<p>(5)sorted set<br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用,取TOP N操作。sorted set可以用来做延时任务。最后一个应用就是可以做范围查找</p>
<h1 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h1><p>redis采用的是定期删除+惰性删除+内存淘汰策略。<br>[2020年6月29日17:25:36在平时的项目中测试,不定期会产生无用token的key数据,平时可以进行模糊删除]</p>
<p>缓存穿透,即黑客故意去请求缓存中不存在的数据,导致所有的请求都怼到数据库上,从而数据库连接异常。</p>
<p>解决方案:<br>(一)利用互斥锁,缓存失效的时候,先去获得锁,得到锁了,再去请求数据库。没得到锁,则休眠一段时间重试<br>(二)采用异步更新策略,无论key是否取到值,都直接返回。value值中维护一个缓存失效时间,缓存如果过期,<br>异步起一个线程去读数据库,更新缓存。需要做缓存预热(项目启动前,先加载缓存)操作。<br>(三)提供一个能迅速判断请求是否有效的拦截机制,比如,利用布隆过滤器,内部维护一系列合法有效的key。<br>迅速判断出,请求所携带的Key是否合法有效。如果不合法,则直接返回。</p>
<p>缓存雪崩,即缓存同一时间大面积的失效,这个时候又来了一波请求,结果请求都怼到数据库上,从而导致数据库连接异常。</p>
<p>解决方案:<br>(一)给缓存的失效时间,加上一个随机值,避免集体失效。<br>(二)使用互斥锁,但是该方案吞吐量明显下降了。<br>(三)双缓存。我们有两个缓存,缓存A和缓存B。缓存A的失效时间为20分钟,缓存B不设失效时间。<br>自己做缓存预热操作。然后细分以下几个小点<br>1 从缓存A读数据库,有则直接返回<br>2 A没有数据,直接从B读数据,直接返回,并且异步启动一个更新线程。<br>3 更新线程同时更新缓存A和缓存B。</p>
<h2 id="如何解决redis的并发竞争key问题"><a href="#如何解决redis的并发竞争key问题" class="headerlink" title="如何解决redis的并发竞争key问题"></a>如何解决redis的并发竞争key问题</h2><p>分析:这个问题大致就是,同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。<br>需要说明一下,博主提前百度了一下,发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。<br>因为我们的生产环境,基本都是redis集群环境,做了数据分片操作。你一个事务中有涉及到多个key操作的时候,<br>这多个key不一定都存储在同一个redis-server上。因此,redis的事务机制,十分鸡肋。</p>
<p>回答:如下所示<br>(1)如果对这个key操作,不要求顺序<br>这种情况下,准备一个分布式锁,大家去抢锁,抢到锁就做set操作即可,比较简单。<br>(2)如果对这个key操作,要求顺序<br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候,<br>需要保存一个时间戳。假设时间戳如下<br>系统A key 1 {valueA  3:00}<br>系统B key 1 {valueB  3:05}<br>系统C key 1 {valueC  3:10}<br>那么,假设这会系统B先抢到锁,将key1设置为{valueB 3:05}。接下来系统A抢到锁,发现自己的valueA的时间戳早于缓存中的时间戳,那就不做set操作了。以此类推。<br>redis分页<br>HSCAN testHash “0” count 10</p>
<p>注：测试field数量在22条时（没有测试Redis中Hash使分页生效时的field数量的下限）,分页未生效。<br>#mysql 执行一个 sql 的过程<br>执行完毕之后有一个缓存的过程<br><a href="https://www.cnblogs.com/luoying/p/12073812.html">https://www.cnblogs.com/luoying/p/12073812.html</a></p>
<h2 id="MySQL分页limit速度太慢的优化方法"><a href="#MySQL分页limit速度太慢的优化方法" class="headerlink" title="MySQL分页limit速度太慢的优化方法"></a>MySQL分页limit速度太慢的优化方法</h2><p>1.子查询优化法<br>先找出第一条数据,然后大于等于这条数据的id就是要获取的数据<br>缺点：数据必须是连续的,可以说不能有where条件,where条件会筛选数据,导致数据失去连续性<br>2.limit限制优化法<br>把limit偏移量限制低于某个数<br>3.where条件先过滤后分页</p>
<h2 id="wait-notify-为什么要搭配使用？"><a href="#wait-notify-为什么要搭配使用？" class="headerlink" title="wait notify 为什么要搭配使用？"></a>wait notify 为什么要搭配使用？</h2><p>单独调用会报异常<br>只有在调用线程拥有某个对象的独占锁时,才能够调用该对象的wait(),notify()和notifyAll()方法。因为程序验证通常是在对象的同步方法或同步代码块中调用它们的。如果尝试在未获取对象锁时调用这三个方法,<br>“java.lang.IllegalMonitorStateException:current thread not owner”。<br>底层把对象作为一个监视器</p>
<h2 id="栈会溢出吗？什么时候溢出？方法区会溢出吗？"><a href="#栈会溢出吗？什么时候溢出？方法区会溢出吗？" class="headerlink" title="栈会溢出吗？什么时候溢出？方法区会溢出吗？"></a>栈会溢出吗？什么时候溢出？方法区会溢出吗？</h2><p>栈是线程私有的,它的生命周期与线程相同,每个方法在执行的时候都会创建一个栈帧,用来<br>存储局部变量表,操作数栈,动态链接,方法出口等信息。局部变量表又包含基本数据类型,<br>对象引用类型。如果线程请求的栈深度大于虚拟机所允许的最大深度,将抛出<br>StackOverflowError 异常,方法递归调用产生这种结果。如果 Java 虚拟机栈可以动态扩展,<br>并且扩展的动作已经尝试过,但是无法申请到足够的内存去完成扩展,或者在新建立线程的时<br>候没有足够的内存去创建对应的虚拟机栈,那么 Java 虚拟机将抛出一个 OutOfMemory 异<br>常。(线程启动过多)。<br>方法区会发生溢出。<br>HotSpot jdk1.7 之前字符串常量池是方法区的一部分,方法区叫做“永久代”,在 1.7 之前<br>无限的创建对象就会造成内存溢出,提示信息：PermGen space 而是用 jdk1.7 之后,开始逐<br>步去永久代,就不会产生内存溢出。<br>方法区用于存放 Class 的相关信息,如类名、访问修饰符、常量池、字段描述、方法描述等,<br>如果动态生成大量的 Class 文件,也会产生内存溢出。常见的场景还有：大量 JSP 或动态产生<br>JSP 文件的应用（JSP 第一次运行时需要编译为 java 类）、基于 OSGi 的应用（即使是同一个<br>类文件,被不同的类加载器加载也会视为不同的类）</p>
<h2 id="redis排行榜代码"><a href="#redis排行榜代码" class="headerlink" title="redis排行榜代码"></a>redis排行榜代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">countPoint</span><span class="params">(Long pointId,String ponitList, Long userId)</span> </span>&#123;</span><br><span class="line">        String key = RedisConstants.get(pointId.toString());</span><br><span class="line">        String userIdStr = userId.toString();</span><br><span class="line">        <span class="keyword">boolean</span> flag = redisService.isMember(key, userIdStr);</span><br><span class="line">        DetailVo vo = DetailVo.builder()</span><br><span class="line">                .pointId(pointId)</span><br><span class="line">                .likeCreateTime(<span class="keyword">new</span> Date())</span><br><span class="line">                .likeUserId(userId)</span><br><span class="line">                .likedUserId(likedUserId)</span><br><span class="line">                .build();</span><br><span class="line">        Map resultMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            redisService.srem(key, userIdStr);</span><br><span class="line">            vo.setType(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//减分</span></span><br><span class="line">            redisService.incrScoreZset(ponitList,likedUserId.toString(),-<span class="number">1</span>);</span><br><span class="line">            resultMap.put(<span class="string">&quot;no&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisService.sadd(key, userIdStr);</span><br><span class="line">            <span class="comment">//加分</span></span><br><span class="line">            redisService.incrScoreZset(ponitList,likedUserId.toString(),<span class="number">1</span>);</span><br><span class="line">            vo.setType(<span class="number">1</span>);</span><br><span class="line">            resultMap.put(<span class="string">&quot;yes&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        mQProducer.sendUpdateUp(vo);</span><br><span class="line">        resultMap.put(<span class="string">&quot;Number&quot;</span>, redisService.scard(key));</span><br><span class="line">        <span class="keyword">return</span> resultMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="请问-这个-Dao-接口的工作原理是什么？Dao-接口里的方法-参数不同时-方法能重载吗？"><a href="#请问-这个-Dao-接口的工作原理是什么？Dao-接口里的方法-参数不同时-方法能重载吗？" class="headerlink" title="请问,这个 Dao 接口的工作原理是什么？Dao 接口里的方法,参数不同时,方法能重载吗？"></a>请问,这个 Dao 接口的工作原理是什么？Dao 接口里的方法,参数不同时,方法能重载吗？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dao 接口即 Mapper 接口。接口的全限名,就是映射文件中的 namespace 的值；</span><br><span class="line">接口的方法名,就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的</span><br><span class="line">参数,就是传递给 sql 的参数。</span><br><span class="line">Mapper 接口是没有实现类的,当调用接口方法时,接口全限名+方法名拼接字符</span><br><span class="line">串作为 key 值,可唯一定位一个 MapperStatement。在 Mybatis 中,每一个</span><br><span class="line">&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签,都会被解析为一个</span><br><span class="line">MapperStatement 对象。</span><br><span class="line">举例：com.mybatis3.mappers.StudentDao.findStudentById,可以唯</span><br><span class="line">一找到 namespace 为 com.mybatis3.mappers.StudentDao 下面 id 为</span><br><span class="line">findStudentById 的 MapperStatement。</span><br><span class="line">Mapper 接口里的方法,是不能重载的,因为是使用 全限名+方法名 的保存和寻</span><br><span class="line">找策略。Mapper 接口的工作原理是 JDK 动态代理,Mybatis 运行时会使用 JDK</span><br><span class="line">动态代理为 Mapper 接口生成代理对象 proxy,代理对象会拦截接口方法,转而</span><br><span class="line">执行 MapperStatement 所代表的 sql,然后将 sql 执行结果返回。</span><br></pre></td></tr></table></figure>
<h2 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis 使用 RowBounds 对象进行分页,它是针对 ResultSet 结果集执行的内<br>存分页,而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分<br>页功能,也可以使用分页插件来完成物理分页。<br>分页插件的基本原理是使用 Mybatis 提供的插件接口,实现自定义插件,在插件<br>的拦截方法内拦截待执行的 sql,然后重写 sql,根据 dialect 方言,添加对应的物<br>理分页语句和物理分页参数。</p>
<h2 id="Mybatis-的一级、二级缓存"><a href="#Mybatis-的一级、二级缓存" class="headerlink" title="Mybatis 的一级、二级缓存"></a>Mybatis 的一级、二级缓存</h2><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存,其存储作用域为<br>Session,当 Session flush 或 close 之后,该 Session 中的所有 Cache 就<br>将清空,默认打开一级缓存。<br>2）二级缓存与一级缓存其机制相同,默认也是采用 PerpetualCache,HashMap<br>存储,不同在于其存储作用域为 Mapper(Namespace),并且可自定义存储源,<br>如 Ehcache。默认不打开二级缓存,要开启二级缓存,使用二级缓存属性类需要<br>实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置<br><cache> ；<br>3）对于缓存数据更新机制,当某一个作用域(一级缓存 Session/二级缓存<br>Namespaces)的进行了 C/U/D 操作后,默认该作用域下所有 select 中的缓存将<br>被 clear。</cache></p>
<h1 id="Redis面试专题"><a href="#Redis面试专题" class="headerlink" title="Redis面试专题"></a>Redis面试专题</h1><h2 id="redis-和-memcached-什么区别？为什么高并发下有时单线程的-redis-比多线程的"><a href="#redis-和-memcached-什么区别？为什么高并发下有时单线程的-redis-比多线程的" class="headerlink" title="redis 和 memcached 什么区别？为什么高并发下有时单线程的 redis 比多线程的"></a>redis 和 memcached 什么区别？为什么高并发下有时单线程的 redis 比多线程的</h2><p>memcached 效率要高？<br>区别：<br>1.mc 可缓存图片和视频。rd 支持除 k/v 更多的数据结构;<br>2.rd 可以使用虚拟内存,rd 可持久化和 aof 灾难恢复,rd 通过主从支持数据备份;<br>3.rd 可以做消息队列。<br>原因：mc 多线程模型引入了缓存一致性和锁,加锁带来了性能损耗。</p>
<h2 id="假如-Redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来？"><a href="#假如-Redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来？" class="headerlink" title="假如 Redis 里面有 1 亿个 key,其中有 10w 个 key 是以某个固定的已知的前缀开头的,如果将它们全部找出来？"></a>假如 Redis 里面有 1 亿个 key,其中有 10w 个 key 是以某个固定的已知的前缀开头的,如果将它们全部找出来？</h2><p>使用 keys 指令可以扫出指定模式的 key 列表。<br>对方接着追问：如果这个 redis 正在给线上的业务提供服务,那使用 keys 指令会有什么问<br>题？<br>这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一<br>段时间,线上服务会停顿,直到指令执行完毕,服务才能恢复。这个时候可以使用 scan 指<br>令,scan 指令可以无阻塞的提取出指定模式的 key 列表,但是会有一定的重复概率,在客<br>户端做一次去重就可以了,但是整体所花费的时间会比直接用 keys 指令长。</p>
<h2 id="Synchronized-锁升级过程"><a href="#Synchronized-锁升级过程" class="headerlink" title="Synchronized 锁升级过程"></a>Synchronized 锁升级过程</h2><p>首先,synchronized 是什么？我们需要明确的给个定义——同步锁,没错,它就是把锁。</p>
<p>可以用来干嘛？锁,当然当然是用于线程间的同步,以及保护临界区内的资源。我们知道,锁是个非常笼统的概念,像生活中有指纹锁、密码锁等等多个种类,那 synchronized 代表的锁具体是把什么锁呢？</p>
<p>答案是—— Java 内置锁。在 Java 中,每个对象中都隐藏着一把锁,而 synchronized 关键字就是激活这把隐式锁的把手（开关）。</p>
<p>先来简单了解一下 synchronized,我们知道其共有 3 种使用方式：</p>
<p>关于扫描时markword,可以去了解下对象在JVM中的结构,这里简单说明,每个对象都会有一个对象头markword,这块区域可以存放hashcode和锁信息以及GC信息</p>
<p>Synchronized 的使用</p>
<p>修饰静态方法：锁住当前 class,作用于该 class 的所有实例<br>修饰非静态方法：只会锁住当前 class 的实例<br>修饰代码块：该方法接受一个对象作为参数,锁住的即该对象<br>使用方法就不在这里赘述,可自行搜索其详细的用法,这不是本篇文章所关心的内容。</p>
<p>知道了 synchronized 的概念,回头来看标题,它说的锁升级到底是个啥？对于不太熟悉锁升级的人来说,可能会想：</p>
<p>所谓锁,不就是啪一下锁上就完事了吗？升级是个什么玩意？这跟打扑克牌也没关系啊。</p>
<p>对于熟悉的人来说,可能会想：</p>
<p>不就是「无锁 ==&gt; 偏向锁 ==&gt; 轻量级锁 ==&gt; 重量级锁 」吗？</p>
<p>你可能在很多地方看到过上面描述的锁升级过程,也能直接背下来。但你真的知道无锁、偏向锁、轻量级锁、重量级锁到底代表着什么吗？这些锁存储在哪里？以及什么情况下会使得锁向下一个 level 升级？</p>
<p>想知道答案,我们似乎必须先搞清楚 Java 内置锁,其内部结构是啥样的？内置锁又存放在哪里？</p>
<p>答案在开篇提到过——在 Java 对象中。</p>
<p>那么现在的问题就从「内置锁结构是啥」变成了「Java 对象长啥样」。</p>
<p> 对象结构<br>从宏观上看,Java 对象的结构很简单,分为三部分：</p>
<p>Java 对象结构</p>
<p>从微观上看,各个部分都还可以深入展开,详见下图：</p>
<p>Java 详细对象结构</p>
<p>接下来分别深入讨论一下这三部分。</p>
<p>对象头<br>从脑图中可以看出,其由 Mark Word、Class Pointer、数组长度三个字段组成。简单来说：</p>
<p>Mark Word：主要用于存储自身运行时数据<br>Class Pointer：是指针,指向方法区中该 class 的对象,JVM 通过此字段来判断当前对象是哪个类的实例<br>数组长度：当且仅当对象是数组时才会有该字段<br>Class Pointer 和数组长度没什么好说的,接下来重点聊聊 Mark Word。</p>
<p>Mark Word 所代表的「运行时数据」主要用来表示当前 Java 对象的线程锁状态以及 GC 的标志。而线程锁状态分别就是无锁、偏向锁、轻量级锁、重量级锁。</p>
<p>所以前文提到的这 4 个状态,其实就是 Java 内置锁的不同状态。</p>
<p>在 JDK 1.6 之前,内置锁都是重量级锁,效率低下。效率低下表现在</p>
<p>而在 JDK 1.6 之后为了提高 synchronized 的效率,才引入了偏向锁、轻量级锁。</p>
<p>随着锁竞争逐渐激烈,其状态会按照「无锁 ==&gt; 偏向锁 ==&gt; 轻量级锁 ==&gt; 重量级锁 」这个方向逐渐升级,并且不可逆,只能进行锁升级,而无法进行锁降级。</p>
<p>接下来我们思考一个问题,既然 Mark Word 可以表示 4 种不同的锁状态,其内部到底是怎么区分的呢？（由于目前主流的 JVM 都是 64 位,所以我们只讨论 64 位的 Mark Word）接下来我们通过图片直观的感受一下。</p>
<p>（1）无锁</p>
<p>无锁</p>
<p>这个可以理解为单线程很快乐的运行,没有其他的线程来和其竞争。</p>
<p>（2）偏向锁</p>
<p>偏向锁</p>
<p>首先,什么叫偏向锁？举个例子,一段同步的代码,一直只被线程 A 访问,既然没有其他的线程来竞争,每次都要获取锁岂不是浪费资源？所以这种情况下线程 A 就会自动进入偏向锁的状态。</p>
<p>后续线程 A 再次访问同步代码时,不需要做任何的 check,直接执行（对该线程的「偏爱」）,这样降低了获取锁的代价,提升了效率。</p>
<p>看到这里,你会发现无锁、偏向锁的 lock 标志位是一样的,即都是 01,这是因为无锁、偏向锁是靠字段 biased_lock 来区分的,0 代表没有使用偏向锁,1 代表启用了偏向锁。为什么要这么搞？你可以理解为无锁、偏向锁在本质上都可以理解为无锁（参考上面提到的线程 A 的状态）,所以 lock 的标志位都是 01 是没毛病的。</p>
<p>PS：这里的线程 ID 是持有当前对象偏向锁的线程</p>
<p>（3）轻量级锁</p>
<p>轻量级锁</p>
<p>但是,一旦有第二个线程参与竞争,就会立即膨胀为轻量级锁。企图抢占的线程一开始会使用自旋：</p>
<p>的方式去尝试获取锁。如果循环几次,其他的线程释放了锁,就不需要进行用户态到内核态的切换。虽然如此,但自旋需要占用很多 CPU 的资源（自行理解汽车空档疯狂踩油门）。如果另一个线程 一直不释放锁,难道它就在这一直空转下去吗？</p>
<p>当然不可能,JDK 1.7 之前是普通自旋,会设定一个最大的自旋次数,默认是 10 次,超过这个阈值就停止自旋。JDK 1.7 之后,引入了适应性自旋。简单来说就是：这次自旋获取到锁了,自旋的次数就会增加；这次自旋没拿到锁,自旋的次数就会减少。</p>
<p>（4）重量级锁</p>
<p>重量级锁</p>
<p>上面提到,试图抢占的线程自旋达到阈值,就会停止自旋,那么此时锁就会膨胀成重量级锁。当其膨胀成重量级锁后,其他竞争的线程进来就不会自旋了,而是直接阻塞等待,并且 Mark Word 中的内容会变成一个监视器（monitor）对象,用来统一管理排队的线程。</p>
<p>这个 monitor 对象,每个对象都会关联一个。monitor 对象本质上是一个同步机制,保证了同时只有一个线程能够进入临界区,在 HotSpot 的虚拟机中,是由 C++ 类 ObjectMonitor 实现的。</p>
<p>那么 monitor 对象具体是如何来管理线程的？接下来我们看几个 ObjectMonitor 类关键的属性：</p>
<p>ContentionQueue：是个队列,所有竞争锁的线程都会先进入这个队列中,可以理解为线程的统一入口,进入的线程会阻塞。<br>EntryList：ContentionQueue 中有资格的线程会被移动到这里,相当于进行一轮初筛,进入的线程会阻塞。<br>Owner：拥有当前 monitor 对象的线程,即 —— 持有锁的那个线程。<br>OnDeck：与 Owner 线程进行竞争的线程,同一时刻只会有一个 OnDeck 线程在竞争。<br>WaitSet：当 Owner 线程调用 wait()  方法被阻塞之后,会被放到这里。当其被唤醒之后,会重新进入 EntryList 当中,这个集合的线程都会阻塞。<br>Count：用于实现可重入锁,synchronized 是可重入的。<br>对象体<br>对象体包含了当前对象的字段和值,在业务中u l是较为核心的部分。</p>
<p>对齐字节<br>就是单纯用于填充的字节,没有其他的业务含义。其目的是为了保证对象所占用的内存大小为 8 的倍数,因为HotSpot VM 的内存管理要求对象的起始地址必须是 8 的倍数。</p>
<p> 锁升级<br>了解完  4 种锁状态之后,我们就可以整体的来看一下锁升级的过程了。<br>锁的详细升级过程<br>1.一开始对象是无锁状态的</p>
<p>2.一个线程尝试执行Synchronize代码块时,成功获得对象的锁,通过CAS操作往该对象markword中插入当前线程id, 同时修改偏向锁的标志位 。此时是偏向锁（偏向这个线程的锁,锁计数+1）,同一个线程可以重复进入该锁,锁计数+1,执行完毕会锁计数-1,直到锁计数复0,释放锁。</p>
<p>正是因为有记录线程id,所以Synchronized实现了可重入锁的逻辑（简单说就是一个锁的拥有者可以重复的获取自己的锁,而不会产生阻塞问题）<br>关于扫描时markword,可以去了解下对象在JVM中的结构,这里简单说明,每个对象都会有一个对象头markword,这块区域可以存放hashcode和锁信息以及GC信息</p>
<p>线程 A 进入 synchronized 开始抢锁,JVM 会判断当前是否是偏向锁的状态,如果是就会根据 Mark Word 中存储的线程 ID 来判断,当前线程 A 是否就是持有偏向锁的线程。如果是,则忽略 check,线程 A 直接执行临界区内的代码。</p>
<p>但如果 Mark Word 里的线程不是线程 A,就会通过自旋尝试获取锁,如果获取到了,就将 Mark Word 中的线程 ID 改为自己的；如果竞争失败,就会立马撤销偏向锁,膨胀为轻量级锁。</p>
<p>后续的竞争线程都会通过自旋来尝试获取锁,如果自旋成功那么锁的状态仍然是轻量级锁。然而如果竞争失败,锁会膨胀为重量级锁,后续等待的竞争的线程都会被阻塞。</p>
<p>无锁状态、偏向锁、轻量级锁、重量级锁 ,这是锁膨胀的过程,不可逆,但只有偏向锁可以变回无锁态。<br>转载博文：<br><a href="https://cloud.tencent.com/developer/article/2074879#:~:text=%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3%20Synchronized%20%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%201%20%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E9%94%81%E4%BD%8F%E5%BD%93%E5%89%8D%20class%EF%BC%8C%E4%BD%9C%E7%94%A8%E4%BA%8E%E8%AF%A5%20class,%E7%9A%84%E6%89%80%E6%9C%89%E5%AE%9E%E4%BE%8B%202%20%E4%BF%AE%E9%A5%B0%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E5%8F%AA%E4%BC%9A%E9%94%81%E4%BD%8F%E5%BD%93%E5%89%8D%20class%20%E7%9A%84%E5%AE%9E%E4%BE%8B%203%20%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%9A%E8%AF%A5%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E9%94%81%E4%BD%8F%E7%9A%84%E5%8D%B3%E8%AF%A5%E5%AF%B9%E8%B1%A1">https://cloud.tencent.com/developer/article/2074879#:~:text=%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3%20Synchronized%20%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%201%20%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E9%94%81%E4%BD%8F%E5%BD%93%E5%89%8D%20class%EF%BC%8C%E4%BD%9C%E7%94%A8%E4%BA%8E%E8%AF%A5%20class,%E7%9A%84%E6%89%80%E6%9C%89%E5%AE%9E%E4%BE%8B%202%20%E4%BF%AE%E9%A5%B0%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E5%8F%AA%E4%BC%9A%E9%94%81%E4%BD%8F%E5%BD%93%E5%89%8D%20class%20%E7%9A%84%E5%AE%9E%E4%BE%8B%203%20%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%9A%E8%AF%A5%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E9%94%81%E4%BD%8F%E7%9A%84%E5%8D%B3%E8%AF%A5%E5%AF%B9%E8%B1%A1</a><br>锁优化篇：<br>JDK1.6引入了大量的优化,如：自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁。锁主要存在四中状态,依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态,他们会随着竞争的激烈而逐渐升级。但是有一点,不可以进行锁降级</p>
<p>一、自旋锁：<br>线程频繁的阻塞和唤醒对CPU来说是一件负担很重的工作,会给系统带来很大的压力。同时很多锁状态只会持续很短一段时间,为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。  所谓自旋锁,就是让该线程等待一段时间,不会被立即挂起,看持有锁的线程是否会很快释放锁,如果释放了,就可以抢到锁。那怎么等待呢？其实就是执行一段无意义的循环,大家是不是瞬间觉得好low,原来就是执行一段for循环,别急着下结论,我们继续来分析</p>
<p>执行一段无意义的循环。如果持有锁的线程很快就释放了锁,那么自旋的效率就非常好。但是如果自旋很久都没抢到锁,那自旋就是浪费资源,说的难听点就是占着茅坑不拉屎。所以说,自旋等待的时间或者次数必须要有一个限度,如果超过了定义的时间仍然没有获取到锁,则把它挂起。</p>
<p>自旋锁在JDK 1.4.2中引入,默认关闭,但是可以使用-XX:+UseSpinning开启,在JDK1.6中默认开启。同时自旋的默认次数为10次,可以通过参数-XX:PreBlockSpin来调整；但是无论你怎么调整这些参数,都无法满足不可预知的情况。于是JDK1.6引入自适应的自旋锁,让虚拟机会变得越来越聪明。</p>
<p>二、适应自旋锁<br>JDK 1.6引入了更加聪明的自旋锁,叫做自适应自旋锁。他的自旋次数是会变的,我用大白话来讲一下,就是线程如果上次自旋成功了,那么这次自旋的次数会更加多,因为虚拟机认为既然上次成功了,那么这次自旋也很有可能会再次成功。反之,如果某个锁很少有自旋成功,那么以后的自旋的次数会减少甚至省略掉自旋过程,以免浪费处理器资源。大家现在觉得没这么low了吧</p>
<p>三、锁消除<br>锁消除用大白话来讲,就是在一段程序里你用了锁,但是jvm检测到这段程序里不存在共享数据竞争问题,也就是变量没有逃逸出方法外,这个时候jvm就会把这个锁消除掉</p>
<p>我们程序员写代码的时候自然是知道哪里需要上锁,哪里不需要,但是有时候我们虽然没有显示使用锁,但是我们不小心使了一些线程安全的API时,如StringBuffer、Vector、HashTable等,这个时候会隐形的加锁。比如下段代码</p>
<p>复制<br>public void sbTest(){<br>        StringBuffer sb= new StringBuffer();<br>        for(int i = 0 ; i &lt; 10 ; i++){<br>            sb.append(i);<br>        }<br>        System.out.println(sb.toString());<br>    }<br>复制<br>复制<br>上面这段代码,JVM可以明显检测到变量sb没有逃逸出方法sbTest()之外,所以JVM可以大胆地将sbTest内部的加锁操作消除。</p>
<p> 四、锁粗化<br>众所周知在使用锁的时候,要让锁的作用范围尽量的小,这样是为了在锁内执行代码尽可能少,缩短持有锁的时间,其他等待锁的线程能尽快拿到锁。在大多数的情况下这样做是正确的。但是连续加锁解锁操作,可能会导致不必要的性能损耗,比如下面这个for循环：</p>
<p>锁粗化前：<br>for (…) {<br>  synchronized (obj) {<br>    // 一些操作<br>  }<br>}<br>锁粗化后：<br>synchronized (this) {<br> for (…) {<br>   // 一些操作<br> }<br>}<br>复制<br>复制<br>大家应该能看出锁粗化大概是什么意思了。就是将多个连续的加锁、解锁操作连接在一起,扩展成一个范围更大的锁。即加锁解锁操作会移到for循环之外。</p>
<p>五、偏向锁<br>当我们创建一个对象时,该对象的部分Markword关键数据如下。</p>
<p>bit fields</p>
<p>是否偏向锁</p>
<p>锁标志位</p>
<p>hash</p>
<p>0</p>
<p>01</p>
<p>从图中可以看出,偏向锁的标志位是“01”,状态是“0”,表示该对象还没有被加上偏向锁。（“1”是表示被加上偏向锁）。该对象被创建出来的那一刻,就有了偏向锁的标志位,这也说明了所有对象都是可偏向的,但所有对象的状态都为“0”,也同时说明所有被创建的对象的偏向锁并没有生效。</p>
<p>不过,当线程执行到临界区（critical section）时,此时会利用CAS(Compare and Swap)操作,将线程ID插入到Markword中,同时修改偏向锁的标志位。</p>
<p>所谓临界区,就是只允许一个线程进去执行操作的区域,即同步代码块。CAS是一个原子性操作</p>
<p>此时的Mark word的结构信息如下：</p>
<p>bit fields</p>
<p>是否偏向锁</p>
<p>锁标志位</p>
<p>threadId</p>
<p>epoch</p>
<p>1</p>
<p>01</p>
<p>此时偏向锁的状态为“1”,说明对象的偏向锁生效了,同时也可以看到,哪个线程获得了该对象的锁。</p>
<p>偏向锁是jdk1.6引入的一项锁优化,其中的“偏”是偏心的偏。它的意思就是说,这个锁会偏向于第一个获得它的线程,在接下来的执行过程中,假如该锁没有被其他线程所获取,没有其他线程来竞争该锁,那么持有偏向锁的线程将永远不需要进行同步操作。也就是说:在此线程之后的执行过程中,如果再次进入或者退出同一段同步块代码,并不再需要去进行加锁或者解锁操作,而是会做以下的步骤：</p>
<p>Load-and-test,也就是简单判断一下当前线程id是否与Markword当中的线程id是否一致.<br>如果一致,则说明此线程已经成功获得了锁,继续执行下面的代码.<br>如果不一致,则要检查一下对象是否还是可偏向,即“是否偏向锁”标志位的值。<br>如果还未偏向,则利用CAS操作来竞争锁,也即是第一次获取锁时的操作。<br>释放锁 偏向锁的释放采用了一种只有竞争才会释放锁的机制,线程是不会主动去释放偏向锁,需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<p>暂停拥有偏向锁的线程,判断锁对象石是否还处于被锁定状态；<br>撤销偏向锁,恢复到无锁状态或者轻量级锁的状态；<br>安全点会导致stw（stop the word）,导致性能下降,这种情况下应当禁用； </p>
<p>查看停顿–安全点停顿日志</p>
<p>要查看安全点停顿,可以打开安全点日志,通过设置JVM参数 -</p>
<p>XX:+PrintGCApplicationStoppedTime 会打出系统停止的时间,</p>
<p>添加-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 这两个参数会打印出详细信息,可以查看到使用偏向锁导致的停顿,时间非常短暂,但是争用严重的情况下,停顿次数也会非常多；</p>
<p>注意：安全点日志不能一直打开： </p>
<ol>
<li>安全点日志默认输出到stdout,一是stdout日志的整洁性,二是stdout所重定向的文件如果不在/dev/shm,可能被锁。 </li>
<li>对于一些很短的停顿,比如取消偏向锁,打印的消耗比停顿本身还大。 </li>
<li>安全点日志是在安全点内打印的,本身加大了安全点的停顿时间。</li>
</ol>
<p>所以安全日志应该只在问题排查时打开。<br>如果在生产系统上要打开,再再增加下面四个参数：<br>-XX:+UnlockDiagnosticVMOptions -XX: -DisplayVMOutput -XX:+LogVMOutput -XX:LogFile=/dev/shm/vm.log<br>打开Diagnostic（只是开放了更多的flag可选,不会主动激活某个flag）,关掉输出VM日志到stdout,输出到独立文件,/dev/shm目录（内存文件系统）。</p>
<p>此日志分三部分：<br>第一部分是时间戳,VM Operation的类型 </p>
<p>第二部分是线程概况,被中括号括起来 </p>
<p>total: 安全点里的总线程数<br>initially_running: 安全点时开始时正在运行状态的线程数<br>wait_to_block: 在VM Operation开始前需要等待其暂停的线程数</p>
<p>第三部分是到达安全点时的各个阶段以及执行操作所花的时间,其中最重要的是vmop</p>
<p>spin: 等待线程响应safepoint号召的时间；<br>block: 暂停所有线程所用的时间；<br>sync: 等于 spin+block,这是从开始到进入安全点所耗的时间,可用于判断进入安全点耗时；<br>cleanup: 清理所用时间；<br>vmop: 真正执行VM Operation的时间。<br>可见,那些很多但又很短的安全点,全都是RevokeBias, 高并发的应用会禁用掉偏向锁。</p>
<p>jvm开启/关闭偏向锁</p>
<p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0<br>关闭偏向锁：-XX:-UseBiasedLocking</p>
<p>六、轻量级锁<br>自旋锁的目标是降低线程切换的成本。如果锁竞争激烈,我们不得不依赖于重量级锁,让竞争失败的线程阻塞；如果完全没有实际的锁竞争,那么申请重量级锁都是浪费的。轻量级锁的目标是,减少无实际竞争情况下,使用重量级锁产生的性能消耗,包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。</p>
<p>顾名思义,轻量级锁是相对于重量级锁而言的。使用轻量级锁时,不需要申请互斥量,仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record（Lock Record：JVM检测到当前对象是无锁状态,则会在当前线程的栈帧中创建一个名为LOCKRECOD表空间用于copy Mark word 中的数据）,如果更新成功,则轻量级锁获取成功,记录锁状态为轻量级锁；否则,说明已经有线程获得了轻量级锁,目前发生了锁竞争（不适合继续使用轻量级锁）,接下来膨胀为重量级锁。</p>
<p>当然,由于轻量级锁天然瞄准不存在锁竞争的场景,如果存在锁竞争但不激烈,仍然可以用自旋锁优化,自旋失败后再膨胀为重量级锁。</p>
<p>缺点：同自旋锁相似：如果锁竞争激烈,那么轻量级将很快膨胀为重量级锁,那么维持轻量级锁的过程就成了浪费。</p>
<p>七、重量级锁<br>        轻量级锁膨胀之后,就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的,而monitor又依赖操作系统的MutexLock(互斥锁)来实现的,所以重量级锁也被成为互斥锁。<br>当轻量级所经过锁撤销等步骤升级为重量级锁之后,它的Markword部分数据大体如下</p>
<p>bit fields</p>
<p>锁标志位</p>
<p>指向Mutex的指针</p>
<p>10</p>
<p>为什么说重量级锁开销大呢</p>
<p>主要是,当系统检查到锁是重量级锁之后,会把等待想要获得锁的线程进行阻塞,被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时,都需要操作系统来帮忙,这就需要从用户态转换到内核态,而转换状态是需要消耗很多时间的,有可能比用户执行代码的时间还要长。<br>这就是说为什么重量级线程开销很大的。</p>
<p>互斥锁(重量级锁)也称为阻塞同步、悲观锁</p>
<p>八、总结<br>        偏向所锁,轻量级锁都是乐观锁,重量级锁是悲观锁。</p>
<pre><code>    一个对象刚开始实例化的时候,没有任何线程来访问它的时候。它是可偏向的,意味着,它现在认为只可能有一个线程来访问它,所以当第一个
</code></pre>
<p>线程来访问它的时候,它会偏向这个线程,此时,对象持有偏向锁。偏向第一个线程,这个线程在修改对象头成为偏向锁的时候使用CAS操作,并将<br>对象头中的ThreadID改成自己的ID,之后再次访问这个对象时,只需要对比ID,不需要再使用CAS在进行操作。</p>
<pre><code>    一旦有第二个线程访问这个对象,因为偏向锁不会主动释放,所以第二个线程可以看到对象时偏向状态,这时表明在这个对象上已经存在竞争了,检查原来持有该对象锁的线程是否依然存活,如果挂了,则可以将对象变为无锁状态,然后重新偏向新的线程,如果原来的线程依然存活,则马上执行那个线程的操作栈,检查该对象的使用情况,如果仍然需要持有偏向锁,则偏向锁升级为轻量级锁,（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了,则可以将对象回复成无锁状态,然后重新偏向。


    轻量级锁认为竞争存在,但是竞争的程度很轻,一般两个线程对于同一个锁的操作都会错开,或者说稍微等待一下（自旋）,另一个线程就会释放锁。但是当自旋超过一定的次数,或者一个线程在持有锁,一个在自旋,又有第三个来访时,轻量级锁膨胀为重量级锁,重量级锁使除了拥有锁的线程以外的线程都阻塞,防止CPU空转。
</code></pre>
<p>转载博文：<a href="https://cloud.tencent.com/developer/article/1698812?from=article.detail.2019347">https://cloud.tencent.com/developer/article/1698812?from=article.detail.2019347</a></p>
<h2 id="Mysql-json数据查询"><a href="#Mysql-json数据查询" class="headerlink" title="Mysql json数据查询"></a>Mysql json数据查询</h2><p>1、使用 字段-&gt;’$.json属性’ 进行查询条件</p>
<p>2、使用 json_extract 函数查询,json_extract(字段, “$.json属性”)</p>
<p>3、根据json数组查询,用 JSON_CONTAINS(字段, JSON_OBJECT(‘json属性’, “内容”))</p>
<p>举例：</p>
<p>SELECT * from<br>test<br>– WHERE attributes -&gt; ‘$.orderInviteCode.inviterUserId’ = 310000000780<br>– WHERE json_extract(attributes, “$.orderInviteCode.inviterUserId”) = 310000000780</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>Thread类有7个基本构造函数,当指定线程执行顺序时,可调用start方法,然后调用join方法,其中join的实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       join(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   			↓</span><br><span class="line">			↓</span><br><span class="line">			↓</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">               wait(<span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">               <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">               <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               wait(delay);</span><br><span class="line">               now = System.currentTimeMillis() - base;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>java无法销毁一个线程,但是当调用isAlive方法时,返回false则已销毁<br>为什么放弃了stop方法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">			 <span class="keyword">this</span> method is inherently unsafe.  Stopping a thread with</span><br><span class="line">     *       Thread.stop causes it to unlock all of the monitors that it</span><br><span class="line">     *       <span class="function">has <span class="title">locked</span> <span class="params">(as a natural consequence of the unchecked</span></span></span><br><span class="line"><span class="params"><span class="function">     *       &#123;<span class="meta">@code</span> ThreadDeath&#125; exception propagating up the stack)</span>.  If</span></span><br><span class="line"><span class="function">     *       any of the objects previously <span class="keyword">protected</span> by these monitors were in</span></span><br><span class="line"><span class="function">     *       an inconsistent state, the damaged objects become visible to</span></span><br><span class="line"><span class="function">     *       other threads, potentially resulting in arbitrary behavior.  Many</span></span><br><span class="line"><span class="function">     *       uses of </span>&#123;<span class="meta">@code</span> stop&#125; should be replaced by code that simply</span><br><span class="line">     *       modifies some variable to indicate that the target thread should</span><br><span class="line">     *       stop running.  The target thread should check <span class="keyword">this</span> variable</span><br><span class="line">     *       regularly, and <span class="keyword">return</span> from its run method in an orderly fashion</span><br><span class="line">     *       <span class="keyword">if</span> the variable indicates that it is to stop running.  If the</span><br><span class="line">     *       <span class="function">target thread waits <span class="keyword">for</span> <span class="keyword">long</span> <span class="title">periods</span> <span class="params">(on a condition variable,</span></span></span><br><span class="line"><span class="params"><span class="function">     *       <span class="keyword">for</span> example)</span>, the </span>&#123;<span class="meta">@code</span> interrupt&#125; method should be used to</span><br><span class="line">     *       interrupt the wait.</span><br><span class="line">     *       For more information, see</span><br><span class="line">     *       &lt;a href=<span class="string">&quot;&#123;@docRoot&#125;/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;</span>&gt;Why</span><br><span class="line">     *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.</span><br><span class="line">防止死锁ddd</span><br><span class="line">所以已经在<span class="number">1.2</span>就过期了</span><br></pre></td></tr></table></figure>
<p>说明Thread interrupt（）  isinterrupted（）interrupted 的区别和含义<br>Thread.interrupt()   设置状态<br>isInterrupted()    判断 返回Boolean<br>interrupted 即判断又清除</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先是一个<span class="keyword">native</span>方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>向调度程序提示当前线程愿意让步,使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择,也就是说,当前也就是刚刚的那个线程还是有可能会被再次执行到的,并不是说一定会执行其他线程而该线程在下一次中不会执行到了.</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>CompletableFuture</title>
    <url>/posts/20220728clhk6ptdn0009csuj09a7gn22.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>想学习CompletableFuture，因此查询资料发现<br>CompletableFuture是JDK8中的新特性，主要用于对JDK5中加入的Future的补充。<br>CompletableFuture实现了CompletionStage和Future接口。<br>需要先了解Future接口<br>什么是Future？<br>简单来说future就是一个Future对象，当执行return await。。。的时候，实际上返回的是一个延迟计算的Future对象，这个Future对象是Dart内置的，有自己的队列策略，它将要操作的事件放入EventQueue中，在队列中的事件按照先进先出的原则去逐一处理事件，当事件处理完成后，将结果返回给Future对象。</p>
<p>在这个过程中涉及到了异步和等待：</p>
<p>异步：就是不用阻塞当前线程，来等待该线程任务处理完成再去执行其他任务。<br>等待：await，声明运算为延迟执行<br>async和await<br>首先看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getData() async&#123;</span><br><span class="line">   return await http.get(Uri.encodeFull(url), headers: &#123;&quot;Accept&quot;: &quot;application/json&quot;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">//然后调用函数来获取结果</span><br><span class="line">String data = getData();</span><br></pre></td></tr></table></figure>

<p>这段代码在运行的时候会报错。<br>因为data是String类型，而函数getData()是一个异步操作函数，其返回值是一个await延迟执行的结果。<br>在Dart中，有await标记的运算，结果都是一个Future对象，Future不是String类型，所以就报错了。<br>如何获取异步函数的结果呢？Dart规定有async标记的函数，只能由await来调用，那么我们可以在函数前加一个await关键字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String data;</span><br><span class="line">setData() async &#123;</span><br><span class="line">  data = <span class="function">await <span class="title">getData</span><span class="params">()</span></span>;    <span class="comment">//getData()延迟执行后赋值给data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async和await的使用其实就只有两点：</p>
<p>await关键字必须在async函数内部使用<br>调用async函数必须使用await关键字</p>
<p>Dart(释义：镖)异步<br>Dart是单线程模型，是一种Event-Looper以及Event-Queue的模型，所有的事件都是通过EventLooper的依次执行。</p>
<p>Event-Looper与Netty的NioEventLoopGroup异曲同工，都是线程模型</p>
<p>作者：zhaoolee<br>链接：<a href="https://www.jianshu.com/p/aefd0e50b802">https://www.jianshu.com/p/aefd0e50b802</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>单线程模型<br>所谓单线程，就是一旦一个函数开始执行，就必须将这个函数执行完，才能去执行其他函数</p>
<p>作者：MakerChin<br>链接：<a href="https://www.jianshu.com/p/890df7ea8f87">https://www.jianshu.com/p/890df7ea8f87</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>Future接口的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//取消任务。参数:是否立即中断任务执行，或者等等任务结束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//任务是否已经取消，若已取消，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//任务是否已经完成。包括任务正常完成、抛出异常或被取消，都返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*等待任务执行结束，获得V类型的结果。InterruptedException: 线程被中断异常， ExecutionException: 任务执行异常，如果任务被取消，还会抛出CancellationException*/</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计算超时，将抛出TimeoutException*/</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用不带参数的get方法的调用被阻塞，直到计算完成。如果在计算完成之前，调用带参get()方法超时时，会抛出TimeoutException异常。若运行该计算的线程被中断，两种get()方法都会抛出InterruptedException。如果计算已经完成，那么get方法立即返回。<br>若计算还在进行，isDone方法返回false；如果完成了，则返回true。<br>调用cancel()时，若计算还没有开始，它被取消且不再开始。若计算处于运行之中，那么如果mayInterrupt参数为true，它就被中断。<br>相比future.get()，其实更推荐使用get (long timeout, TimeUnit unit) 方法，因为设置了超时时间可以防止程序无限制的等待future的返回结果。<br>FutureTask源码解析<br>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="comment">//状态为NEW</span></span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>实际上Callable = Runnable + result，继续看上面的第二个构造方法，看看Executors.callable(runnable, result)的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//new了一个RunnableAdapter,返回Callable,说明RunnableAdapter实现了Callable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>状态值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//初始化状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//正在执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//正常完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//出现异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//正被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//已被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>FutureTask的run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*compareAndSwapObject(this, runnerOffset,]null, Thread.currentThread()))</span></span><br><span class="line"><span class="comment">         其中第一个参数为需要改变的对象，第二个为偏移量，第三个参数为期待的值，第四个为更新后的值。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//call()方法是由FutureTask调用的,说明call()不是异步执行的</span></span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//设置异常</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>set方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// NEW -&gt; COMPLETING</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            <span class="comment">//返回结果,也包括异常</span></span><br><span class="line">            outcome = v;</span><br><span class="line">            <span class="comment">//COMPLETING -&gt; NORMAL</span></span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">            <span class="comment">//唤醒等待的线程</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>get方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//是否是未完成状态,是则等待</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            <span class="comment">//等待过程</span></span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/itcats_cn/article/details/81322122">https://blog.csdn.net/itcats_cn/article/details/81322122</a></p>
<p>CompletableFuture类的官方API文档解释：</p>
<p>CompletableFuture是一个在完成时可以触发相关方法和操作的Future，并且它可以视作为CompletableStage。<br>除了直接操作状态和结果的这些方法和相关方法外（CompletableFuture API提供的方法），CompletableFuture还实现了以下的CompletionStage的相关策略：<br>① 非异步方法的完成，可以由当前CompletableFuture的线程提供，也可以由其他调用完方法的线程提供。<br>② 所有没有显示使用Executor的异步方法，会使用ForkJoinPool.commonPool()（那些并行度小于2的任务会创建一个新线程来运行）。为了简化监视、调试和跟踪异步方法，所有异步任务都被标记为CompletableFuture.AsynchronouseCompletionTask。<br>③ 所有CompletionStage方法都是独立于其他公共方法实现的，因此一个方法的行为不受子类中其他方法的覆盖影响。<br>CompletableFuture还实现了Future的以下策略<br>① 不像FutureTask，因CompletableFuture无法直接控制计算任务的完成，所以CompletableFuture的取消会被视为异常完成。调用cancel()方法会和调用completeExceptionally（）方法一样，具有同样的效果。isCompletedEceptionally()方法可以判断CompletableFuture是否是异常完成。<br>② 在调用get()和get(long, TimeUnit)方法时以异常的形式完成，则会抛出ExecutionException,大多数情况下都会使用join()和getNow(T)，它们会抛出CompletionException。<br>小结：</p>
<p>Concurrent包中的Future在获取结果时会发生阻塞，而CompletableFuture则不会，它可以通过触发异步方法来获取结果。<br>在CompletableFuture中，如果没有显示指定的Executor的参数，则会调用默认的ForkJoinPool.commonPool()。<br>调用CompletableFuture的cancel()方法和调用completeExceptionally()方法的效果一样。<br>在JDK5中，使用Future来获取结果时都非常的不方便，只能通过get()方法阻塞线程或者通过轮询isDone()的方式来获取任务结果，这种阻塞或轮询的方式会无畏的消耗CPU资源，而且还不能及时的获取任务结果，因此JDK8中提供了CompletableFuture来实现异步的获取任务结果。</p>
<p>使用下CompletableFuture的API<br>CompletableFuture类提供了非常多的方法供我们使用，包括了runAsync()、supplyAsync()、thenAccept()等方法。<br>runAsync()，异步运行:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAsyncExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, executorService);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cf.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CompletedFuture...isDown&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">CompletedFuture…isDown</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里调用的runAsync()方法没有使用ForkJoinPool的线程，而是使用了Executors.newSingleThreadExecutor()中的线程。runAsync()其实效果跟单开一个线程一样。<br>supplyAsync()</p>
<p>supply有供应的意思，supplyAsync就可以理解为异步供应，查看supplyAsync()方法入参可以知道，其有两个入参：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Supplier supplier,</span><br><span class="line">Executor executor</span><br></pre></td></tr></table></figure>
<p>这里先简单介绍下Supplier接口，Supplier接口是JDK8引入的新特性，它也是用于创建对象的，只不过调用Supplier的get()方法时，才会去通过构造方法去创建对象，并且每次创建出的对象都不一样。Supplier常用语法为：Supplier<MySupplier> sup= MySupplier::new;<br>再展示代码例子之前，再讲一个thenAccept()方法，可以发现thenAccept()方法的入参如下：</MySupplier></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Comsumer&lt;? super T&gt;</span><br><span class="line">Comsumer接口同样是java8新引入的特性，它有两个重要接口方法：</span><br><span class="line"></span><br><span class="line">accept()</span><br><span class="line">andThen()</span><br><span class="line">thenAccept()可以理解为接收CompletableFuture的结果然后再进行处理。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面看下supplyAsync()和thenAccept()的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void thenApply() throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(2);</span><br><span class="line">        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123; //实现了Supplier的get()方法</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;supplyAsync &quot; + Thread.currentThread().getName());</span><br><span class="line">            return &quot;hello &quot;;</span><br><span class="line">        &#125;,executorService).thenAccept(s -&gt; &#123; //实现了Comsumper的accept()方法</span><br><span class="line">            try &#123;</span><br><span class="line">                thenApply_test(s + &quot;world&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (cf.isDone()) &#123;</span><br><span class="line">                System.out.println(&quot;CompletedFuture...isDown&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">supplyAsync pool-1-thread-1</span><br><span class="line">thenApply_test hello world</span><br><span class="line">thenApply_test pool-1-thread-1</span><br></pre></td></tr></table></figure>
<p>从代码逻辑可以看出，thenApply_test等到了pool-1-thread-1线程完成任务后，才进行的调用，并且拿到了supplye()方法返回的结果，而main则异步执行了，这就避免了Future获取结果时需要阻塞或轮询的弊端。<br>exceptionally<br>当任务在执行过程中报错了咋办？exceptionally()方法很好的解决了这个问题，当报错时会去调用exceptionally()方法，它的入参为：Function&lt;Throwable, ? extends T&gt; fn，fn为执行任务报错时的回调方法，下面看看代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void exceptionally() &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if (1 == 1) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;测试exceptionally...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;s1&quot;;</span><br><span class="line">        &#125;, executorService).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            return &quot;helloworld &quot; + e.getMessage();</span><br><span class="line">        &#125;);</span><br><span class="line">        cf.thenAcceptAsync(s -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;thenAcceptAsync: &quot; + s);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;main: &quot; + Thread.currentThread().getName());</span><br><span class="line">        while (true) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main: main</span><br><span class="line">java.lang.RuntimeException: 测试exceptionally…</span><br><span class="line">CompletableFuture is Down…helloworld java.lang.RuntimeException: 测试exceptionally…</span><br><span class="line">thenAcceptAsync: helloworld java.lang.RuntimeException: 测试exceptionally…</span><br></pre></td></tr></table></figure>
<p>从代码以及运行结果来看，当任务执行过程中报错时会执行exceptionally()中的代码，thenAcceptAsync()会获取抛出的异常并输出到控制台，不管CompletableFuture()执行过程中报错、正常完成、还是取消，都会被标示为已完成，所以最后CompletableFuture.isDown()为true。</p>
<p>在Java8中，新增的ForkJoinPool.commonPool()方法，这个方法可以获得一个公共的ForkJoin线程池，这个公共线程池中的所有线程都是Daemon线程，意味着如果主线程退出，这些线程无论是否执行完毕，都会退出系统。</p>
<p>2.3 源码分析<br>CompletableFuture类实现了Future接口和CompletionStage接口，Future大家都经常遇到，但是这个CompletionStage接口就有点陌生了，这里的CompletionStage实际上是一个任务执行的一个“阶段”，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; &#123;</span><br><span class="line">	volatile Object result;       // CompletableFuture的结果值或者是一个异常的报装对象AltResult</span><br><span class="line">    volatile Completion stack;    // 依赖操作栈的栈顶</span><br><span class="line">    ...</span><br><span class="line">    // CompletableFuture的方法</span><br><span class="line">    ... </span><br><span class="line">	// Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">    private static final long RESULT;</span><br><span class="line">    private static final long STACK;</span><br><span class="line">    private static final long NEXT;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            final sun.misc.Unsafe u;</span><br><span class="line">            UNSAFE = u = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = CompletableFuture.class;</span><br><span class="line">            RESULT = u.objectFieldOffset(k.getDeclaredField(&quot;result&quot;)); //计算result属性的位偏移量</span><br><span class="line">            STACK = u.objectFieldOffset(k.getDeclaredField(&quot;stack&quot;)); //计算stack属性的位偏移量</span><br><span class="line">            NEXT = u.objectFieldOffset </span><br><span class="line">                (Completion.class.getDeclaredField(&quot;next&quot;));  //计算next属性的位偏移量</span><br><span class="line">        &#125; catch (Exception x) &#123;</span><br><span class="line">            throw new Error(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在CompletableFuture中有一个静态代码块，在CompletableFuture类初始化之前就进行调用，代码块里的内容就是通过Unsafe类去获取CompletableFuture的result、stack和next属性的“偏移量”，这个偏移量主要用于Unsafe的CAS操作时进行位移量的比较。<br>runAsync(Runnable, Executor) &amp; runAsync(Runnable)<br>runAsync()做的事情就是异步的执行任务，返回的是CompletableFuture对象，不过CompletableFuture对象不包含结果。runAsync()方法有两个重载方法，这两个重载方法的区别是Executor可以指定为自己想要使用的线程池，而runAsync(Runnable)则使用的是ForkJoinPool.commonPool()。</p>
<p>下面先来看看runAsync(Runnable)的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) &#123;</span><br><span class="line">       return asyncRunStage(asyncPool, runnable);</span><br><span class="line">   &#125;</span><br><span class="line">这里的asyncPool是一个静态的成员变量：</span><br></pre></td></tr></table></figure>
<p>private static final boolean useCommonPool =<br>        (ForkJoinPool.getCommonPoolParallelism() &gt; 1); // 并行级别<br>private static final Executor asyncPool = useCommonPool ?<br>    ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();<br>回到asyncRunStage()源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static CompletableFuture&lt;Void&gt; asyncRunStage(Executor e, Runnable f) &#123;</span><br><span class="line">       if (f == null) throw new NullPointerException();</span><br><span class="line">       CompletableFuture&lt;Void&gt; d = new CompletableFuture&lt;Void&gt;();</span><br><span class="line">       e.execute(new AsyncRun(d, f));</span><br><span class="line">       return d;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>看到asyncRunStage()源码，可以知道任务是由Executor来执行的，那么可想而知Async类一定是实现了Callable接口或者继承了Runnable类，查看Async类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class AsyncRun extends ForkJoinTask&lt;Void&gt;</span><br><span class="line">            implements Runnable, AsynchronousCompletionTask &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; dep; Runnable fn;</span><br><span class="line">        AsyncRun(CompletableFuture&lt;Void&gt; dep, Runnable fn) &#123;</span><br><span class="line">            this.dep = dep; this.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final Void getRawResult() &#123; return null; &#125;</span><br><span class="line">        public final void setRawResult(Void v) &#123;&#125;</span><br><span class="line">        public final boolean exec() &#123; run(); return true; &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            CompletableFuture&lt;Void&gt; d; Runnable f;</span><br><span class="line">            if ((d = dep) != null &amp;&amp; (f = fn) != null) &#123;</span><br><span class="line">                dep = null; fn = null;//释放掉内存</span><br><span class="line">                if (d.result == null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        f.run();</span><br><span class="line">                        d.completeNull();</span><br><span class="line">                    &#125; catch (Throwable ex) &#123;</span><br><span class="line">                        d.completeThrowable(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d.postComplete(); // 任务结束后，会执行所有依赖此任务的其他任务，这些任务以一个无锁并发栈的形式存在</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在AsyncRun类中，实现了Runnable接口的run()方法，在run()方法内部，会调用传进来的Runnable对象的run()方法，这里就需要用户自己去实现了，上文中的实例代码就是通过Lambda表达式来实现了Runnable接口。调用了f.run()之后，然后就是completeNull()方法了，该方法底层通过调用UNSAFE类的compareAndSwapObject()方法，来以CAS的方式将CompletableFuture的结果赋为null。postComplete()就是任务结束后，会执行所有依赖此任务的其他任务，这些任务以一个无锁并发栈的形式存在。<br>postComplete()的源码还是有点复杂的，先不急着分析。先看看Completion这个抽象类的数据结构组成：</p>
<p>Completion<br>下面先看看Completion的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果触发，则执行完成操作，返回可能需要传播的依赖项（如果存在）。</span><br><span class="line">@param mode SYNC, ASYNC, or NESTED</span><br><span class="line">abstract static class Completion extends ForkJoinTask&lt;Void&gt;</span><br><span class="line">        implements Runnable, AsynchronousCompletionTask &#123;</span><br><span class="line">        volatile Completion next;      </span><br><span class="line">        abstract CompletableFuture&lt;?&gt; tryFire(int mode);</span><br><span class="line">        abstract boolean isLive();</span><br><span class="line"></span><br><span class="line">        public final void run()                &#123; tryFire(ASYNC); &#125;</span><br><span class="line">        public final boolean exec()            &#123; tryFire(ASYNC); return true; &#125;</span><br><span class="line">        public final Void getRawResult()       &#123; return null; &#125;</span><br><span class="line">        public final void setRawResult(Void v) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Completion是一个抽象类，分别实现了Runnable、AsynchronousCompletionTask接口，继承了ForkJoinPoolTask类，而ForJoinPoolTask抽象类又实现了Future接口，因此Completion实际上就是一个Future。可以看到Completion的抽象方法和成员方法的实现逻辑都短短一行或者没有，可以猜到这些方法的实现都是在其子类中。其实现类包括了UniCompletion、BiCompletion、UniAccept、BiAccept等，如下图：<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Completion.jpg" alt="流程"></p>
<p>而Completion类中还有一个非常重要的成员属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile Completion next;</span><br></pre></td></tr></table></figure>
<p>有印象的读者应该能记得，CompletableFuture中有一个属性——stack，就是Completion类的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile Completion stack;</span><br></pre></td></tr></table></figure>
<p>由这个属性可以看出，CompletableFuture其实就是一个链表的一个数据结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract static class UniCompletion&lt;T,V&gt; extends Completion &#123;</span><br><span class="line">        Executor executor;                 // executor to use (null if none)</span><br><span class="line">        CompletableFuture&lt;V&gt; dep;          // 代表的依赖的CompletableFuture</span><br><span class="line">        CompletableFuture&lt;T&gt; src;          // 代表的是源CompletableFuture</span><br><span class="line"></span><br><span class="line">        UniCompletion(Executor executor, CompletableFuture&lt;V&gt; dep,</span><br><span class="line">                      CompletableFuture&lt;T&gt; src) &#123;</span><br><span class="line">            this.executor = executor; this.dep = dep; this.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * 确保当前Completion可以被调用；并且使用ForkJoinPool标记为来确保只有一个线程可以调用，</span><br><span class="line">         * 如果是异步的，则在任务启动之后通过tryFire来进行调用。tryFire方法时在UniAccept类中。</span><br><span class="line">         */</span><br><span class="line">        final boolean claim() &#123;</span><br><span class="line">            Executor e = executor;</span><br><span class="line">            if (compareAndSetForkJoinTaskTag((short)0, (short)1)) &#123;</span><br><span class="line">                if (e == null)</span><br><span class="line">                    return true;</span><br><span class="line">                executor = null; // disable</span><br><span class="line">                e.execute(this);</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean isLive() &#123; return dep != null; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>claim方法要在执行action前调用，若claim方法返回false，则不能调用action，原则上要保证action只执行一次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class UniAccept&lt;T&gt; extends UniCompletion&lt;T,Void&gt; &#123;</span><br><span class="line">        Consumer&lt;? super T&gt; fn;</span><br><span class="line">        UniAccept(Executor executor, CompletableFuture&lt;Void&gt; dep,</span><br><span class="line">                  CompletableFuture&lt;T&gt; src, Consumer&lt;? super T&gt; fn) &#123;</span><br><span class="line">            super(executor, dep, src); this.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 尝试去调用当前任务。uniAccept()方法为核心逻辑。</span><br><span class="line">         */</span><br><span class="line">        final CompletableFuture&lt;Void&gt; tryFire(int mode) &#123;</span><br><span class="line">            CompletableFuture&lt;Void&gt; d; CompletableFuture&lt;T&gt; a;</span><br><span class="line">            if ((d = dep) == null ||</span><br><span class="line">                !d.uniAccept(a = src, fn, mode &gt; 0 ? null : this))</span><br><span class="line">                return null;</span><br><span class="line">            dep = null; src = null; fn = null;</span><br><span class="line">            return d.postFire(a, mode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final &lt;S&gt; boolean uniAccept(CompletableFuture&lt;S&gt; a,</span><br><span class="line">                                Consumer&lt;? super S&gt; f, UniAccept&lt;S&gt; c) &#123;</span><br><span class="line">        Object r; Throwable x;</span><br><span class="line">        if (a == null || (r = a.result) == null || f == null) //判断源任务是否已经完成了，a表示的就是源任务，a.result就代表的是原任务的结果。</span><br><span class="line">            return false;</span><br><span class="line">        tryComplete: if (result == null) &#123;</span><br><span class="line">            if (r instanceof AltResult) &#123;</span><br><span class="line">                if ((x = ((AltResult)r).ex) != null) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    break tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = null;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (c != null &amp;&amp; !c.claim())</span><br><span class="line">                    return false;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;) S s = (S) r;</span><br><span class="line">                f.accept(s);  //去调用Comsumer</span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于Completion的执行，还有几个关键的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int SYNC   =  0;//同步</span><br><span class="line">static final int ASYNC  =  1;//异步</span><br><span class="line">static final int NESTED = -1;//嵌套</span><br></pre></td></tr></table></figure>
<p>Completion在CompletableFuture中是如何工作的呢？现在先不着急了解其原理，下面再去看下一个重要的接口——CompletionStage。</p>
<p>CompletionStage<br>下面介绍下CompletionStage接口。看字面意思可以理解为“完成动作的一个阶段”，查看官方注释文档：CompletionStage是一个可能执行异步计算的“阶段”，这个阶段会在另一个CompletionStage完成时调用去执行动作或者计算，一个CompletionStage会以正常完成或者中断的形式“完成”，并且它的“完成”会触发其他依赖的CompletionStage。CompletionStage 接口的方法一般都返回新的CompletionStage，因此构成了链式的调用。<br>【下文中Stage代表CompletionStage】</p>
<p>那么在Java中什么是CompletionStage呢？<br>官方定义中，一个Function，Comsumer或者Runnable都会被描述为一个CompletionStage，相关方法比如有apply，accept，run等，这些方法的区别在于它们有些是需要传入参，有些则会产生“结果”。</p>
<p>Funtion方法会产生结果<br>Comsumer会消耗结果<br>Runable既不产生结果也不消耗结果<br>下面看看一个Stage的调用例子：</p>
<p>stage.thenApply(x -&gt; square(x)).thenAccept(x -&gt; System.out.println(x)).thenRun(() -&gt; System.out.println())<br>1<br>这里x -&gt; square(x)就是一个Function类型的Stage，它返回了x。x -&gt; System.out.println(x)就是一个Comsumer类型的Stage，用于接收上一个Stage的结果x。() -&gt;System.out.println()就是一个Runnable类型的Stage，既不消耗结果也不产生结果。</p>
<p>一个、两个或者任意一个CompletionStage的完成都会触发依赖的CompletionStage的执行，CompletionStage的依赖动作可以由带有then的前缀方法来实现。如果一个Stage被两个Stage的完成给触发，则这个Stage可以通过相应的Combine方法来结合它们的结果，相应的Combine方法包括：thenCombine、thenCombineAsync。但如果一个Stage是被两个Stage中的其中一个触发，则无法去combine它们的结果，因为这个Stage无法确保这个结果是那个与之依赖的Stage返回的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testCombine() throws Exception &#123;</span><br><span class="line">       String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           return &quot;hello&quot;;</span><br><span class="line">       &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           return &quot; world&quot;;</span><br><span class="line">       &#125;), (s1, s2) -&gt; s1 + &quot; &quot; + s2).join();</span><br><span class="line"></span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>虽然Stage之间的依赖关系可以控制触发计算，但是并不能保证任何的顺序。</p>
<p>另外，可以用一下三种的任何一种方式来安排一个新Stage的计算：default execution、default asynchronous execution（方法后缀都带有async）或者custom（自定义一个executor）。默认和异步模式的执行属性由CompletionStage实现而不是此接口指定。</p>
<p>小结：CompletionStage确保了CompletableFuture能够进行链式调用。</p>
<p>下面开始介绍CompletableFuture的几个核心方法：</p>
<p>postComplete</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void postComplete() &#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; f = this; Completion h;    //this表示当前的CompletableFuture</span><br><span class="line">        while ((h = f.stack) != null ||                                  //判断stack栈是否为空</span><br><span class="line">               (f != this &amp;&amp; (h = (f = this).stack) != null)) &#123;    </span><br><span class="line">            CompletableFuture&lt;?&gt; d; Completion t;      </span><br><span class="line">            if (f.casStack(h, t = h.next)) &#123;                          //通过CAS出栈，</span><br><span class="line">                if (t != null) &#123;</span><br><span class="line">                    if (f != this) &#123;</span><br><span class="line">                        pushStack(h);             //如果f不是this，将刚出栈的h入this的栈顶</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    h.next = null;    // detach   帮助GC</span><br><span class="line">                &#125;</span><br><span class="line">                f = (d = h.tryFire(NESTED)) == null ? this : d;        //调用tryFire</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>postComplete()方法可以理解为当任务完成之后，调用的一个“后完成”方法，主要用于触发其他依赖任务。</p>
<p>uniAccept</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final &lt;S&gt; boolean uniAccept(CompletableFuture&lt;S&gt; a,</span><br><span class="line">                                Consumer&lt;? super S&gt; f, UniAccept&lt;S&gt; c) &#123;</span><br><span class="line">        Object r; Throwable x;</span><br><span class="line">        if (a == null || (r = a.result) == null || f == null)    //判断当前CompletableFuture是否已完成，如果没完成则返回false；如果完成了则执行下面的逻辑。</span><br><span class="line">            return false;</span><br><span class="line">        tryComplete: if (result == null) &#123;</span><br><span class="line">            if (r instanceof AltResult) &#123;   //判断任务结果是否是AltResult类型</span><br><span class="line">                if ((x = ((AltResult)r).ex) != null) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    break tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = null;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (c != null &amp;&amp; !c.claim()) //判断当前任务是否可以执行</span><br><span class="line">                    return false;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;) S s = (S) r;   //获取任务结果</span><br><span class="line">                f.accept(s);    //执行Comsumer</span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个很巧妙的地方，就是uniAccept的入参中，CompletableFuture a表示的是源任务，UniAccept c中报装有依赖的任务，这点需要清除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushStack</span><br><span class="line"></span><br><span class="line">	final void pushStack(Completion c) &#123;</span><br><span class="line">        do &#123;&#125; while (!tryPushStack(c));      //使用CAS自旋方式压入栈，避免了加锁竞争</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	final boolean tryPushStack(Completion c) &#123;</span><br><span class="line">        Completion h = stack;         </span><br><span class="line">        lazySetNext(c, h);   //将当前stack设置为c的next</span><br><span class="line">        return UNSAFE.compareAndSwapObject(this, STACK, h, c); //尝试把当前栈（h）更新为新值（c）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	static void lazySetNext(Completion c, Completion next) &#123;</span><br><span class="line">        UNSAFE.putOrderedObject(c, NEXT, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>光分析源码也没法深入理解其代码原理，下面结合一段示例代码来对代码原理进行分析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void thenApply() throws Exception &#123;</span><br><span class="line">       ExecutorService executorService = Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">       CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">                //休眠200秒</span><br><span class="line">               Thread.sleep(200000);</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(&quot;supplyAsync &quot; + Thread.currentThread().getName());</span><br><span class="line">           return &quot;hello &quot;;</span><br><span class="line">       &#125;,executorService).thenAccept(s -&gt; &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               thenApply_test(s + &quot;world&quot;);</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       System.out.println(Thread.currentThread().getName());</span><br><span class="line">       while (true) &#123;</span><br><span class="line">           if (cf.isDone()) &#123;</span><br><span class="line">               System.out.println(&quot;CompletedFuture...isDown&quot;);</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 运行结果：</span><br><span class="line">    main</span><br><span class="line">    supplyAsync pool-1-thread-1</span><br><span class="line">    thenApply_test hello world</span><br><span class="line">    thenApply_test pool-1-thread-1</span><br><span class="line">    CompletedFuture...isDown</span><br><span class="line">    */</span><br></pre></td></tr></table></figure>
<p>这段示例代码所做的事情就是supplyAsync(Supplier supplier)休眠200秒之后，返回一个字符串，thenAccept(Consumer&lt;? super T&gt; action)等到任务完成之后接收这个字符串，并且调用thenApply_test()方法，随后输出 hello world。<br>代码中让线程休眠200秒是为了方便观察CompletableFuture的传递过程。</p>
<p>下面就描述下程序的整个运作流程。<br>① 主线程调用CompletableFuture的supplyAsync()方法，传入Supplier和Executor。在supplyAsync()中又继续调用CompletableFuture的asyncSupplyStage(Executor, Supplier)方法。</p>
<p>来到asyncSupplyStage()方法中，调用指定的线程池，并执行execute(new AsyncSupply(d,f))，这里d就是我们的“源任务”，接下来thenApply()要依赖着这个源任务进行后续逻辑操作，f就是Supplier的函数式编程。</p>
<p>AsyncSupply实现了Runnable的run()方法，核心逻辑就在run()方法里。在run()方法里，先判断d.result == null，判断该任务是否已经完成，防止并发情况下其他线程完成此任务了。f.get()就是调用的Supplier的函数式编程，这里会休眠200秒，所以executor线程池开启的线程会在这里阻塞200秒。</p>
<p>② 虽然executor线程池线程阻塞了，但是main线程任然会继续执行接下来的代码。</p>
<p>main线程会在asyncSupplyStage()方法中返回d，就是我们的“依赖任务”，而这个任务此时还处在阻塞中。接下来main线程会继续执行CompletableFuture的thenAccept(Comsumer&lt;? super T&gt; action)方法，然后调用CompletableFuture的uniAcceptStage()方法。<br>在这里插入图片描述<br>在uniAcceptStage()方法中，会将“依赖任务”、“源任务”、线程池以及Comsumer报装程一个UniAccept对象，然后调用push()压入stack的栈顶中。随后调用UniAccept的tryFire()方法。<br>在这里插入图片描述<br>其中的CompletableFuture的uniAccept()方法会判断任务是否完成，判断依据是a.result 是否为空，这里的a就是之前传入的“源任务”，等到“源任务”阻塞200秒过后，就会完成任务，并将字符串存入到 result中。<br>在这里插入图片描述<br>判断到“源任务”完成之后，就会调用接下来的逻辑。s拿到的值就是“源”任务返回的字符串，并且传入到了Comsumer.accept()方法中。然而“源任务”还在阻塞中，main线程会跳出uniAccept()，继续执行接下来的逻辑。接下来就是输出当前线程的名字，然后调用while(true)，结束条件为CompletableFuture.isDone()，当任务完成时则结束while(true)循环。</p>
<p>③ 回到“源任务”，虽然main线程已经结束了整个生命周期，但是executor线程池的线程任然阻塞着的，休眠了200秒之后，继续执行任务。<br>在这里插入图片描述<br>然后来到了postComplete()方法。这个方法在前面已经介绍到了，它是CompletableFuture的核心方法之一，做了许多事情。最重要的一件事情就是触发其他依赖任务，接下来调用的方法依次为：UniAccept.tryFire(mode) ——&gt; CompletableFuture.uniAccept(…) ——&gt; Comsumer.accept(s) ——&gt; 输出“hello world”，并输出当前调用线程的线程名。因这个调用链已经在②中介绍过了，所以就不再详细介绍其运作逻辑。<br>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">      runAsync();</span><br><span class="line">      supplyAsync();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //无返回值</span><br><span class="line">    public static void runAsync() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;run end ...&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        future.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //有返回值</span><br><span class="line">    public static void supplyAsync() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Long&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;run end ...&quot;);</span><br><span class="line">            return System.currentTimeMillis();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        long time = future.get();</span><br><span class="line">        System.out.println(&quot;time = &quot;+time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run end ...</span><br><span class="line">run end ...</span><br><span class="line">time = 1596010020281</span><br></pre></td></tr></table></figure>
<p>小结： 通过这个小示例，终于理解到了“源任务”和“依赖任务”之间的调用关系，以及CompletableFuture的基本运作原理。然而CompletableFuture还有其他的方法需要去深入分析，由于篇幅所限就不再赘述，感兴趣的读者可以以debug的模式去一点一点分析CompletableFuture其他方法的底层原理。这里不得不说Java并发包作者Doug Lea大神真的太厉害了，阅读他的源码之后，可以发现他写的代码不能以技术来形容，而应该使用“艺术”来形容。</p>
<p>总结<br>CompletableFuture底层由于借助了魔法类Unsafe的相关CAS方法，除了get或join结果之外，其他方法都实现了无锁操作。<br>CompletableFuture实现了CompletionStage接口，因而具备了链式调用的能力，CompletionStage提供了either、apply、run以及then等相关方法，使得CompletableFuture可以使用各种应用场景。<br>CompletableFuture中有“源任务”和“依赖任务”，“源任务”的完成能够触发“依赖任务”的执行，这里的完成可以是返回正常结果或者是异常。<br>CompletableFuture默认使用ForkJoinPool，也可以使用指定线程池来执行任务。</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>CompletableFuture</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅永不过时</title>
    <url>/posts/20220726clhk6pteg001ucsuj3ycu1ncd.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>无论是日常编码，还是业务涉及，能够优雅的表达思想，提高代码简洁度，阅读性都是一种能力，总结一下优雅的做法</p>
<p>优雅的关闭流<br>java7 try with resource，针对实现了AutoCloseable接口的类，都可优雅的关闭流，从而舍弃finally关闭</p>
<p>try catch finally</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader in = null;</span><br><span class="line">try &#123;</span><br><span class="line">			....</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (in != null) &#123;</span><br><span class="line">					in.close();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (Exception e2) &#123;</span><br><span class="line">				e2.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">try winth resource</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try (final BufferedReader in = new BufferedReader(new InputStreamReader((new URL(url + &quot;?&quot; + param)).openConnection().getInputStream()));PrintWriter out =new PrintWriter(response.getWriter()))&#123;</span><br><span class="line"></span><br><span class="line">	...	</span><br><span class="line">	&#125;catch&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Netty 优雅的关闭流程<br>1<br>shutdownGracefully()<br>Lambda表达式<br>list求交集</p>
<p>1<br>List<Long> collect = list1.stream().filter(list2::contains).collect(Collectors.toList());<br>设计模式代替if else,策略模式，模板模式<br>代码整洁度，例如多注入service，按着高矮胖瘦排列，视觉舒适，controller求求你别写业务代码了</Long></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public  List getRandomList(List&lt;?&gt; paramList,int count)&#123;</span><br><span class="line">        if(count==0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Random random=new Random();</span><br><span class="line">        List&lt;Integer&gt; tempList=new ArrayList&lt;&gt;();//临时存放产生的list索引，去除重复的索引</span><br><span class="line">        List newList=new ArrayList();//生成新的list集合</span><br><span class="line">        int temp=0;</span><br><span class="line">        if(count&lt;=1)&#123;//如果数据小于1，取一条数据</span><br><span class="line">            temp = random.nextInt(paramList.size());</span><br><span class="line">            newList.add(paramList.get(temp));</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for(int i=0;i&lt;Math.ceil(count);i++)&#123;</span><br><span class="line">                temp=random.nextInt(paramList.size());//初始化一个随机数，将产生的随机数作为被抽list的索引</span><br><span class="line">                if(!tempList.contains(temp))&#123;//判断随机抽取的随机数</span><br><span class="line">                    tempList.add(temp);</span><br><span class="line">                    newList.add(paramList.get(temp));</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>优雅判空<br>个人喜欢Assert判空，至于java8的Optional并没体会到优雅之处，日常StringUtils，Collections，isNoBlank等，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String testOptional(Test test) &#123;</span><br><span class="line">        return Optional.ofNullable(test).flatMap(Test::getTest3)</span><br><span class="line">                .flatMap(Test3::getTest2)</span><br><span class="line">                .map(Test2::getInfo)</span><br><span class="line">                .orElse(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">看起来挺优雅，但日常没体会到</span><br><span class="line">还有日常常用的instanceof</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else if (f instanceof TreeBin) &#123;</span><br><span class="line">        validated = true;</span><br><span class="line">        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">        if ((r = t.root) != null &amp;&amp;</span><br><span class="line">            (p = r.findTreeNode(hash, key, null)) != null) &#123;</span><br><span class="line">            V pv = p.val;</span><br><span class="line">            if (cv == null || cv == pv ||</span><br><span class="line">                (pv != null &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                oldVal = pv;</span><br><span class="line">                if (value != null)</span><br><span class="line">                    p.val = value;</span><br><span class="line">                else if (t.removeTreeNode(p))</span><br><span class="line">                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
  </entry>
  <entry>
    <title>Leetcode算法题</title>
    <url>/posts/20220726clhk6ptdr000hcsujea72h7n4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>一：力扣第14题 编写一个函数来查找字符串数组中的最长公共前缀<br>官方解法：<br>##方法一：横向扫描</p>
<p>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if (strs == null || strs.length == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = strs[0];</span><br><span class="line">        int count = strs.length;</span><br><span class="line">        for (int i = 1; i &lt; count; i++) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            if (prefix.length() == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String longestCommonPrefix(String str1, String str2) &#123;</span><br><span class="line">        int length = Math.min(str1.length(), str2.length());</span><br><span class="line">        int index = 0;</span><br><span class="line">        while (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return str1.substring(0, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复杂度分析</span><br><span class="line">时间复杂度：O(mn)O(mn)，其中 mm 是字符串数组中的字符串的平均长度，nn 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</span><br><span class="line">空间复杂度：O(1)O(1)。使用的额外空间复杂度为常数。</span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>#leetcode 用户灵魂画手<br>思路<br>标签：链表<br>当字符串数组长度为 0 时则公共前缀为空，直接返回<br>令最长公共前缀 ans 的值为第一个字符串，进行初始化<br>遍历后面的字符串，依次将其与 ans 进行比较，两两找出公共前缀，最终结果即为最长公共前缀<br>如果查找过程中出现了 ans 为空的情况，则公共前缀不存在直接返回<br>时间复杂度：O(s)O(s)，s 为所有字符串的长度之和<br>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs.length == 0) </span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        String ans = strs[0];</span><br><span class="line">        for(int i =1;i&lt;strs.length;i++) &#123;</span><br><span class="line">            int j=0;</span><br><span class="line">            for(;j&lt;ans.length() &amp;&amp; j &lt; strs[i].length();j++) &#123;</span><br><span class="line">                if(ans.charAt(j) != strs[i].charAt(j))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.substring(0, j);</span><br><span class="line">            if(ans.equals(&quot;&quot;))</span><br><span class="line">                return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">作者：guanpengchn</span><br><span class="line">链接：https://leetcode-cn.com/problems/longest-common-prefix/solution/hua-jie-suan-fa-14-zui-chang-gong-gong-qian-zhui-b/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>#最易理解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        String s=&quot;&quot;;</span><br><span class="line">        int judge=1;</span><br><span class="line">        if(strs.length==0)&#123;//数组为空直接返回&quot;&quot;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;strs[0].length();i++)&#123;</span><br><span class="line">            char a=strs[0].charAt(i);//直接选择第一个数组元素，依次取这个字符串的字符</span><br><span class="line">            </span><br><span class="line">            for(int j=0;j&lt;strs.length;j++)&#123;</span><br><span class="line">                </span><br><span class="line">                if(i&gt;=strs[j].length())&#123;//因为每个字符串长度不同，防止溢出</span><br><span class="line">                    judge=0;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if(a!=strs[j].charAt(i))&#123;</span><br><span class="line">                    judge=0;//只要存在不同，直接退出</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                else&#123;</span><br><span class="line">                    if(j==strs.length-1)&#123;</span><br><span class="line">                        s=s+a;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            if(judge==0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">本文链接：https://blog.csdn.net/shancx/article/details/82746264</span><br></pre></td></tr></table></figure>
<p>二：未排序正整数数组中累加和为给定值的最长子数组长度<br>给定一个数组arr，该数组无序，每个数正数，给定一个K，求arr的所有子数组中所有元素相加和为k的最长子数组的长度。</p>
<p>例如：arr=[1,2,1,1,1],k=3</p>
<p>结果是3，[1,1,1]的长度。</p>
<p>思路：</p>
<p>首先用两个位置来标记子数组左右两头，记为left与right，开始的时候都在数组的最左边即left=right=0，过程如下：</p>
<p>1，开始变量left=0，right=0，代表子数组arr[left,right];</p>
<p>2，变量sum始终表示子数组arr[left,right]的和，开始的时候sum= arr[0],即是arr[0,0]的和；</p>
<p>3，变量len一直记录累加和为k的所有子数组中最大子数组的长度，开始的时候len=0;</p>
<p>4，根据sum与k的比较结果决定是left移动还right移动。若干sum==K，说明arr[left,right]累加和为k,如果长度大于len，更新len</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Array;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by wuxiaosi on 2017/9/24.</span><br><span class="line"> */</span><br><span class="line">public class getMaxLength &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int k=3;</span><br><span class="line">        int[] arr=&#123;1,2,1,1,1&#125;;</span><br><span class="line">        System.out.println(getMaxLengthK(arr,k));</span><br><span class="line">    &#125;</span><br><span class="line">    public static int getMaxLengthK(int[] arr,int k)&#123;</span><br><span class="line">        if(arr==null||arr.length==0||k&lt;=0)&#123;</span><br><span class="line">            return  0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=0;</span><br><span class="line">        int sum=arr[0];</span><br><span class="line">        int len=0;</span><br><span class="line">        while(right&lt;arr.length)&#123;</span><br><span class="line">            if(sum==k)&#123;</span><br><span class="line">                len = Math.max(len,right-left+1);</span><br><span class="line">                sum=sum-arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            else if(sum&lt;k)&#123;</span><br><span class="line">                right++;//向右移动</span><br><span class="line">                if(right==arr.length)&#123;//right到数组边界长度，就break</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                sum=sum+arr[right];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sum=sum-arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「wuxiaosi808」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/wuxiaosi808/article/details/78079574</span><br></pre></td></tr></table></figure>
<p>三 有两个整数数组A1，A2，设计函数求其两个数组的最大值和第二大的值<br>思路一：</p>
<p>1.获取最值需要进行比较，每一次比较都会有一个较大的值，因为该值的不确定性，通过一个变量进行临时存储。</p>
<p>2.让数组中的每一个元素都和这个变量中的值进行比较，如果大于变量中的值，就用该变量记录较大值。</p>
<p>3.当所有的元素都比较完成，那么该变量中的存储就是数组中的最大值了。</p>
<p>步骤：</p>
<p>1.定义变量，初始化为数组中的任意一个元素。</p>
<p>2.通过循环语句对数组进行遍历。</p>
<p>3.在变量过程中定义判断条件，如果遍历到的元素比变量中的元素大，就赋值给该变量。</p>
<p>注意：</p>
<p>通过定义一个功能来完成，以便提高代码的复用性。该功能结果为数组中的最大元素，未知内容为数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args) </span><br><span class="line">	&#123;</span><br><span class="line">		int[] arr1 = &#123;9,5,6,3,1,2,8,7&#125;;</span><br><span class="line">		int max1 = getMax(arr1);</span><br><span class="line">		System.out.println(&quot;max1=&quot;+max1);</span><br><span class="line">		double[] arr2 = &#123;9.0,5.0,6.0,3.0,1.0,2.0,8.0,7.0&#125;;</span><br><span class="line">		double max2 = getMax(arr2);</span><br><span class="line">		System.out.println(&quot;max2=&quot;+max2);</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	//获取int类型数组最大值</span><br><span class="line">	public static int getMax(int[] arr)</span><br><span class="line">	&#123;</span><br><span class="line">		int max = arr[0];</span><br><span class="line">		for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(arr[i]&gt;max)</span><br><span class="line">				max = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return max;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取double类型数组最大值，功能相似，以重载的形式存在</span><br><span class="line">	public static double getMax(double[] arr)</span><br><span class="line">	&#123;</span><br><span class="line">		double max = arr[0];</span><br><span class="line">		for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(arr[i]&gt;max)</span><br><span class="line">				max = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return max;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路二：</p>
<p>1.定义变量，初始化为数组角标0。</p>
<p>2.通过循环语句对数组进行遍历。</p>
<p>3.在变量过程中定义判断条件，如果遍历到的元素比角标所在的元素中的数值大，就将较大值的角标赋值给变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args) </span><br><span class="line">	&#123;</span><br><span class="line">		int[] arr1 = &#123;9,5,6,3,1,2,8,7&#125;;</span><br><span class="line">		int max1 = getMax(arr1);</span><br><span class="line">		System.out.println(&quot;max1=&quot;+max1);</span><br><span class="line">		double[] arr2 = &#123;9.0,5.0,6.0,3.0,1.0,2.0,8.0,7.0&#125;;</span><br><span class="line">		double max2 = getMax(arr2);</span><br><span class="line">		System.out.println(&quot;max2=&quot;+max2);</span><br><span class="line">	&#125;</span><br><span class="line">	//获取int类型数组最大值</span><br><span class="line">	public static int getMax(int[] arr)</span><br><span class="line">	&#123;</span><br><span class="line">		int max = 0;</span><br><span class="line">		for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(arr[i]&gt;arr[max])</span><br><span class="line">				max = i;</span><br><span class="line">		&#125;</span><br><span class="line">		return arr[max];</span><br><span class="line">	&#125;</span><br><span class="line">	//获取double类型数组最大值，功能相似，以重载的形式存在</span><br><span class="line">	public static double getMax(double[] arr)</span><br><span class="line">	&#123;</span><br><span class="line">		double max = 0;</span><br><span class="line">		for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(arr[i]&gt;arr[max])</span><br><span class="line">				max = i;</span><br><span class="line">		&#125;</span><br><span class="line">		return arr[max];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「Destiny_lt」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/ytu_lt/article/details/70160598</span><br></pre></td></tr></table></figure>
<h1 id="四-翻转单词顺序列（I-am-a-student-gt-student-a-am-I）"><a href="#四-翻转单词顺序列（I-am-a-student-gt-student-a-am-I）" class="headerlink" title="四 翻转单词顺序列（I am a student.-&gt;student. a am I）"></a>四 翻转单词顺序列（I am a student.-&gt;student. a am I）</h1><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”<br>方法一：双指针<br>算法解析：<br>倒序遍历字符串 ss ，记录单词左右索引边界 ii , jj ；<br>每确定一个单词的边界，则将其添加至单词列表 resres ；<br>最终，将单词列表拼接为字符串，并返回即可。<br>复杂度分析：<br>时间复杂度 O(N)O(N) ： 其中 NN 为字符串 ss 的长度，线性遍历字符串。<br>空间复杂度 O(N)O(N) ： 新建的 list(Python) 或 StringBuilder(Java) 中的字符串总长度 \leq N≤N ，占用 O(N)O(N) 大小的额外空间。<br>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        s = s.trim(); // 删除首尾空格</span><br><span class="line">        int j = s.length() - 1, i = j;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        while(i &gt;= 0) &#123;</span><br><span class="line">            while(i &gt;= 0 &amp;&amp; s.charAt(i) != &#x27; &#x27;) i--; // 搜索首个空格</span><br><span class="line">            res.append(s.substring(i + 1, j + 1) + &quot; &quot;); // 添加单词</span><br><span class="line">            while(i &gt;= 0 &amp;&amp; s.charAt(i) == &#x27; &#x27;) i--; // 跳过单词间空格</span><br><span class="line">            j = i; // j 指向下个单词的尾字符</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString().trim(); // 转化为字符串并返回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：分割 + 倒序<br>利用 “字符串分割”、“列表倒序” 的内置函数 （面试时不建议使用） ，可简便地实现本题的字符串翻转要求<br>复杂度分析：<br>时间复杂度 O(N)O(N) ： 总体为线性时间复杂度，各函数时间复杂度和参考资料链接如下。<br>split() 方法： 为 O(N)O(N) ；<br>trim() 和 strip() 方法： 最差情况下（当字符串全为空格时），为 O(N)O(N) ；<br>join() 方法： 为 O(N)O(N) ；<br>reverse() 方法： 为 O(N)O(N) ；<br>空间复杂度 O(N)O(N) ： 单词列表 strsstrs 占用线性大小的额外空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        String[] strs = s.trim().split(&quot; &quot;); // 删除首尾空格，分割字符串</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        for(int i = strs.length - 1; i &gt;= 0; i--) &#123; // 倒序遍历单词列表</span><br><span class="line">            if(strs[i].equals(&quot;&quot;)) continue; // 遇到空单词则跳过</span><br><span class="line">            res.append(strs[i] + &quot; &quot;); // 将单词拼接至 StringBuilder</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString().trim(); // 转化为字符串，删除尾部空格，并返回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/mian-shi-ti-58-i-fan-zhuan-dan-ci-shun-xu-shuang-z/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String ReverseSentence(String str)</span><br><span class="line">    &#123;</span><br><span class="line">        //先单个单词反转,再整体反转。I am a student.》》I ma a .tneduts 》》student. a am I</span><br><span class="line">        if(str.length()==0)</span><br><span class="line">            return str;</span><br><span class="line"></span><br><span class="line">        char[]chs=str.toCharArray();</span><br><span class="line"></span><br><span class="line">        //对单个字符数组元素进行反转</span><br><span class="line">        int i=0,j=0;//定义两个指针进行遍历</span><br><span class="line">        while(j&lt;=str.length())&#123;</span><br><span class="line"></span><br><span class="line">            //以空格作为区分，对每个单词进行反转</span><br><span class="line">            if(j==str.length()||chs[j]==&#x27; &#x27;)&#123;//j==str.length()不要忘记</span><br><span class="line">                reverse(chs,i,j-1);</span><br><span class="line">                i=j+1;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果chs[j]!=&#x27; &#x27;那么继续遍历直到找到空格</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //整体字符串反转</span><br><span class="line">        reverse(chs,0,str.length()-1);</span><br><span class="line"></span><br><span class="line">        return new String(chs);//学习</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private void reverse(char[]ch,int i,int j)&#123;</span><br><span class="line">        while(i&lt;j)&#123;</span><br><span class="line">            //反转交换,代码是一样的</span><br><span class="line">            char temp=ch[i];</span><br><span class="line">            ch[i]=ch[j];</span><br><span class="line">            ch[j]=temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">本文链接：https://blog.csdn.net/hefenglian/article/details/79932709</span><br></pre></td></tr></table></figure>
<h1 id="最牛逼的解法：JavaScript"><a href="#最牛逼的解法：JavaScript" class="headerlink" title="最牛逼的解法：JavaScript"></a>最牛逼的解法：JavaScript</h1><p>解法：先用trim()把字符串两端空格去掉，split(‘ ‘)把字符串切割成以空格为界限的单词块，filter()过滤掉数组中的纯空格，reverse()进行数组反转，join(‘ ‘)把数组变成中间只带一个空格的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    var reverseWords = function (s) &#123;</span><br><span class="line">        var str = s.trim().split(&#x27; &#x27;).filter(item =&gt; item!=&#x27;&#x27;).reverse().join(&#x27; &#x27;)</span><br><span class="line">        console.log(str)</span><br><span class="line">    &#125;;</span><br><span class="line">作者：CHH_</span><br><span class="line">链接：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/yi-xing-dai-ma-jie-jue-suo-you-by-chen-1wz/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>暴力求解法(百度百科)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">暴力求解法, 又名直接带入法（Directly Calculating）它是已知最古老的算法之一，与&quot;直观目测法&quot;，&quot;心灵感应法&quot;并称世界三大不可思议数学计算法则， 其可追溯至3200年前，古老的埃及人便开始使用象形文字进行复杂的数学演算。它首次的文本出现是欧几里德的《几何原本》（第V卷，命题i和ii）中，而在中国则可以追溯至宋朝末年出现的沈括《梦溪笔谈》</span><br><span class="line">暴力求解法的由来</span><br><span class="line"></span><br><span class="line">在汉高祖时期有一个有趣的小故事是这样的:</span><br></pre></td></tr></table></figure>
<p>“高祖年间,大将军韩信征讨突厥得胜,七月七日凯旋而归，其时举国腾。信进宫，高祖曰:’淮阴侯乃真人也，战无不功克，朕三年尝闻智勇，招为爱卿，果其然，甚好甚慰。’信曰:’大王聪明仁惠，敬贤礼士，江表英豪贤归附，臣听闻蜀地龙光射牛斗之墟，人杰多地灵，又适王举兵招马，无怪骏才星驰。’高祖对曰:’今汝方成大业，且问卿求?’信:’乃望众亲赐匹布，以二渐累。’回:’善，明日使文库之卿，方得人数。’隔日使返，帝问:”需布甚许?”曰:”臣不才，方得淮阴侯亲友八十五者，食客则七百七十六人之众，臣斗胆以树枝编排数之方得须七三万千三百二十馀一匹”帝惊道:”甚许!乃至库之空不能所期，淮阴岂谋他意?”遂隔日将信斩之，不知了了。”<br>暴力求解法的演算<br>1.例题:在地面上的同一1地点分别以速率V1、V2先后竖直像上抛出两个可视为质点的小球。第二个小球抛出后经过T时间与第一个小球相遇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">设第一小球抛出后t0时间与第二小球相遇 (此时第二小球已运动T,T&lt;t0)</span><br><span class="line">因为 h1 = h2</span><br><span class="line">v1t0 - <span class="number">1</span>/2g(t0)^<span class="number">2</span> = v2T -<span class="number">1</span>/2gT^<span class="number">2</span></span><br><span class="line">所以 T = (v2+√(v2^<span class="number">2</span>-2g(v1t0 - <span class="number">1</span>/2g(t0)^<span class="number">2</span>))) / g</span><br><span class="line">又 T &lt; v2/g</span><br><span class="line">根据复杂计算</span><br><span class="line">可得 T = (v2-√v2^<span class="number">2</span>-v1^<span class="number">2</span>) / g</span><br><span class="line">所以 Tmax = (v2-√v2^<span class="number">2</span>-v1^<span class="number">2</span>) / g</span><br></pre></td></tr></table></figure></div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>Leetcode算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>蚂蚁一面整理</title>
    <url>/posts/20220726clhk6pteo002hcsuje47bbt29.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>java的同步容器，并发容器？<br>同步：即每次只有一个线程访问容器状态。<br>并发：即每次可有多个线程访问容器状态。<br>同步容器：Vector，HashTable<br>并发容器：ConCurrentHashMap，CopeyOnwrite<br>–当并发读远多于修改的场景下需要使用List和Set时，可以考虑使用CopyOnWriteArrayList和CopyOnWriteArraySet；<br>–当需要并发使用&lt;Key, Value&gt;键值对存取数据时，可以使用ConcurrentHashMap；<br>–当要保证并发&lt;Key, Value&gt;键值对有序时可以使用ConcurrentSkipListMap。</p>
<p>ArrayList和LinkedList的插入和访问的复杂度<br>即数组与链表的访问插入复杂度<br>1&gt;.数组在访问时可通过下标直接查询，复杂度O(1),链表复杂度O(n)<br>2&gt;.数组插入时数组下标需要移动O(n)，链表直接操作指针O(1)<br>反射原理—&gt;</p>
<blockquote>
<p>反射可动态加载外部配置对象，通过class.forName加载类信息，而forName方法就是通过反射类调用的类信息，<br>jvm加载获取到里面的classLoader，通过native方法获取类信息，最终调用invoke0()方法，反射是线程安全的，<br>因为loadClass方法是synchronized修饰的，找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；<br>注解原理—&gt;</p>
</blockquote>
<blockquote>
<p>注解等同于加了标记,注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池<br>注解参数成员必须是public的，没有成员方法也行，但是就没得意义了<br>新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？<br>新生代分为Eden区，幸存from区，幸存to区，大小比例8:1:1<br>新生代使用复制算法，高效，省去了标记整理的过程，新生代需要清理的对象数量巨大，复制算法浪费空间，但效率高，<br>–&gt;引申<br>MinorGC的过程(复制-&gt;清空-&gt;互换)<br>1:Eden,SurvivorFrom复制到SurvivorTo，年龄+1</p>
</blockquote>
<p>首先，当Eden区满的时候会触发第一次GC,把还活着的对象拷贝到SurvivorFrom区，当Eden区再次出发GC的时候会扫描Eden区和form区，对这个区域进行垃圾回收，经过这次回收还活着的，复制到To区，对象年龄+1</p>
<p>2:清空Eden区、SurvivorFrom</p>
<p>然后清空Eden区和SurvivorFrom区的对象，谁空谁是to。</p>
<p>3:SurvivorTo和SurvivorFrom互换</p>
<p>互换之后SurvivorTo成为下一次GC的From区，当对象年龄达到15，最终如果存活，存入老年代。<br>—&gt;jvm分区</p>
<p>jvm分区<br>jvm分区<br>堆栈方法区<br>堆管存储，类实例和数组对象存储<br>栈管运行，存储基础数据类型和引用，栈帧<br>1.8之前是方法区，1.8之后改为元空间，存储静态变量 + 常量 + 类信息(构造方法/接口定义) + 运行时常量池存在方法区中<br>—&gt;垃圾回收算法<br>复制算法，标记清除，标记压缩，引用计数算法，可达性分析算法<br>复制算法</p>
<p>把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。</p>
<p>引用计数法：循环引用不可回收，不推荐</p>
<p>GCRoot：可达性分析算法</p>
<p>从根集对象向下搜索，如果一个对象没有任何链相连时，则说明对象不可用。</p>
<p>哪些可以作为GC root的对象<br>1.虚拟机栈中的引用对象<br>2.方法区中的类静态属性引用的对象<br>3.方法区中常量引用的对象<br>4.本地方法栈中引用的对象<br>如何确定垃圾？<br>已经不再被内存使用到的空间<br>JVM虚拟机 YGC和FGC发生的具体场景</p>
<p>YGC和FGC是什么<br>YGC ：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。 （复制算法 —&gt; 一般适用对象存活率低的场景）</p>
<p>FGC ：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。 （标记整理或者标记清除算法 —&gt; 一般适用于对象存活率高的场景）</p>
<p>2、什么时候执行YGC和FGC</p>
<p>1、eden空间不足,执行 young gc</p>
<p>2、old空间不足，perm空间不足，调用方法System.gc() ，ygc时的悲观策略,<br>dump live的内存信息时(jmap –dump:live)，都会执行full gc</p>
<p>3.JVM老年代和新生代的比例<br>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。<br>这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。<br>新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<br>默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )</p>
<p>频繁 fullgc 的排查<br>full gc产生场景如上叙述一下<br>其次猜测一下大概产生原因<br>尤其是大对象，80%以上的情况就是他。 那么大对象从哪里来的：<br>【1】数据库（包括 Mysql和 Mongodb等 NOSql数据库），结果集太大；<br>【2】第三方接口传输的大对象；<br>【3】消息队列，消息太大；</p>
<p>排查步骤—-&gt;<br>    (1):打印GCdetail<br>    -XX:+PrintGCDtails<br>    (2):生成dump文件  注意:dump操作的时候是会发生stop the word事件的，也就是说此时所有的用户线程都会暂停运行<br>    开启XX:+HeapDumpBeforeFullGC<br>    使用jvisualvm查看<br>&lt;关于top k 问题已经在实际解决Linux 阿里云服务器问题应用&gt;<br>—&gt;JMM<br>java memory model<br>—&gt;垃圾收集器<br>并行 串行 并发标记 CMS G1 ZGC<br>G1不产生内存碎片 可精准控制停顿</p>
<p>–&gt;CMS垃圾回收过程<br>1.总体介绍：<br>CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于老年代的回收采用CMS。CMS采用的基础算法是：标记—清除。</p>
<p>CMS<br>CMS<br>2.CMS过程：<br>初始标记(STW initial mark)<br>并发标记(Concurrent marking)<br>并发预清理(Concurrent precleaning)<br>重新标记(STW remark)<br>并发清理(Concurrent sweeping)<br>并发重置(Concurrent reset)<br>5.如何处理接口的重复请求？不得不说他不好好问，目的是问如何保证接口的幂等性?<br>分布式系统中，服务部署在不同的服务器上，但是数据要保证打到一个redis上<br>对于每个请求必须有一个唯一的标识。举个例子：订单支付请求，肯定得包含订单 id，一个订单 id 最多支付一次。<br>每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在数据库中记录个状态，比如支付之前记录一条这个订单的支付流水。<br>每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId 已经存在了，唯一键约束生效，报错插入不进去的。然后系统就不用再扣款了。<br>在网络延迟传输中，会造成消息队列重试，在重试过程中，消息会存在重复</p>
<p>解决方案：</p>
<p>1.如果是数据库的插入操作，给消息做一个主键，避免出现脏数据。<br>2.使用第三方做消费记录，例如Redis，全局id为K，消息为V，写入到Redis，消费之前先去查Redis是否存在<br>–&gt;引申分布式系统中如何生成高效的分布式唯一ID 雪花算法<br>可用分布式锁,redis 递增,机器的唯一码 拿出几位存为机器id,这样一来每次查询操作相对更快</p>
<p>G1回收器有个非常好的特性就是会不断的帮助JVM调整策略， 会根据实际的GC情况调整年轻代和老年代的比例大小，默认情况下，年轻代最多可以占用60%的堆内存。这其实就是GC的灵活性。</p>
<p>G1的另一个显著特点他能够让用户设置应用的暂停时间，通过参数：-XX:MaxGCPauseMillis来指定，为什么G1能做到这一点呢？也许你已经注意到了，G1回收的第4步，它是“选择一些内存块”，而不是整代内存来回收，这是G1跟其它GC非常不同的一点，其它GC每次回收都会回收整个Generation的内存(Eden, Old), 而回收内存所需的时间就取决于内存的大小，以及实际垃圾的多少，所以垃圾回收时间是不可控的；而G1每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如</p>
<p>Http与Https的区别？<br>博客:<a href="https://blog.csdn.net/guolin_blog/article/details/104546558">https://blog.csdn.net/guolin_blog/article/details/104546558</a><br>总结：首先回答对称加密以及非对称加密的区别。<br>对称加密比较简单，就是客户端和服务器共用同一个密钥，该密钥可以用于加密一段内容，同时也可以用于解密这段内容。对称加密的优点是加解密效率高，但是在安全性方面可能存在一些问题，因为密钥存放在客户端有被窃取的风险。对称加密的代表算法有：AES、DES等。</p>
<p>而非对称加密则要复杂一点，它将密钥分成了两种：公钥和私钥。公钥通常存放在客户端，私钥通常存放在服务器。使用公钥加密的数据只有用私钥才能解密，反过来使用私钥加密的数据也只有用公钥才能解密。非对称加密的优点是安全性更高，因为客户端发送给服务器的加密信息只有用服务器的私钥才能解密，因此不用担心被别人破解，但缺点是加解密的效率相比于对称加密要差很多。非对称加密的代表算法有：RSA、ElGamal等。<br>关键词：CA机构<br>个人理解：https使用的是对称加密与非对称加密相结合的方式。首先双端通信使用非对称加密，客户端加密传输时先请求第三方CA机构，CA加密处理完返回给服务器端，证书中加入了网站的域名，</p>
<p>redis掀桌连问</p>
<p>redis<br>redis<br>1.redis的hash怎么实现的？(实现原理)rehash过程<br>redis初始创建hash表,有序集合，链表时, 存储结构采用一种ziplist的存储结构, 这种结构内存排列更紧密, 能提高访存性能.<br>hash_max_ziplist_entries和hash_max_ziplist_value值作为阀值，hash_max_ziplist_entries表示一旦ziplist中元素数量超过该值，则需要转换为dict结构；hash_max_ziplist_value表示一旦ziplist中数据长度大于该值，则需要转换为dict结构。<br>哈希等价于Java语言的HashMap或者是Python语言的字典（Dict）<br>redis hash 的内部结构.第一维是数组,第二维是链表.组成一个 hashtable.<br>在 Java 中 HashMap 扩容是个很耗时的操作,需要去申请新的数组,为了追求高性能,Redis 采用了渐进式 rehash 策略.这也是 hash 中最重要的部分.<br>在扩容的时候 rehash 策略会保留新旧两个 hashtable 结构,查询时也会同时查询两个 hashtable.Redis会将旧 hashtable 中的内容一点一点的迁移到新的 hashtable 中,当迁移完成时,就会用新的 hashtable 取代之前的.当 hashtable 移除了最后一个元素之后,这个数据结构将会被删除.<br><a href="https://juejin.im/post/5cfe6383e51d45599e019d8f">https://juejin.im/post/5cfe6383e51d45599e019d8f</a><br>与java的hashmap的rehash区别<br>个人理解：hashmap的rehash是一次性拷贝的，不同的是，Redis的字典只能是字符串，另外他们rehash的方式不一样，因为Java的HashMap的字典很大时，rehash是个耗时的操作，需要一次全部rehash。Redis为了追求高性能，不能堵塞服务，所以采用了渐进式rehash策略。<br>rehash的详细步骤<br><a href="https://www.cnblogs.com/meituantech/p/9376472.html">https://www.cnblogs.com/meituantech/p/9376472.html</a><br>与ConcurrentHashMap扩容的策略比较？<br>ConcurrentHashMap采用的扩容策略为： “多线程协同式rehash“。<br>1.扩容所花费的时间对比： 一个单线程渐进扩容，一个多线程协同扩容。在平均的情况下，是ConcurrentHashMap 快。这也意味着，扩容时所需要 花费的空间能够更快的进行释放。<br>2.读操作，两者性能相差不多。<br>3.写操作，Redis的字典返回更快些，因为它不像ConcurrentHashMap那样去帮着扩容(当要写的桶位已经搬到了newTable时)，等扩容完才能进行操作。<br>4.删除操作，与写一样。<br><a href="http://xytschool.com/resource/236.html">http://xytschool.com/resource/236.html</a><br>redis如何保证高可用<br>保证redis高可用机制需要redis主从复制、redis持久化机制、哨兵机制、keepalived等的支持。<br>主从复制的作用：数据备份、读写分离、分布式集群、实现高可用、宕机容错机制等。</p>
<p>redis主从复制原理<br>首先主从复制需要分为两个角色：master(主) 和 slave(从) ，注意：redis里面只支持一个主，不像Mysql、Nginx主从复制可以多主多从。</p>
<p>(1)redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</p>
<p>(2)通过redis的复制功能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p>
<p><a href="https://blog.csdn.net/itcats_cn/article/details/82428716">https://blog.csdn.net/itcats_cn/article/details/82428716</a></p>
<h1 id="说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？"><a href="#说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？" class="headerlink" title="说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？***"></a>说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？***</h1><p>个人理解：强一致性的数据是不适合放在缓存中的。另外MySQL对事务的支持也是redis本身不能达到的，需要单独实现<br>一般不是说redis or  MySQL,而是redis+MySQL<br><a href="https://blog.csdn.net/u011784767/article/details/76824822">https://blog.csdn.net/u011784767/article/details/76824822</a><br>为什么Redis进行RDB持久化数据时，新起一个进程而不是在原进程中起一个线程来持久化数据<br>(1)Redis RDB持久化机制会阻塞主进程，这样主进程就无法响应客户端请求。<br>(2)我们知道Redis对客户端响应请求的工作模型是单进程和单线程的，如果在主进程内启动一个线程，这样会造成对数据的竞争条件，为了避免使用锁降低性能。基于以上两点这就是为什么Redis通过启动一个进程来执行RDB了<br>—单线程的redis为什么这么快<br>(1)纯内存操作<br>(2)单线程操作，避免了频繁的上下文切换<br>(3)采用了非阻塞I/O多路复用机制</p>
<p>1<br>—Redis的数据类型以及使用场景<br>(1)String<br>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。<br>一般做一些复杂的计数功能的缓存。</p>
<p>(2)hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，<br>就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p>
<p>(3)list<br>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，<br>做基于redis的分页功能，性能极佳，用户体验好。</p>
<p>(4)set<br>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？<br>因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再启一个公共服务，太麻烦了。</p>
<p>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p>
<p>(5)sorted set<br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。sorted set可以用来做延时任务。最后一个应用就是可以做范围查找</p>
<p>1</p>
<h1 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h1><p>redis采用的是定期删除+惰性删除+内存淘汰策略。<br>[2020年6月29日17:25:36在平时的项目中测试，不定期会产生无用token的key数据，平时可以进行模糊删除]</p>
<p>```<br>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>
<p>解决方案:<br>(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试<br>(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，<br>异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。<br>(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。<br>迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p>
<p>缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p>
<p>解决方案:<br>(一)给缓存的失效时间，加上一个随机值，避免集体失效。<br>(二)使用互斥锁，但是该方案吞吐量明显下降了。<br>(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。<br>自己做缓存预热操作。然后细分以下几个小点<br>1 从缓存A读数据库，有则直接返回<br>2 A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。<br>3 更新线程同时更新缓存A和缓存B。</p>
<p>8、如何解决redis的并发竞争key问题</p>
<p>分析:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。<br>需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。<br>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，<br>这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。</p>
<p>回答:如下所示<br>(1)如果对这个key操作，不要求顺序<br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>(2)如果对这个key操作，要求顺序<br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，<br>需要保存一个时间戳。假设时间戳如下<br>系统A key 1 {valueA  3:00}<br>系统B key 1 {valueB  3:05}<br>系统C key 1 {valueC  3:10}<br>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。<br>redis分页<br>HSCAN testHash “0” count 10</p>
<p>注：测试field数量在22条时（没有测试Redis中Hash使分页生效时的field数量的下限），分页未生效。<br>#mysql 执行一个 sql 的过程<br>执行完毕之后有一个缓存的过程</p>
<p>mysql<br>mysql<br><a href="https://www.cnblogs.com/luoying/p/12073812.html">https://www.cnblogs.com/luoying/p/12073812.html</a></p>
<p>MySQL分页limit速度太慢的优化方法<br>1.子查询优化法<br>先找出第一条数据，然后大于等于这条数据的id就是要获取的数据<br>缺点：数据必须是连续的，可以说不能有where条件，where条件会筛选数据，导致数据失去连续性<br>2.limit限制优化法<br>把limit偏移量限制低于某个数<br>3.where条件先过滤后分页<br>wait notify 为什么要搭配使用？<br>单独调用会报异常<br>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。因为程序验证通常是在对象的同步方法或同步代码块中调用它们的。如果尝试在未获取对象锁时调用这三个方法，<br>“java.lang.IllegalMonitorStateException:current thread not owner”。<br>底层把对象作为一个监视器</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>List遍历删除</title>
    <url>/posts/20220726clhk6ptdq000gcsuj8f4dbwwc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;ad&quot;</span>);</span><br><span class="line">       Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">       <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">           String next = iterator.next();</span><br><span class="line">           <span class="keyword">if</span>(<span class="string">&quot;a&quot;</span>.equals(next)||<span class="string">&quot;c&quot;</span>.equals(next))&#123;</span><br><span class="line">               iterator.remove();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(JSONObject.toJSONString(list));</span><br><span class="line">   &#125;</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;ad&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ad&quot;</span>);</span><br><span class="line">      	list.removeIf(s-&gt;<span class="string">&quot;a&quot;</span>.equals(s)||<span class="string">&quot;c&quot;</span>.equals(s));</span><br><span class="line">        System.out.println(JSONObject.toJSONString(list));</span><br><span class="line">    &#125;</span><br><span class="line">异常操作</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">list.removeIf(s -&gt; <span class="string">&quot;a&quot;</span>.equals(s) || <span class="string">&quot;c&quot;</span>.equals(s));</span><br><span class="line">System.out.println(JSONObject.toJSONString(list));</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.UnsupportedOperationException</span><br><span class="line">        原因</span><br><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;varargs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T &gt; List &lt; T &gt; asList(T...a)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span> include</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractList做任何操作都是异常</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">( <span class="keyword">int</span> index, E element)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation always throws an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException     &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span> <span class="params">( <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line">修改</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] str=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;abcd&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; strs = Arrays.asList(str);</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.addAll(strs);</span><br><span class="line">list.removeIf(s-&gt;<span class="string">&quot;a&quot;</span>.equals(s)||<span class="string">&quot;c&quot;</span>.equals(s));</span><br><span class="line">System.out.println(JSONObject.toJSONString(list));</span><br></pre></td></tr></table></figure></div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>List遍历删除</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql海量数据存储与优化</title>
    <url>/posts/20220725clhk6ptdu000mcsuj4mtt7x1k.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>我坚信，机会永远属于有准备的人，我们与其羡慕他人的成功，不如从此刻起，积累足够多的知识和面试经验，为将来进入更好的公司做充足的准备<br>本片文章将会根据资料学习深入Mysql的设计与优化<br>1、Mysql基础知识</p>
<p>2、Mysql架构原理和存储机制</p>
<p>3、Mysql高可用方案</p>
<p>4、Mysql企业面试真题分享</p>
<p>Mysql基础知识<br>MySQL起源和分支<br>MySQL 是最流行的关系型数据库软件之一，由于其体积小、速度快、开源免费、简单易用、维护成本<br>低等，在集群架构中易于扩展、高可用，因此深受开发者和企业的欢迎。<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql1.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql2.jpg" alt="流程"></p>
<p>MySQL体系架构<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql3.jpg" alt="流程"></p>
<p>MySQL Server架构自顶向下大致可以分网络连接层、服务层、存储引擎层和系统文件层。<br>一、网络连接层<br>客户端连接器（Client Connectors）：提供与MySQL服务器建立的支持。目前几乎支持所有主流<br>的服务端编程技术，例如常见的 Java、C、Python、.NET等，它们通过各自API技术与MySQL建立<br>连接。<br>二、服务层（MySQL Server）<br>服务层是MySQL Server的核心，主要包含系统管理和控制工具、连接池、SQL接口、解析器、查询优<br>化器和缓存六个部分。<br>连接池（Connection Pool）：负责存储和管理客户端与数据库的连接，一个线程负责管理一个连接。<br>系统管理和控制工具（Management Services &amp; Utilities）：例如备份恢复、安全管理、集群<br>管理等<br>SQL接口（SQL Interface）：用于接受客户端发送的各种SQL命令，并且返回用户需要查询的结<br>果。比如DML、DDL、存储过程、视图、触发器等。<br>解析器（Parser）：负责将请求的SQL解析生成一个”解析树”。然后根据一些MySQL规则进一步<br>检查解析树是否合法。<br>查询优化器（Optimizer）：当“解析树”通过解析器语法检查后，将交由优化器将其转化成执行计<br>划，然后与存储引擎交互。<br>select uid,name from user where gender=1;<br>选取–》投影–》联接 策略<br>1）select先根据where语句进行选取，并不是查询出全部数据再过滤<br>2）select查询根据uid和name进行属性投影，并不是取出所有字段<br>3）将前面选取和投影联接起来最终生成查询结果<br>缓存（Cache&amp;Buffer）： 缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，权限缓<br>存，引擎缓存等。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。<br>三、存储引擎层（Pluggable Storage Engines）<br>存储引擎负责MySQL中数据的存储与提取，与底层系统文件进行交互。MySQL存储引擎是插件式的，<br>服务器中的查询执行引擎通过接口与存储引擎进行通信，接口屏蔽了不同存储引擎之间的差异 。现在有<br>很多种存储引擎，各有各的特点，最常见的是MyISAM和InnoDB。<br>四、系统文件层（File System）<br>该层负责将数据库的数据和日志存储在文件系统之上，并完成与存储引擎的交互，是文件的物理存储<br>层。主要包含日志文件，数据文件，配置文件，pid 文件，socket 文件等。<br>日志文件<br>错误日志（Error log）<br>默认开启，show variables like ‘%log_error%’<br>通用查询日志（General query log）<br>记录一般查询语句，show variables like ‘%general%’;<br>二进制日志（binary log）<br>记录了对MySQL数据库执行的更改操作，并且记录了语句的发生时间、执行时长；但是它不<br>记录select、show等不修改数据库的SQL。主要用于数据库恢复和主从复制。<br>show variables like ‘%log_bin%’; //是否开启<br>show variables like ‘%binlog%’; //参数查看<br>show binary logs;//查看日志文件<br>慢查询日志（Slow query log）<br>记录所有执行时间超时的查询SQL，默认是10秒。<br>show variables like ‘%slow_query%’; //是否开启<br>show variables like ‘%long_query_time%’; //时长<br>配置文件<br>用于存放MySQL所有的配置信息文件，比如my.cnf、my.ini等。<br>数据文件<br>db.opt 文件：记录这个库的默认使用的字符集和校验规则。<br>frm 文件：存储与表相关的元数据（meta）信息，包括表结构的定义信息等，每一张表都会<br>有一个frm 文件。<br>MYD 文件：MyISAM 存储引擎专用，存放 MyISAM 表的数据（data)，每一张表都会有一个<br>.MYD 文件。<br>MYI 文件：MyISAM 存储引擎专用，存放 MyISAM 表的索引相关信息，每一张 MyISAM 表对<br>应一个 .MYI 文件。<br>ibd文件和 IBDATA 文件：存放 InnoDB 的数据文件（包括索引）。InnoDB 存储引擎有两种<br>表空间方式：独享表空间和共享表空间。独享表空间使用 .ibd 文件来存放数据，且每一张<br>InnoDB 表对应一个 .ibd 文件。共享表空间使用 .ibdata 文件，所有表共同使用一个（或多<br>个，自行配置）.ibdata 文件。<br>ibdata1 文件：系统表空间数据文件，存储表元数据、Undo日志等 。<br>ib_logfile0、ib_logfile1 文件：Redo log 日志文件。<br>pid 文件<br>pid 文件是 mysqld 应用程序在 Unix/Linux 环境下的一个进程文件，和许多其他 Unix/Linux 服务<br>端程序一样，它存放着自己的进程 id。<br>socket 文件<br>socket 文件也是在 Unix/Linux 环境下才有的，用户在 Unix/Linux 环境下客户端连接可以不通过<br>TCP/IP 网络而直接使用 Unix Socket 来连接 MySQL</p>
<p>MySQL运行机制<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql4.jpg" alt="流程"></p>
<p>①建立连接（Connectors&amp;Connection Pool），通过客户端/服务器通信协议与MySQL建立连<br>接。MySQL 客户端与服务端的通信方式是 “ 半双工 ”。对于每一个 MySQL 的连接，时刻都有一个<br>线程状态来标识这个连接正在做什么。<br>通讯机制：<br>全双工：能同时发送和接收数据，例如平时打电话。<br>半双工：指的某一时刻，要么发送数据，要么接收数据，不能同时。例如早期对讲机<br>单工：只能发送数据或只能接收数据。例如单行道<br>线程状态：<br>show processlist; //查看用户正在运行的线程信息，root用户能查看所有线程，其他用户只能看自<br>己的<br>id：线程ID，可以使用kill xx；<br>user：启动这个线程的用户<br>Host：发送请求的客户端的IP和端口号<br>db：当前命令在哪个库执行<br>Command：该线程正在执行的操作命令<br>Create DB：正在创建库操作<br>Drop DB：正在删除库操作<br>Execute：正在执行一个PreparedStatement<br>Close Stmt：正在关闭一个PreparedStatement<br>Query：正在执行一个语句<br>Sleep：正在等待客户端发送语句<br>Quit：正在退出<br>Shutdown：正在关闭服务器<br>Time：表示该线程处于当前状态的时间，单位是秒<br>State：线程状态<br>Updating：正在搜索匹配记录，进行修改<br>Sleeping：正在等待客户端发送新请求<br>Starting：正在执行请求处理<br>Checking table：正在检查数据表<br>Closing table : 正在将表中数据刷新到磁盘中<br>Locked：被其他查询锁住了记录<br>Sending Data：正在处理Select查询，同时将结果发送给客户端<br>Info：一般记录线程执行的语句，默认显示前100个字符。想查看完整的使用show full<br>processlist;<br>②查询缓存（Cache&amp;Buffer），这是MySQL的一个可优化查询的地方，如果开启了查询缓存且在<br>查询缓存过程中查询到完全相同的SQL语句，则将查询结果直接返回给客户端；如果没有开启查询<br>缓存或者没有查询到完全相同的 SQL 语句则会由解析器进行语法语义解析，并生成“解析树”。<br>缓存Select查询的结果和SQL语句<br>执行Select查询时，先查询缓存，判断是否存在可用的记录集，要求是否完全相同（包括参<br>数值），这样才会匹配缓存数据命中。<br>即使开启查询缓存，以下SQL也不能缓存<br>查询语句使用SQL_NO_CACHE<br>查询的结果大于query_cache_limit设置<br>查询中有一些不确定的参数，比如now()<br>show variables like ‘%query_cache%’; //查看查询缓存是否启用，空间大小，限制等<br>show status like ‘Qcache%’; //查看更详细的缓存参数，可用缓存空间，缓存块，缓存多少等<br>③解析器（Parser）将客户端发送的SQL进行语法解析，生成”解析树”。预处理器根据一些MySQL<br>规则进一步检查“解析树”是否合法，例如这里将检查数据表和数据列是否存在，还会解析名字和别<br>名，看看它们是否有歧义，最后生成新的“解析树”。<br>④查询优化器（Optimizer）根据“解析树”生成最优的执行计划。MySQL使用很多优化策略生成最<br>优的执行计划，可以分为两类：静态优化（编译时优化）、动态优化（运行时优化）。<br>等价变换策略<br>5=5 and a&gt;5 改成 a &gt; 5<br>a &lt; b and a=5 改成b&gt;5 and a=5<br>基于联合索引，调整条件位置等<br>优化count、min、max等函数<br>InnoDB引擎min函数只需要找索引最左边<br>InnoDB引擎max函数只需要找索引最右边<br>MyISAM引擎count(*)，不需要计算，直接返回<br>提前终止查询<br>使用了limit查询，获取limit所需的数据，就不在继续遍历后面数据<br>in的优化<br>MySQL对in查询，会先进行排序，再采用二分法查找数据。比如where id in (2,1,3)，变<br>成 in (1,2,3)<br>⑤查询执行引擎负责执行 SQL 语句，此时查询执行引擎会根据 SQL 语句中表的存储引擎类型，以<br>及对应的API接口与底层存储引擎缓存或者物理文件的交互，得到查询结果并返回给客户端。若开<br>启用查询缓存，这时会将SQL 语句和结果完整地保存到查询缓存（Cache&amp;Buffer）中，以后若有<br>相同的 SQL 语句执行则直接返回结果。<br>如果开启了查询缓存，先将查询结果做缓存操作<br>返回结果过多，采用增量模式返回</p>
<p>MySQL存储引擎<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql5.jpg" alt="流程"></p>
<p>存储引擎在MySQL的体系架构中位于第三层，负责MySQL中的数据的存储和提取，是与文件打交道的<br>子系统，它是根据MySQL提供的文件访问层抽象接口定制的一种文件访问机制，这种机制就叫作存储引<br>擎。<br>使用show engines命令，就可以查看当前数据库支持的引擎信息。<br>在5.5版本之前默认采用MyISAM存储引擎，从5.5开始采用InnoDB存储引擎。<br>InnoDB：支持事务，具有提交，回滚和崩溃恢复能力，事务安全<br>MyISAM：不支持事务和外键，访问速度快<br>Memory：利用内存创建表，访问速度非常快，因为数据在内存，而且默认使用Hash索引，但是<br>一旦关闭，数据就会丢失<br>Archive：归档类型引擎，仅能支持insert和select语句<br>Csv：以CSV文件进行数据存储，由于文件限制，所有列必须强制指定not null，另外CSV引擎也不<br>支持索引和分区，适合做数据交换的中间表<br>BlackHole: 黑洞，只进不出，进来消失，所有插入数据都不会保存<br>Federated：可以访问远端MySQL数据库中的表。一个本地表，不保存数据，访问远程表内容。<br>MRG_MyISAM：一组MyISAM表的组合，这些MyISAM表必须结构相同，Merge表本身没有数据，<br>对Merge操作可以对一组MyISAM表进行操作。<br>3.1 InnoDB和MyISAM对比<br>InnoDB和MyISAM是使用MySQL时最常用的两种引擎类型，我们重点来看下两者区别。<br>事务和外键<br>InnoDB支持事务和外键，具有安全性和完整性，适合大量insert或update操作<br>MyISAM不支持事务和外键，它提供高速存储和检索，适合大量的select查询操作<br>锁机制<br>InnoDB支持行级锁，锁定指定记录。基于索引来加锁实现。<br>MyISAM支持表级锁，锁定整张表。<br>索引结构<br>InnoDB使用聚集索引（聚簇索引），索引和记录在一起存储，既缓存索引，也缓存记录。<br>MyISAM使用非聚集索引（非聚簇索引），索引和记录分开。<br>并发处理能力<br>MyISAM使用表锁，会导致写操作并发率低，读之间并不阻塞，读写阻塞。<br>InnoDB读写阻塞可以与隔离级别有关，可以采用多版本并发控制（MVCC）来支持高并发<br>存储文件<br>InnoDB表对应两个文件，一个.frm表结构文件，一个.ibd数据文件。InnoDB表最大支持64TB；<br>MyISAM表对应三个文件，一个.frm表结构文件，一个MYD表数据文件，一个.MYI索引文件。从<br>MySQL5.0开始默认限制是256TB。<br>适用场景<br>MyISAM<br>不需要事务支持（不支持）<br>并发相对较低（锁定机制问题）<br>数据修改相对较少，以读为主<br>数据一致性要求不高<br>InnoDB<br>需要事务支持（具有较好的事务特性）<br>行级锁定对高并发有很好的适应能力<br>数据更新较为频繁的场景<br>数据一致性要求较高<br>硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，减少磁盘IO<br>总结<br>两种引擎该如何选择？<br>是否需要事务？有，InnoDB<br>是否存在并发修改？有，InnoDB<br>是否追求快速查询，且数据修改少？是，MyISAM<br>在绝大多数情况下，推荐使用InnoDB</p>
<p>InnoDB存储结构<br>从MySQL 5.5版本开始默认使用InnoDB作为引擎，它擅长处理事务，具有自动崩溃恢复的特性，在日<br>常开发中使用非常广泛。下面是官方的InnoDB引擎架构图，主要分为内存结构和磁盘结构两大部分</p>
<p>内存结构主要包括Buffer Pool、Change Buffer、Adaptive Hash Index和Log Buffer四大组件。<br>Buffer Pool：缓冲池，简称BP。BP以Page页为单位，默认大小16K，BP的底层采用链表数<br>据结构管理Page。在InnoDB访问表记录和索引时会在Page页中缓存，以后使用可以减少磁<br>盘IO操作，提升效率。<br>Page管理机制<br>Page根据状态可以分为三种类型：<br>free page ： 空闲page，未被使用<br>clean page：被使用page，数据没有被修改过<br>dirty page：脏页，被使用page，数据被修改过，页中数据和磁盘的数据产生了不<br>一致<br>针对上述三种page类型，InnoDB通过三种链表结构来维护和管理<br>free list ：表示空闲缓冲区，管理free page<br>flush list：表示需要刷新到磁盘的缓冲区，管理dirty page，内部page按修改时间<br>排序。脏页即存在于flush链表，也在LRU链表中，但是两种互不影响，LRU链表负<br>责管理page的可用性和释放，而flush链表负责管理脏页的刷盘操作。<br>lru list：表示正在使用的缓冲区，管理clean page和dirty page，缓冲区以<br>midpoint为基点，前面链表称为new列表区，存放经常访问的数据，占63%；后<br>面的链表称为old列表区，存放使用较少数据，占37%。<br>改进型LRU算法维护<br>普通LRU：末尾淘汰法，新数据从链表头部加入，释放空间时从末尾淘汰<br>改性LRU：链表分为new和old两个部分，加入元素时并不是从表头插入，而是从中间<br>midpoint位置插入，如果数据很快被访问，那么page就会向new列表头部移动，如果<br>数据没有被访问，会逐步向old尾部移动，等待淘汰。<br>每当有新的page数据读取到buffer pool时，InnoDb引擎会判断是否有空闲页，是否足<br>够，如果有就将free page从free list列表删除，放入到LRU列表中。没有空闲页，就会<br>根据LRU算法淘汰LRU链表默认的页，将内存空间释放分配给新的页。<br>Buffer Pool配置参数<br>show variables like ‘%innodb_page_size%’; //查看page页大小<br>show variables like ‘%innodb_old%’; //查看lru list中old列表参数<br>show variables like ‘%innodb_buffer%’; //查看buffer pool参数<br>建议：将innodb_buffer_pool_size设置为总内存大小的60%-80%，<br>innodb_buffer_pool_instances可以设置为多个，这样可以避免缓存争夺。<br>Change Buffer：写缓冲区，简称CB。在进行DML操作时，如果BP没有其相应的Page数据，<br>并不会立刻将磁盘页加载到缓冲池，而是在CB记录缓冲变更，等未来数据被读取时，再将数<br>据合并恢复到BP中。<br>ChangeBuffer占用BufferPool空间，默认占25%，最大允许占50%，可以根据读写业务量来<br>进行调整。参数innodb_change_buffer_max_size;<br>当更新一条记录时，该记录在BufferPool存在，直接在BufferPool修改，一次内存操作。如<br>果该记录在BufferPool不存在（没有命中），会直接在ChangeBuffer进行一次内存操作，不<br>用再去磁盘查询数据，避免一次磁盘IO。当下次查询记录时，会先进性磁盘读取，然后再从<br>ChangeBuffer中读取信息合并，最终载入BufferPool中。<br>写缓冲区，仅适用于非唯一普通索引页，为什么？<br>如果在索引设置唯一性，在进行修改时，InnoDB必须要做唯一性校验，因此必须查询磁盘，<br>做一次IO操作。会直接将记录查询到BufferPool中，然后在缓冲池修改，不会在<br>ChangeBuffer操作。<br>Adaptive Hash Index：自适应哈希索引，用于优化对BP数据的查询。InnoDB存储引擎会监<br>控对表索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，所以<br>称之为自适应。InnoDB存储引擎会自动根据访问的频率和模式来为某些页建立哈希索引。<br>Log Buffer：日志缓冲区，用来保存要写入磁盘上log文件（Redo/Undo）的数据，日志缓冲<br>区的内容定期刷新到磁盘log文件中。日志缓冲区满时会自动将其刷新到磁盘，当遇到BLOB<br>或多行更新的大事务操作时，增加日志缓冲区可以节省磁盘I/O。<br>LogBuffer主要是用于记录InnoDB引擎日志，在DML操作时会产生Redo和Undo日志。<br>LogBuffer空间满了，会自动写入磁盘。可以通过将innodb_log_buffer_size参数调大，减少<br>磁盘IO频率<br>innodb_flush_log_at_trx_commit参数控制日志刷新行为，默认为1<br>0 ： 每隔1秒写日志文件和刷盘操作（写日志文件LogBuffer–&gt;OS cache，刷盘OS<br>cache–&gt;磁盘文件），最多丢失1秒数据<br>1：事务提交，立刻写日志文件和刷盘，数据不丢失，但是会频繁IO操作<br>2：事务提交，立刻写日志文件，每隔1秒钟进行刷盘操作</p>
<p>InnoDB磁盘结构<br>InnoDB磁盘主要包含Tablespaces，InnoDB Data Dictionary，Doublewrite Buffer、Redo Log<br>和Undo Logs。<br>表空间（Tablespaces）：用于存储表结构和数据。表空间又分为系统表空间、独立表空间、<br>通用表空间、临时表空间、Undo表空间等多种类型；<br>系统表空间（The System Tablespace）<br>包含InnoDB数据字典，Doublewrite Buffer，Change Buffer，Undo Logs的存储区<br>域。系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。系统表空<br>间是一个共享的表空间因为它是被多个表共享的。该空间的数据文件通过参数<br>innodb_data_file_path控制，默认值是ibdata1:12M:autoextend(文件名为ibdata1、<br>12MB、自动扩展)。<br>独立表空间（File-Per-Table Tablespaces）<br>默认开启，独立表空间是一个单表表空间，该表创建于自己的数据文件中，而非创建于<br>系统表空间中。当innodb_file_per_table选项开启时，表将被创建于表空间中。否则，<br>innodb将被创建于系统表空间中。每个表文件表空间由一个.ibd数据文件代表，该文件<br>默认被创建于数据库目录中。表空间的表文件支持动态（dynamic）和压缩<br>（commpressed）行格式。<br>通用表空间（General Tablespaces）<br>通用表空间为通过create tablespace语法创建的共享表空间。通用表空间可以创建于<br>mysql数据目录外的其他表空间，其可以容纳多张表，且其支持所有的行格式。<br>撤销表空间（Undo Tablespaces）<br>撤销表空间由一个或多个包含Undo日志文件组成。在MySQL 5.7版本之前Undo占用的<br>是System Tablespace共享区，从5.7开始将Undo从System Tablespace分离了出来。<br>InnoDB使用的undo表空间由innodb_undo_tablespaces配置选项控制，默认为0。参<br>数值为0表示使用系统表空间ibdata1;大于0表示使用undo表空间undo_001、<br>undo_002等。<br>临时表空间（Temporary Tablespaces） CREATE TABLESPACE ts1 ADD DATAFILE ts1.ibd Engine=InnoDB; //创建表空 间ts1 CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1; //将表添加到ts1 表空间<br>分为session temporary tablespaces 和global temporary tablespace两种。session<br>temporary tablespaces 存储的是用户创建的临时表和磁盘内部的临时表。global<br>temporary tablespace储存用户临时表的回滚段（rollback segments ）。mysql服务<br>器正常关闭或异常终止时，临时表空间将被移除，每次启动时会被重新创建。<br>数据字典（InnoDB Data Dictionary）<br>InnoDB数据字典由内部系统表组成，这些表包含用于查找表、索引和表字段等对象的元数<br>据。元数据物理上位于InnoDB系统表空间中。由于历史原因，数据字典元数据在一定程度上<br>与InnoDB表元数据文件（.frm文件）中存储的信息重叠。<br>双写缓冲区（Doublewrite Buffer）<br>位于系统表空间，是一个存储区域。在BufferPage的page页刷新到磁盘真正的位置前，会先<br>将数据存在Doublewrite 缓冲区。如果在page页写入过程中出现操作系统、存储子系统或<br>mysqld进程崩溃，InnoDB可以在崩溃恢复期间从Doublewrite 缓冲区中找到页面的一个好<br>备份。在大多数情况下，默认情况下启用双写缓冲区，要禁用Doublewrite 缓冲区，可以将<br>innodb_doublewrite设置为0。使用Doublewrite 缓冲区时建议将innodb_flush_method设<br>置为O_DIRECT。<br>MySQL的innodb_flush_method这个参数控制着innodb数据文件及redo log的打开、<br>刷写模式。有三个值：fdatasync(默认)，O_DSYNC，O_DIRECT。设置O_DIRECT表示<br>数据文件写入操作会通知操作系统不要缓存数据，也不要用预读，直接从Innodb<br>Buffer写到磁盘文件。<br>默认的fdatasync意思是先写入操作系统缓存，然后再调用fsync()函数去异步刷数据文<br>件与redo log的缓存信息。<br>重做日志（Redo Log）<br>重做日志是一种基于磁盘的数据结构，用于在崩溃恢复期间更正不完整事务写入的数据。<br>MySQL以循环方式写入重做日志文件，记录InnoDB中所有对Buffer Pool修改的日志。当出<br>现实例故障（像断电），导致数据未能更新到数据文件，则数据库重启时须redo，重新把数<br>据更新到数据文件。读写事务在执行的过程中，都会不断的产生redo log。默认情况下，重<br>做日志在磁盘上由两个名为ib_logfile0和ib_logfile1的文件物理表示。<br>撤销日志（Undo Logs）<br>撤消日志是在事务开始之前保存的被修改数据的备份，用于例外情况时回滚事务。撤消日志<br>属于逻辑日志，根据每行记录进行记录。撤消日志存在于系统表空间、撤消表空间和临时表<br>空间中。<br>MySQL 5.7 版本<br>将 Undo日志表空间从共享表空间 ibdata 文件中分离出来，可以在安装 MySQL 时由用<br>户自行指定文件大小和数量。<br>增加了 temporary 临时表空间，里面存储着临时表或临时查询结果集的数据。<br>Buffer Pool 大小可以动态修改，无需重启数据库实例。<br>MySQL 8.0 版本<br>将InnoDB表的数据字典和Undo都从共享表空间ibdata中彻底分离出来了，以前需要<br>ibdata中数据字典与独立表空间ibd文件中数据字典一致才行，8.0版本就不需要了。<br>temporary 临时表空间也可以配置多个物理文件，而且均为 InnoDB 存储引擎并能创建<br>索引，这样加快了处理的速度。<br>用户可以像 Oracle 数据库那样设置一些表空间，每个表空间对应多个物理文件，每个<br>表空间可以给多个表使用，但一个表只能存储在一个表空间中。<br>将Doublewrite Buffer从共享表空间ibdata中也分离出来了</p>
<p>InnoDB线程模型<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql6.jpg" alt="流程"></p>
<p>IO Thread<br>在InnoDB中使用了大量的AIO（Async IO）来做读写处理，这样可以极大提高数据库的性能。在<br>InnoDB1.0版本之前共有4个IO Thread，分别是write，read，insert buffer和log thread，后来<br>版本将read thread和write thread分别增大到了4个，一共有10个了。<br>read thread ： 负责读取操作，将数据从磁盘加载到缓存page页。4个<br>write thread：负责写操作，将缓存脏页刷新到磁盘。4个<br>log thread：负责将日志缓冲区内容刷新到磁盘。1个<br>insert buffer thread ：负责将写缓冲内容刷新到磁盘。1个<br>Purge Thread<br>事务提交之后，其使用的undo日志将不再需要，因此需要Purge Thread回收已经分配的undo<br>页。<br>show variables like ‘%innodb_purge_threads%’;<br>Page Cleaner Thread<br>作用是将脏数据刷新到磁盘，脏数据刷盘后相应的redo log也就可以覆盖，即可以同步数据，又能<br>达到redo log循环使用的目的。会调用write thread线程处理。<br>show variables like ‘%innodb_page_cleaners%’;<br>Master Thread<br>Master thread是InnoDB的主线程，负责调度其他各线程，优先级最高。作用是将缓冲池中的数<br>据异步刷新到磁盘 ，保证数据的一致性。包含：脏页的刷新（page cleaner thread）、undo页<br>回收（purge thread）、redo日志刷新（log thread）、合并写缓冲等。内部有两个主处理，分别<br>是每隔1秒和10秒处理。<br>每1秒的操作：<br>刷新日志缓冲区，刷到磁盘<br>合并写缓冲区数据，根据IO读写压力来决定是否操作<br>刷新脏页数据到磁盘，根据脏页比例达到75%才操作（innodb_max_dirty_pages_pct，<br>innodb_io_capacity） 每10秒的操作：<br>刷新脏页数据到磁盘<br>合并写缓冲区数据<br>刷新日志缓冲区<br>删除无用的undo页</p>
<p>Undolog and binlog and redoLog<br>Undo Log<br>3.5.1 Undo Log介绍<br>Undo：意为撤销或取消，以撤销操作为目的，返回指定某个状态的操作。<br>Undo Log：数据库事务开始之前，会将要修改的记录存放到 Undo 日志里，当事务回滚时或者数<br>据库崩溃时，可以利用 Undo 日志，撤销未提交事务对数据库产生的影响。<br>Undo Log产生和销毁：Undo Log在事务开始前产生；事务在提交时，并不会立刻删除undo<br>log，innodb会将该事务对应的undo log放入到删除列表中，后面会通过后台线程purge thread进<br>行回收处理。Undo Log属于逻辑日志，记录一个变化过程。例如执行一个delete，undolog会记<br>录一个insert；执行一个update，undolog会记录一个相反的update。<br>Undo Log存储：undo log采用段的方式管理和记录。在innodb数据文件中包含一种rollback<br>segment回滚段，内部包含1024个undo log segment。可以通过下面一组参数来控制Undo log存<br>储。<br>3.5.2 Undo Log作用<br>实现事务的原子性<br>Undo Log 是为了实现事务的原子性而出现的产物。事务处理过程中，如果出现了错误或者用户执<br>行了 ROLLBACK 语句，MySQL 可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。<br>实现多版本并发控制（MVCC）<br>Undo Log 在 MySQL InnoDB 存储引擎中用来实现多版本并发控制。事务未提交之前，Undo Log<br>保存了未提交之前的版本数据，Undo Log 中的数据可作为数据旧版本快照供其他并发事务进行快<br>照读。<br>事务A手动开启事务，执行更新操作，首先会把更新命中的数据备份到 Undo Buffer 中。<br>事务B手动开启事务，执行查询操作，会读取 Undo 日志数据返回，进行快照读<br>3.6 Redo Log和Binlog<br>Redo Log和Binlog是MySQL日志系统中非常重要的两种机制，也有很多相似之处，下面介绍下两者细<br>节和区别。<br>3.6.1 Redo Log日志<br>Redo Log介绍<br>show variables like ‘%innodb_undo%’;<br>Redo：顾名思义就是重做。以恢复操作为目的，在数据库发生意外时重现操作。<br>Redo Log：指事务中修改的任何数据，将最新的数据备份存储的位置（Redo Log），被称为重做<br>日志。<br>Redo Log 的生成和释放：随着事务操作的执行，就会生成Redo Log，在事务提交时会将产生<br>Redo Log写入Log Buffer，并不是随着事务的提交就立刻写入磁盘文件。等事务操作的脏页写入<br>到磁盘之后，Redo Log 的使命也就完成了，Redo Log占用的空间就可以重用（被覆盖写入）。<br>Redo Log工作原理<br>Redo Log 是为了实现事务的持久性而出现的产物。防止在发生故障的时间点，尚有脏页未写入表<br>的 IBD 文件中，在重启 MySQL 服务的时候，根据 Redo Log 进行重做，从而达到事务的未入磁盘<br>数据进行持久化这一特性。<br>Redo Log写入机制<br>Redo Log 文件内容是以顺序循环的方式写入文件，写满时则回溯到第一个文件，进行覆盖写。<br>如图所示：<br>write pos 是当前记录的位置，一边写一边后移，写到最后一个文件末尾后就回到 0 号文件开<br>头；<br>checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数<br>据文件；<br>write pos 和 checkpoint 之间还空着的部分，可以用来记录新的操作。如果 write pos 追上<br>checkpoint，表示写满，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint<br>推进一下。<br>Redo Log相关配置参数<br>每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组至少有2个重做日志文<br>件，默认为ib_logfile0和ib_logfile1。可以通过下面一组参数控制Redo Log存储：<br>show variables like ‘%innodb_log%’;<br>Redo Buffer 持久化到 Redo Log 的策略，可通过 Innodb_flush_log_at_trx_commit 设置：<br>0：每秒提交 Redo buffer -&gt;OS cache -&gt; flush cache to disk，可能丢失一秒内的事务数<br>据。由后台Master线程每隔 1秒执行一次操作。<br>1（默认值）：每次事务提交执行 Redo Buffer -&gt; OS cache -&gt; flush cache to disk，最安<br>全，性能最差的方式。<br>2：每次事务提交执行 Redo Buffer -&gt; OS cache，然后由后台Master线程再每隔1秒执行OS<br>cache -&gt; flush cache to disk 的操作。<br>一般建议选择取值2，因为 MySQL 挂了数据没有损失，整个服务器挂了才会损失1秒的事务提交数<br>据。<br>3.6.2 Binlog日志<br>Binlog记录模式<br>Redo Log 是属于InnoDB引擎所特有的日志，而MySQL Server也有自己的日志，即 Binary<br>log（二进制日志），简称Binlog。Binlog是记录所有数据库表结构变更以及表数据修改的二进制<br>日志，不会记录SELECT和SHOW这类操作。Binlog日志是以事件形式记录，还包含语句所执行的<br>消耗时间。开启Binlog日志有以下两个最重要的使用场景。<br>主从复制：在主库中开启Binlog功能，这样主库就可以把Binlog传递给从库，从库拿到<br>Binlog后实现数据恢复达到主从数据一致性。<br>数据恢复：通过mysqlbinlog工具来恢复数据。<br>Binlog文件名默认为“主机名_binlog-序列号”格式，例如oak_binlog-000001，也可以在配置文件<br>中指定名称。文件记录模式有STATEMENT、ROW和MIXED三种，具体含义如下。<br>ROW（row-based replication, RBR）：日志中会记录每一行数据被修改的情况，然后在<br>slave端对相同的数据进行修改。<br>优点：能清楚记录每一个行数据的修改细节，能完全实现主从数据同步和数据的恢复。<br>缺点：批量操作，会产生大量的日志，尤其是alter table会让日志暴涨。<br>STATMENT（statement-based replication, SBR）：每一条被修改数据的SQL都会记录到<br>master的Binlog中，slave在复制的时候SQL进程会解析成和原来master端执行过的相同的<br>SQL再次执行。简称SQL语句复制。<br>优点：日志量小，减少磁盘IO，提升存储和恢复速度<br>缺点：在某些情况下会导致主从数据不一致，比如last_insert_id()、now()等函数。<br>MIXED（mixed-based replication, MBR）：以上两种模式的混合使用，一般会使用<br>STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存<br>binlog，MySQL会根据执行的SQL语句选择写入模式。<br>Binlog文件结构<br>MySQL的binlog文件中记录的是对数据库的各种修改操作，用来表示修改操作的数据结构是Log<br>event。不同的修改操作对应的不同的log event。比较常用的log event有：Query event、Row event、Xid event等。binlog文件的内容就是各种Log event的集合。<br>Binlog文件中Log event结构如下图所示：<br>Binlog写入机制<br>根据记录模式和操作触发event事件生成log event（事件触发执行机制）<br>将事务执行过程中产生log event写入缓冲区，每个事务线程都有一个缓冲区<br>Log Event保存在一个binlog_cache_mngr数据结构中，在该结构中有两个缓冲区，一个是<br>stmt_cache，用于存放不支持事务的信息；另一个是trx_cache，用于存放支持事务的信息。<br>事务在提交阶段会将产生的log event写入到外部binlog文件中。<br>不同事务以串行方式将log event写入binlog文件中，所以一个事务包含的log event信息在<br>binlog文件中是连续的，中间不会插入其他事务的log event。<br>Binlog文件操作<br>Binlog状态查看<br>show variables like ‘log_bin’;<br>开启Binlog功能<br>mysql&gt; set global log_bin=mysqllogbin; ERROR 1238 (HY000): Variable ‘log_bin’ is a read only variable<br>需要修改my.cnf或my.ini配置文件，在[mysqld]下面增加log_bin=mysql_bin_log，重启<br>MySQL服务。<br>#log-bin=ON #log-bin-basename=mysqlbinlog binlog-format=ROW log-bin=mysqlbinlog<br>使用show binlog events命令<br>show binary logs; //等价于show master logs; show master status; show binlog events; show binlog events in ‘mysqlbinlog.000001’;<br>使用mysqlbinlog 命令<br>mysqlbinlog “文件名” mysqlbinlog “文件名” &gt; “test.sql”<br>使用 binlog 恢复数据<br>//按指定时间恢复 mysqlbinlog –start-datetime=”2020-04-25 18:00:00” –stop- datetime=”2020-04-26 00:00:00” mysqlbinlog.000002 | mysql -uroot -p1234 //按事件位置号恢复 mysqlbinlog –start-position=154 –stop-position=957 mysqlbinlog.000002 | mysql -uroot -p1234<br>mysqldump：定期全部备份数据库数据。mysqlbinlog可以做增量备份和恢复操作。<br>删除Binlog文件<br>purge binary logs to ‘mysqlbinlog.000001’; //删除指定文件 purge binary logs before ‘2020-04-28 00:00:00’; //删除指定时间之前的文件 reset master; //清除所有文件<br>可以通过设置expire_logs_days参数来启动自动清理功能。默认值为0表示没启用。设置为1表示超<br>出1天binlog文件会自动删除掉。<br>Redo Log和Binlog区别<br>Redo Log是属于InnoDB引擎功能，Binlog是属于MySQL Server自带功能，并且是以二进制<br>文件记录。<br>Redo Log属于物理日志，记录该数据页更新状态内容，Binlog是逻辑日志，记录更新过程。<br>Redo Log日志是循环写，日志空间大小是固定，Binlog是追加写入，写完一个写下一个，不<br>会覆盖使用。<br>Redo Log作为服务器异常宕机后事务数据自动恢复使用，Binlog可以作为主从复制和数据恢<br>复使用。Binlog没有自动crash-safe能力。</p>
<p>MySQL索引原理<br>索引类型<br>索引可以提升查询速度，会影响where查询，以及order by排序。MySQL索引类型如下：<br>从索引存储结构划分：B Tree索引、Hash索引、FULLTEXT全文索引、R Tree索引<br>从应用层次划分：普通索引、唯一索引、主键索引、复合索引<br>从索引键值类型划分：主键索引、辅助索引（二级索引）<br>从数据存储和索引键值逻辑关系划分：聚集索引（聚簇索引）、非聚集索引（非聚簇索引）<br>普通索引<br>这是最基本的索引类型，基于普通字段建立的索引，没有任何限制。<br>创建普通索引的方法如下：<br>CREATE INDEX &lt;索引的名字&gt; ON tablename (字段名);<br>ALTER TABLE tablename ADD INDEX [索引的名字] (字段名);<br>CREATE TABLE tablename ( […], INDEX [索引的名字] (字段名) );<br>1.2 唯一索引<br>与”普通索引”类似，不同的就是：索引字段的值必须唯一，但允许有空值 。在创建或修改表时追加唯一<br>约束，就会自动创建对应的唯一索引。<br>创建唯一索引的方法如下：<br>CREATE UNIQUE INDEX &lt;索引的名字&gt; ON tablename (字段名);<br>ALTER TABLE tablename ADD UNIQUE INDEX [索引的名字] (字段名);<br>CREATE TABLE tablename ( […], UNIQUE [索引的名字] (字段名) ;<br>1.3 主键索引<br>它是一种特殊的唯一索引，不允许有空值。在创建或修改表时追加主键约束即可，每个表只能有一个主<br>键。<br>创建主键索引的方法如下：<br>CREATE TABLE tablename ( […], PRIMARY KEY (字段名) );<br>ALTER TABLE tablename ADD PRIMARY KEY (字段名);<br>1.4 复合索引<br>单一索引是指索引列为一列的情况，即新建索引的语句只实施在一列上；用户可以在多个列上建立索<br>引，这种索引叫做组复合索引（组合索引）。复合索引可以代替多个单一索引，相比多个单一索引复合<br>索引所需的开销更小。<br>索引同时有两个概念叫做窄索引和宽索引，窄索引是指索引列为1-2列的索引，宽索引也就是索引列超<br>过2列的索引，设计索引的一个重要原则就是能用窄索引不用宽索引，因为窄索引往往比组合索引更有<br>效。<br>创建组合索引的方法如下：<br>CREATE INDEX &lt;索引的名字&gt; ON tablename (字段名1，字段名2…);<br>ALTER TABLE tablename ADD INDEX [索引的名字] (字段名1，字段名2…);<br>CREATE TABLE tablename ( […], INDEX [索引的名字] (字段名1，字段名2…) );<br>复合索引使用注意事项：<br>何时使用复合索引，要根据where条件建索引，注意不要过多使用索引，过多使用会对更新操作效<br>率有很大影响。<br>如果表已经建立了(col1，col2)，就没有必要再单独建立（col1）；如果现在有(col1)索引，如果查<br>询需要col1和col2条件，可以建立(col1,col2)复合索引，对于查询有一定提高。<br>1.5 全文索引<br>查询操作在数据量比较少时，可以使用like模糊查询，但是对于大量的文本数据检索，效率很低。如果<br>使用全文索引，查询速度会比like快很多倍。在MySQL 5.6 以前的版本，只有MyISAM存储引擎支持全<br>文索引，从MySQL 5.6开始MyISAM和InnoDB存储引擎均支持。<br>创建全文索引的方法如下：<br>CREATE FULLTEXT INDEX &lt;索引的名字&gt; ON tablename (字段名);<br>ALTER TABLE tablename ADD FULLTEXT [索引的名字] (字段名);<br>CREATE TABLE tablename ( […], FULLTEXT KEY [索引的名字] (字段名) ;<br>和常用的like模糊查询不同，全文索引有自己的语法格式，使用 match 和 against 关键字，比如<br>全文索引使用注意事项：<br>全文索引必须在字符串、文本字段上建立。<br>全文索引字段值必须在最小字符和最大字符之间的才会有效。（innodb：3-84；myisam：4-<br>84）<br>全文索引字段值要进行切词处理，按syntax字符进行切割，例如b+aaa，切分成b和aaa<br>全文索引匹配查询，默认使用的是等值匹配，例如a匹配a，不会匹配ab,ac。如果想匹配可以在布<br>尔模式下搜索a*<br>第2节 索引原理<br>MySQL官方对索引定义：是存储引擎用于快速查找记录的一种数据结构。需要额外开辟空间和数据维护<br>工作。<br>索引是物理数据页存储，在数据文件中（InnoDB，ibd文件），利用数据页(page)存储。<br>索引可以加快检索速度，但是同时也会降低增删改操作速度，索引维护需要代价。<br>索引涉及的理论知识：二分查找法、Hash和B+Tree。<br>2.1 二分查找法<br>二分查找法也叫作折半查找法，它是在有序数组中查找指定数据的搜索算法。它的优点是等值查询、范<br>围查询性能优秀，缺点是更新数据、新增数据、删除数据维护成本高。<br>首先定位left和right两个指针<br>select * from user where match(name) against(‘aaa’); select * from user where match(name) against(‘a*’ in boolean mode);<br>计算(left+right)/2<br>判断除2后索引位置值与目标值的大小比对<br>索引位置值大于目标值就-1，right移动；如果小于目标值就+1，left移动<br>举个例子，下面的有序数组有17 个值，查找的目标值是7，过程如下：<br>第一次查找<br>第二次查找<br>第三次查找<br>第四次查找<br>2.2 Hash结构<br>Hash底层实现是由Hash表来实现的，是根据键值 &lt;key,value&gt; 存储数据的结构。非常适合根据key查找<br>value值，也就是单个key查询，或者说等值查询。其结构如下所示：<br>从上面结构可以看出，Hash索引可以方便的提供等值查询，但是对于范围查询就需要全表扫描了。<br>Hash索引在MySQL 中Hash结构主要应用在Memory原生的Hash索引 、InnoDB 自适应哈希索引。<br>InnoDB提供的自适应哈希索引功能强大，接下来重点描述下InnoDB 自适应哈希索引。<br>InnoDB自适应哈希索引是为了提升查询效率，InnoDB存储引擎会监控表上各个索引页的查询，当<br>InnoDB注意到某些索引值访问非常频繁时，会在内存中基于B+Tree索引再创建一个哈希索引，使得内<br>存中的 B+Tree 索引具备哈希索引的功能，即能够快速定值访问频繁访问的索引页。<br>InnoDB自适应哈希索引：在使用Hash索引访问时，一次性查找就能定位数据，等值查询效率要优于<br>B+Tree。<br>自适应哈希索引的建立使得InnoDB存储引擎能自动根据索引页访问的频率和模式自动地为某些热点页<br>建立哈希索引来加速访问。另外InnoDB自适应哈希索引的功能，用户只能选择开启或关闭功能，无法<br>进行人工干涉。<br>show engine innodb status \G; show variables like ‘%innodb_adaptive%’;<br>2.3 B+Tree结构<br>MySQL数据库索引采用的是B+Tree结构，在B-Tree结构上做了优化改造。<br>B-Tree结构<br>索引值和data数据分布在整棵树结构中<br>每个节点可以存放多个索引值及对应的data数据<br>树节点中的多个索引值从左到右升序排列<br>B树的搜索：从根节点开始，对节点内的索引值序列采用二分法查找，如果命中就结束查找。没有<br>命中会进入子节点重复查找过程，直到所对应的的节点指针为空，或已经是叶子节点了才结束。<br>B+Tree结构<br>非叶子节点不存储data数据，只存储索引值，这样便于存储更多的索引值<br>叶子节点包含了所有的索引值和data数据<br>叶子节点用指针连接，提高区间的访问性能<br>相比B树，B+树进行范围查找时，只需要查找定位两个节点的索引值，然后利用叶子节点的指针进<br>行遍历即可。而B树需要遍历范围内所有的节点和数据，显然B+Tree效率高。<br>2.4 聚簇索引和辅助索引<br>聚簇索引和非聚簇索引：B+Tree的叶子节点存放主键索引值和行记录就属于聚簇索引；如果索引值和行<br>记录分开存放就属于非聚簇索引。<br>主键索引和辅助索引：B+Tree的叶子节点存放的是主键字段值就属于主键索引；如果存放的是非主键值<br>就属于辅助索引（二级索引）。<br>在InnoDB引擎中，主键索引采用的就是聚簇索引结构存储。<br>聚簇索引（聚集索引）<br>聚簇索引是一种数据存储方式，InnoDB的聚簇索引就是按照主键顺序构建 B+Tree结构。B+Tree<br>的叶子节点就是行记录，行记录和主键值紧凑地存储在一起。 这也意味着 InnoDB 的主键索引就<br>是数据表本身，它按主键顺序存放了整张表的数据，占用的空间就是整个表数据量的大小。通常说<br>的主键索引就是聚集索引。<br>InnoDB的表要求必须要有聚簇索引：<br>如果表定义了主键，则主键索引就是聚簇索引<br>如果表没有定义主键，则第一个非空unique列作为聚簇索引<br>否则InnoDB会从建一个隐藏的row-id作为聚簇索引<br>辅助索引<br>InnoDB辅助索引，也叫作二级索引，是根据索引列构建 B+Tree结构。但在 B+Tree 的叶子节点中<br>只存了索引列和主键的信息。二级索引占用的空间会比聚簇索引小很多， 通常创建辅助索引就是<br>为了提升查询效率。一个表InnoDB只能创建一个聚簇索引，但可以创建多个辅助索引。<br>非聚簇索引<br>与InnoDB表存储不同，MyISAM数据表的索引文件和数据文件是分开的，被称为非聚簇索引结<br>构。</p>
<p>查询优化<br>MySQL 提供了一个 EXPLAIN 命令，它可以对 SELECT 语句进行分析，并输出 SELECT 执行的详细信<br>息，供开发人员有针对性的优化。例如：<br>EXPLAIN 命令的输出内容大致如下：<br>select_type<br>表示查询的类型。常用的值如下：<br>SIMPLE ： 表示查询语句不包含子查询或union<br>PRIMARY：表示此查询是最外层的查询<br>UNION：表示此查询是UNION的第二个或后续的查询<br>EXPLAIN SELECT * from user WHERE id &lt; 3;<br>DEPENDENT UNION：UNION中的第二个或后续的查询语句，使用了外面查询结果<br>UNION RESULT：UNION的结果<br>SUBQUERY：SELECT子查询语句<br>DEPENDENT SUBQUERY：SELECT子查询语句依赖外层查询的结果。<br>最常见的查询类型是SIMPLE，表示我们的查询没有子查询也没用到UNION查询。<br>type<br>表示存储引擎查询数据时采用的方式。比较重要的一个属性，通过它可以判断出查询是全表扫描还<br>是基于索引的部分扫描。常用属性值如下，从上至下效率依次增强。<br>ALL：表示全表扫描，性能最差。<br>index：表示基于索引的全表扫描，先扫描索引再扫描全表数据。<br>range：表示使用索引范围查询。使用&gt;、&gt;=、&lt;、&lt;=、in等等。<br>ref：表示使用非唯一索引进行单值查询。<br>eq_ref：一般情况下出现在多表join查询，表示前面表的每一个记录，都只能匹配后面表的一<br>行结果。<br>const：表示使用主键或唯一索引做等值查询，常量查询。<br>NULL：表示不用访问表，速度最快。<br>possible_keys<br>表示查询时能够使用到的索引。注意并不一定会真正使用，显示的是索引名称。<br>key<br>表示查询时真正使用到的索引，显示的是索引名称。<br>rows<br>MySQL查询优化器会根据统计信息，估算SQL要查询到结果需要扫描多少行记录。原则上rows是<br>越少效率越高，可以直观的了解到SQL效率高低。<br>key_len<br>表示查询使用了索引的字节数量。可以判断是否全部使用了组合索引。<br>key_len的计算规则如下：<br>字符串类型<br>字符串长度跟字符集有关：latin1=1、gbk=2、utf8=3、utf8mb4=4<br>char(n)：n*字符集长度<br>varchar(n)：n * 字符集长度 + 2字节<br>数值类型<br>TINYINT：1个字节<br>SMALLINT：2个字节<br>MEDIUMINT：3个字节<br>INT、FLOAT：4个字节<br>BIGINT、DOUBLE：8个字节<br>时间类型<br>DATE：3个字节<br>TIMESTAMP：4个字节<br>DATETIME：8个字节<br>字段属性<br>NULL属性占用1个字节，如果一个字段设置了NOT NULL，则没有此项。<br>Extra<br>Extra表示很多额外的信息，各种操作会在Extra提示相关信息，常见几种如下：<br>Using where<br>表示查询需要通过索引回表查询数据。<br>Using index<br>表示查询需要通过索引，索引就可以满足所需数据。<br>Using filesort<br>表示查询出来的结果需要额外排序，数据量小在内存，大的话在磁盘，因此有Using filesort<br>建议优化。<br>Using temprorary<br>查询使用到了临时表，一般出现于去重、分组等操作。<br>3.2 回表查询<br>在之前介绍过，InnoDB索引有聚簇索引和辅助索引。聚簇索引的叶子节点存储行记录，InnoDB必须要<br>有，且只有一个。辅助索引的叶子节点存储的是主键值和索引字段值，通过辅助索引无法直接定位行记<br>录，通常情况下，需要扫码两遍索引树。先通过辅助索引定位主键值，然后再通过聚簇索引定位行记<br>录，这就叫做回表查询，它的性能比扫一遍索引树低。<br>总结：通过索引查询主键值，然后再去聚簇索引查询记录信息<br>3.3 覆盖索引<br>在SQL-Server官网的介绍如下：<br>在MySQL官网，类似的说法出现在explain查询计划优化章节，即explain的输出结果Extra字段为Using<br>index时，能够触发索引覆盖。<br>不管是SQL-Server官网，还是MySQL官网，都表达了：只需要在一棵索引树上就能获取SQL所需的所<br>有列数据，无需回表，速度更快，这就叫做索引覆盖。<br>实现索引覆盖最常见的方法就是：将被查询的字段，建立到组合索引。<br>3.4 最左前缀原则<br>复合索引使用时遵循最左前缀原则，最左前缀顾名思义，就是最左优先，即查询中使用到最左边的列，<br>那么查询就会使用到索引，如果从索引的第二列开始查找，索引将失效。<br>3.5 LIKE查询<br>面试题：MySQL在使用like模糊查询时，索引能不能起作用？<br>回答：MySQL在使用Like模糊查询时，索引是可以被使用的，只有把%字符写在后面才会使用到索引。<br>select * from user where name like ‘%o%’; //不起作用<br>select * from user where name like ‘o%’; //起作用<br>select * from user where name like ‘%o’; //不起作用<br>3.6 NULL查询<br>面试题：如果MySQL表的某一列含有NULL值，那么包含该列的索引是否有效？<br>对MySQL来说，NULL是一个特殊的值，从概念上讲，NULL意味着“一个未知值”，它的处理方式与其他<br>值有些不同。比如：不能使用=，&lt;，&gt;这样的运算符，对NULL做算术运算的结果都是NULL，count时<br>不会包括NULL行等，NULL比空字符串需要更多的存储空间等。<br>NULL列需要增加额外空间来记录其值是否为NULL。对于MyISAM表，每一个空列额外占用一位，四舍<br>五入到最接近的字节。<br>虽然MySQL可以在含有NULL的列上使用索引，但NULL和其他数据还是有区别的，不建议列上允许为<br>NULL。最好设置NOT NULL，并给一个默认值，比如0和 ‘’ 空字符串等，如果是datetime类型，也可以<br>设置系统当前时间或某个固定的特殊值，例如’1970-01-01 00:00:00’。 “NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”<br>3.7 索引与排序<br>MySQL查询支持filesort和index两种方式的排序，filesort是先把结果查出，然后在缓存或磁盘进行排序<br>操作，效率较低。使用index是指利用索引自动实现排序，不需另做排序操作，效率会比较高。<br>filesort有两种排序算法：双路排序和单路排序。<br>双路排序：需要两次磁盘扫描读取，最终得到用户数据。第一次将排序字段读取出来，然后排序；第二<br>次去读取其他字段数据。<br>单路排序：从磁盘查询所需的所有列数据，然后在内存排序将结果返回。如果查询数据超出缓存<br>sort_buffer，会导致多次磁盘读取操作，并创建临时表，最后产生了多次IO，反而会增加负担。解决方<br>案：少使用select *；增加sort_buffer_size容量和max_length_for_sort_data容量。<br>如果我们Explain分析SQL，结果中Extra属性显示Using filesort，表示使用了filesort排序方式，需要优<br>化。如果Extra属性显示Using index时，表示覆盖索引，也表示所有操作在索引上完成，也可以使用<br>index排序方式，建议大家尽可能采用覆盖索引。<br>以下几种情况，会使用index方式的排序。<br>ORDER BY 子句索引列组合满足索引最左前列<br>WHERE子句+ORDER BY子句索引列组合满足索引最左前列<br>以下几种情况，会使用filesort方式的排序。<br>对索引列同时使用了ASC和DESC<br>WHERE子句和ORDER BY子句满足最左前缀，但where子句使用了范围查询（例如&gt;、&lt;、in<br>等）<br>ORDER BY或者WHERE+ORDER BY索引列没有满足索引最左前列<br>使用了不同的索引，MySQL每次只采用一个索引，ORDER BY涉及了两个索引<br>WHERE子句与ORDER BY子句，使用了不同的索引<br>explain select id from user order by id; //对应(id)、(id,name)索引有效 explain select id from user where age=18 order by name; //对应 (age,name)索引 explain select id from user order by age asc,name desc; //对应 (age,name)索引 explain select id from user where age&gt;10 order by name; //对应 (age,name)索引 explain select id from user order by name; //对应(age,name)索引 explain select id from user order by name,age; //对应(name)、(age)两个索 引explain select id from user where name=’tom’ order by age; //对应 (name)、(age)索引<br>WHERE子句或者ORDER BY子句中索引列使用了表达式，包括函数表达式<br>第4节 查询优化<br>4.1 慢查询定位<br>开启慢查询日志<br>查看 MySQL 数据库是否开启了慢查询日志和慢查询日志文件的存储位置的命令如下：<br>通过如下命令开启慢查询日志：<br>long_query_time：指定慢查询的阀值，单位秒。如果SQL执行时间超过阀值，就属于慢查询<br>记录到日志文件中。<br>log_queries_not_using_indexes：表示会记录没有使用索引的查询SQL。前提是slow_query_log<br>的值为ON，否则不会奏效。<br>查看慢查询日志<br>文本方式查看<br>直接使用文本编辑器打开slow.log日志即可。<br>time：日志记录的时间<br>User@Host：执行的用户及主机<br>Query_time：执行的时间<br>Lock_time：锁表时间<br>Rows_sent：发送给请求方的记录数，结果数量<br>Rows_examined：语句扫描的记录条数<br>SET timestamp：语句执行的时间点<br>select….：执行的具体的SQL语句<br>使用mysqldumpslow查看<br>MySQL 提供了一个慢查询日志分析工具mysqldumpslow，可以通过该工具分析慢查询日志<br>内容。<br>在 MySQL bin目录下执行下面命令可以查看该使用格式。<br>运行如下命令查看慢查询日志信息：<br>explain select id from user order by abs(age); //对应(age)索引 SHOW VARIABLES LIKE ‘slow_query_log%’ SET global slow_query_log = ON; SET global slow_query_log_file = ‘OAK-slow.log’; SET global log_queries_not_using_indexes = ON; SET long_query_time = 10; perl mysqldumpslow.pl –help<br>除了使用mysqldumpslow工具，也可以使用第三方分析工具，比如pt-query-digest、<br>mysqlsla等。<br>4.2 慢查询优化<br>索引和慢查询<br>如何判断是否为慢查询？<br>MySQL判断一条语句是否为慢查询语句，主要依据SQL语句的执行时间，它把当前语句的执<br>行时间跟 long_query_time 参数做比较，如果语句的执行时间 &gt; long_query_time，就会把<br>这条执行语句记录到慢查询日志里面。long_query_time 参数的默认值是 10s，该参数值可<br>以根据自己的业务需要进行调整。<br>如何判断是否应用了索引？<br>SQL语句是否使用了索引，可根据SQL语句执行过程中有没有用到表的索引，可通过 explain<br>命令分析查看，检查结果中的 key 值，是否为NULL。<br>应用了索引是否一定快？<br>下面我们来看看下面语句的 explain 的结果，你觉得这条语句有用上索引吗？比如<br>虽然使用了索引，但是还是从主键索引的最左边的叶节点开始向右扫描整个索引树，进行了<br>全表扫描，此时索引就失去了意义。<br>而像 select * from user where id = 2; 这样的语句，才是我们平时说的使用了索引。它表示<br>的意思是，我们使用了索引的快速搜索功能，并且有效地减少了扫描行数。<br>查询是否使用索引，只是表示一个SQL语句的执行过程；而是否为慢查询，是由它执行的时间决定<br>的，也就是说是否使用了索引和是否是慢查询两者之间没有必然的联系。<br>我们在使用索引时，不要只关注是否起作用，应该关心索引是否减少了查询扫描的数据行数，如果<br>扫描行数减少了，效率才会得到提升。对于一个大表，不止要创建索引，还要考虑索引过滤性，过<br>滤性好，执行速度才会快。<br>提高索引过滤性<br>假如有一个5000万记录的用户表，通过sex=’男’索引过滤后，还需要定位3000万，SQL执行速度也<br>不会很快。其实这个问题涉及到索引的过滤性，比如1万条记录利用索引过滤后定位10条、100<br>条、1000条，那他们过滤性是不同的。索引过滤性与索引字段、表的数据量、表设计结构都有关<br>系。<br>下面我们看一个案例：<br>优化1 perl mysqldumpslow.pl -t 5 -s at C:\ProgramData\MySQL\Data\OAK-slow.log select * from user where id&gt;0; 表：student 字段：id,name,sex,age 造数据：insert into student (name,sex,age) select name,sex,age from student; SQL案例：select * from student where age=18 and name like ‘张%’;（全表扫 描）alter table student add index(name); //追加name索引<br>优化3<br>慢查询原因总结<br>全表扫描：explain分析type属性all<br>全索引扫描：explain分析type属性index<br>索引过滤性不好：靠索引字段选型、数据量和状态、表设计<br>频繁的回表查询开销：尽量少用select *，使用覆盖索引<br>4.3 分页查询优化<br>一般性分页<br>般的分页查询使用简单的 limit 子句就可以实现。limit格式如下：<br>第一个参数指定第一个返回记录行的偏移量，注意从0开始；<br>第二个参数指定返回记录行的最大数目；<br>如果只给定一个参数，它表示返回最大的记录行数目；<br>思考1：如果偏移量固定，返回记录量对执行时间有什么影响？<br>结果：在查询记录时，返回记录量低于100条，查询时间基本没有变化，差距不大。随着查询记录<br>量越大，所花费的时间也会越来越多。<br>思考2：如果查询偏移量变化，返回记录数固定对执行时间有什么影响？</p>
<p>优化2 alter table student add index(age,name); //追加age,name索引 可以看到，index condition pushdown 优化的效果还是很不错的。再进一步优化，我们可以把名 字的第一个字和年龄做一个联合索引，这里可以使用 MySQL 5.7 引入的虚拟列来实现。 //为user表添加first_name虚拟列，以及联合索引(first_name,age) alter table student add first_name varchar(2) generated always as (left(name, 1)), add index(first_name, age); explain select * from student where first_name=’张’ and age=18; SELECT * FROM 表名 LIMIT [offset,] rows select * from user limit 10000,1; select * from user limit 10000,10; select * from user limit 10000,100; select * from user limit 10000,1000; select * from user limit 10000,10000;<br>结果：在查询记录时，如果查询记录量相同，偏移量超过100后就开始随着偏移量增大，查询时间<br>急剧的增加。（这种分页查询机制，每次都会从数据库第一条记录开始扫描，越往后查询越慢，而<br>且查询的数据越多，也会拖慢总查询速度。）<br>分页优化方案<br>第一步：利用覆盖索引优化<br>第二步：利用子查询优化<br>原因：使用了id做主键比较(id&gt;=)，并且子查询使用了覆盖索引进行优化。<br>MySQL事务和锁<br>第1节 ACID 特性<br>在关系型数据库管理系统中，一个逻辑工作单元要成为事务，必须满足这 4 个特性，即所谓的 ACID：<br>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p>
<p>1.1 原子性<br>原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。<br>修改—》Buffer Pool修改—》刷盘。可能会有下面两种情况：<br>事务提交了，如果此时Buffer Pool的脏页没有刷盘，如何保证修改的数据生效？ Redo<br>如果事务没提交，但是Buffer Pool的脏页刷盘了，如何保证不该存在的数据撤销？Undo<br>每一个写事务，都会修改BufferPool，从而产生相应的Redo/Undo日志，在Buffer Pool 中的页被刷到<br>磁盘之前，这些日志信息都会先写入到日志文件中，如果 Buffer Pool 中的脏页没有刷成功，此时数据<br>库挂了，那在数据库再次启动之后，可以通过 Redo 日志将其恢复出来，以保证脏页写的数据不会丢<br>失。如果脏页刷新成功，此时数据库挂了，就需要通过Undo来实现了。<br>1.2 持久性<br>持久性：指的是一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，后续的操作或故障不<br>应该对其有任何影响，不会丢失。<br>如下图所示，一个“提交”动作触发的操作有：binlog落地、发送binlog、存储引擎提交、flush_logs，<br>check_point、事务提交标记等。这些都是数据库保证其数据完整性、持久性的手段。<br>select * from user limit 1,100; select * from user limit 10,100; select * from user limit 100,100; select * from user limit 1000,100; select * from user limit 10000,100; select * from user limit 10000,100; select id from user limit 10000,100; select * from user limit 10000,100; select * from user where id&gt;= (select id from user limit 10000,1) limit 100;<br>MySQL的持久性也与WAL技术相关，redo log在系统Crash重启之类的情况时，可以修复数据，从而保<br>障事务的持久性。通过原子性可以保证逻辑上的持久性，通过存储引擎的数据刷盘可以保证物理上的持<br>久性。<br>1.3 隔离性<br>隔离性：指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并<br>发事务是隔离的。<br>InnoDB 支持的隔离性有 4 种，隔离性从低到高分别为：读未提交、读提交、可重复读、可串行化。锁<br>和多版本控制（MVCC）技术就是用于保障隔离性的（后面课程详解）。<br>1.4 一致性<br>一致性：指的是事务开始之前和事务结束之后，数据库的完整性限制未被破坏。一致性包括两方面的内<br>容，分别是约束一致性和数据一致性。<br>约束一致性：创建表结构时所指定的外键、Check、唯一索引等约束，可惜在 MySQL 中不支持<br>Check 。<br>数据一致性：是一个综合性的规定，因为它是由原子性、持久性、隔离性共同保证的结果，而不是<br>单单依赖于某一种技术。<br>一致性也可以理解为数据的完整性。数据的完整性是通过原子性、隔离性、持久性来保证的，而这3个<br>特性又是通过 Redo/Undo 来保证的。逻辑上的一致性，包括唯一索引、外键约束、check 约束，这属<br>于业务逻辑范畴。<br>ACID 及它们之间的关系如下图所示，4个特性中有3个与 WAL 有关系，都需要通过 Redo、Undo 日志<br>来保证等。<br>WAL的全称为Write-Ahead Logging，先写日志，再写磁盘。<br>第2节 事务控制的演进<br>2.1 并发事务<br>事务并发处理可能会带来一些问题，比如：更新丢失、脏读、不可重复读、幻读等。<br>更新丢失<br>当两个或多个事务更新同一行记录，会产生更新丢失现象。可以分为回滚覆盖和提交覆盖。<br>回滚覆盖：一个事务回滚操作，把其他事务已提交的数据给覆盖了。<br>提交覆盖：一个事务提交操作，把其他事务已提交的数据给覆盖了。<br>脏读<br>一个事务读取到了另一个事务修改但未提交的数据。<br>不可重复读<br>一个事务中多次读取同一行记录不一致，后面读取的跟前面读取的不一致。<br>幻读<br>一个事务中多次按相同条件查询，结果不一致。后续查询的结果和面前查询结果不同，多了或少了<br>几行记录。<br>2.3 排队<br>最简单的方法，就是完全顺序执行所有事务的数据库操作，不需要加锁，简单的说就是全局排队。序列<br>化执行所有的事务单元，数据库某个时刻只处理一个事务操作，特点是强一致性，处理性能低。<br>2.2 排他锁<br>引入锁之后就可以支持并发处理事务，如果事务之间涉及到相同的数据项时，会使用排他锁，或叫互斥<br>锁，先进入的事务独占数据项以后，其他事务被阻塞，等待前面的事务释放锁。<br>注意，在整个事务1结束之前，锁是不会被释放的，所以，事务2必须等到事务1结束之后开始。<br>2.3 读写锁<br>读和写操作：读读、写写、读写、写读。<br>读写锁就是进一步细化锁的颗粒度，区分读操作和写操作，让读和读之间不加锁，这样下面的两个事务<br>就可以同时被执行了。<br>读写锁，可以让读和读并行，而读和写、写和读、写和写这几种之间还是要加排他锁。<br>2.4 MVCC<br>多版本控制MVCC，也就是Copy on Write的思想。MVCC除了支持读和读并行，还支持读和写、写和读<br>的并行，但为了保证一致性，写和写是无法并行的。<br>在事务1开始写操作的时候会copy一个记录的副本，其他事务读操作会读取这个记录副本，因此不会影<br>响其他事务对此记录的读取，实现写和读并行。<br>一、MVCC概念<br>MVCC（Multi Version Concurrency Control）被称为多版本控制，是指在数据库中为了实现高并发的<br>数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。<br>多版本控制很巧妙地将稀缺资源的独占互斥转换为并发，大大提高了数据库的吞吐量及读写性能。<br>如何生成的多版本？每次事务修改操作之前，都会在Undo日志中记录修改之前的数据状态和事务号，<br>该备份记录可以用于其他事务的读取，也可以进行必要时的数据回滚。<br>二、MVCC实现原理<br>MVCC最大的好处是读不加锁，读写不冲突。在读多写少的系统应用中，读写不冲突是非常重要的，极<br>大的提升系统的并发性能，这也是为什么现阶段几乎所有的关系型数据库都支持 MVCC 的原因，不过目<br>前MVCC只在 Read Commited 和 Repeatable Read 两种隔离级别下工作。<br>在 MVCC 并发控制中，读操作可以分为两类: 快照读（Snapshot Read）与当前读 （Current Read）。<br>快照读：读取的是记录的快照版本（有可能是历史版本），不用加锁。（select）<br>当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发<br>修改这条记录。（select… for update 或lock in share mode，insert/delete/update）<br>为了让大家更直观地理解 MVCC 的实现原理，举一个记录更新的案例来讲解 MVCC 中多版本的实现。<br>假设 F1～F6 是表中字段的名字，1～6 是其对应的数据。后面三个隐含字段分别对应该行的隐含ID、事<br>务号和回滚指针，如下图所示。<br>具体的更新过程如下：<br>假如一条数据是刚 INSERT 的，DB_ROW_ID 为 1，其他两个字段为空。当事务 1 更改该行的数据值<br>时，会进行如下操作，如下图所示。<br>用排他锁锁定该行；记录 Redo log；<br>把该行修改前的值复制到 Undo log，即图中下面的行；<br>修改当前行的值，填写事务编号，使回滚指针指向 Undo log 中修改前的行。<br>接下来事务2操作，过程与事务 1 相同，此时 Undo log 中会有两行记录，并且通过回滚指针连在一<br>起，通过当前记录的回滚指针回溯到该行创建时的初始内容，如下图所示。<br>MVCC已经实现了读读、读写、写读并发处理，如果想进一步解决写写冲突，可以采用下面两种方案：<br>乐观锁<br>悲观锁<br>第3节 事务隔离级别<br>3.1 隔离级别类型<br>前面提到的“更新丢失”、”脏读”、“不可重复读”和“幻读”等并发事务问题，其实都是数据库一致性问题，<br>为了解决这些问题，MySQL数据库是通过事务隔离级别来解决的，数据库系统提供了以下 4 种事务隔<br>离级别供用户选择。<br>读未提交<br>Read Uncommitted 读未提交：解决了回滚覆盖类型的更新丢失，但可能发生脏读现象，也就是<br>可能读取到其他会话中未提交事务修改的数据。<br>已提交读<br>Read Committed 读已提交：只能读取到其他会话中已经提交的数据，解决了脏读。但可能发生<br>不可重复读现象，也就是可能在一个事务中两次查询结果不一致。<br>可重复度<br>Repeatable Read 可重复读：解决了不可重复读，它确保同一事务的多个实例在并发读取数据<br>时，会看到同样的数据行。不过理论上会出现幻读，简单的说幻读指的的当用户读取某一范围的数<br>据行时，另一个事务又在该范围插入了新行，当用户在读取该范围的数据时会发现有新的幻影行。<br>可串行化<br>Serializable 串行化：所有的增删改查串行执行。它通过强制事务排序，解决相互冲突，从而解决<br>幻度的问题。这个级别可能导致大量的超时现象的和锁竞争，效率低下。<br>数据库的事务隔离级别越高，并发问题就越小，但是并发处理能力越差（代价）。读未提交隔离级别最<br>低，并发问题多，但是并发处理能力好。以后使用时，可以根据系统特点来选择一个合适的隔离级别，<br>比如对不可重复读和幻读并不敏感，更多关心数据库并发处理能力，此时可以使用Read Commited隔<br>离级别。<br>事务隔离级别，针对Innodb引擎，支持事务的功能。像MyISAM引擎没有关系。<br>事务隔离级别和锁的关系<br>1）事务隔离级别是SQL92定制的标准，相当于事务并发控制的整体解决方案，本质上是对锁和MVCC使<br>用的封装，隐藏了底层细节。<br>2）锁是数据库实现并发控制的基础，事务隔离性是采用锁来实现，对相应操作加不同的锁，就可以防<br>止其他事务同时对数据进行读写操作。<br>3）对用户来讲，首先选择使用隔离级别，当选用的隔离级别不能解决并发问题或需求时，才有必要在<br>开发中手动的设置锁。<br>MySQL默认隔离级别：可重复读<br>Oracle、SQLServer默认隔离级别：读已提交<br>一般使用时，建议采用默认隔离级别，然后存在的一些并发问题，可以通过悲观锁、乐观锁等实现处<br>理。<br>3.2 MySQL隔离级别控制<br>MySQL默认的事务隔离级别是Repeatable Read，查看MySQL当前数据库的事务隔离级别命令如下：<br>或show variables like ‘tx_isolation’;<br>设置事务隔离级别可以如下命令：<br>第4节 锁机制和实战<br>4.1 锁分类<br>在 MySQL中锁有很多不同的分类。<br>从操作的粒度可分为表级锁、行级锁和页级锁。<br>表级锁：每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在<br>MyISAM、InnoDB、BDB 等存储引擎中。<br>行级锁：每次操作锁住一行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应<br>用在InnoDB 存储引擎中。<br>页级锁：每次锁定相邻的一组记录，锁定粒度界于表锁和行锁之间，开销和加锁时间界于表<br>锁和行锁之间，并发度一般。应用在BDB 存储引擎中。<br>从操作的类型可分为读锁和写锁。<br>读锁（S锁）：共享锁，针对同一份数据，多个读操作可以同时进行而不会互相影响。<br>写锁（X锁）：排他锁，当前写操作没有完成前，它会阻断其他写锁和读锁。<br>IS锁、IX锁：意向读锁、意向写锁，属于表级锁，S和X主要针对行级锁。在对表记录添加S或X锁之<br>前，会先对表添加IS或IX锁。<br>S锁：事务A对记录添加了S锁，可以对记录进行读操作，不能做修改，其他事务可以对该记录追加<br>S锁，但是不能追加X锁，需要追加X锁，需要等记录的S锁全部释放。<br>X锁：事务A对记录添加了X锁，可以对记录进行读和修改操作，其他事务不能对记录做读和修改操<br>作。<br>从操作的性能可分为乐观锁和悲观锁。<br>乐观锁：一般的实现方式是对记录数据版本进行比对，在数据更新提交的时候才会进行冲突<br>检测，如果发现冲突了，则提示错误信息。<br>悲观锁：在对一条数据修改的时候，为了避免同时被其他人修改，在修改数据之前先锁定，<br>再修改的控制方式。共享锁和排他锁是悲观锁的不同实现，但都属于悲观锁范畴。<br>4.2 行锁原理<br>在InnoDB引擎中，我们可以使用行锁和表锁，其中行锁又分为共享锁和排他锁。InnoDB行锁是通过对<br>索引数据页上的记录加锁实现的，主要实现算法有 3 种：Record Lock、Gap Lock 和 Next-key Lock。 select @@tx_isolation; set tx_isolation=’READ-UNCOMMITTED’; set tx_isolation=’READ-COMMITTED’; set tx_isolation=’REPEATABLE-READ’; set tx_isolation=’SERIALIZABLE’;<br>RecordLock锁：锁定单个行记录的锁。（记录锁，RC、RR隔离级别都支持）<br>GapLock锁：间隙锁，锁定索引记录间隙，确保索引记录的间隙不变。（范围锁，RR隔离级别支<br>持）<br>Next-key Lock 锁：记录锁和间隙锁组合，同时锁住数据，并且锁住数据前后范围。（记录锁+范<br>围锁，RR隔离级别支持）<br>在RR隔离级别，InnoDB对于记录加锁行为都是先采用Next-Key Lock，但是当SQL操作含有唯一索引<br>时，Innodb会对Next-Key Lock进行优化，降级为RecordLock，仅锁住索引本身而非范围。<br>1）select … from 语句：InnoDB引擎采用MVCC机制实现非阻塞读，所以对于普通的select语句，<br>InnoDB不加锁<br>2）select … from lock in share mode语句：追加了共享锁，InnoDB会使用Next-Key Lock锁进行处<br>理，如果扫描发现唯一索引，可以降级为RecordLock锁。<br>3）select … from for update语句：追加了排他锁，InnoDB会使用Next-Key Lock锁进行处理，如果扫<br>描发现唯一索引，可以降级为RecordLock锁。<br>4）update … where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以<br>降级为RecordLock锁。<br>5）delete … where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降<br>级为RecordLock锁。<br>6）insert语句：InnoDB会在将要插入的那一行设置一个排他的RecordLock锁。<br>下面以“update t1 set name=‘XX’ where id=10”操作为例，举例子分析下 InnoDB 对不同索引的加锁行<br>为，以RR隔离级别为例。<br>主键加锁<br>加锁行为：仅在id=10的主键索引记录上加X锁。<br>唯一键加锁<br>加锁行为：现在唯一索引id上加X锁，然后在id=10的主键索引记录上加X锁。<br>非唯一键加锁<br>加锁行为：对满足id=10条件的记录和主键分别加X锁，然后在(6,c)-(10,b)、(10,b)-(10,d)、(10,d)-<br>(11,f)范围分别加Gap Lock。<br>无索引加锁<br>加锁行为：表里所有行和间隙都会加X锁。（当没有索引时，会导致全表锁定，因为InnoDB引擎<br>锁机制是基于索引实现的记录锁定）。<br>4.3 悲观锁<br>悲观锁（Pessimistic Locking），是指在数据处理过程，将数据处于锁定状态，一般使用数据库的锁机<br>制实现。从广义上来讲，前面提到的行锁、表锁、读锁、写锁、共享锁、排他锁等，这些都属于悲观锁<br>范畴。<br>表级锁<br>表级锁每次操作都锁住整张表，并发度最低。常用命令如下：<br>手动增加表锁<br>查看表上加过的锁<br>删除表锁<br>表级读锁：当前表追加read锁，当前连接和其他的连接都可以读操作；但是当前连接增删改操作<br>会报错，其他连接增删改会被阻塞。<br>lock table 表名称 read|write,表名称2 read|write; show open tables; unlock tables;<br>表级写锁：当前表追加write锁，当前连接可以对表做增删改查操作，其他连接对该表所有操作都<br>被阻塞（包括查询）。<br>总结：表级读锁会阻塞写操作，但是不会阻塞读操作。而写锁则会把读和写操作都阻塞。<br>共享锁（行级锁-读锁）<br>共享锁又称为读锁，简称S锁。共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数<br>据，但是只能读不能修改。使用共享锁的方法是在select … lock in share mode，只适用查询语<br>句。<br>总结：事务使用了共享锁（读锁），只能读取，不能修改，修改操作被阻塞。<br>排他锁（行级锁-写锁）<br>排他锁又称为写锁，简称X锁。排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排<br>他锁，其他事务就不能对该行记录做其他操作，也不能获取该行的锁。<br>使用排他锁的方法是在SQL末尾加上for update，innodb引擎默认会在update，delete语句加上<br>for update。行级锁的实现其实是依靠其对应的索引，所以如果操作没用到索引的查询，那么会锁<br>住全表记录。<br>总结：事务使用了排他锁（写锁），当前事务可以读取和修改，其他事务不能修改，也不能获取记录<br>锁（select… for update）。如果查询没有使用到索引，将会锁住整个表记录。<br>4.4 乐观锁<br>乐观锁是相对于悲观锁而言的，它不是数据库提供的功能，需要开发者自己去实现。在数据库操作时，<br>想法很乐观，认为这次的操作不会导致冲突，因此在数据库操作时并不做任何的特殊处理，即不加锁，<br>而是在进行事务提交时再去判断是否有冲突了。<br>乐观锁实现的关键点：冲突的检测。<br>悲观锁和乐观锁都可以解决事务写写并发，在应用中可以根据并发处理能力选择区分，比如对并发率要<br>求高的选择乐观锁；对于并发率要求低的可以选择悲观锁。<br>乐观锁实现原理<br>使用版本字段（version）<br>先给数据表增加一个版本(version) 字段，每操作一次，将那条记录的版本号加 1。version<br>是用来查看被读的记录有无变化，作用是防止记录在业务处理期间被其他事务修改。<br>使用时间戳（Timestamp）<br>与使用version版本字段相似，同样需要给在数据表增加一个字段，字段类型使用timestamp<br>时间戳。也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳<br>进行对比，如果一致则提交更新，否则就是版本冲突，取消操作。<br>乐观锁案例<br>下面我们使用下单过程作为案例，描述下乐观锁的使用。<br>第一步：查询商品信息<br>第二部：根据商品信息生成订单<br>第三部：修改商品库存<br>除了自己手动实现乐观锁之外，许多数据库访问框架也封装了乐观锁的实现，比如<br>hibernate框架。MyBatis框架大家可以使用OptimisticLocker插件来扩展。<br>4.5 死锁与解决方案<br>下面介绍几种常见的死锁现象和解决方案：<br>一、表锁死锁<br>产生原因：<br>select (quantity,version) from products where id=1; insert into orders … insert into items … update products set quantity=quantity-1,version=version+1 where id=1 and version=#{version};<br>用户A访问表A（锁住了表A），然后又访问表B；另一个用户B访问表B（锁住了表B），然后企图<br>访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要<br>等用户A释放表A才能继续，这就死锁就产生了。<br>用户A–》A表（表锁）–》B表（表锁）<br>用户B–》B表（表锁）–》A表（表锁）<br>解决方案：<br>这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分<br>析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个<br>资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任<br>何时刻都应该按照相同的顺序来锁定资源。<br>二、行级锁死锁<br>产生原因1：<br>如果在事务中执行了一条没有索引条件的查询，引发全表扫描，把行级锁上升为全表记录锁定（等<br>价于表级锁），多个这样的事务执行后，就很容易产生死锁和阻塞，最终应用系统会越来越慢，发<br>生阻塞或死锁。<br>解决方案1：<br>SQL语句中不要使用太复杂的关联多表的查询；使用explain“执行计划”对SQL语句进行分析，对于<br>有全表扫描和全表锁定的SQL语句，建立相应的索引进行优化。<br>产生原因2：<br>两个事务分别想拿到对方持有的锁，互相等待，于是产生死锁。<br>解决方案2：<br>在同一个事务中，尽可能做到一次锁定所需要的所有资源<br>按照id对资源排序，然后按顺序进行处理<br>三、共享锁转换为排他锁<br>产生原因：<br>事务A 查询一条纪录，然后更新该条纪录；此时事务B 也更新该条纪录，这时事务B 的排他锁由于<br>事务A 有共享锁，必须等A 释放共享锁后才可以获取，只能排队等待。事务A 再执行更新操作时，<br>此处发生死锁，因为事务A 需要排他锁来做更新操作。但是，无法授予该锁请求，因为事务B 已经<br>有一个排他锁请求，并且正在等待事务A 释放其共享锁。<br>事务A: select * from dept where deptno=1 lock in share mode; //共享锁,1<br>update dept set dname=’java’ where deptno=1;//排他锁,3<br>事务B: update dept set dname=’Java’ where deptno=1;//由于1有共享锁，没法获取排他锁，需<br>等待，2<br>解决方案：<br>对于按钮等控件，点击立刻失效，不让用户重复点击，避免引发同时对同一条记录多次操<br>作；<br>使用乐观锁进行控制。乐观锁机制避免了长事务中的数据库加锁开销，大大提升了大并发量<br>下的系统性能。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用<br>户更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中；<br>四、死锁排查<br>MySQL提供了几个与锁有关的参数和命令，可以辅助我们优化锁操作，减少死锁发生。<br>查看死锁日志<br>通过show engine innodb status\G命令查看近期死锁日志信息。<br>使用方法：1、查看近期死锁日志信息；2、使用explain查看下SQL执行计划<br>查看锁状态变量<br>通过show status like’innodb_row_lock%‘命令检查状态变量，分析系统中的行锁的争夺<br>情况<br>Innodb_row_lock_current_waits：当前正在等待锁的数量<br>Innodb_row_lock_time：从系统启动到现在锁定总时间长度<br>Innodb_row_lock_time_avg： 每次等待锁的平均时间<br>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次锁的时间<br>Innodb_row_lock_waits：系统启动后到现在总共等待的次数<br>如果等待次数高，而且每次等待时间长，需要分析系统中为什么会有如此多的等待，然后着<br>手定制优化</p>
<p>除了自己手动实现乐观锁之外，许多数据库访问框架也封装了乐观锁的实现，比如<br>hibernate框架。MyBatis框架大家可以使用OptimisticLocker插件来扩展。</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>主站博客迁移之字节跳动面经个人搜索答案</title>
    <url>/posts/20220725clhk6pteg001vcsuj0loyh9m7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>问题来源<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E9%A2%98.jpg" alt="流程"></p>
<h1 id="1-线程池参数的含义？"><a href="#1-线程池参数的含义？" class="headerlink" title="1.线程池参数的含义？"></a>1.线程池参数的含义？</h1><p>int corePoolSize：常驻线程数<br>int maximumPoolSize：线程池同时执行的最大线程数，&gt;=1<br>long keepAliveTime:空闲线程的存活时间<br>TimeUnit unit：keepAliveTime的单位<br>BlockingQueueworkQueue：被提交等待被执行的任务<br>ThreadFactory threadFactory：工作线程的线程工厂<br>RejectedExecutionHandler handler：线程池拒绝策略<br>线程池拒绝策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize时，</span><br><span class="line">如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</span><br><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。 </span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务 </span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务</span><br></pre></td></tr></table></figure>
<h1 id="2-innodb的索引实现"><a href="#2-innodb的索引实现" class="headerlink" title="2.innodb的索引实现"></a>2.innodb的索引实现</h1><p>1.表数据文件本身是按照B+tree组织的一个索引文件结构<br>2.聚集索引叶子结点包含了完整的数据记,这个索引的key是数据表的主键</p>
<h1 id="3-为什么是B-tree？"><a href="#3-为什么是B-tree？" class="headerlink" title="3.为什么是B+tree？"></a>3.为什么是B+tree？</h1><p>其实选择B+tree是因为树的高度小,Hash有个致命的缺点就是浪费内存,如果采用二叉树，那么当数据量越大的时候，这棵树就越深，树越深IO的次数就会越多（提高系统效率的两种方式：1、减少IO次数 2、减少IO量）<br>根据上述分析得出我们需要得出结论：我们需要找一个有多个分支且有序的多叉有序树<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/B%2Btree.jpg" alt="流程"></p>
<h1 id="4-操作系统虚拟内存换页的过程是什么？"><a href="#4-操作系统虚拟内存换页的过程是什么？" class="headerlink" title="4.操作系统虚拟内存换页的过程是什么？"></a>4.操作系统虚拟内存换页的过程是什么？</h1><p>1.如果内存中有空闲的物理页面，则分配一物理页帧r，然后转第4步，否则转第2步；<br>2.选择某种页面置换算法，选择一个将被替换的物理页帧r，它所对应的逻辑页为q，如果该页在内存期间被修改过，则需把它写回到外存；<br>3.将q所对应的页表项进行修改，把驻留位置0；<br>4.将需要访问的页p装入到物理页面r中；<br>5.修改p所对应的页表项的内容，把驻留位置1，把物理页帧号置为x；<br>6.重新运行被中断的指令。</p>
<h1 id="5-线程池大小与-CPU-处理器的利用率之比可以用下面公式估算"><a href="#5-线程池大小与-CPU-处理器的利用率之比可以用下面公式估算" class="headerlink" title="5.线程池大小与 CPU 处理器的利用率之比可以用下面公式估算"></a>5.线程池大小与 CPU 处理器的利用率之比可以用下面公式估算</h1><p>CPU密集型多为cpu运算频繁的：设置CPU核数+1<br>IO密集型：设置cpu核数*10</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Support class for thread pool size</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Nadeem Mohammad</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolUtil</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">ThreadPoolUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Each tasks blocks 90% of the time, and works only 10% of its</span></span><br><span class="line"><span class="comment">	 *	lifetime. That is, I/O intensive pool</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> io intesive Thread pool size</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ioIntesivePoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">double</span> blockingCoefficient = <span class="number">0.9</span>;</span><br><span class="line">		<span class="keyword">return</span> poolSize(blockingCoefficient);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * Number of threads = Number of Available Cores / (1 - Blocking</span></span><br><span class="line"><span class="comment">	 * Coefficient) where the blocking coefficient is between 0 and 1.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * A computation-intensive task has a blocking coefficient of 0, whereas an</span></span><br><span class="line"><span class="comment">	 * IO-intensive task has a value close to 1,</span></span><br><span class="line"><span class="comment">	 * so we don&#x27;t have to worry about the value reaching 1.</span></span><br><span class="line"><span class="comment">	 *  <span class="doctag">@param</span> blockingCoefficient the coefficient</span></span><br><span class="line"><span class="comment">	 *  <span class="doctag">@return</span> Thread pool size</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">poolSize</span><span class="params">(<span class="keyword">double</span> blockingCoefficient)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//cpu核数</span></span><br><span class="line">		<span class="keyword">int</span> numberOfCores = Runtime.getRuntime().availableProcessors();</span><br><span class="line">  </span><br><span class="line">		<span class="keyword">int</span> poolSize = (<span class="keyword">int</span>) (numberOfCores / (<span class="number">1</span> - blockingCoefficient));</span><br><span class="line">		<span class="keyword">return</span> poolSize;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-Redis的使用—分布式锁的实现"><a href="#6-Redis的使用—分布式锁的实现" class="headerlink" title="6.Redis的使用—分布式锁的实现"></a>6.Redis的使用—分布式锁的实现</h1><p>1.数据库乐观锁；<br>2.基于Redis的分布式锁；<br>3.基于ZooKeeper的分布式锁<br>4.redisson的红锁<br>一 基于数据库<br>a.数据库建一张表，字段方法名并且作为唯一性，当一个方法执行时插入，则相当于获得锁，其他线程将无法访问，方法执行完则释放锁。</p>
<p>但是上面这种存在问题：</p>
<p>1、数据库单点，出现故障则将导致系统不可用。</p>
<p>2、没有失效时间，一旦操作方法异常，导致一直没有解锁，也将导致其他不可用用。</p>
<p>b.使用select * from user u where username = ‘’ for update 来对记录加上排他锁。操作完成后使用commit命令释放锁。<br>二基于缓存 redis</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">&quot;NX&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">&quot;PX&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三基于zk<br>大致思路：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p>
<p>ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同步到所有的Follower机器上，所以性能上不如基于缓存实现。<br>综合比较:1.3性能低，推荐redis<br>如果对数据有强一致性要求,不能放缓存</p>
<h1 id="7-TCP-三次握手和四次挥手"><a href="#7-TCP-三次握手和四次挥手" class="headerlink" title="7.TCP 三次握手和四次挥手"></a>7.TCP 三次握手和四次挥手</h1><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="流程"></p>
<p>三次握手只是在建立连接。三次握手之后，才有资源的开辟。可以开始传输数据了。<br>C -&gt; S (syn, seq=j) C 说，我想连接<br>S -&gt; C (syn+ack, ack=j+1, syn=k) 发完之后，C 知道了 S 能收到自己的消息<br>C -&gt; S (ack, ack=k+1) 发完之后，S 知道了 C 能收到自己的消息（确认是双向的），这就是为什么需要第三次握手<br>三次握手之后，双方开辟资源，建立了 socket，实际应用时，第三次握手包和发送的数据包是粘连在一起的。</p>
<p>如果类比三次握手，在第二次挥手的时候同时发 FIN + ACK 明显不合理，因为被动方可能没有数据发送完，你这么关太草率了，所以需要四次。<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="流程"><br>①客户端发送报文===&gt;<br>②服务端收到报文，结束监听，返回一段报文<br>③客户端确认收到TCP报文，并返回最后一段TCP报文<br>即SYN建立连接报文与ACK确认接收报文是在同一次”握手”当中传输的，所以”三次握手”不多也不少，正好让双方明确彼此信息互通<br>所谓的四次挥手即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放<br>都是由客户端发起</p>
<h1 id="8-为什么四次分手之后，还会等两个传输时间，才会释放资源"><a href="#8-为什么四次分手之后，还会等两个传输时间，才会释放资源" class="headerlink" title="8.为什么四次分手之后，还会等两个传输时间，才会释放资源"></a>8.为什么四次分手之后，还会等两个传输时间，才会释放资源</h1><p>因为如果最后 C 端返回的 ACK 号丢失了，这时 S 端没有收到 ACK，会重发一遍 FIN，如果此时客户端的套接字已经被删除了，会发生什么呢？套接字被删除，端口被释放，这时别的应用可能创建新的套接字，恰好分配了同一个端口号，而服务器重发的 FIN 正好到达，这个 FIN 就会错误的跑到新的套接字里面，新的套接字就开始执行断开操作了。为了避免这样的误操作，C 端会等几分钟再删除套接字。</p>
<h1 id="9-volatile关键字的作用"><a href="#9-volatile关键字的作用" class="headerlink" title="9.volatile关键字的作用"></a>9.volatile关键字的作用</h1><p>被volatile修饰的变量在编译成字节码文件时会多个lock指令，该指令在执行过程中会生成相应的内存屏障，以此来解决可见性跟重排序的问题。</p>
<p>1.解决的是多核CPU带来的缓存与CPU之间数据的可见性<br>JMM:java内存模型<br>1.线程解锁前，必须把共享变量刷新回主内存<br>2.线程加锁前，必须读取主内存的最新值到自己的工作内存<br>3.加锁与解锁必须是同一把锁<br>volatile实现内存指令重排，保证可见性和禁止指令重排，<br>可保证一段内存中一个变量的原子性，原生类型都是原子性的。所以java中 volatile long，volatile double都是线程安全的</p>
<h1 id="10-乐观锁，悲观"><a href="#10-乐观锁，悲观" class="headerlink" title="10.乐观锁，悲观"></a>10.乐观锁，悲观</h1><p>乐观锁(Optimistic Lock):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</span><br><span class="line">两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，</span><br><span class="line">这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适</span><br></pre></td></tr></table></figure>
<p>悲观锁(Pessimistic Lock)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</span><br></pre></td></tr></table></figure>
<h1 id="11-HashMap结构，是否线程安全-ConcurrentHashMap如何保证线程安全"><a href="#11-HashMap结构，是否线程安全-ConcurrentHashMap如何保证线程安全" class="headerlink" title="11.HashMap结构，是否线程安全?ConcurrentHashMap如何保证线程安全"></a>11.HashMap结构，是否线程安全?ConcurrentHashMap如何保证线程安全</h1><p>HashMap在java1.7之前底层数据结构是数组+链表，1.8之后是数组+链表+红黑树，<br>在1.7以前的put方法采用的是头插法，当hash碰撞次数到达8，且桶内元素到达64个的时候形成链表，但是在极端情况下会造成链表过长，效率变低，并且在rehash的时候，头插法会造成回环链首尾相连，形成死锁，在java1.8以后采用红黑树，除了添加效率都高，是线程不安全的，不安全示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMapThread thread0 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        HashMapThread thread1 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        HashMapThread thread2 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        HashMapThread thread3 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        HashMapThread thread4 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMapThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ai.get() &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">            map.put(ai.get(), ai.get());</span><br><span class="line">            ai.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.通常代替HashMap的安全由HashTable代替，但是多线程下他的put.get方法都是synchronized，效率太低，<br>2.Collections.synchronizedMap(),底层仍是synchronized<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/java9.jpg" alt="流程"><br>3.ConcurrentHashMap 与 ConcurrentSkipListMap<br>ConcurrentHashMap 加锁<br>ConcurrentSkipListMap 不需要加锁，浪费空间，<br>4.ConcurrentHashMap<br>ConcurrentHashMap如何保证线程安全，在1.7以前由划分segment分段锁机制，共计16个并发级别，隔离级别太大，有很多空间就浪费了，太小就段内的元素过多<br>1.8以后是cas算法C语言写得，无锁算法，put添加的时候，链表+红黑树<br>put方法（无锁添加）</p>
<h1 id="12-之前用过哪些设计模式"><a href="#12-之前用过哪些设计模式" class="headerlink" title="12.之前用过哪些设计模式"></a>12.之前用过哪些设计模式</h1><p>目前项目再用的是责任链设计模型，像动态代理，装饰者，工厂模式，在Spring的源码中都有体现，责任链模式旨在降低处理请求流程的耦合<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&mid=2247484453&idx=1&sn=3f4160943cab8fa5f22048b66f7bc588&chksm=ceb09b58f9c7124e65565183cac89fe041f8cec1e06f4e1711d614957ea2ce4bb02a16b8ff3d&token=827240829&lang=zh_CN#rd" title="责任链模式">责任链模式</a></p>
<h1 id="13-滑动窗口"><a href="#13-滑动窗口" class="headerlink" title="13.滑动窗口"></a>13.滑动窗口</h1><p>题目描述<br>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和≥ s的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>
<p>示例:</p>
<p>输入: s = 7, nums = [2,3,1,2,4,3]<br>输出: 2<br>解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析  滑动窗口 Sliding  Window</span></span><br><span class="line">          <span class="comment">/*1+2+3=6</span></span><br><span class="line"><span class="comment">            6-1+6=11    = 2+3+6  6-移除的数+加入的数</span></span><br><span class="line"><span class="comment">            11-2+4=13  =3+6+4</span></span><br><span class="line"><span class="comment">            13-3+5=15  =6+4+5</span></span><br><span class="line"><span class="comment">            数组定长</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, result = nums.length + <span class="number">1</span>, total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; nums.length) &#123;</span><br><span class="line">            total += nums[j];</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">while</span> (total &gt;= s) &#123;</span><br><span class="line">                result = Math.min(result, j - i);</span><br><span class="line">                total -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == nums.length + <span class="number">1</span> ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="14-Btree和-B-tree的优缺点"><a href="#14-Btree和-B-tree的优缺点" class="headerlink" title="14.Btree和 B+tree的优缺点"></a>14.Btree和 B+tree的优缺点</h1><p>B+树中的B代表平衡（balance），而不是二叉（binary）<br>二叉查找树<br>二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。<br>平衡二叉树<br>如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。</p>
<p>B+Tree<br>B+Tree相对于B-Tree有几点不同：<br>非叶子节点只存储键值信息。<br>所有叶子节点之间都有一个链指针。<br>数据记录都存放在叶子节点中。<br>查询速度快，但是占用空间<br>索引结构：B-Tree B+Tree B：balance<br>B-Tree：平衡二叉树<br>特点：<br>1.具有数据节点<br>2.指向下层指针<br>3.指向数据指针<br>缺页查询,产生IO<br>B+Tree：<br>特点:<br>1.具有数据节点<br>2.指向下层指针<br>命中数据3层查找后查询数据指针<br>加载更快，产生更少IO<br>效率：BTree更高，但从IO角度，Mysql选择B+Tree</p>
<h1 id="15-说一下HashMap的实现，扩容机制，扩容时如何保证操作"><a href="#15-说一下HashMap的实现，扩容机制，扩容时如何保证操作" class="headerlink" title="15.说一下HashMap的实现，扩容机制，扩容时如何保证操作"></a>15.说一下HashMap的实现，扩容机制，扩容时如何保证操作</h1><p>put 方法比较复杂，实现步骤大致如下：<br>1、先通过 hash 值计算出 key 映射到哪个桶。<br>2、如果桶上没有碰撞冲突，则直接插入。<br>3、如果出现碰撞冲突了，则需要处理冲突：<br>（1）如果该桶使用红黑树处理冲突，则调用红黑树的方法插入。<br>（2）否则采用传统的链式方法插入。如果链的长度到达临界值，则把链转变为红<br>黑树。<br>4、如果桶中存在重复的键，则为该键替换新值。<br>5、如果 size 大于阈值(8)，则进行扩容</p>
<p>根据hash算法得到hash码值，也就是数组的索引值，在判断是否有对象，如果没有则放入<br>如果有则先通过equals比较两个对象的内容，如果内容一样，则覆盖value，<br>如果内容不一样，形成链表，1.7后加的放前面，这种情况叫做hash碰撞，这种情况我们是尽可能避免的，如果这里的元素过多的话，插入效率过低，为了避免的话，重写hashcode和equals方法保持一致，这种情况避免不了<br>加载因子，当到达元素个数的0.75，进行扩容，扩容则每个元素重新运算位置，，如果到达100%其他位置可能会不存入，如果太小，则频繁扩容，可浪费空间。这样碰撞的概率会降低，但是极端情况下还是需要查询每个元素比较，效率极低。<br>1.8以后，数组+链表+红黑树<br>当碰撞的个数大于8时，并且总容量大于64时，将链表转为红黑树，除了添加以外其他的效率都高，jdk1.8加到链表末尾，扩容以后不需要运行hash算法计算hashcode值。原来hash表的总长度，加上hash表的现在的位置，就放到第8个位置即可。<br>3.redis扩容机制(渐进式单线程扩容)<br>Redis是一个键值对（key-value pair）数据库服务器，Redis服务器结构是redis.h/redisServer结构表示，Redis服务器中的所有数据库保存在db数组中，数据库的结构是redis.h/redisDb，其中，redisDb结构的dict字典保存了数据库中的所有键值对，所以，说起Redis的扩容机制，指的就是字典中哈希表的rehash（重新散列）操作<br>在实际开发过程中，这个rehash 操作并不是一次性、集中式完成的，而是分多次、渐进式地完成的。<br>　　　　渐进式rehash 的详细步骤：<br>　　　　　　1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表<br>　　　　　　2、在几点钟维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始<br>　　　　　　3、在rehash 进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一<br>　　　　　　4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束<br>　　　　采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量。</p>
<h1 id="16-SpringAop，ioc的原理，如何解决循环依赖"><a href="#16-SpringAop，ioc的原理，如何解决循环依赖" class="headerlink" title="16.SpringAop，ioc的原理，如何解决循环依赖"></a>16.SpringAop，ioc的原理，如何解决循环依赖</h1><p>SpringIoc可以对我们应用程序中的java对象做一个集中化的管理，从而使我们从繁琐的new Object()；中解脱出来<br>Spring中AOP的有两种实现方式：<br>1、JDK动态代理<br>2、Cglib动态代理<br>在没有修改原有类的代码的情况下，对原有类的功能进行了增强<br>静态代理模式：静态代理说白了就是在程序运行前就已经存在代理类的字节码文件，代理类和原始类的关系在运行前就已经确定<br>动态代理模式:动态代理类的源码是在程序运行期间通过JVM反射等机制动态生成，代理类和委托类的关系是运行时才确定的<br>使用jdk生成的动态代理的前提是目标类必须有实现的接口。但这里又引入一个问题,如果某个类没有实现接口,就不能使用JDK动态代理,所以Cglib代理就是解决这个问题的<br>Cglib使用的前提是目标类不能为final修饰。因为final修饰的类不能被继承。<br>核心原理是使用动态代理模式在方法执行前后或出现异常时加入相关逻辑。<br>通过定义和前面代码我们可以发现3点：<br>1.AOP是基于动态代理模式。<br>2.AOP是方法级别的（要测试的方法不能为static修饰，因为接口中不能存在静态方法，编译就会报错）。<br>3.AOP可以分离业务代码和关注点代码（重复代码），在执行业务代码时，动态的注入关注点代码。切面就是关注点代码形成的类。</p>
<p>循环依赖解决<br>1.在字段上使用@Autowired注解，让Spring决定在合适的时机注入<br>2.用基于setter方法的依赖注入</p>
<h1 id="17-两个线程对变量i进行加1操作，结果如何？为什么？如何解决？"><a href="#17-两个线程对变量i进行加1操作，结果如何？为什么？如何解决？" class="headerlink" title="17.两个线程对变量i进行加1操作，结果如何？为什么？如何解决？"></a>17.两个线程对变量i进行加1操作，结果如何？为什么？如何解决？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i=i+<span class="number">1</span>;</span><br><span class="line">    action();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;==&gt;&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    Thread t2= <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==&gt;t1:<span class="number">1</span></span><br><span class="line">==&gt;t2:<span class="number">2</span></span><br><span class="line"></span><br><span class="line">==&gt;t1:<span class="number">2</span></span><br><span class="line">==&gt;t2:<span class="number">1</span></span><br><span class="line"></span><br><span class="line">==&gt;t1:<span class="number">2</span></span><br><span class="line">==&gt;t2:<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>线程安全问题，对共享变量进行修改<br>改进方法1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SysUserServiceImpl.class)&#123;</span><br><span class="line">        i=i+<span class="number">1</span>;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;==&gt;&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    Thread t2= <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized在多jvm情况下不生效,且效率低下<br>方法2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = num.getAndIncrement();</span><br><span class="line">    action(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;由&quot;</span>+i+<span class="string">&quot;==&gt;&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    Thread t2= <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==&gt;&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            i=i+<span class="number">1</span>;</span><br><span class="line">            action();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(SysUserServiceImpl::inc,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2= <span class="keyword">new</span> Thread(SysUserServiceImpl::inc,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="18-CAS概念，原子类实现"><a href="#18-CAS概念，原子类实现" class="headerlink" title="18.CAS概念，原子类实现"></a>18.CAS概念，原子类实现</h1><p>CAS锁是比较偏重的操作？<br>CAS在操作锁时，执行比较并交换操作，相对synchronized瘦锁是比较重的锁，偏向锁在这里避免了CAS操作。UseBiaseLocking对synchronize有用<br>比较并交换，判断取出内存中某时刻的数据并在当下时刻进行交换，缺点：循环时间长，只能保证一个共享变量的原子操作，引来ABA问题?<br>CAS核心是由native修饰的Unsafe类，其中valueOff为内存偏移量地址，变量由volatile修饰。<br>private static final Unsafe unsafe<br>private volatile int value;<br>unsafe类是CAS的核心类，是由C语言native方法来访问的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中getAndAddInt方法，this表示当前对象valueoffset表示内存中的偏移地址，delta是当前value增加的变量<br>CAS即比较当前值与预设值，交换并增加，如果与预想一致就交换，否则再次自旋，所以带来循环开销问题，进而引来ABA问题。<br>原子类的话经典类：AtomicInteger，其共享变量是由volatile修饰的，<br>getAndIncrement是unsafe类操作，底层也是cas</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized</p>
<h1 id="19-synchronized和Lock有什么区别？"><a href="#19-synchronized和Lock有什么区别？" class="headerlink" title="19.synchronized和Lock有什么区别？"></a>19.synchronized和Lock有什么区别？</h1><p>①:synchronized是JVM层面实现的，java提供的关键字，Lock是API层面的锁。<br>②:synchronized不需要手动释放锁，底层会自动释放，<br>Lock则需要手动释放锁，否则有可能导致死锁<br>③:synchronized等待不可中断，除非抛出异常或者执行完成<br>Lock可以中断，通过interrupt()可中断<br>④:synchronized是非公平锁<br>Lock是默认公平锁，当传入false时是非公平锁<br>⑤:synchronized不可绑定多个条件<br>Lock可实现分组唤醒需要唤醒的锁<br>monitorenter<br>monitorexit<br>synchronized通过监控对象来完成，本质是锁一个对象<br>同步方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;  </span><br><span class="line">  public synchronized void method() &#123;</span><br><span class="line">          System.out.println(&quot;synchronized....&quot;);  </span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修饰方法与修饰代码块产生字节码不同<br>如何实现lock，AQS:AbstractQueuedSynchronizer,AQS是ReentrantLock的核心实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock的子类Sync类的final static子类FairSync和NonFairSync用于支持公平锁和非公平锁。<br>AQS的tryAcquire()和FairSync的tryAcquire()判定是否为公平锁，其实现也是偏向锁UseBiaseLock的实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br><span class="line">     * recursive call or no waiters or is first.</span><br><span class="line">     */</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法首先会判断当前线程的状态，如果c==0 说明没有线程正在竞争锁。（反过来，如果c!=0则说明已经有其他线程已经拥有了锁）。如果c==0，则通过CAS将状态设置为acquires(独占锁的acquires为1)，后续每次重入该锁都会+1，每次unlock都会-1，当数据为0时则释放锁资源。其中精妙的部分在于：并发访问时，有可能多个线程同时检测到c为0，此时执行compareAndSetState(0, acquires))设置，可以预见，如果当前线程CAS成功，则其他线程都不会再成功，也就默认当前线程获取了锁，直接作为running线程，很显然这个线程并没有进入等待队列。如果c!=0，首先判断获取锁的线程是不是当前线程，如果是当前线程，则表明为锁重入，继续+1，修改state的状态，此时并没有锁竞争，也非CAS，因此这段代码也非常漂亮的实现了偏向锁。</p>
<h1 id="20-AQS有什么特点"><a href="#20-AQS有什么特点" class="headerlink" title="20.AQS有什么特点"></a>20.AQS有什么特点</h1><p>AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.util.concurrent）下locks包内的一个类。它实现了一个FIFO(FirstIn、FisrtOut先进先出)的队列。底层实现的数据结构是一个双向链表<br>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中</p>
<p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p>
<p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p>
<p>//返回同步状态的当前值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final int getState() &#123;  </span><br><span class="line">        return state;</span><br><span class="line">&#125;</span><br><span class="line"> // 设置同步状态的值</span><br><span class="line">protected final void setState(int newState) &#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span><br><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、AQS设计思想<br>使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。</p>
<p>利用int类型标识状态。在AQS类中有一个叫做state的成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The synchronization state.</span><br><span class="line"> */</span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure>
<p>基于AQS有一个同步组件，叫做ReentrantLock。在这个组件里，stste表示获取锁的线程数，假如state=0，表示还没有线程获取锁，1表示有线程获取了锁。大于1表示重入锁的数量。</p>
<p>继承：子类通过继承并通过实现它的方法管理其状态（acquire和release方法操纵状态）。</p>
<p>可以同时实现排它锁和共享锁模式（独占、共享），站在一个使用者的角度，AQS的功能主要分为两类：独占和共享。它的所有子类中，要么实现并使用了它的独占功能的api，要么使用了共享锁的功能，而不会同时使用两套api，即便是最有名的子类ReentrantReadWriteLock也是通过两个内部类读锁和写锁分别实现了两套api来实现的。</p>
<p>3、AQS的大致实现思路<br>AQS内部维护了一个CLH队列来管理锁。线程会首先尝试获取锁，如果失败就将当前线程及等待状态等信息包装成一个node节点加入到同步队列sync queue里。 接着会不断的循环尝试获取锁，条件是当前节点为head的直接后继才会尝试。如果失败就会阻塞自己直到自己被唤醒。而当持有锁的线程释放锁的时候，会唤醒队列中的后继线程。</p>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p>
<h1 id="Spring-主要思想-IOC-AOP"><a href="#Spring-主要思想-IOC-AOP" class="headerlink" title="Spring 主要思想 IOC,AOP"></a>Spring 主要思想 IOC,AOP</h1></div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>面试,字节跳动</tag>
      </tags>
  </entry>
  <entry>
    <title>主站博客迁移之Nginx安装与原理</title>
    <url>/posts/20220725clhk6ptea001jcsujfjna73hi.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>官网<a href="http://nginx.org/">http://nginx.org/</a><br>需要的素材</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pcre-<span class="number">8.37</span>.tar.gz</span><br><span class="line">openssl-<span class="number">1.0</span>.1t.tar.gz</span><br><span class="line">zlib-<span class="number">1.2</span><span class="number">.8</span>.tar.gz</span><br><span class="line">nginx-<span class="number">1.11</span><span class="number">.1</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>1.1.安装pcre<br>解压缩pcre-xx.tar.gz包<br>进入解压缩目录，执行./configure<br>如果提示，需要提前安装gcc++<br>进入安装光盘目录的软件包(/media/CentOSXX/Package)<br>执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rpm -ivh libstdc++-devel-<span class="number">4.4</span><span class="number">.7</span>-<span class="number">17.</span>el6.x86_64.rpm</span><br><span class="line">rpm -ivh gcc-c++-<span class="number">4.4</span><span class="number">.7</span>-<span class="number">17.</span>el6.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>./configure完成后，回到pcre目录下执行make，再执行make install<br>2. 安装openssl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、 解压缩openssl-xx.tar.gz包。</span><br><span class="line"><span class="number">2</span>、 进入解压缩目录，执行./config</span><br><span class="line"><span class="number">3</span>、 make &amp;&amp; make install</span><br><span class="line"><span class="number">3.</span> 安装zlib</span><br><span class="line"><span class="number">1</span>、 解压缩zlib-xx.tar.gz包。</span><br><span class="line"><span class="number">2</span>、 进入解压缩目录，执行./configure。</span><br><span class="line"><span class="number">3</span>、 make &amp;&amp; make install</span><br><span class="line"><span class="number">4.</span> 安装nginx</span><br><span class="line"><span class="number">1</span>、 解压缩nginx-xx.tar.gz包。</span><br><span class="line"><span class="number">2</span>、 进入解压缩目录，执行./configure。</span><br><span class="line"><span class="number">3</span>、 make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>nginx无法启动: libpcre.so.1/libpcre.so.0: cannot<br>open shared object file解决办法<br>解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/lib/libpcre.so.1 /lib64</span><br><span class="line">32位系统则：</span><br><span class="line">ln -s /usr/local/lib/libpcre.so.1 /lib</span><br></pre></td></tr></table></figure>

<p>在/usr/local/nginx/sbin目录下<br>执行 ./nginx<br>启动命令 在/usr/local/nginx/sbin目录下<br>执行 ./nginx<br>关闭命令 在/usr/local/nginx/sbin目录下<br>执行 ./nginx -s stop<br>重新加载命令 在/usr/local/nginx/sbin目录下<br>执行 ./nginx -s reload<br>设置nginx为自启动服务<br>修改linux 启动脚本/etc/rc.d/rc<br>加入 :<br>/usr/local/nginx/sbin/nginx<br>5、配置nginx.conf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">......</span><br><span class="line">upstream myserver&#123;</span><br><span class="line">ip_hash;<span class="comment">//ip取哈希码  与反向代理服务器取模 分在那一台</span></span><br><span class="line">server <span class="number">115.28</span><span class="number">.52</span><span class="number">.63</span>:<span class="number">8080</span> weight=<span class="number">1</span>;</span><br><span class="line">server <span class="number">115.28</span><span class="number">.52</span><span class="number">.63</span>:<span class="number">8180</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">server&#123;</span><br><span class="line">location / &#123;</span><br><span class="line">.........</span><br><span class="line">proxy_pass http:<span class="comment">//myserver;</span></span><br><span class="line">proxy_connect_timeout <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>master-workers的机制的好处<br>首先，对于每个worker进程来说，独立的进程，不需要加锁，<br>所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方<br>便很多。<br>其次，采用独立的进程，可以让互相之间不会影响，一个进程<br>退出后，其它进程还在工作，服务不会中断，master进程则很快启<br>动新的worker进程。当然，worker进程的异常退出，肯定是程序有<br>bug了，异常退出，会导致当前worker上的所有请求失败，不过不<br>会影响到所有请求，所以降低了风险<br>需要设置多少个worker<br>Nginx 同redis类似都采用了io多路复用机制，每个<br>worker都是一个独立的进程，但每个进程里只有一个主线<br>程，通过异步非阻塞的方式来处理请求， 即使是千上万个<br>请求也不在话下。每个worker的线程可以把一个cpu的性<br>能发挥到极致。<br>所以worker数和服务器的cpu数相等是最为适宜的。设<br>少了会浪费cpu，设多了会造成cpu频繁切换上下文带来的<br>损耗。</p>
<p>//静态资源请求 2个<br>//动态资源请求 4个</p>
<p>#设置worker数量。<br>worker_processes 4<br>#work绑定cpu(4 work绑定4cpu)。<br>worker_cpu_affinity 0001 0010 0100 1000<br>#work绑定cpu (4 work绑定8cpu中的4个) 。<br>worker_cpu_affinity 0000001 00000010 00000100<br>00001000<br>连接数worker_connection<br>• 这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx<br>能建立的最大连接数，应该是worker_connections * worker_processes。<br>当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的<br>最大并发数量是worker_connections * worker_processes，如果是支持<br>http1.1的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数<br>是： worker_connections * worker_processes /2，而如果是HTTP作<br>为反向代理来说，最大并发数量应该是worker_connections *<br>worker_processes/4。因为作为反向代理服务器，每个并发会建立与客<br>户端的连接和与后端服务的连接，会占用两个连接。</p>
<p>worker_connections * worker_processes /2 静态<br>worker_connections * worker_processes /4 动态</p>
<p>work最先处理请求 nobody表示权限最低 路人甲<br>use epoll</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>主站博客迁移之Thymleaf项目常用操作</title>
    <url>/posts/20220725clhk6pted001ocsuj47m7c8ug.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>Thymleaf搭配Springboot完成页面渲染，整理下日常开发中常见常用操作<br>1.下拉框动态被选中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;inputLevel&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;col-6 col-form-label form-label&quot;</span>&gt;用户等级:&lt;/label&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;col-6&quot;</span>&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;inputLevel&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;form-control&quot;</span> name=<span class="string">&quot;level&quot;</span>&gt;</span><br><span class="line">&lt;option value=<span class="string">&quot;&quot;</span></span><br><span class="line">th:selected=<span class="string">&quot;$&#123;null==req?&#x27;selected&#x27;:req.level==null?&#x27;select&#x27;:&#x27;false&#x27;&#125;&quot;</span>&gt;</span><br><span class="line">全部</span><br><span class="line">&lt;/option&gt;</span><br><span class="line">&lt;option value=<span class="string">&quot;1&quot;</span></span><br><span class="line">th:selected=<span class="string">&quot;$&#123;null==req?&#x27;false&#x27;:req.level==&#x27;1&#x27;?&#x27;select&#x27;:&#x27;false&#x27;&#125;&quot;</span>&gt;<span class="number">1</span>级</span><br><span class="line">&lt;/option&gt;</span><br><span class="line">&lt;option value=<span class="string">&quot;2&quot;</span></span><br><span class="line">th:selected=<span class="string">&quot;$&#123;null==req?&#x27;false&#x27;:req.level==&#x27;2&#x27;?&#x27;select&#x27;:&#x27;false&#x27;&#125;&quot;</span>&gt;<span class="number">2</span>级</span><br><span class="line">&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>2.动态复选框选中(判断List是否包含)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;checkbox&quot;</span></span><br><span class="line">  th:id=<span class="string">&quot;&#x27;checkboxResource&#x27; + $&#123;resourceEn.key&#125;&quot;</span></span><br><span class="line">  th:checked=<span class="string">&quot;$&#123;null==req.resourceIdList?&#x27;false&#x27;:#arrays.contains(req.resourceIdList, #strings.toString(resourceEn.key))?&#x27;checked&#x27;:&#x27;false&#x27;&#125;&quot;</span></span><br><span class="line">  name=<span class="string">&quot;resourceIdList&quot;</span> th:value=<span class="string">&quot;$&#123;resourceEn.key&#125;&quot;</span>&gt;</span><br><span class="line">  &lt;label th:text=<span class="string">&quot;$&#123;resourceEn.value.name&#125;&quot;</span> th:<span class="keyword">for</span>=<span class="string">&quot;&#x27;checkboxResource&#x27; + $&#123;resourceEn.key&#125;&quot;</span>&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure>
<p>3.onclick动态传值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> th:text=<span class="string">&quot;*&#123;status&#125;==0?&#x27;开启&#x27;:&#x27;关闭&#x27;&quot;</span></span><br><span class="line">th:attr=<span class="string">&quot;disabled=*&#123;status==10?true:false&#125;&quot;</span></span><br><span class="line">th:data-id=<span class="string">&quot;$&#123;supplier.id&#125;&quot;</span></span><br><span class="line">th:data-status=<span class="string">&quot;*&#123;status==0?1:0&#125;&quot;</span></span><br><span class="line">th:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;*&#123;status ==0||status!=1&#125;?&#x27;btn btn-block btn-success&#x27;:&#x27;btn btn-block btn-danger&#x27;&quot;</span></span><br><span class="line">onclick=<span class="string">&quot;enable(this.getAttribute(&#x27;data-id&#x27;),this.getAttribute(&#x27;data-status&#x27;))&quot;</span>&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>4.日期格式化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;td th:text=<span class="string">&quot;*&#123;#dates.format(updateTime, &#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>5.保留小数点后两位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;label <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;ml-3&quot;</span> th:<span class="keyword">if</span>=<span class="string">&quot;*&#123;price ne 1.0&#125;&quot;</span> th:text=<span class="string">&quot;*&#123;#numbers.formatDecimal(price * 10,0,2)&#125;&quot;</span>&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure>
<p>6.点击详情/编辑回显下拉被选中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;form-control select2bs4&quot;</span> style=<span class="string">&quot;width: 100%;&quot;</span> name=<span class="string">&quot;id&quot;</span>&gt;</span><br><span class="line">&lt;option value=<span class="string">&quot;&quot;</span> selected=<span class="string">&quot;selected&quot;</span>&gt;==请选择==&lt;/option&gt;</span><br><span class="line">&lt;option th:each=<span class="string">&quot;user : $&#123;users&#125;&quot;</span> th:selected=<span class="string">&quot;$&#123;user.id eq dept.id&#125;&quot;</span>  th:text=<span class="string">&quot;$&#123;user.Name&#125;&quot;</span>&gt;&lt;/option&gt;&lt;/select&gt;</span><br></pre></td></tr></table></figure></div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>Thymleaf</tag>
      </tags>
  </entry>
  <entry>
    <title>主站博客迁移之SpringCloudAlibaba服务注册新发现</title>
    <url>/posts/20220725clhk6pteb001lcsujeok8fbg7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>2018.09.21「小马哥技术周报」- 第一期《Spring Cloud 服务发现新选择 - Alibaba Nacos Discovery</p>
<p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud1.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud2.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud3.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud4.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud5.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud6.jpg" alt="流程"><br>基本是刚出来的时候就已经讲了，现在都2020了<br>不太适合大规模的分布式服务发现ZAB算法<br>内存型，有内存限制</p>
<p>Springcloudcommons as servicediscovery load balancing  circuit break<br>EnableDiscoveryClient是通用API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscoveryClient</span> <span class="keyword">extends</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> DEFAULT_ORDER = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;ServiceInstance&gt; <span class="title">getInstances</span><span class="params">(String serviceId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getServices</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类的其中一种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaDiscoveryClient</span> <span class="keyword">implements</span> <span class="title">DiscoveryClient</span> </span>&#123;</span><br><span class="line">    实现方法的返回值的ServiceInstance源码</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getInstanceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zk是唯一标识；eureka是ip+服务名</span><br><span class="line">    <span class="function">String <span class="title">getServiceId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getHost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否是HTTPs协议or not</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">URI <span class="title">getUri</span><span class="params">()</span></span>;</span><br><span class="line">    源信息  zk是又专门存储字段  补充信息</span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Eureka传递序列化或反序列化通过metadata传递，相关的开销比较大<br>超类接口Registration cloud commons 继承了上面的serviceInstance<br>现在的位置<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/Springcloud7.jpg" alt="流程"></p>
<p>空继承，为了扩展</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span>&lt;<span class="title">R</span> <span class="keyword">extends</span> <span class="title">Registration</span>&gt; </span>&#123;</span><br><span class="line">    注册</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(R registration)</span></span>;</span><br><span class="line">    de解除注册</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(R registration)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(R registration, String status)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getStatus</span><span class="params">(R registration)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Nacos的实现注册"><a href="#Nacos的实现注册" class="headerlink" title="Nacos的实现注册"></a>Nacos的实现注册</h2><p> com.alibaba.nacos.api.naming;NamingService<br>现在我下载源码总是下不下来，以为是maven出问题，忘记因为其他项目公用maven，导致maven配置的是私服地址，改下maven就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">F:\cloud2020&gt;mvn dependency:resolve -Dclassifier=sources</span><br><span class="line">[INFO] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">Downloading from nexus-server: xxx</span><br><span class="line">ependencies/<span class="number">2.2</span><span class="number">.2</span>.RELEASE/spring-boot-dependencies-<span class="number">2.2</span><span class="number">.2</span>.RELEASE.pom</span><br><span class="line">Downloading from nexus-server: xxx</span><br><span class="line">-dependencies/Hoxton.SR1/spring-cloud-dependencies-Hoxton.SR1.pom</span><br><span class="line">Downloading from nexus-server: xxx</span><br><span class="line">-dependencies/<span class="number">2.1</span><span class="number">.0</span>.RELEASE/spring-cloud-alibaba-dependencies-<span class="number">2.1</span><span class="number">.0</span>.RELEASE.pom</span><br></pre></td></tr></table></figure>
<p>namingSpace有很多重载方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NamingService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * register a instance to service</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName name of service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip          instance ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port        instance port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NacosException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String ip, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * register a instance to service</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName name of service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName   group of service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip          instance ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port        instance port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NacosException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String groupName, String ip, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> NacosException</span>;</span><br></pre></td></tr></table></figure>
<p>返回的是Instance</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get all instances of a service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceName name of service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A list of instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NacosException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 服务名   是否健康</span><br><span class="line"><span class="function">List&lt;Instance&gt; <span class="title">getAllInstances</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line">Ribbon--&gt;server  </span><br><span class="line">Eureka==&gt;ServiceInstance</span><br></pre></td></tr></table></figure>
<p>namingSpace以及instance都是Nacos的Api,而registration是Spring 为了适配实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Registration registration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;No service to register for nacos client...&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String serviceId = registration.getServiceId();</span><br><span class="line">        <span class="comment">//this.getNacosInstanceFromRegistration  get  set</span></span><br><span class="line">        Instance instance = <span class="keyword">this</span>.getNacosInstanceFromRegistration(registration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            放入nacos  注册中心持久化  可以连db</span><br><span class="line">            <span class="keyword">this</span>.namingService.registerInstance(serviceId, instance);</span><br><span class="line">            log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, <span class="keyword">new</span> Object[]&#123;serviceId, instance.getIp(), instance.getPort()&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;nacos registry, &#123;&#125; register failed...&#123;&#125;,&quot;</span>, <span class="keyword">new</span> Object[]&#123;serviceId, registration.toString(), var5&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放入nacos  注册中心持久化  可以连db<br>this.namingService.registerInstance(serviceId, instance);<br>Nacos  =Naming +config server<br>上面的实现类图可以看到ZK的实现<br>org.springframework.cloud.zookeeper.serviceregistry;<br>ZK的注册 反注册就跟现在的Nacos有一定程度的相似<br>注解驱动<br>依赖注入<br>外部化配置<br>事件驱动<br>github.com/nacos-group/nacos-spring-project<br>github.com/nacos-group/nacos-spring-boot-project</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>SpringCloudAlibaba</tag>
      </tags>
  </entry>
  <entry>
    <title>主站博客迁移之拒绝解析又臭又长的JSON</title>
    <url>/posts/20220725clhk6ptee001rcsujg3i9dmq7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>在日常工作中，不管是因为接收前端返回约定格式的JSON字符串，还是因为需要约定格式请求第三方服务，或者需要将前端画像xml解析成JSON，再或者需要接入第三方短信，供应商，数据提供商的JSON数据，或是需要提供对外暴露接口的API，可见解析JSON是一个常见操作。</p>
<p>JSON是一个轻量级的数据交换格式。</p>
<p>一：表单数据由数据库实体对象接收</p>
<p>常见的前后端约定字段，指定字段名称后，由数据库实体接收序列化后的表单数据，无序解析。</p>
<p>二：JSONObject解析</p>
<p>前后端约定格式，实体接收String类型，通过JSONObject解析JSON，JSONArray等操作</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">            </span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;createBy&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createTime&quot;</span>: <span class="number">1521171180000</span>,</span><br><span class="line">        <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;fa fa-gear&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuId&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;menuName&quot;</span>: <span class="string">&quot;系统管理&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuType&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line">        <span class="string">&quot;orderNum&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;params&quot;</span>: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;perms&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;#&quot;</span>,</span><br><span class="line">        <span class="string">&quot;visible&quot;</span>: <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">            </span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;createBy&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createTime&quot;</span>: <span class="number">1521171180000</span>,</span><br><span class="line">        <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;fa fa-video-camera&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuId&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;menuName&quot;</span>: <span class="string">&quot;系统监控&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuType&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line">        <span class="string">&quot;orderNum&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;params&quot;</span>: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;perms&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;#&quot;</span>,</span><br><span class="line">        <span class="string">&quot;visible&quot;</span>: <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">            </span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;createBy&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createTime&quot;</span>: <span class="number">1521171180000</span>,</span><br><span class="line">        <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;fa fa-bars&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuId&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">&quot;menuName&quot;</span>: <span class="string">&quot;系统工具&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuType&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line">        <span class="string">&quot;orderNum&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;params&quot;</span>: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;perms&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;#&quot;</span>,</span><br><span class="line">        <span class="string">&quot;visible&quot;</span>: <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>通过JSONObject以及解析JSONArray获取<br>三：接入第三方API</p>
<p>接入第三方API，或者按约定调用第三方服务时，你会发现约定了又臭有长的JSON格式，包含特定字段，包含token，包含秘钥，一个详细数据解析接口，上百个字段是常见的，而且多种格式嵌套解析，如果单纯将收到的字符串手动转化成JSONObject，还要判空，还要层层遍历，还要验证数据的有效性，这是在是不小的工作量。</p>
<p>改造方法：提取最长，覆盖字段最全的作为实体列接收，含有List数据就由List接收，最外层K值由字段接收，涉及类型判断需按约定传不同数值的，定义为枚举，秘钥等特殊Key值MD5加解密传递。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果url是空，则认为是解析历史数据 不需要拼装请求</span></span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(url)) &#123;</span><br><span class="line">            Client client = <span class="keyword">new</span> Client();</span><br><span class="line">            Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;mobileReli&quot;</span>.equals(interfaceCode)) &#123; <span class="comment">//if类型判断定义为枚举      </span></span><br><span class="line">                String infoJson = String.format(<span class="string">&quot;&#123;\&quot;phone\&quot;:\&quot;%s\&quot;,\&quot;name\&quot;:\&quot;%s\&quot;,\&quot;curDate\&quot;:\&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">                        applyRecord.getPhone(), applyRecord.getName(), applyRecord.getFlashblackDate());</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">long</span> time = System.currentTimeMillis();<span class="comment">//重复度高的字段由优特实体类接收</span></span><br><span class="line">                sb.append(secret + <span class="string">&quot;!&quot;</span> + appKey + <span class="string">&quot;!&quot;</span> + time + <span class="string">&quot;!&quot;</span> + applyRecord.getName() + <span class="string">&quot;!&quot;</span></span><br><span class="line">                        + applyRecord.getPhone() + <span class="string">&quot;!&quot;</span> + secret + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">                sign = hdsClient.md5(sb.toString());</span><br><span class="line">                String param = String.format(<span class="string">&quot;appKey=%s&amp;infoJson=%s&amp;sign=%s&amp;time=%s&quot;</span>, appKey, infoJson, sign, time);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jsonData = hdsClient.getResult(url, param);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;DSModel&quot;</span>.equals(interfaceCode)) &#123;</span><br><span class="line">                String infoJson = String.format(<span class="string">&quot;&#123;\&quot;mobile\&quot;:\&quot;%s\&quot;,\&quot;name\&quot;:\&quot;%s\&quot;,\&quot;starttime\&quot;:\&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">                        applyRecord.getPhone(), applyRecord.getName(), applyRecord.getFlashblackDate());</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">                sb.append(secret + <span class="string">&quot;!&quot;</span> + appKey + <span class="string">&quot;!&quot;</span> + time + <span class="string">&quot;!&quot;</span> + applyRecord.getName() + <span class="string">&quot;!&quot;</span></span><br><span class="line">                        + applyRecord.getPhone() + <span class="string">&quot;!&quot;</span> + applyRecord.getFlashblackDate() + <span class="string">&quot;!&quot;</span> + secret + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">                sign = hdsClient.md5(sb.toString());</span><br><span class="line">                String param = String.format(<span class="string">&quot;appKey=%s&amp;infoJson=%s&amp;sign=%s&amp;time=%s&quot;</span>, appKey, infoJson, sign, time);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jsonData = hdsClient.getResult(url, param);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;addressDetection&quot;</span>.equals(interfaceCode)) &#123;   </span><br><span class="line">                String infoJson = String.format(<span class="string">&quot;&#123;\&quot;phone\&quot;:\&quot;%s\&quot;,\&quot;address\&quot;:\&quot;%s\&quot;,\&quot;curDate\&quot;:\&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">                        applyRecord.getPhone(), applyRecord.getAddress(), applyRecord.getFlashblackDate());</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">                sb.append(secret + <span class="string">&quot;!&quot;</span> + appKey + <span class="string">&quot;!&quot;</span> + time + <span class="string">&quot;!&quot;</span> + applyRecord.getPhone() + <span class="string">&quot;!&quot;</span></span><br><span class="line">                        + applyRecord.getAddress() + <span class="string">&quot;!&quot;</span> + applyRecord.getFlashblackDate() + <span class="string">&quot;!&quot;</span> + secret + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">                sign = hdsClient.md5(sb.toString());</span><br><span class="line">                String param = String.format(<span class="string">&quot;appKey=%s&amp;infoJson=%s&amp;sign=%s&amp;time=%s&quot;</span>, appKey, infoJson, sign, time);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jsonData = hdsClient.getResult(url, param);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">InterfaceCodeEnum</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    InterfaceCode1(<span class="number">1</span>,<span class="string">&quot;mobileReli&quot;</span>),</span><br><span class="line">    InterfaceCode2(<span class="number">2</span>,<span class="string">&quot;DSModel&quot;</span>),</span><br><span class="line">    InterfaceCode3(<span class="number">3</span>,<span class="string">&quot;addressDetection&quot;</span>),</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    InterfaceCodeEnum(Integer code, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNameBycode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (InterfaceCodeEnum a : InterfaceCodeEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.code.equals(code)) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceCodeResult</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//基础信息</span></span><br><span class="line">    <span class="keyword">private</span> Base base;</span><br><span class="line">    <span class="comment">//秘钥信息</span></span><br><span class="line">    <span class="keyword">private</span> AuthInfo authInfo;</span><br><span class="line">    <span class="comment">//外层字段封装为对象接收</span></span><br><span class="line">    <span class="keyword">private</span> AddressResult  addressResult;</span><br><span class="line">    <span class="comment">//重复多层信息List接收</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Flashblack&gt; flashblack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当接收到JSON字符串时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InterfaceCodeResult codeResult=JSONObject.parseObject(InterfaceCodeResult.getRequestInfo(),InterfaceCodeResult.class);</span><br><span class="line">if(PreInterfaceStatus.equals(codeResult.base.getTyep()))&#123;</span><br><span class="line">  return JavaConvertUtil.conversion(codeResult, CodeParams.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅需要判断多个类型即可，对应字段会自动解析，当接收又臭又长的XML解析还需要后端验证时，需要封装Util类进行验证调用</p>
<p>同步更新至微信公众号，请搜索:赵KK日常技术记录，不定时更新文章内容</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>项目实战----行政优先级分析</title>
    <url>/posts/20220510clhk6pteq002rcsuj7ugeai6f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>在现有地点中解析其地点优先级,最小到区县,当前区县可指定作业优先级,当绑定优先级数据后的数据应在选择时优先展示。</p>
<h2 id="行政优先级维护"><a href="#行政优先级维护" class="headerlink" title="行政优先级维护"></a>行政优先级维护</h2><p>采用百度地图数据很行行政区域编码维护,考虑到现有数据是人工维护,获取其省市区县可能不准确,所以先根据其经纬度定位后可准确获取其省市区县,然后再进行编码维护。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>地点北京市东城区天安门，百度坐标116.403963,39.915119</p>
<h2 id="API"><a href="#API" class="headerlink" title="API:"></a>API:</h2><p><a href="https://lbsyun.baidu.com/index.php?title=webapi/district-search">https://lbsyun.baidu.com/index.php?title=webapi/district-search</a><br><a href="https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding-abroad">https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding-abroad</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"> Map&lt;String, String&gt; map = IbsBMapUtils.reverseGeocoding(&quot;116.403963&quot;, &quot;39.915119&quot;);</span><br><span class="line">                String province = map.get(&quot;province&quot;);</span><br><span class="line"></span><br><span class="line">List&lt;IbsBMapUtils.Districts&gt; districts = IbsBMapUtils.regionSearch(province.substring(0, 2));</span><br><span class="line">                for (IbsBMapUtils.Districts district : districts) &#123;</span><br><span class="line">                    DivisionDo divisionDo = new DivisionDo();</span><br><span class="line">                    divisionDo.setProvinceCode(district.getCode());</span><br><span class="line">                    divisionDo.setProvinceName(district.getName());</span><br><span class="line">                    divisionDo.setWarehouseCode(locationConfigDO.getWarehouseCode());</span><br><span class="line">                    List&lt;IbsBMapUtils.Districts&gt; districtsList = district.getDistricts();</span><br><span class="line">                    if (org.apache.commons.collections.CollectionUtils.isNotEmpty(districtsList)) &#123;</span><br><span class="line">                        for (IbsBMapUtils.Districts districts2 : districtsList) &#123;</span><br><span class="line">                            divisionDo.setCityCode(districts2.getCode());</span><br><span class="line">                            divisionDo.setCityName(districts2.getName());</span><br><span class="line">                            List&lt;IbsBMapUtils.Districts&gt; districts3 = districts2.getDistricts();</span><br><span class="line">                            if (org.apache.commons.collections.CollectionUtils.isNotEmpty(districts3)) &#123;</span><br><span class="line">                                for (IbsBMapUtils.Districts district3 : districts3) &#123;</span><br><span class="line">                                    divisionDo.setRegionName(district3.getName());</span><br><span class="line">                                    divisionDo.setRegionCode(district3.getCode());</span><br><span class="line">                                    divisionRepository.insert(divisionDo);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                divisionRepository.insert(divisionDo);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        divisionRepository.insert(divisionDo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="当前区域指定优先级作业后数据优先展示"><a href="#当前区域指定优先级作业后数据优先展示" class="headerlink" title="当前区域指定优先级作业后数据优先展示"></a>当前区域指定优先级作业后数据优先展示</h2><p>例如北京市有N个区,指定了N个规划路线,当东城区指定了由最近的骑手配送时，则点击东城区商家的配送线路优先展示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;MunicipalLevel&gt;  list = MunicipalLevelMapper.selectMunicipalLevelList(&quot;北京市-东城区&quot;);</span><br><span class="line"></span><br><span class="line">       if(CollectionUtils.isEmpty(list))&#123;</span><br><span class="line">           return Collections.emptyList();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">	List&lt;String&gt; riderList = divisionMapper.getRiderByProvince(&quot;11001&quot;, &quot;北京市&quot;,&quot;东城区&quot;);</span><br><span class="line">               //错误实例</span><br><span class="line">			if (CollectionUtils.isNotEmpty(riderList)) &#123;</span><br><span class="line">                   for (String riderName : riderList) &#123;</span><br><span class="line">                       List&lt;RirderListResponse&gt; listResponses = list.stream().filter(vo -&gt; StringUtils.isNotEmpty(vo.getRirderName()) &amp;&amp; vo.getRiderName().equals(riderName)).collect(Collectors.toList());</span><br><span class="line">                       if (CollectionUtils.isNotEmpty(listResponses)) &#123;</span><br><span class="line">                           for (int i = 0; i &lt; listResponses.size(); i++) &#123;</span><br><span class="line">                               RirderListResponse response = listResponses.get(i);</span><br><span class="line">                               final List l = list;</span><br><span class="line">                               l.set(i, l.set(j, l.get(i)));</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       log.warn(&quot;响应&#123;&#125;&quot;, JSONObject.toJSONString(list));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="bug修复"><a href="#bug修复" class="headerlink" title="bug修复"></a>bug修复</h2><p>当前查询出东城区绑定优先级为1.2.3.4时，查询出来的顺序更新索引位置会变为4.3.2.1，且考虑到list会多个且可重复重新更改代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;MunicipalLevel&gt;  list = MunicipalLevelMapper.selectMunicipalLevelList(&quot;北京市-东城区&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       if(CollectionUtils.isEmpty(list))&#123;</span><br><span class="line">           return Collections.emptyList();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">              List&lt;String&gt; riderList = divisionMapper.getRiderByProvince(&quot;11001&quot;, &quot;北京市&quot;,&quot;东城区&quot;);</span><br><span class="line">               riderList = riderList.stream().filter(item -&gt; responseList.stream().map(RouteListResponse::getName).collect(Collectors.toList()).contains(item)).collect(Collectors.toList());</span><br><span class="line">               Collections.reverse(riderList);</span><br><span class="line">                   Collections.reverse(riderList);</span><br><span class="line">                   for (int i = 0; i &lt; riderList.size(); i++) &#123;</span><br><span class="line">                       for (MunicipalLevel res : list) &#123;</span><br><span class="line">                           if(res.getName().equals(riderList.get(i)))&#123;</span><br><span class="line">                               Collections.swap(list, list.indexOf(res), i);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;         </span><br><span class="line">           </span><br></pre></td></tr></table></figure>
<h2 id="bug再次修复终极版"><a href="#bug再次修复终极版" class="headerlink" title="bug再次修复终极版"></a>bug再次修复终极版</h2><p>当存在多个优先级相同的区域路线时，会因为本身在list的位置不同，导致最后只有第一个正确，其他元素位置不正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">if(CollectionUtils.isEmpty(list))&#123;</span><br><span class="line">            return Collections.emptyList();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">              // List&lt;String&gt; riderList = divisionMapper.getRiderByProvince(&quot;11001&quot;, &quot;北京市&quot;,&quot;东城区&quot;);</span><br><span class="line">                //riderList = riderList.stream().filter(item -&gt; responseList.stream().map(RouteListResponse::getName).collect(Collectors.toList()).contains(item)).collect(Collectors.toList());</span><br><span class="line">                    //Collections.reverse(riderList);</span><br><span class="line">                    //借助外部元素记录交换元素位置</span><br><span class="line">                    if (CollectionUtils.isNotEmpty(supplierList)) &#123;</span><br><span class="line">                    int a = 0 ;</span><br><span class="line">                    for (int i = 0; i &lt; riderList.size(); i++) &#123;</span><br><span class="line">                        for (MunicipalLevel res : list) &#123;</span><br><span class="line">                            if(res.getName().equals(riderList.get(i)))&#123;</span><br><span class="line">                                Collections.swap(list, list.indexOf(res), i);</span><br><span class="line">                                a++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql中的锁表语句查看方法汇总</title>
    <url>/posts/20220428clhk6pte50015csuj5aqe6n6t.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">&#x27;Table%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">+----------------------------+----------+</span><br><span class="line"></span><br><span class="line">| Variable_name        | Value |</span><br><span class="line"></span><br><span class="line">+----------------------------+----------+</span><br><span class="line"></span><br><span class="line">| Table_locks_immediate | <span class="number">105</span>         |</span><br><span class="line"></span><br><span class="line">| Table_locks_waited   | <span class="number">3</span>           |</span><br><span class="line"></span><br><span class="line">+----------------------------+----------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Table_locks_immediate    26839653<br>Table_locks_waited            0<br>Table_open_cache_hits    3<br>Table_open_cache_misses    2<br>Table_open_cache_overflows    2</p>
<p>Table_locks_immediate  指的是能够立即获得表级锁的次数</p>
<p>Table_locks_waited  指的是不能立即获取表级锁而需要等待的次数</p>
<p>Table_open_cache_hits  表缓存被命中的次数</p>
<p>Table_open_cache_misses 表缓存未被命中的次数</p>
<p>Table_open_cache_overflows  就是上面说的淘汰的instance（table cache）的数量</p>
<p>查看正在被锁定的的表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>怎么查找mysql中的锁表语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> processlist;</span><br><span class="line">与<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.processlist效果相同</span><br></pre></td></tr></table></figure>
<p>SHOW PROCESSLIST显示哪些线程正在运行。您也可以使用mysqladmin processlist语句得到此信息。如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程（也就是，与您正在使用的MySQL账户相关的线程）。如果有线程在update或者insert 某个表，此时进程的status为updating 或者 sending data。<br>show processlist 是显示用户正在运行的线程，需要注意的是，除了 root 用户能看到所有正在运行的线程外，其他用户都只能看到自己正在运行的线程，看不到其它用户正在运行的线程。除非单独个这个用户赋予了PROCESS 权限<br>– 查看那些表锁到了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>– 查看进程号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> processlist;</span><br></pre></td></tr></table></figure>
<p>–删除进程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">kill <span class="number">1085850</span>；</span><br></pre></td></tr></table></figure>
<p> <img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql.png" alt="流程"></p>
<p>Id: 就是这个线程的唯一标识，当我们发现这个线程有问题的时候，可以通过 kill 命令，加上这个Id值将这个线程杀掉。前面我们说了show processlist 显示的信息时来自information_schema.processlist 表，所以这个Id就是这个表的主键。<br>User: 就是指启动这个线程的用户。<br>Host: 记录了发送请求的客户端的 IP 和 端口号。通过这些信息在排查问题的时候，我们可以定位到是哪个客户端的哪个进程发送的请求。<br>DB: 当前执行的命令是在哪一个数据库上。如果没有指定数据库，则该值为 NULL 。<br>Command: 是指此刻该线程正在执行的命令。这个很复杂，下面单独解释<br>Time: 表示该线程处于当前状态的时间。<br>State: 线程的状态，和 Command 对应，下面单独解释。<br>Info: 一般记录的是线程执行的语句。默认只显示前100个字符，也就是你看到的语句可能是截断了的，要看全部信息，需要使用 show full processlist。<br>下面我们单独看一下 Command 的值：<br>Binlog Dump: 主节点正在将二进制日志 ，同步到从节点<br>Change User: 正在执行一个 change-user 的操作<br>Close Stmt: 正在关闭一个Prepared Statement 对象<br>Connect: 一个从节点连上了主节点<br>Connect Out: 一个从节点正在连主节点<br>Create DB: 正在执行一个create-database 的操作<br>Daemon: 服务器内部线程，而不是来自客户端的链接<br>Debug: 线程正在生成调试信息<br>Delayed Insert: 该线程是一个延迟插入的处理程序<br>Drop DB: 正在执行一个 drop-database 的操作<br>Execute: 正在执行一个 Prepared Statement<br>Fetch: 正在从Prepared Statement 中获取执行结果<br>Field List: 正在获取表的列信息<br>Init DB: 该线程正在选取一个默认的数据库<br>Kill : 正在执行 kill 语句，杀死指定线程<br>Long Data: 正在从Prepared Statement 中检索 long data<br>Ping: 正在处理 server-ping 的请求<br>Prepare: 该线程正在准备一个 Prepared Statement<br>ProcessList: 该线程正在生成服务器线程相关信息<br>Query: 该线程正在执行一个语句<br>Quit: 该线程正在退出<br>Refresh：该线程正在刷表，日志或缓存；或者在重置状态变量，或者在复制服务器信息<br>Register Slave： 正在注册从节点<br>Reset Stmt: 正在重置 prepared statement<br>Set Option: 正在设置或重置客户端的 statement-execution 选项<br>Shutdown: 正在关闭服务器<br>Sleep: 正在等待客户端向它发送执行语句<br>Statistics: 该线程正在生成 server-status 信息<br>Table Dump: 正在发送表的内容到从服务器<br>Time: Unused</p>
<p>那么MySQL突然飙升,首先查询当下主库内正在运行的线程以及是否有占用资源的SQL。然后执行分析info语句，看此次SQL是否是新发版功能引起，如果是新功能引起，立即回滚。</p>
<p>– 查询非 Sleep 状态的链接，按消耗时间倒序展示，自己加条件过滤</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, db, <span class="keyword">user</span>, host, command, <span class="type">time</span>, state, info</span><br><span class="line"><span class="keyword">from</span> information_schema.processlist</span><br><span class="line"><span class="keyword">where</span> command <span class="operator">!=</span> <span class="string">&#x27;Sleep&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="type">time</span> <span class="keyword">desc</span> </span><br></pre></td></tr></table></figure>
<p>其次查看CAT，但是CAT中除了Heartbeat报表GC异常以外，只有一条一分钟的SQL，并没有其他超时SQL</p>
<p>然后查看Grafana可以看到飙升时间在7点18分</p>
<p>在这个时间段查询PMM</p>
<p>没有异常，但是在其他服务中查询到有长达10分钟SQL未返回。</p>
<p>运行show full processlist命令查看是否有线程递增的情况</p>
<p>查询发现每一秒都有一个SQL在查询，经过代码分析，是某个接口前端轮询调用每秒都在进行查询导致的，没想到一个查询频率超高的SQL能导致CPU超高</p>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=90978812&cid=155358422&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;"></iframe></div>

</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能vs人工智障之图片识别</title>
    <url>/posts/20220407clhk6pteh001ycsuj6lancm46.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>从车牌识别到图片的相似度处理。开始的目的是识别车牌，以供研究opencv的,在接触车牌的识别的过程中,接触到java的tess4j以及java整合opencv的过程,但是车牌识别效率很低。人为识别是很清晰的但是仍然解析不出来。</p>
<h2 id="1-Tess4j"><a href="#1-Tess4j" class="headerlink" title="1.Tess4j"></a>1.Tess4j</h2><p>引入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/net.sourceforge.tess4j/tess4j --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.sourceforge.tess4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tess4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.4</span><span class="number">.8</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>下载中文检索所需包否则会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Please make sure the TESSDATA_PREFIX environment variable is set to your “tessdata” directory</span><br></pre></td></tr></table></figure>
<p>我是直接在gitee拉下来的包手动添加的<br><a href="https://gitee.com/it_moon/tessdata?_from=gitee_search">https://gitee.com/it_moon/tessdata?_from=gitee_search</a></p>
<h2 id="2-Demo"><a href="#2-Demo" class="headerlink" title="2.Demo"></a>2.Demo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建实例</span></span><br><span class="line">       ITesseract instance = <span class="keyword">new</span> Tesseract();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置识别语言</span></span><br><span class="line"></span><br><span class="line">       instance.setLanguage(<span class="string">&quot;chi_sim&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置识别引擎</span></span><br><span class="line"></span><br><span class="line">       instance.setOcrEngineMode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件</span></span><br><span class="line"></span><br><span class="line">       BufferedImage image = ImageIO.read(TestTextOcr.class.getResourceAsStream(<span class="string">&quot;/2.jpg&quot;</span>));</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 识别</span></span><br><span class="line">           String result = instance.doOCR(image);</span><br><span class="line">           System.out.println(result);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (TesseractException e) &#123;</span><br><span class="line">           System.err.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>车牌识别对应EL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String el =&quot;/^[京津晋冀蒙辽吉黑沪苏浙皖闽赣鲁豫鄂湘粤桂琼渝川贵云藏陕甘青宁新][ABCDEFGHJKLMNPQRSTUVWXY][\\dABCDEFGHJKLNMxPQRSTUVWXYZ]&#123;5&#125;$/&quot;;</span><br></pre></td></tr></table></figure>
<p>但是识别效率很低很低<br>参考其他的识别算法仍然识别不出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws TesseractException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        ITesseract instance = new Tesseract();</span><br><span class="line">        //如果未将tessdata放在根目录下需要指定绝对路径</span><br><span class="line">        //设置训练库的位置</span><br><span class="line">        //instance.setDatapath(&quot;the absolute path of tessdata&quot;);</span><br><span class="line"></span><br><span class="line">        //如果需要识别英文之外的语种，需要指定识别语种，并且需要将对应的语言包放进项目中</span><br><span class="line">        // chi_sim ：简体中文， eng    根据需求选择语言库</span><br><span class="line">        instance.setLanguage(&quot;chi_sim&quot;);</span><br><span class="line"></span><br><span class="line">        // 指定识别图片</span><br><span class="line">        instance.setOcrEngineMode(0);</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        String ocrResultNew = dealImage(&quot;C:\\Users\\Admin\\Desktop\\9-160514164SDY.jpg&quot;);</span><br><span class="line">        File imgDir = new File(ocrResultNew);</span><br><span class="line">        String ocrResult = instance.doOCR(imgDir);</span><br><span class="line">        String el =&quot;/^[京津晋冀蒙辽吉黑沪苏浙皖闽赣鲁豫鄂湘粤桂琼渝川贵云藏陕甘青宁新][ABCDEFGHJKLMNPQRSTUVWXY][\\dABCDEFGHJKLNMxPQRSTUVWXYZ]&#123;5&#125;$/&quot;;</span><br><span class="line">        System.out.println(&quot;识别结果: \n&quot; + ocrResult + &quot;\n 耗时：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br><span class="line">        if(ocrResult.matches(el))&#123;</span><br><span class="line">            // 输出识别结果</span><br><span class="line">            System.out.println(&quot;识别结果: \n&quot; + ocrResult + &quot;\n 耗时：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            log.error(&quot;车牌识别有误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我开始搜索java结合opencv的项目，但是仍然识别失败。<br>识别过程为：识别切图–&gt;</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot+Netty仿微信实战设计文档</title>
    <url>/posts/20220331clhk6ptdt000kcsuj0q778p07.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>日期：2021-12-28<br>版本号：1.0.0<br>作者：kk</p>
<p>1   编写目的<br> 1.1    术语与定义<br> 1.2    引用标准和规范<br> 1.3    参考资料<br>2    系统总体框架<br> 2.1    设计目标<br> 2.2    总体技术路线<br> 2.3    架构概览<br> 2.3.1    架构总览图<br> 2.3.2    功能一览图<br>3功能展示</p>
<p>1.1编写目的</p>
<p>体验APP通讯,实现聊天功能以及聊天项目的设计思路，选用高性能传输非阻塞的netty框架进行开发,秒级响应</p>
<p>接入websocket技术应用聊天消息的已读未读，还有聊天消息的测试与联调</p>
<p>Netty心跳检测机制</p>
<p>云服务器构建项目，引入CICD，以及Devops构建,接入监控体系，一秒钟定位异常</p>
<p>针对登陆不同场景，结合桥接模式进行项目改造，代码review<br>1.2 术语与定义<br>Netty：Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.<br>NLP:自然语言处理(NLP，Natural Language Processing) 是研究人与计算机交互的语言问题的一门学科。按照技术实现难度的不同，这类系统可以分成简单匹配式、模糊匹配式和段落理解式三种类型。<br>推荐系统：帮助用户找到想要的商品</p>
<p>1.3 引用标准和规范<br>1.阿里巴巴开发规范<br>2.接口使用规范<br>3.开发过程规范<br>4.异常管理规范<br>1.4参考资料<br>《阿里巴巴开发规范》–阿里官方Java代码规范标准<br>Netty实战</p>
<p>2系统总体框架<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E6%94%B9%E7%AD%BE%E6%B5%81%E7%A8%8Bv1.1%20(1).png" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E6%B5%81%E7%A8%8Bv1.1.jpg" alt="流程"><br>2.1设计目标<br>目标：旨在模拟微信APP体验实时通讯理念,秒级响应用户请求，由前后端统一处理消息，模拟从登陆/注册-&gt;用户个人信息维护-&gt;交友聊天等主流程。<br>玩转云服务器，从容面对IM聊天业务，延伸场景:自住回复机器人等。<br>技术扩展<br>1.登陆：用户登陆保存用户信息到缓存，以便用户第二次打开app可实现不输入密码登陆，并对密码进行MD5加密。<br>2.登陆时生成全局唯一id，根据id的调用谷歌的com.google.zxing.BarcodeFormat生成个人二维码并进行保存，当加好友，扫一扫时可进行唯一id判断来添加维护好友关系。<br>3.登陆后可进行个人信息维护，角色管理，查看数据，页面配置，黑名单管理等，朋友圈既是一个社区型评论功能化系统，可进行功能复用。<br>4.站在业务角度分析一次聊天事件的流程<br>5.当出现用户群后，根据DSSM模型分析用户行为。<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/dssm.png" alt="流程"><br>6.Netty源码解读<br>7.云服务项目部署<br>2.2总体技术路线<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF.png" alt="流程"><br>2.3系统架构<br>1、以业务分析为输入，以总体的企业应用架构为原则，按着不同区域划分，由于本次基础以聊天业务为入口，侧重点不同，在此不做分析。<br>2、业务可配置性实时变化，引入apollo<br>3、定位用户ip，上传用户真实ip定位用户位置，引入iP2region，举例说明：即为了用户的隐私安全，定位用户的位置，第一时间定位报警用户行为的位置。<br>4、随着公司的业务的不断发展，当基础的系统逐步成型以后。业务运营就需要开始做⽤户的拉新和促活,从⽽保障 DUA 的增速以及最终 ROI 转换<br>3.功能展示<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220110164204.png" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220110164157.png" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220110164201.png" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220110164204.png" alt="流程"><br>4.延伸问题：DSSM(Deep Structured Semantic Models)<br>也叫深度语义匹配模型，最早是微软发表的一篇应用于NLP领域中计算语义相似度任务的文章。深度语义匹配模型当用户量达到一定群体，分析用户行为，精准推送用户广告，喜好分析等成了我们不可或缺的一个话题。通过打标签，关联分组，给不同数据源的关联，这里涉及到两种建模：一种是自然兴趣建模，根据用户操作终端行为获得user-item关联，给不同的数据源打标获得item-tag关联，最后将上面两种关联进行join操作得到user-tag的关联实现给用户打上兴趣标签，这里相当于是从标签维度为广告主推荐人群；另一种就是商业兴趣建模，在自然兴趣建模的基础上，从广告维度为广告主推荐人群，那么就需要目前大火的DSSM双塔模型了。<br>那么平时最多的用户喜好数据来源哪里？<br>1.输入法<br>输入搜素引擎：根据用户的每日输入词都可推算你的历史组词，当然可分析此行为找出关联性最多的词组进行特征分析，将用户标签、用户属性、项目属性、用户操作行为、聚类算法、基于用户、基于项目、基于内容等混合推荐。<br>2.点击日志<br>短视频平台/海量曝光日志，根据用户多次点击的同tag类视频进行爱好分析，比如滑雪视频，你点击一次，首页就会出现多篇推荐，然后在产生一次点击，就会源源不断的进行推荐<br>其实第一次看这篇论文的时候，有点云里雾里，我不得不再次进行阅读，但结合推荐系统来看更容理解，推荐算法大致可以分为以下几类<br>基于流行度的算法<br>协同过滤算法<br>基于内容的算法<br>基于模型的算法<br>混合算法<br>在次就不展开讨论，只个人结合资料查阅，而DSSM更像是在基于模型的基础上，完成推荐任务，跟分治算法，回溯算法等不谋而合<br>5.朋友圈设计：点赞+评论<br>结合社区内容设计，将朋友圈视为新的一个tab展示，并将社区属性的评论与点赞进行集成展示。<br>对于点赞和评论的博文可参考个人公众号文章<br>点赞功能设计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&amp;mid=2247484981&amp;idx=1&amp;sn=569bc3d748026dd8c2814e33a3e916d0&amp;chksm=ceb09948f9c7105e203e09e4bb1d30de17bba55a68f7d4df71ccb55c8e34871e2b02b7a1f9ed&amp;token=889485161&amp;lang=zh_CN#rd</span></span><br></pre></td></tr></table></figure>
<p>本次着重介绍评论系统<br>1.使用递归开发评论功能，并改造为极简循环调用，防止递归层次太深<br>大多数的评论功能可<br>1、单一消息体：分为主评论，然后层级下逐一排列回复，消息体之间一对多<br>2、嵌套消息体：即分为主评论，层级以下可互相回复评论，但展示层级是在同为第二层(着重解释)<br>3、套娃消息体：即可对每条评论进行回复，除主消息体外，都视为第二层，且可对第二层消息体进行回复，每次回复视为一层，消息体为一对多中的多又是一对多~</p>
<h1 id="单一消息体"><a href="#单一消息体" class="headerlink" title="单一消息体"></a>单一消息体</h1><p>数据库设计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE `comment_msg` (</span><br><span class="line">  `id` varchar(<span class="number">64</span>) NOT NULL,</span><br><span class="line">  `send_user_id` varchar(<span class="number">64</span>) NOT NULL,</span><br><span class="line">  `accept_user_id` varchar(<span class="number">64</span>) NOT NULL,</span><br><span class="line">  `msg` varchar(<span class="number">255</span>) NOT NULL,</span><br><span class="line">  `sign_flag` <span class="keyword">int</span>(<span class="number">1</span>) NOT NULL COMMENT <span class="string">&#x27;消息是否签收状态\r\n1：签收\r\n0：未签收\r\n&#x27;</span>,</span><br><span class="line">  `create_time` datetime NOT NULL COMMENT <span class="string">&#x27;发送请求的事件&#x27;</span>,</span><br><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`id`)</span></span></span><br><span class="line"><span class="function">) ENGINE</span>=InnoDB DEFAULT CHARSET=utf8mb4</span><br></pre></td></tr></table></figure>
<p>即展示所有主题评论下的所有评论即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from comment_msg where send_user_id=#&#123;send_user_id&#125;</span><br></pre></td></tr></table></figure>

<h1 id="嵌套消息体"><a href="#嵌套消息体" class="headerlink" title="嵌套消息体"></a>嵌套消息体</h1></div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>还在手动写单元测试？</title>
    <url>/posts/20220207clhk6ptep002ncsujdpb8fqi6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h1 id="JUnitGenerator安装"><a href="#JUnitGenerator安装" class="headerlink" title="JUnitGenerator安装"></a>JUnitGenerator安装</h1><p>在Idea市场里安装JUnitGenerator插件如图，重启后生效<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/junit1.png" alt="流程"></p>
<h1 id="设置生成路径及模板"><a href="#设置生成路径及模板" class="headerlink" title="设置生成路径及模板"></a>设置生成路径及模板</h1><p>Output Path: ${SOURCEPATH}/..//../test/java/${PACKAGE}/${FILENAME}<br>注：根据实际项目结构调整，设置为默认模板，另需要在Project Structure–&gt;Modules中设置Test文件目录，可改造为自启动，随容器启动，<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/junit2.png" alt="流程"></p>
<h1 id="设置Junit4-生成模板"><a href="#设置Junit4-生成模板" class="headerlink" title="设置Junit4 生成模板"></a>设置Junit4 生成模板</h1><p>支持 CommonResponse 或  Wrapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#macro (cap $strIn)$strIn.valueOf($strIn.charAt(<span class="number">0</span>)).toUpperCase()$strIn.substring(<span class="number">1</span>)#end </span><br><span class="line">#foreach ($entry in $entryList) </span><br><span class="line">#set( $testClass=<span class="string">&quot;$&#123;entry.className&#125;Test&quot;</span>) </span><br><span class="line"><span class="keyword">package</span> $entry.packageName; </span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test; </span><br><span class="line"><span class="keyword">import</span> org.junit.Before; </span><br><span class="line"><span class="keyword">import</span> org.junit.After; </span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BSF+Junit4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Creator</span> zhaokk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateDate</span> $&#123;Date&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DESC</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $<span class="title">testClass</span> </span>&#123; </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">final</span> String ipAndPort=<span class="string">&quot;localhost:8080/&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String token=<span class="string">&quot;login-token&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String extend = <span class="string">&quot;extend&quot;</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HttpHeaders requestHeaders;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        requestHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        requestHeaders.add(<span class="string">&quot;token&quot;</span>, token);</span><br><span class="line">        requestHeaders.add(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        JunitUtils.setRequestHeaders(requestHeaders);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#foreach($method in $entry.methodList) </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * Method: $method.signature </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> test#cap($&#123;method.name&#125;)() <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">        <span class="comment">//Make request</span></span><br><span class="line">        TestEntity testEntity=JunitUtils.checkRequest(ipAndPort,token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Show Controller &amp; Mehtod</span></span><br><span class="line">        <span class="comment">//FIXME new $entry.packageName.$&#123;entry.className&#125;().$&#123;method.name&#125;();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Model 1 (Parameter is url)</span></span><br><span class="line">        <span class="comment">//Map&lt;String,String&gt; objectRequest=new HashMap();</span></span><br><span class="line">        <span class="comment">//objectRequest.put(&quot;&#123;id&#125;&quot;,&quot;1000000157729&quot;);</span></span><br><span class="line">        <span class="comment">//testEntity.setRequestObj(objectRequest);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Model 2 (Parameter is Object)</span></span><br><span class="line">        <span class="comment">//UserLoginReq objectRequest = new UserLoginReq();//JSON.parseObject(&quot;jsonString&quot;,UserLoginReq.class)</span></span><br><span class="line">        <span class="comment">//objectRequest.setUsername(&quot;18311140968&quot;);</span></span><br><span class="line">        <span class="comment">//objectRequest.setPassword(&quot;aa123456&quot;);</span></span><br><span class="line">        <span class="comment">//testEntity.setRequestObj(objectRequest);</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">//Model 3 (Parameter is url &amp; Object)</span></span><br><span class="line">        <span class="comment">//Map&lt;String,String&gt; urlMap=new HashMap();</span></span><br><span class="line">        <span class="comment">//urlMap.put(&quot;&#123;pageNo&#125;&quot;,&quot;1&quot;);</span></span><br><span class="line">        <span class="comment">//urlMap.put(&quot;&#123;pageSize&#125;&quot;,&quot;10&quot;);</span></span><br><span class="line">	<span class="comment">//UserLoginReq objectRequest = new UserLoginReq();//JSON.parseObject(&quot;jsonString&quot;,UserLoginReq.class)</span></span><br><span class="line">        <span class="comment">//objectRequest.setUsername(&quot;18311140968&quot;);</span></span><br><span class="line">        <span class="comment">//objectRequest.setPassword(&quot;aa123456&quot;);</span></span><br><span class="line">        <span class="comment">//testEntity.setRequestObj(objectRequest);</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">//model 1  and model 2 (ResponseEntity)</span></span><br><span class="line">        ResponseEntity&lt;CommonResponse&gt; responseResponseEntity=JunitUtils.getResponseEntity(testEntity);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//model 3 (ResponseEntity)</span></span><br><span class="line">        <span class="comment">//ResponseEntity&lt;CommonResponse&gt; responseResponseEntity=JunitUtils.getResponseEntity(urlMap,testEntity);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ResponseEntity To Object</span></span><br><span class="line">        <span class="comment">//CommonResponse&lt;UserResp&gt; response = responseResponseEntity.getBody();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Check CommonResponse code is 200000</span></span><br><span class="line">        JunitUtils.checkResponse(responseResponseEntity.getBody());</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">#end </span><br><span class="line"></span><br><span class="line">#foreach($method in $entry.privateMethodList) </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Method: $method.signature </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> test#cap($&#123;method.name&#125;)() <span class="keyword">throws</span> Exception &#123; </span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Test goes here... </span></span><br><span class="line">#foreach($string in $method.reflectionCode) </span><br><span class="line">$string </span><br><span class="line">#end </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">#end </span><br><span class="line">&#125; </span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">代码块<span class="number">1</span>：根据ipAndPort和token 拼装基础的URL和请求头</span><br><span class="line">代码块<span class="number">2</span>：工具块，方便快速跳转到本方法的源头</span><br><span class="line">代码块<span class="number">3</span>：模式<span class="number">1</span>参数封装，一般用于GET 和DELETE 请求，纯URL</span><br><span class="line">代码块<span class="number">4</span>：模式<span class="number">2</span>参数封装，一般用于POST和PUT 请求，纯对象。支持Json字符串，如下：</span><br><span class="line">         UpdateUserByPKReq objectRequest = JunitUtils.jsonToObject(<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;接口测试-勿删\&quot;,\&quot;userNumber\&quot;:\&quot;1573195928331\&quot;&quot;</span>,UpdateUserByPKReq.class);</span><br><span class="line">          </span><br><span class="line">代码块<span class="number">5</span>：模式<span class="number">1</span>和模式<span class="number">2</span>的组合，拼装URL+对象</span><br><span class="line">代码块<span class="number">6</span>：适用于模式<span class="number">1</span>和模式<span class="number">2</span>，进行具体的请求并获得响应结果</span><br><span class="line">代码块<span class="number">7</span>：适用于模式<span class="number">3</span>，进行具体的请求并获得响应结果</span><br><span class="line">代码块<span class="number">8</span>：检查响应结果，默认<span class="number">200000</span>为成功，如果非<span class="number">200000</span>失败。如有多个状态码均为成功，可以增加成功状态码进行入参，</span><br><span class="line">         如下：JunitUtils.checkResponse(responseResponseEntity.getBody(),<span class="number">600220</span>)</span><br></pre></td></tr></table></figure>

<p>这里可自行改造为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaokk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> $&#123;Date&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = com.xxx.class)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line">workspace.xml中加入</span><br><span class="line">&lt;component name=<span class="string">&quot;PropertiesComponent&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dynamic.classpath&quot;</span> value=<span class="string">&quot;true&quot;</span> /&gt;</span><br><span class="line">&lt;!--  --&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/junit3.png" alt="流程"></p>
<h1 id="不知道大家有没有用有道云笔记的没有，经常性的新打开的笔记会在首行，但除了阅读之外，应该在最后一行继续编辑，所有大多情况下需要鼠标滑动到行尾，搜索过很多方法，不如Ctrl-A，然后→右箭头好用。mark"><a href="#不知道大家有没有用有道云笔记的没有，经常性的新打开的笔记会在首行，但除了阅读之外，应该在最后一行继续编辑，所有大多情况下需要鼠标滑动到行尾，搜索过很多方法，不如Ctrl-A，然后→右箭头好用。mark" class="headerlink" title="不知道大家有没有用有道云笔记的没有，经常性的新打开的笔记会在首行，但除了阅读之外，应该在最后一行继续编辑，所有大多情况下需要鼠标滑动到行尾，搜索过很多方法，不如Ctrl+A，然后→右箭头好用。mark"></a>不知道大家有没有用有道云笔记的没有，经常性的新打开的笔记会在首行，但除了阅读之外，应该在最后一行继续编辑，所有大多情况下需要鼠标滑动到行尾，搜索过很多方法，不如Ctrl+A，然后→右箭头好用。mark</h1></div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>JunitTest</tag>
      </tags>
  </entry>
  <entry>
    <title>如何删除valine评论</title>
    <url>/posts/20220126clhk6ptej0021csujcij2htbx.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><p>1.登陆leancloud</p>
<p>2.找到结构话数据–comment<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/cloud.png" alt="流程"><br>3.将测试数据一一删掉</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>valine</tag>
      </tags>
  </entry>
  <entry>
    <title>开源堡垒机jumpserver安装部署</title>
    <url>/posts/20220114clhk6ptek0026csuj6oep77zn.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h1 id="临时高可用架构方案如下"><a href="#临时高可用架构方案如下" class="headerlink" title="临时高可用架构方案如下"></a>临时高可用架构方案如下</h1><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%A0%A1%E5%9E%92%E6%9C%BA.png" alt="流程"></p>
<p>一，安装mysql数据库</p>
<p>1 ，安装（步骤省略）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum -y localinstall http:<span class="comment">//mirrors.ustc.edu.cn/mysql-repo/mysql57-community-release-el7.rpm</span></span><br><span class="line"></span><br><span class="line">yum install -y mysql-community-server</span><br><span class="line"></span><br><span class="line">systemctl enable mysqld</span><br><span class="line"></span><br><span class="line">systemctl start mysqld</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> ，数据库授权</span><br><span class="line"></span><br><span class="line">mysql –uroot</span><br><span class="line"></span><br><span class="line">create database jumpserver <span class="keyword">default</span> charset <span class="string">&#x27;utf8&#x27;</span> ;</span><br><span class="line"></span><br><span class="line">set global validate_password_policy = LOW ;</span><br><span class="line"></span><br><span class="line">create user <span class="string">&#x27;jumpserver&#x27;</span> @<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27; z&amp;cemb2iqYPiC$N3&#x27;</span> ;</span><br><span class="line"></span><br><span class="line">grant all on jumpserver . * to <span class="string">&#x27;jumpserver&#x27;</span> @<span class="string">&#x27;%&#x27;</span> ;</span><br><span class="line"></span><br><span class="line">flush privileges ;</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>


<p>二，安装jumperver</p>
<p>1 ，下载安装包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd /data</span><br><span class="line"></span><br><span class="line">wget https:<span class="comment">//github.com/jumpserver/installer/releases/download/v2.16.3/jumpserver-installer-v2.16.3.tar.gz</span></span><br><span class="line"></span><br><span class="line">tar -xf jumpserver-installer-v2<span class="number">.16</span><span class="number">.3</span>.tar.gz</span><br><span class="line"></span><br><span class="line">cd jumpserver-installer-v2<span class="number">.16</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>
<p>2 ，调整配置模板</p>
<h1 id="根据需要修改配置文件模板-如果不清楚用途可以跳过修改"><a href="#根据需要修改配置文件模板-如果不清楚用途可以跳过修改" class="headerlink" title="根据需要修改配置文件模板, 如果不清楚用途可以跳过修改"></a>根据需要修改配置文件模板, 如果不清楚用途可以跳过修改</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat config-example.txt</span><br></pre></td></tr></table></figure>
<h1 id="以下设置如果为空系统会自动生成随机字符串填入"><a href="#以下设置如果为空系统会自动生成随机字符串填入" class="headerlink" title="以下设置如果为空系统会自动生成随机字符串填入"></a>以下设置如果为空系统会自动生成随机字符串填入</h1><h2 id="迁移请修改-SECRET-KEY-和-BOOTSTRAP-TOKEN-为原来的设置"><a href="#迁移请修改-SECRET-KEY-和-BOOTSTRAP-TOKEN-为原来的设置" class="headerlink" title="迁移请修改 SECRET_KEY 和 BOOTSTRAP_TOKEN 为原来的设置"></a>迁移请修改 SECRET_KEY 和 BOOTSTRAP_TOKEN 为原来的设置</h2><h2 id="完整参数文档-https-docs-jumpserver-org-zh-master-admin-guide-env"><a href="#完整参数文档-https-docs-jumpserver-org-zh-master-admin-guide-env" class="headerlink" title="完整参数文档 https://docs.jumpserver.org/zh/master/admin-guide/env/"></a>完整参数文档 <a href="https://docs.jumpserver.org/zh/master/admin-guide/env/">https://docs.jumpserver.org/zh/master/admin-guide/env/</a></h2><h2 id="MySQL-配置-USE-EXTERNAL-MYSQL-1-表示使用外置数据库-请输入正确的-MySQL-信息"><a href="#MySQL-配置-USE-EXTERNAL-MYSQL-1-表示使用外置数据库-请输入正确的-MySQL-信息" class="headerlink" title="MySQL 配置, USE_EXTERNAL_MYSQL=1 表示使用外置数据库, 请输入正确的 MySQL 信息"></a>MySQL 配置, USE_EXTERNAL_MYSQL=1 表示使用外置数据库, 请输入正确的 MySQL 信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">USE_EXTERNAL_MYSQL=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">DB_HOST= <span class="number">10.0</span><span class="number">.77</span><span class="number">.38</span></span><br><span class="line"></span><br><span class="line">DB_PORT= <span class="number">3306</span></span><br><span class="line"></span><br><span class="line">DB_USER= jumpserver</span><br><span class="line"></span><br><span class="line">DB_PASSWORD= z&amp;cemb2iqYPiC$N3</span><br><span class="line"></span><br><span class="line">DB_NAME= jumpserver</span><br><span class="line"></span><br><span class="line">  （ # 主要关注数据库相关配置文件）</span><br></pre></td></tr></table></figure>
<p>3 ，安装 jumpserver 服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[root<span class="meta">@jumpserver</span>-slave /data/jumpserver-installer-v2<span class="number">.16</span><span class="number">.3</span>]$ ./jmsctl.sh install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       ██╗██╗   ██╗███╗   ███╗██████╗ ███████╗███████╗██████╗ ██╗   ██╗███████╗██████╗</span><br><span class="line"></span><br><span class="line">       ██║██║   ██║████╗ ████║██╔══██╗██╔════╝██╔════╝██╔══██╗██║   ██║██╔════╝██╔══██╗</span><br><span class="line"></span><br><span class="line">       ██║██║   ██║██╔████╔██║██████╔╝███████╗█████╗  ██████╔╝██║   ██║█████╗  ██████╔╝</span><br><span class="line"></span><br><span class="line">  ██   ██║██║   ██║██║╚██╔╝██║██╔═══╝ ╚════██║██╔══╝  ██╔══██╗╚██╗ ██╔╝██╔══╝  ██╔══██╗</span><br><span class="line"></span><br><span class="line">  ╚█████╔╝╚██████╔╝██║ ╚═╝ ██║██║     ███████║███████╗██║  ██║ ╚████╔╝ ███████╗██║  ██║</span><br><span class="line"></span><br><span class="line">   ╚════╝  ╚═════╝ ╚═╝     ╚═╝╚═╝     ╚══════╝╚══════╝╚═╝  ╚═╝  ╚═══╝  ╚══════╝╚═╝  ╚═╝</span><br><span class="line"></span><br><span class="line">                                                                     Version:  v2<span class="number">.16</span><span class="number">.3</span></span><br><span class="line"></span><br><span class="line">需要手动操作的内容如下：</span><br><span class="line"></span><br><span class="line">    是否需要自定义 docker 存储目录, 默认将使用目录 /<span class="keyword">var</span>/lib/docker? (y/n)  (默认为 n): n</span><br><span class="line"></span><br><span class="line">    是否需要支持 IPv6? (y/n)  (默认为 n): n</span><br><span class="line"></span><br><span class="line">   是否需要自定义持久化存储, 默认将使用目录 /opt/jumpserver? (y/n)  (默认为 n): <span class="function">y</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   Persistent storage <span class="title">directory</span> <span class="params">(<span class="keyword">default</span> /opt/jumpserver)</span>: /data/jumpserver</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   是否使用外部 MySQL? <span class="params">(y/n)</span>  <span class="params">(默认为 n)</span>: y</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   请输入 MySQL 的主机地址 <span class="params">(无默认值)</span>: 10.0.77.38</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   请输入 MySQL 的端口 <span class="params">(默认为<span class="number">3306</span>)</span>: 3306</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   请输入 MySQL 的数据库<span class="params">(事先做好授权)</span> <span class="params">(默认为jumpserver)</span>: jumpserver</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   请输入 MySQL 的用户名 <span class="params">(无默认值)</span>: jumpserver</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   请输入 MySQL 的密码 <span class="params">(无默认值)</span>: z&amp;cemb2iqYPiC$N3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    是否使用外部 Redis? <span class="params">(y/n)</span>  <span class="params">(默认为 n)</span>: n</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    是否需要配置 JumpServer 对外访问端口? <span class="params">(y/n)</span>  <span class="params">(默认为 n)</span>: n</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<p>三，修改docker数据目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#默认docker安装的数据目录为/var/lib/docker，需要迁移到数据盘/data/目录下</span><br><span class="line"></span><br><span class="line">mv -f /var/lib/docker /data/docker</span><br><span class="line"></span><br><span class="line">ln -sf /data/docker /var/lib/docker</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>


<p>四，启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装完成后配置文件 /opt/jumpserver/config/config.txt</span><br><span class="line"></span><br><span class="line">cd /data/jumpserver-installer-v2.16.3</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line"></span><br><span class="line">./jmsctl.sh start</span><br><span class="line"></span><br><span class="line"># 其他常用操作</span><br><span class="line"></span><br><span class="line"># 停止</span><br><span class="line"></span><br><span class="line">./jmsctl.sh down</span><br><span class="line"></span><br><span class="line"># 卸载</span><br><span class="line"></span><br><span class="line">./jmsctl.sh uninstall</span><br><span class="line"></span><br><span class="line"># 帮助</span><br><span class="line"></span><br><span class="line">./jmsctl.sh –h</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>五，登录验证服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">登录：localhost</span><br><span class="line"></span><br><span class="line">默认账号：admin   默认密码：admin</span><br></pre></td></tr></table></figure>

<p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%A0%A1%E5%9E%92%E6%9C%BA1.png" alt="流程"></p>
<p>六，部署高可用jumpserver服务</p>
<p>另外一台服务器上部署jumpserver服务，连接第一台服务器得mysql数据库</p>
<p>部署步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ，下载安装包</span><br><span class="line"></span><br><span class="line">cd /data</span><br><span class="line"></span><br><span class="line">wget https://github.com/jumpserver/installer/releases/download/v2.16.3/jumpserver-installer-v2.16.3.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xf jumpserver-installer-v2.16.3.tar.gz</span><br><span class="line"></span><br><span class="line">cd jumpserver-installer-v2.16.3</span><br></pre></td></tr></table></figure>
<p>2 ，安装服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@jumpserver-slave /data/jumpserver-installer-v2.16.3]$ ./jmsctl.sh install</span><br><span class="line"></span><br><span class="line">是否需要自定义 docker 存储目录, 默认将使用目录 /var/lib/docker? (y/n)  (默认为 n): n</span><br><span class="line"></span><br><span class="line">是否需要支持 IPv6? (y/n)  (默认为 n): n</span><br><span class="line"></span><br><span class="line">是否需要自定义持久化存储, 默认将使用目录 /opt/jumpserver? (y/n)  (默认为 n): y</span><br><span class="line"></span><br><span class="line">   Persistent storage directory (default /opt/jumpserver): /data/jumpserver</span><br><span class="line"></span><br><span class="line">是否使用外部 MySQL? (y/n)  (默认为 n): y</span><br><span class="line"></span><br><span class="line">   请输入 MySQL 的主机地址 (无默认值): 10.0.77.38</span><br><span class="line"></span><br><span class="line">   请输入 MySQL 的端口 (默认为3306): 3306</span><br><span class="line"></span><br><span class="line">   请输入 MySQL 的数据库(事先做好授权) (默认为jumpserver): jumpserver</span><br><span class="line"></span><br><span class="line">   请输入 MySQL 的用户名 (无默认值): jumpserver</span><br><span class="line"></span><br><span class="line">   请输入 MySQL 的密码 (无默认值): z&amp;cemb2iqYPiC$N3</span><br></pre></td></tr></table></figure>
<p>3 ，修改 docker 默认数据目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv -f /var/lib/docker /data/docker</span><br><span class="line"></span><br><span class="line">ln -sf /data/docker /var/lib/docker</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>4 ，启动服务</p>
<h1 id="安装完成后配置文件-opt-jumpserver-config-config-txt"><a href="#安装完成后配置文件-opt-jumpserver-config-config-txt" class="headerlink" title="安装完成后配置文件 /opt/jumpserver/config/config.txt"></a>安装完成后配置文件 /opt/jumpserver/config/config.txt</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /opt/jumpserver-installer-v2.16.3</span><br></pre></td></tr></table></figure>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./jmsctl.sh start</span><br></pre></td></tr></table></figure></div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>堡垒机</tag>
      </tags>
  </entry>
  <entry>
    <title>还在手动维护Yapi?</title>
    <url>/posts/20220106clhk6ptep002lcsujbumq0ey0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="readmore-container"><h1 id="【置顶】-留言请点击友链留言室或者在文章底部留言"><a href="#【置顶】-留言请点击友链留言室或者在文章底部留言" class="headerlink" title="【置顶】 留言请点击友链留言室或者在文章底部留言"></a>【置顶】 留言请点击友链留言室或者在文章底部留言</h1><p>因前后端人员通过接口定义字段，返回值等对接时非常苦恼，没有一个很好的平台维护，后端每次迭代都要写开发文档，需求变化，多系统联调等，给前后端联调造成阻塞。</p>
<h1 id="1、后端开发文档编写规范"><a href="#1、后端开发文档编写规范" class="headerlink" title="1、后端开发文档编写规范"></a>1、后端开发文档编写规范</h1><p>1）文档模板统一使用：xxx系统开发文档-模板.docx<br>2）后端每次迭代需要编写开发文档，并进行技术评审（前端、后端、测试、产品参与）<br>3）文档的命名方式：《产品名称-V版本号-设计开发文档-编写人》<br>4) 文档统一保存<br>5）后端必须在编写业务代码前，优先设计API（Swagger），并提供给测试和前端，最大化并行迭代。<br>6）允许特殊情况延期提供API，如：需求变化、多系统联调等。</p>
<h1 id="Swagger使用规范"><a href="#Swagger使用规范" class="headerlink" title="Swagger使用规范"></a>Swagger使用规范</h1><p>1）后端开发人员必须使用Swagger<br>2）API接口定义参数时，要明确备注信息和是否必须，样例如下：<br>public class SupplierReq {<br>   @NotEmpty(message = “姓名必填”)<br>   @ApiModelProperty(value = “员工姓名”, required = true)<br>   private String name;</p>
<p>   @Size(min = 6, max = 64, message = “手机号或工号不能为空，长度介于6~64之间”)<br>   @ApiModelProperty(value = “手机号”, required = true)<br>   private String telephone;<br>}<br>3）API定义业务方法时(Controller层)，使用Swagger注解@ApiOperation明确业务方法信息，样例如下：<br>@PostMapping(“/updateCatRateLimit”)<br>@ApiOperation(“设置监控项流控QPS”)<br>public CommonResponse<String> updateCatRateLimit(@RequestBody Req req) {<br>    return super.visit(() -&gt; mcenterRateLimitService.updateCatRateLimit(req));<br>}<br>具体swagger详细接口请参考：<a href="https://swagger.io/docs/">https://swagger.io/docs/</a></String></p>
<h1 id="后端接口输出太慢？"><a href="#后端接口输出太慢？" class="headerlink" title="后端接口输出太慢？"></a>后端接口输出太慢？</h1><p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/image.png" alt="流程"><br>当接到新需求，进行产品需求评审–&gt;技术文档编写–&gt;数据库设计–&gt;业务梳理–&gt;测试用例评审等等流程下来，很难在短时间内给出接口，但即便如此，我也没听说过谁会因为后端给不出接口耽误前端开发进度<br>为了更快速的输出接口等响应，推荐api管理工具APIpost,swagger,Yapi等~<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/apipost.png" alt="apipost"></p>
<h1 id="Swagger遇见Yapi"><a href="#Swagger遇见Yapi" class="headerlink" title="Swagger遇见Yapi"></a>Swagger遇见Yapi</h1><h3 id="一-YapiUpload"><a href="#一-YapiUpload" class="headerlink" title="一 YapiUpload"></a>一 YapiUpload</h3><p>1、在IDEA-&gt;Preferences-&gt;Plugins中 输入YapiUpload插件，点击Install，重启IDEA后可以使用。<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/a4a92829-a7d3-4758-ad34-6b715fd4bd05.png" alt="流程"><br>2、配置项目<br>在我们已经从git同步的项目，打开.idea文件夹下的misc.xml，添加如下配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;component name=<span class="string">&quot;yapi&quot;</span>&gt;</span><br><span class="line">  &lt;option name=<span class="string">&quot;projectToken&quot;</span>&gt;yapi中获取项目token&lt;/option&gt;</span><br><span class="line">  &lt;option name=<span class="string">&quot;projectId&quot;</span>&gt;项目ID&lt;/option&gt;</span><br><span class="line">  &lt;option name=<span class="string">&quot;yapiUrl&quot;</span>&gt;http:<span class="comment">//mock.xxx.com&lt;/option&gt;</span></span><br><span class="line">  &lt;option name=<span class="string">&quot;projectType&quot;</span>&gt;api&lt;/option&gt;</span><br><span class="line">&lt;/component&gt;</span><br></pre></td></tr></table></figure>
<p>完整配置如下所示:<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE.png" alt="流程"><br> 获取配置信息:<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE.png" alt="流程"><br>3、接口上传<br>这一步是我们日常工作经常使用的操作，在我们编写好的接口类文件中，我们只需选中类名或者选中要上传接口的方法名右键选择“UploadToYapi”，两者的区别是，选择类名会上传此类中的全部接口，选择方法名仅上传单个接口，按需选择即可。参数非空需要加入 @NotNull或@NotEmpty。如果需要将接口传入指定目录下，需要在类上添加注释</p>
<p><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/c6418ea5-b7e2-41de-9582-3e82e717a8a9.png" alt="流程"></p>
<h3 id="批量上传"><a href="#批量上传" class="headerlink" title="批量上传"></a>批量上传</h3><p>将本地或者服务器环境生成的swagger.doc/swagger.json地址复制<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/import.png" alt="上传"><br>即可批量上传至Yapi~</p>
</div>

			<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
			<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
				try {
					var plugin = new ReadmorePlugin();
					plugin.init({
						"type": "hexo",
						"id": "readmore-container",
						"name": "赵KK日常技术记录",
						"blogId": "62435-1742912502174-081",
						"qrcode": "https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/999.png",
						"keyword": "验证码",
						"random": "1",
						"height": "auto",
						"expires": "7",
						"lockToc": "yes",
						"interval": "60",
						"baseUrl": ""
					});
				} catch(e) {
					console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
				}
			}
			</script>
		]]></content>
      <tags>
        <tag>Yapi</tag>
      </tags>
  </entry>
</search>
