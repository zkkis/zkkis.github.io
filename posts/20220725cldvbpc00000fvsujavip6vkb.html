<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Mysql海量数据存储与优化 | 赵KK的个人博客</title>
  <meta name="description" content="我坚信，机会永远属于有准备的人，我们与其羡慕他人的成功，不如从此刻起，积累足够多的知识和面试经验，为将来进入更好的公司做充足的准备本片文章将会根据资料学习深入Mysql的设计与优化1、Mysql基础知识 2、Mysql架构原理和存储机制 3、Mysql高可用方案 4、Mysql企业面试真题分享 Mysql基础知识MySQL起源和分支MySQL 是最流行的关系型数据库软件之一，由于其体积小、速度快、">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql海量数据存储与优化">
<meta property="og:url" content="https://zkkget.github.io/posts/20220725cldvbpc00000fvsujavip6vkb.html">
<meta property="og:site_name" content="赵KK个人博客第三站">
<meta property="og:description" content="我坚信，机会永远属于有准备的人，我们与其羡慕他人的成功，不如从此刻起，积累足够多的知识和面试经验，为将来进入更好的公司做充足的准备本片文章将会根据资料学习深入Mysql的设计与优化1、Mysql基础知识 2、Mysql架构原理和存储机制 3、Mysql高可用方案 4、Mysql企业面试真题分享 Mysql基础知识MySQL起源和分支MySQL 是最流行的关系型数据库软件之一，由于其体积小、速度快、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql1.jpg">
<meta property="og:image" content="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql2.jpg">
<meta property="og:image" content="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql3.jpg">
<meta property="og:image" content="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql4.jpg">
<meta property="og:image" content="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql5.jpg">
<meta property="og:image" content="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql6.jpg">
<meta property="article:published_time" content="2022-07-25T08:17:47.000Z">
<meta property="article:modified_time" content="2022-07-25T08:24:40.644Z">
<meta property="article:author" content="赵KK">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql1.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://zkkget.github.io/posts/20220725cldvbpc00000fvsujavip6vkb.html">
  
    <link rel="alternate" href="/atom.xml" title="赵KK个人博客第三站" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://kkget.github.io/" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">赵kk</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">java Developer &amp; pm</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 北京, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://kkget.github.io/" target="_blank" title="主站博客" data-toggle=tooltip data-placement=top><i class="icon icon-主站博客"></i></a></li>
        
        <li><a href="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.png" target="_blank" title="公众号" data-toggle=tooltip data-placement=top><i class="icon icon-公众号"></i></a></li>
        
        <li><a href="https://cloud.tencent.com/developer/inventory/14725" target="_blank" title="云+社区" data-toggle=tooltip data-placement=top><i class="icon icon-云+社区"></i></a></li>
        
        <li><a href="/1462018576" target="_blank" title="QQ" data-toggle=tooltip data-placement=top><i class="icon icon-QQ"></i></a></li>
        
    </ul>

    </nav>
  </div>
  <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
  <style>
      .pace .pace-progress {
          background: #1E92FB; /*进度条颜色*/
          height: 3px;
      }
      .pace .pace-progress-inner {
           box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
      }
      .pace .pace-activity {
          border-top-color: #1E92FB;    /*上边框颜色*/
          border-left-color: #1E92FB;    /*左边框颜色*/
      }
  </style>

</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>有问题可搜索</br>个人公众号<赵KK日常技术记录></br>或联系作者进行沟通!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MQ/">MQ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud-Nacos/">SpringCloud Nacos</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Springboot/">Springboot</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode/">leetcode</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/">并发编程专题</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CompletableFuture/" rel="tag">CompletableFuture</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ContainsAll/" rel="tag">ContainsAll</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSON/" rel="tag">JSON</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JunitTest/" rel="tag">JunitTest</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode%E7%AE%97%E6%B3%95%E9%A2%98/" rel="tag">Leetcode算法题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/List%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4/" rel="tag">List遍历删除</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/" rel="tag">MQ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud-Nacos/" rel="tag">SpringCloud Nacos</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloudAlibaba/" rel="tag">SpringCloudAlibaba</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Springboot/" rel="tag">Springboot</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thymleaf/" rel="tag">Thymleaf</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yapi/" rel="tag">Yapi</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/opencv/" rel="tag">opencv</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/valine/" rel="tag">valine</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%A1%E5%9E%92%E6%9C%BA/" rel="tag">堡垒机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E6%88%98/" rel="tag">实战</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/" rel="tag">并发编程专题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag">面经</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/" rel="tag">面试,字节跳动</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/CompletableFuture/" style="font-size: 13px;">CompletableFuture</a> <a href="/tags/ContainsAll/" style="font-size: 13px;">ContainsAll</a> <a href="/tags/JSON/" style="font-size: 13px;">JSON</a> <a href="/tags/JunitTest/" style="font-size: 13px;">JunitTest</a> <a href="/tags/Leetcode%E7%AE%97%E6%B3%95%E9%A2%98/" style="font-size: 13px;">Leetcode算法题</a> <a href="/tags/List%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4/" style="font-size: 13px;">List遍历删除</a> <a href="/tags/MQ/" style="font-size: 13px;">MQ</a> <a href="/tags/MySQL/" style="font-size: 13px;">MySQL</a> <a href="/tags/Mysql/" style="font-size: 13.5px;">Mysql</a> <a href="/tags/Nginx/" style="font-size: 13px;">Nginx</a> <a href="/tags/SpringCloud-Nacos/" style="font-size: 13px;">SpringCloud Nacos</a> <a href="/tags/SpringCloudAlibaba/" style="font-size: 13px;">SpringCloudAlibaba</a> <a href="/tags/Springboot/" style="font-size: 13.5px;">Springboot</a> <a href="/tags/Thymleaf/" style="font-size: 13px;">Thymleaf</a> <a href="/tags/Yapi/" style="font-size: 13px;">Yapi</a> <a href="/tags/leetcode/" style="font-size: 14px;">leetcode</a> <a href="/tags/opencv/" style="font-size: 13px;">opencv</a> <a href="/tags/valine/" style="font-size: 13px;">valine</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 13px;">事务</a> <a href="/tags/%E5%A0%A1%E5%9E%92%E6%9C%BA/" style="font-size: 13px;">堡垒机</a> <a href="/tags/%E5%AE%9E%E6%88%98/" style="font-size: 13px;">实战</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/" style="font-size: 13px;">并发编程专题</a> <a href="/tags/%E9%9D%A2%E7%BB%8F/" style="font-size: 13px;">面经</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13.5px;">面试</a> <a href="/tags/%E9%9D%A2%E8%AF%95-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/" style="font-size: 13px;">面试,字节跳动</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/">并发编程专题</a>
              </p>
              <p class="item-title">
                <a href="/posts/20230207a1.html" class="title">java并发编程专题连载系列</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-07T06:14:39.000Z" itemprop="datePublished">2023-02-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a>
              </p>
              <p class="item-title">
                <a href="/posts/20221018a1.html" class="title">字节跳动｜字节客户端｜一二三面+hr面（已Offer）</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-18T06:23:27.000Z" itemprop="datePublished">2022-10-18</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/leetcode/">leetcode</a>
              </p>
              <p class="item-title">
                <a href="/posts/20221012a1.html" class="title">LeetCode每日一题之817题链表组件</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-12T06:12:47.000Z" itemprop="datePublished">2022-10-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/leetcode/">leetcode</a>
              </p>
              <p class="item-title">
                <a href="/posts/20221009a1.html" class="title">LeetCode856括号的分数</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-09T03:19:44.000Z" itemprop="datePublished">2022-10-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/leetcode/">leetcode</a>
              </p>
              <p class="item-title">
                <a href="/posts/20221008a1.html" class="title">leetCode870题田忌赛马</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-08T09:09:46.000Z" itemprop="datePublished">2022-10-08</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-Mysql海量数据存储与优化" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Mysql海量数据存储与优化
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/20220725cldvbpc00000fvsujavip6vkb.html" class="article-date">
	  <time datetime="2022-07-25T08:17:47.000Z" itemprop="datePublished">2022-07-25</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/Mysql/" rel="tag">Mysql</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/20220725cldvbpc00000fvsujavip6vkb.html#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 22.3k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 81(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>我坚信，机会永远属于有准备的人，我们与其羡慕他人的成功，不如从此刻起，积累足够多的知识和面试经验，为将来进入更好的公司做充足的准备<br>本片文章将会根据资料学习深入Mysql的设计与优化<br>1、Mysql基础知识</p>
<p>2、Mysql架构原理和存储机制</p>
<p>3、Mysql高可用方案</p>
<p>4、Mysql企业面试真题分享</p>
<p>Mysql基础知识<br>MySQL起源和分支<br>MySQL 是最流行的关系型数据库软件之一，由于其体积小、速度快、开源免费、简单易用、维护成本<br>低等，在集群架构中易于扩展、高可用，因此深受开发者和企业的欢迎。<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql1.jpg" alt="流程"><br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql2.jpg" alt="流程"></p>
<p>MySQL体系架构<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql3.jpg" alt="流程"></p>
<p>MySQL Server架构自顶向下大致可以分网络连接层、服务层、存储引擎层和系统文件层。<br>一、网络连接层<br>客户端连接器（Client Connectors）：提供与MySQL服务器建立的支持。目前几乎支持所有主流<br>的服务端编程技术，例如常见的 Java、C、Python、.NET等，它们通过各自API技术与MySQL建立<br>连接。<br>二、服务层（MySQL Server）<br>服务层是MySQL Server的核心，主要包含系统管理和控制工具、连接池、SQL接口、解析器、查询优<br>化器和缓存六个部分。<br>连接池（Connection Pool）：负责存储和管理客户端与数据库的连接，一个线程负责管理一个连接。<br>系统管理和控制工具（Management Services &amp; Utilities）：例如备份恢复、安全管理、集群<br>管理等<br>SQL接口（SQL Interface）：用于接受客户端发送的各种SQL命令，并且返回用户需要查询的结<br>果。比如DML、DDL、存储过程、视图、触发器等。<br>解析器（Parser）：负责将请求的SQL解析生成一个”解析树”。然后根据一些MySQL规则进一步<br>检查解析树是否合法。<br>查询优化器（Optimizer）：当“解析树”通过解析器语法检查后，将交由优化器将其转化成执行计<br>划，然后与存储引擎交互。<br>select uid,name from user where gender=1;<br>选取–》投影–》联接 策略<br>1）select先根据where语句进行选取，并不是查询出全部数据再过滤<br>2）select查询根据uid和name进行属性投影，并不是取出所有字段<br>3）将前面选取和投影联接起来最终生成查询结果<br>缓存（Cache&amp;Buffer）： 缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，权限缓<br>存，引擎缓存等。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。<br>三、存储引擎层（Pluggable Storage Engines）<br>存储引擎负责MySQL中数据的存储与提取，与底层系统文件进行交互。MySQL存储引擎是插件式的，<br>服务器中的查询执行引擎通过接口与存储引擎进行通信，接口屏蔽了不同存储引擎之间的差异 。现在有<br>很多种存储引擎，各有各的特点，最常见的是MyISAM和InnoDB。<br>四、系统文件层（File System）<br>该层负责将数据库的数据和日志存储在文件系统之上，并完成与存储引擎的交互，是文件的物理存储<br>层。主要包含日志文件，数据文件，配置文件，pid 文件，socket 文件等。<br>日志文件<br>错误日志（Error log）<br>默认开启，show variables like ‘%log_error%’<br>通用查询日志（General query log）<br>记录一般查询语句，show variables like ‘%general%’;<br>二进制日志（binary log）<br>记录了对MySQL数据库执行的更改操作，并且记录了语句的发生时间、执行时长；但是它不<br>记录select、show等不修改数据库的SQL。主要用于数据库恢复和主从复制。<br>show variables like ‘%log_bin%’; //是否开启<br>show variables like ‘%binlog%’; //参数查看<br>show binary logs;//查看日志文件<br>慢查询日志（Slow query log）<br>记录所有执行时间超时的查询SQL，默认是10秒。<br>show variables like ‘%slow_query%’; //是否开启<br>show variables like ‘%long_query_time%’; //时长<br>配置文件<br>用于存放MySQL所有的配置信息文件，比如my.cnf、my.ini等。<br>数据文件<br>db.opt 文件：记录这个库的默认使用的字符集和校验规则。<br>frm 文件：存储与表相关的元数据（meta）信息，包括表结构的定义信息等，每一张表都会<br>有一个frm 文件。<br>MYD 文件：MyISAM 存储引擎专用，存放 MyISAM 表的数据（data)，每一张表都会有一个<br>.MYD 文件。<br>MYI 文件：MyISAM 存储引擎专用，存放 MyISAM 表的索引相关信息，每一张 MyISAM 表对<br>应一个 .MYI 文件。<br>ibd文件和 IBDATA 文件：存放 InnoDB 的数据文件（包括索引）。InnoDB 存储引擎有两种<br>表空间方式：独享表空间和共享表空间。独享表空间使用 .ibd 文件来存放数据，且每一张<br>InnoDB 表对应一个 .ibd 文件。共享表空间使用 .ibdata 文件，所有表共同使用一个（或多<br>个，自行配置）.ibdata 文件。<br>ibdata1 文件：系统表空间数据文件，存储表元数据、Undo日志等 。<br>ib_logfile0、ib_logfile1 文件：Redo log 日志文件。<br>pid 文件<br>pid 文件是 mysqld 应用程序在 Unix/Linux 环境下的一个进程文件，和许多其他 Unix/Linux 服务<br>端程序一样，它存放着自己的进程 id。<br>socket 文件<br>socket 文件也是在 Unix/Linux 环境下才有的，用户在 Unix/Linux 环境下客户端连接可以不通过<br>TCP/IP 网络而直接使用 Unix Socket 来连接 MySQL</p>
<p>MySQL运行机制<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql4.jpg" alt="流程"></p>
<p>①建立连接（Connectors&amp;Connection Pool），通过客户端/服务器通信协议与MySQL建立连<br>接。MySQL 客户端与服务端的通信方式是 “ 半双工 ”。对于每一个 MySQL 的连接，时刻都有一个<br>线程状态来标识这个连接正在做什么。<br>通讯机制：<br>全双工：能同时发送和接收数据，例如平时打电话。<br>半双工：指的某一时刻，要么发送数据，要么接收数据，不能同时。例如早期对讲机<br>单工：只能发送数据或只能接收数据。例如单行道<br>线程状态：<br>show processlist; //查看用户正在运行的线程信息，root用户能查看所有线程，其他用户只能看自<br>己的<br>id：线程ID，可以使用kill xx；<br>user：启动这个线程的用户<br>Host：发送请求的客户端的IP和端口号<br>db：当前命令在哪个库执行<br>Command：该线程正在执行的操作命令<br>Create DB：正在创建库操作<br>Drop DB：正在删除库操作<br>Execute：正在执行一个PreparedStatement<br>Close Stmt：正在关闭一个PreparedStatement<br>Query：正在执行一个语句<br>Sleep：正在等待客户端发送语句<br>Quit：正在退出<br>Shutdown：正在关闭服务器<br>Time：表示该线程处于当前状态的时间，单位是秒<br>State：线程状态<br>Updating：正在搜索匹配记录，进行修改<br>Sleeping：正在等待客户端发送新请求<br>Starting：正在执行请求处理<br>Checking table：正在检查数据表<br>Closing table : 正在将表中数据刷新到磁盘中<br>Locked：被其他查询锁住了记录<br>Sending Data：正在处理Select查询，同时将结果发送给客户端<br>Info：一般记录线程执行的语句，默认显示前100个字符。想查看完整的使用show full<br>processlist;<br>②查询缓存（Cache&amp;Buffer），这是MySQL的一个可优化查询的地方，如果开启了查询缓存且在<br>查询缓存过程中查询到完全相同的SQL语句，则将查询结果直接返回给客户端；如果没有开启查询<br>缓存或者没有查询到完全相同的 SQL 语句则会由解析器进行语法语义解析，并生成“解析树”。<br>缓存Select查询的结果和SQL语句<br>执行Select查询时，先查询缓存，判断是否存在可用的记录集，要求是否完全相同（包括参<br>数值），这样才会匹配缓存数据命中。<br>即使开启查询缓存，以下SQL也不能缓存<br>查询语句使用SQL_NO_CACHE<br>查询的结果大于query_cache_limit设置<br>查询中有一些不确定的参数，比如now()<br>show variables like ‘%query_cache%’; //查看查询缓存是否启用，空间大小，限制等<br>show status like ‘Qcache%’; //查看更详细的缓存参数，可用缓存空间，缓存块，缓存多少等<br>③解析器（Parser）将客户端发送的SQL进行语法解析，生成”解析树”。预处理器根据一些MySQL<br>规则进一步检查“解析树”是否合法，例如这里将检查数据表和数据列是否存在，还会解析名字和别<br>名，看看它们是否有歧义，最后生成新的“解析树”。<br>④查询优化器（Optimizer）根据“解析树”生成最优的执行计划。MySQL使用很多优化策略生成最<br>优的执行计划，可以分为两类：静态优化（编译时优化）、动态优化（运行时优化）。<br>等价变换策略<br>5=5 and a&gt;5 改成 a &gt; 5<br>a &lt; b and a=5 改成b&gt;5 and a=5<br>基于联合索引，调整条件位置等<br>优化count、min、max等函数<br>InnoDB引擎min函数只需要找索引最左边<br>InnoDB引擎max函数只需要找索引最右边<br>MyISAM引擎count(*)，不需要计算，直接返回<br>提前终止查询<br>使用了limit查询，获取limit所需的数据，就不在继续遍历后面数据<br>in的优化<br>MySQL对in查询，会先进行排序，再采用二分法查找数据。比如where id in (2,1,3)，变<br>成 in (1,2,3)<br>⑤查询执行引擎负责执行 SQL 语句，此时查询执行引擎会根据 SQL 语句中表的存储引擎类型，以<br>及对应的API接口与底层存储引擎缓存或者物理文件的交互，得到查询结果并返回给客户端。若开<br>启用查询缓存，这时会将SQL 语句和结果完整地保存到查询缓存（Cache&amp;Buffer）中，以后若有<br>相同的 SQL 语句执行则直接返回结果。<br>如果开启了查询缓存，先将查询结果做缓存操作<br>返回结果过多，采用增量模式返回</p>
<p>MySQL存储引擎<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql5.jpg" alt="流程"></p>
<p>存储引擎在MySQL的体系架构中位于第三层，负责MySQL中的数据的存储和提取，是与文件打交道的<br>子系统，它是根据MySQL提供的文件访问层抽象接口定制的一种文件访问机制，这种机制就叫作存储引<br>擎。<br>使用show engines命令，就可以查看当前数据库支持的引擎信息。<br>在5.5版本之前默认采用MyISAM存储引擎，从5.5开始采用InnoDB存储引擎。<br>InnoDB：支持事务，具有提交，回滚和崩溃恢复能力，事务安全<br>MyISAM：不支持事务和外键，访问速度快<br>Memory：利用内存创建表，访问速度非常快，因为数据在内存，而且默认使用Hash索引，但是<br>一旦关闭，数据就会丢失<br>Archive：归档类型引擎，仅能支持insert和select语句<br>Csv：以CSV文件进行数据存储，由于文件限制，所有列必须强制指定not null，另外CSV引擎也不<br>支持索引和分区，适合做数据交换的中间表<br>BlackHole: 黑洞，只进不出，进来消失，所有插入数据都不会保存<br>Federated：可以访问远端MySQL数据库中的表。一个本地表，不保存数据，访问远程表内容。<br>MRG_MyISAM：一组MyISAM表的组合，这些MyISAM表必须结构相同，Merge表本身没有数据，<br>对Merge操作可以对一组MyISAM表进行操作。<br>3.1 InnoDB和MyISAM对比<br>InnoDB和MyISAM是使用MySQL时最常用的两种引擎类型，我们重点来看下两者区别。<br>事务和外键<br>InnoDB支持事务和外键，具有安全性和完整性，适合大量insert或update操作<br>MyISAM不支持事务和外键，它提供高速存储和检索，适合大量的select查询操作<br>锁机制<br>InnoDB支持行级锁，锁定指定记录。基于索引来加锁实现。<br>MyISAM支持表级锁，锁定整张表。<br>索引结构<br>InnoDB使用聚集索引（聚簇索引），索引和记录在一起存储，既缓存索引，也缓存记录。<br>MyISAM使用非聚集索引（非聚簇索引），索引和记录分开。<br>并发处理能力<br>MyISAM使用表锁，会导致写操作并发率低，读之间并不阻塞，读写阻塞。<br>InnoDB读写阻塞可以与隔离级别有关，可以采用多版本并发控制（MVCC）来支持高并发<br>存储文件<br>InnoDB表对应两个文件，一个.frm表结构文件，一个.ibd数据文件。InnoDB表最大支持64TB；<br>MyISAM表对应三个文件，一个.frm表结构文件，一个MYD表数据文件，一个.MYI索引文件。从<br>MySQL5.0开始默认限制是256TB。<br>适用场景<br>MyISAM<br>不需要事务支持（不支持）<br>并发相对较低（锁定机制问题）<br>数据修改相对较少，以读为主<br>数据一致性要求不高<br>InnoDB<br>需要事务支持（具有较好的事务特性）<br>行级锁定对高并发有很好的适应能力<br>数据更新较为频繁的场景<br>数据一致性要求较高<br>硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，减少磁盘IO<br>总结<br>两种引擎该如何选择？<br>是否需要事务？有，InnoDB<br>是否存在并发修改？有，InnoDB<br>是否追求快速查询，且数据修改少？是，MyISAM<br>在绝大多数情况下，推荐使用InnoDB</p>
<p>InnoDB存储结构<br>从MySQL 5.5版本开始默认使用InnoDB作为引擎，它擅长处理事务，具有自动崩溃恢复的特性，在日<br>常开发中使用非常广泛。下面是官方的InnoDB引擎架构图，主要分为内存结构和磁盘结构两大部分</p>
<p>内存结构主要包括Buffer Pool、Change Buffer、Adaptive Hash Index和Log Buffer四大组件。<br>Buffer Pool：缓冲池，简称BP。BP以Page页为单位，默认大小16K，BP的底层采用链表数<br>据结构管理Page。在InnoDB访问表记录和索引时会在Page页中缓存，以后使用可以减少磁<br>盘IO操作，提升效率。<br>Page管理机制<br>Page根据状态可以分为三种类型：<br>free page ： 空闲page，未被使用<br>clean page：被使用page，数据没有被修改过<br>dirty page：脏页，被使用page，数据被修改过，页中数据和磁盘的数据产生了不<br>一致<br>针对上述三种page类型，InnoDB通过三种链表结构来维护和管理<br>free list ：表示空闲缓冲区，管理free page<br>flush list：表示需要刷新到磁盘的缓冲区，管理dirty page，内部page按修改时间<br>排序。脏页即存在于flush链表，也在LRU链表中，但是两种互不影响，LRU链表负<br>责管理page的可用性和释放，而flush链表负责管理脏页的刷盘操作。<br>lru list：表示正在使用的缓冲区，管理clean page和dirty page，缓冲区以<br>midpoint为基点，前面链表称为new列表区，存放经常访问的数据，占63%；后<br>面的链表称为old列表区，存放使用较少数据，占37%。<br>改进型LRU算法维护<br>普通LRU：末尾淘汰法，新数据从链表头部加入，释放空间时从末尾淘汰<br>改性LRU：链表分为new和old两个部分，加入元素时并不是从表头插入，而是从中间<br>midpoint位置插入，如果数据很快被访问，那么page就会向new列表头部移动，如果<br>数据没有被访问，会逐步向old尾部移动，等待淘汰。<br>每当有新的page数据读取到buffer pool时，InnoDb引擎会判断是否有空闲页，是否足<br>够，如果有就将free page从free list列表删除，放入到LRU列表中。没有空闲页，就会<br>根据LRU算法淘汰LRU链表默认的页，将内存空间释放分配给新的页。<br>Buffer Pool配置参数<br>show variables like ‘%innodb_page_size%’; //查看page页大小<br>show variables like ‘%innodb_old%’; //查看lru list中old列表参数<br>show variables like ‘%innodb_buffer%’; //查看buffer pool参数<br>建议：将innodb_buffer_pool_size设置为总内存大小的60%-80%，<br>innodb_buffer_pool_instances可以设置为多个，这样可以避免缓存争夺。<br>Change Buffer：写缓冲区，简称CB。在进行DML操作时，如果BP没有其相应的Page数据，<br>并不会立刻将磁盘页加载到缓冲池，而是在CB记录缓冲变更，等未来数据被读取时，再将数<br>据合并恢复到BP中。<br>ChangeBuffer占用BufferPool空间，默认占25%，最大允许占50%，可以根据读写业务量来<br>进行调整。参数innodb_change_buffer_max_size;<br>当更新一条记录时，该记录在BufferPool存在，直接在BufferPool修改，一次内存操作。如<br>果该记录在BufferPool不存在（没有命中），会直接在ChangeBuffer进行一次内存操作，不<br>用再去磁盘查询数据，避免一次磁盘IO。当下次查询记录时，会先进性磁盘读取，然后再从<br>ChangeBuffer中读取信息合并，最终载入BufferPool中。<br>写缓冲区，仅适用于非唯一普通索引页，为什么？<br>如果在索引设置唯一性，在进行修改时，InnoDB必须要做唯一性校验，因此必须查询磁盘，<br>做一次IO操作。会直接将记录查询到BufferPool中，然后在缓冲池修改，不会在<br>ChangeBuffer操作。<br>Adaptive Hash Index：自适应哈希索引，用于优化对BP数据的查询。InnoDB存储引擎会监<br>控对表索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，所以<br>称之为自适应。InnoDB存储引擎会自动根据访问的频率和模式来为某些页建立哈希索引。<br>Log Buffer：日志缓冲区，用来保存要写入磁盘上log文件（Redo/Undo）的数据，日志缓冲<br>区的内容定期刷新到磁盘log文件中。日志缓冲区满时会自动将其刷新到磁盘，当遇到BLOB<br>或多行更新的大事务操作时，增加日志缓冲区可以节省磁盘I/O。<br>LogBuffer主要是用于记录InnoDB引擎日志，在DML操作时会产生Redo和Undo日志。<br>LogBuffer空间满了，会自动写入磁盘。可以通过将innodb_log_buffer_size参数调大，减少<br>磁盘IO频率<br>innodb_flush_log_at_trx_commit参数控制日志刷新行为，默认为1<br>0 ： 每隔1秒写日志文件和刷盘操作（写日志文件LogBuffer–&gt;OS cache，刷盘OS<br>cache–&gt;磁盘文件），最多丢失1秒数据<br>1：事务提交，立刻写日志文件和刷盘，数据不丢失，但是会频繁IO操作<br>2：事务提交，立刻写日志文件，每隔1秒钟进行刷盘操作</p>
<p>InnoDB磁盘结构<br>InnoDB磁盘主要包含Tablespaces，InnoDB Data Dictionary，Doublewrite Buffer、Redo Log<br>和Undo Logs。<br>表空间（Tablespaces）：用于存储表结构和数据。表空间又分为系统表空间、独立表空间、<br>通用表空间、临时表空间、Undo表空间等多种类型；<br>系统表空间（The System Tablespace）<br>包含InnoDB数据字典，Doublewrite Buffer，Change Buffer，Undo Logs的存储区<br>域。系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。系统表空<br>间是一个共享的表空间因为它是被多个表共享的。该空间的数据文件通过参数<br>innodb_data_file_path控制，默认值是ibdata1:12M:autoextend(文件名为ibdata1、<br>12MB、自动扩展)。<br>独立表空间（File-Per-Table Tablespaces）<br>默认开启，独立表空间是一个单表表空间，该表创建于自己的数据文件中，而非创建于<br>系统表空间中。当innodb_file_per_table选项开启时，表将被创建于表空间中。否则，<br>innodb将被创建于系统表空间中。每个表文件表空间由一个.ibd数据文件代表，该文件<br>默认被创建于数据库目录中。表空间的表文件支持动态（dynamic）和压缩<br>（commpressed）行格式。<br>通用表空间（General Tablespaces）<br>通用表空间为通过create tablespace语法创建的共享表空间。通用表空间可以创建于<br>mysql数据目录外的其他表空间，其可以容纳多张表，且其支持所有的行格式。<br>撤销表空间（Undo Tablespaces）<br>撤销表空间由一个或多个包含Undo日志文件组成。在MySQL 5.7版本之前Undo占用的<br>是System Tablespace共享区，从5.7开始将Undo从System Tablespace分离了出来。<br>InnoDB使用的undo表空间由innodb_undo_tablespaces配置选项控制，默认为0。参<br>数值为0表示使用系统表空间ibdata1;大于0表示使用undo表空间undo_001、<br>undo_002等。<br>临时表空间（Temporary Tablespaces） CREATE TABLESPACE ts1 ADD DATAFILE ts1.ibd Engine=InnoDB; //创建表空 间ts1 CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1; //将表添加到ts1 表空间<br>分为session temporary tablespaces 和global temporary tablespace两种。session<br>temporary tablespaces 存储的是用户创建的临时表和磁盘内部的临时表。global<br>temporary tablespace储存用户临时表的回滚段（rollback segments ）。mysql服务<br>器正常关闭或异常终止时，临时表空间将被移除，每次启动时会被重新创建。<br>数据字典（InnoDB Data Dictionary）<br>InnoDB数据字典由内部系统表组成，这些表包含用于查找表、索引和表字段等对象的元数<br>据。元数据物理上位于InnoDB系统表空间中。由于历史原因，数据字典元数据在一定程度上<br>与InnoDB表元数据文件（.frm文件）中存储的信息重叠。<br>双写缓冲区（Doublewrite Buffer）<br>位于系统表空间，是一个存储区域。在BufferPage的page页刷新到磁盘真正的位置前，会先<br>将数据存在Doublewrite 缓冲区。如果在page页写入过程中出现操作系统、存储子系统或<br>mysqld进程崩溃，InnoDB可以在崩溃恢复期间从Doublewrite 缓冲区中找到页面的一个好<br>备份。在大多数情况下，默认情况下启用双写缓冲区，要禁用Doublewrite 缓冲区，可以将<br>innodb_doublewrite设置为0。使用Doublewrite 缓冲区时建议将innodb_flush_method设<br>置为O_DIRECT。<br>MySQL的innodb_flush_method这个参数控制着innodb数据文件及redo log的打开、<br>刷写模式。有三个值：fdatasync(默认)，O_DSYNC，O_DIRECT。设置O_DIRECT表示<br>数据文件写入操作会通知操作系统不要缓存数据，也不要用预读，直接从Innodb<br>Buffer写到磁盘文件。<br>默认的fdatasync意思是先写入操作系统缓存，然后再调用fsync()函数去异步刷数据文<br>件与redo log的缓存信息。<br>重做日志（Redo Log）<br>重做日志是一种基于磁盘的数据结构，用于在崩溃恢复期间更正不完整事务写入的数据。<br>MySQL以循环方式写入重做日志文件，记录InnoDB中所有对Buffer Pool修改的日志。当出<br>现实例故障（像断电），导致数据未能更新到数据文件，则数据库重启时须redo，重新把数<br>据更新到数据文件。读写事务在执行的过程中，都会不断的产生redo log。默认情况下，重<br>做日志在磁盘上由两个名为ib_logfile0和ib_logfile1的文件物理表示。<br>撤销日志（Undo Logs）<br>撤消日志是在事务开始之前保存的被修改数据的备份，用于例外情况时回滚事务。撤消日志<br>属于逻辑日志，根据每行记录进行记录。撤消日志存在于系统表空间、撤消表空间和临时表<br>空间中。<br>MySQL 5.7 版本<br>将 Undo日志表空间从共享表空间 ibdata 文件中分离出来，可以在安装 MySQL 时由用<br>户自行指定文件大小和数量。<br>增加了 temporary 临时表空间，里面存储着临时表或临时查询结果集的数据。<br>Buffer Pool 大小可以动态修改，无需重启数据库实例。<br>MySQL 8.0 版本<br>将InnoDB表的数据字典和Undo都从共享表空间ibdata中彻底分离出来了，以前需要<br>ibdata中数据字典与独立表空间ibd文件中数据字典一致才行，8.0版本就不需要了。<br>temporary 临时表空间也可以配置多个物理文件，而且均为 InnoDB 存储引擎并能创建<br>索引，这样加快了处理的速度。<br>用户可以像 Oracle 数据库那样设置一些表空间，每个表空间对应多个物理文件，每个<br>表空间可以给多个表使用，但一个表只能存储在一个表空间中。<br>将Doublewrite Buffer从共享表空间ibdata中也分离出来了</p>
<p>InnoDB线程模型<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/mysql6.jpg" alt="流程"></p>
<p>IO Thread<br>在InnoDB中使用了大量的AIO（Async IO）来做读写处理，这样可以极大提高数据库的性能。在<br>InnoDB1.0版本之前共有4个IO Thread，分别是write，read，insert buffer和log thread，后来<br>版本将read thread和write thread分别增大到了4个，一共有10个了。<br>read thread ： 负责读取操作，将数据从磁盘加载到缓存page页。4个<br>write thread：负责写操作，将缓存脏页刷新到磁盘。4个<br>log thread：负责将日志缓冲区内容刷新到磁盘。1个<br>insert buffer thread ：负责将写缓冲内容刷新到磁盘。1个<br>Purge Thread<br>事务提交之后，其使用的undo日志将不再需要，因此需要Purge Thread回收已经分配的undo<br>页。<br>show variables like ‘%innodb_purge_threads%’;<br>Page Cleaner Thread<br>作用是将脏数据刷新到磁盘，脏数据刷盘后相应的redo log也就可以覆盖，即可以同步数据，又能<br>达到redo log循环使用的目的。会调用write thread线程处理。<br>show variables like ‘%innodb_page_cleaners%’;<br>Master Thread<br>Master thread是InnoDB的主线程，负责调度其他各线程，优先级最高。作用是将缓冲池中的数<br>据异步刷新到磁盘 ，保证数据的一致性。包含：脏页的刷新（page cleaner thread）、undo页<br>回收（purge thread）、redo日志刷新（log thread）、合并写缓冲等。内部有两个主处理，分别<br>是每隔1秒和10秒处理。<br>每1秒的操作：<br>刷新日志缓冲区，刷到磁盘<br>合并写缓冲区数据，根据IO读写压力来决定是否操作<br>刷新脏页数据到磁盘，根据脏页比例达到75%才操作（innodb_max_dirty_pages_pct，<br>innodb_io_capacity） 每10秒的操作：<br>刷新脏页数据到磁盘<br>合并写缓冲区数据<br>刷新日志缓冲区<br>删除无用的undo页</p>
<p>Undolog and binlog and redoLog<br>Undo Log<br>3.5.1 Undo Log介绍<br>Undo：意为撤销或取消，以撤销操作为目的，返回指定某个状态的操作。<br>Undo Log：数据库事务开始之前，会将要修改的记录存放到 Undo 日志里，当事务回滚时或者数<br>据库崩溃时，可以利用 Undo 日志，撤销未提交事务对数据库产生的影响。<br>Undo Log产生和销毁：Undo Log在事务开始前产生；事务在提交时，并不会立刻删除undo<br>log，innodb会将该事务对应的undo log放入到删除列表中，后面会通过后台线程purge thread进<br>行回收处理。Undo Log属于逻辑日志，记录一个变化过程。例如执行一个delete，undolog会记<br>录一个insert；执行一个update，undolog会记录一个相反的update。<br>Undo Log存储：undo log采用段的方式管理和记录。在innodb数据文件中包含一种rollback<br>segment回滚段，内部包含1024个undo log segment。可以通过下面一组参数来控制Undo log存<br>储。<br>3.5.2 Undo Log作用<br>实现事务的原子性<br>Undo Log 是为了实现事务的原子性而出现的产物。事务处理过程中，如果出现了错误或者用户执<br>行了 ROLLBACK 语句，MySQL 可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。<br>实现多版本并发控制（MVCC）<br>Undo Log 在 MySQL InnoDB 存储引擎中用来实现多版本并发控制。事务未提交之前，Undo Log<br>保存了未提交之前的版本数据，Undo Log 中的数据可作为数据旧版本快照供其他并发事务进行快<br>照读。<br>事务A手动开启事务，执行更新操作，首先会把更新命中的数据备份到 Undo Buffer 中。<br>事务B手动开启事务，执行查询操作，会读取 Undo 日志数据返回，进行快照读<br>3.6 Redo Log和Binlog<br>Redo Log和Binlog是MySQL日志系统中非常重要的两种机制，也有很多相似之处，下面介绍下两者细<br>节和区别。<br>3.6.1 Redo Log日志<br>Redo Log介绍<br>show variables like ‘%innodb_undo%’;<br>Redo：顾名思义就是重做。以恢复操作为目的，在数据库发生意外时重现操作。<br>Redo Log：指事务中修改的任何数据，将最新的数据备份存储的位置（Redo Log），被称为重做<br>日志。<br>Redo Log 的生成和释放：随着事务操作的执行，就会生成Redo Log，在事务提交时会将产生<br>Redo Log写入Log Buffer，并不是随着事务的提交就立刻写入磁盘文件。等事务操作的脏页写入<br>到磁盘之后，Redo Log 的使命也就完成了，Redo Log占用的空间就可以重用（被覆盖写入）。<br>Redo Log工作原理<br>Redo Log 是为了实现事务的持久性而出现的产物。防止在发生故障的时间点，尚有脏页未写入表<br>的 IBD 文件中，在重启 MySQL 服务的时候，根据 Redo Log 进行重做，从而达到事务的未入磁盘<br>数据进行持久化这一特性。<br>Redo Log写入机制<br>Redo Log 文件内容是以顺序循环的方式写入文件，写满时则回溯到第一个文件，进行覆盖写。<br>如图所示：<br>write pos 是当前记录的位置，一边写一边后移，写到最后一个文件末尾后就回到 0 号文件开<br>头；<br>checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数<br>据文件；<br>write pos 和 checkpoint 之间还空着的部分，可以用来记录新的操作。如果 write pos 追上<br>checkpoint，表示写满，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint<br>推进一下。<br>Redo Log相关配置参数<br>每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组至少有2个重做日志文<br>件，默认为ib_logfile0和ib_logfile1。可以通过下面一组参数控制Redo Log存储：<br>show variables like ‘%innodb_log%’;<br>Redo Buffer 持久化到 Redo Log 的策略，可通过 Innodb_flush_log_at_trx_commit 设置：<br>0：每秒提交 Redo buffer -&gt;OS cache -&gt; flush cache to disk，可能丢失一秒内的事务数<br>据。由后台Master线程每隔 1秒执行一次操作。<br>1（默认值）：每次事务提交执行 Redo Buffer -&gt; OS cache -&gt; flush cache to disk，最安<br>全，性能最差的方式。<br>2：每次事务提交执行 Redo Buffer -&gt; OS cache，然后由后台Master线程再每隔1秒执行OS<br>cache -&gt; flush cache to disk 的操作。<br>一般建议选择取值2，因为 MySQL 挂了数据没有损失，整个服务器挂了才会损失1秒的事务提交数<br>据。<br>3.6.2 Binlog日志<br>Binlog记录模式<br>Redo Log 是属于InnoDB引擎所特有的日志，而MySQL Server也有自己的日志，即 Binary<br>log（二进制日志），简称Binlog。Binlog是记录所有数据库表结构变更以及表数据修改的二进制<br>日志，不会记录SELECT和SHOW这类操作。Binlog日志是以事件形式记录，还包含语句所执行的<br>消耗时间。开启Binlog日志有以下两个最重要的使用场景。<br>主从复制：在主库中开启Binlog功能，这样主库就可以把Binlog传递给从库，从库拿到<br>Binlog后实现数据恢复达到主从数据一致性。<br>数据恢复：通过mysqlbinlog工具来恢复数据。<br>Binlog文件名默认为“主机名_binlog-序列号”格式，例如oak_binlog-000001，也可以在配置文件<br>中指定名称。文件记录模式有STATEMENT、ROW和MIXED三种，具体含义如下。<br>ROW（row-based replication, RBR）：日志中会记录每一行数据被修改的情况，然后在<br>slave端对相同的数据进行修改。<br>优点：能清楚记录每一个行数据的修改细节，能完全实现主从数据同步和数据的恢复。<br>缺点：批量操作，会产生大量的日志，尤其是alter table会让日志暴涨。<br>STATMENT（statement-based replication, SBR）：每一条被修改数据的SQL都会记录到<br>master的Binlog中，slave在复制的时候SQL进程会解析成和原来master端执行过的相同的<br>SQL再次执行。简称SQL语句复制。<br>优点：日志量小，减少磁盘IO，提升存储和恢复速度<br>缺点：在某些情况下会导致主从数据不一致，比如last_insert_id()、now()等函数。<br>MIXED（mixed-based replication, MBR）：以上两种模式的混合使用，一般会使用<br>STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存<br>binlog，MySQL会根据执行的SQL语句选择写入模式。<br>Binlog文件结构<br>MySQL的binlog文件中记录的是对数据库的各种修改操作，用来表示修改操作的数据结构是Log<br>event。不同的修改操作对应的不同的log event。比较常用的log event有：Query event、Row event、Xid event等。binlog文件的内容就是各种Log event的集合。<br>Binlog文件中Log event结构如下图所示：<br>Binlog写入机制<br>根据记录模式和操作触发event事件生成log event（事件触发执行机制）<br>将事务执行过程中产生log event写入缓冲区，每个事务线程都有一个缓冲区<br>Log Event保存在一个binlog_cache_mngr数据结构中，在该结构中有两个缓冲区，一个是<br>stmt_cache，用于存放不支持事务的信息；另一个是trx_cache，用于存放支持事务的信息。<br>事务在提交阶段会将产生的log event写入到外部binlog文件中。<br>不同事务以串行方式将log event写入binlog文件中，所以一个事务包含的log event信息在<br>binlog文件中是连续的，中间不会插入其他事务的log event。<br>Binlog文件操作<br>Binlog状态查看<br>show variables like ‘log_bin’;<br>开启Binlog功能<br>mysql&gt; set global log_bin=mysqllogbin; ERROR 1238 (HY000): Variable ‘log_bin’ is a read only variable<br>需要修改my.cnf或my.ini配置文件，在[mysqld]下面增加log_bin=mysql_bin_log，重启<br>MySQL服务。<br>#log-bin=ON #log-bin-basename=mysqlbinlog binlog-format=ROW log-bin=mysqlbinlog<br>使用show binlog events命令<br>show binary logs; //等价于show master logs; show master status; show binlog events; show binlog events in ‘mysqlbinlog.000001’;<br>使用mysqlbinlog 命令<br>mysqlbinlog “文件名” mysqlbinlog “文件名” &gt; “test.sql”<br>使用 binlog 恢复数据<br>//按指定时间恢复 mysqlbinlog –start-datetime=”2020-04-25 18:00:00” –stop- datetime=”2020-04-26 00:00:00” mysqlbinlog.000002 | mysql -uroot -p1234 //按事件位置号恢复 mysqlbinlog –start-position=154 –stop-position=957 mysqlbinlog.000002 | mysql -uroot -p1234<br>mysqldump：定期全部备份数据库数据。mysqlbinlog可以做增量备份和恢复操作。<br>删除Binlog文件<br>purge binary logs to ‘mysqlbinlog.000001’; //删除指定文件 purge binary logs before ‘2020-04-28 00:00:00’; //删除指定时间之前的文件 reset master; //清除所有文件<br>可以通过设置expire_logs_days参数来启动自动清理功能。默认值为0表示没启用。设置为1表示超<br>出1天binlog文件会自动删除掉。<br>Redo Log和Binlog区别<br>Redo Log是属于InnoDB引擎功能，Binlog是属于MySQL Server自带功能，并且是以二进制<br>文件记录。<br>Redo Log属于物理日志，记录该数据页更新状态内容，Binlog是逻辑日志，记录更新过程。<br>Redo Log日志是循环写，日志空间大小是固定，Binlog是追加写入，写完一个写下一个，不<br>会覆盖使用。<br>Redo Log作为服务器异常宕机后事务数据自动恢复使用，Binlog可以作为主从复制和数据恢<br>复使用。Binlog没有自动crash-safe能力。</p>
<p>MySQL索引原理<br>索引类型<br>索引可以提升查询速度，会影响where查询，以及order by排序。MySQL索引类型如下：<br>从索引存储结构划分：B Tree索引、Hash索引、FULLTEXT全文索引、R Tree索引<br>从应用层次划分：普通索引、唯一索引、主键索引、复合索引<br>从索引键值类型划分：主键索引、辅助索引（二级索引）<br>从数据存储和索引键值逻辑关系划分：聚集索引（聚簇索引）、非聚集索引（非聚簇索引）<br>普通索引<br>这是最基本的索引类型，基于普通字段建立的索引，没有任何限制。<br>创建普通索引的方法如下：<br>CREATE INDEX &lt;索引的名字&gt; ON tablename (字段名);<br>ALTER TABLE tablename ADD INDEX [索引的名字] (字段名);<br>CREATE TABLE tablename ( […], INDEX [索引的名字] (字段名) );<br>1.2 唯一索引<br>与”普通索引”类似，不同的就是：索引字段的值必须唯一，但允许有空值 。在创建或修改表时追加唯一<br>约束，就会自动创建对应的唯一索引。<br>创建唯一索引的方法如下：<br>CREATE UNIQUE INDEX &lt;索引的名字&gt; ON tablename (字段名);<br>ALTER TABLE tablename ADD UNIQUE INDEX [索引的名字] (字段名);<br>CREATE TABLE tablename ( […], UNIQUE [索引的名字] (字段名) ;<br>1.3 主键索引<br>它是一种特殊的唯一索引，不允许有空值。在创建或修改表时追加主键约束即可，每个表只能有一个主<br>键。<br>创建主键索引的方法如下：<br>CREATE TABLE tablename ( […], PRIMARY KEY (字段名) );<br>ALTER TABLE tablename ADD PRIMARY KEY (字段名);<br>1.4 复合索引<br>单一索引是指索引列为一列的情况，即新建索引的语句只实施在一列上；用户可以在多个列上建立索<br>引，这种索引叫做组复合索引（组合索引）。复合索引可以代替多个单一索引，相比多个单一索引复合<br>索引所需的开销更小。<br>索引同时有两个概念叫做窄索引和宽索引，窄索引是指索引列为1-2列的索引，宽索引也就是索引列超<br>过2列的索引，设计索引的一个重要原则就是能用窄索引不用宽索引，因为窄索引往往比组合索引更有<br>效。<br>创建组合索引的方法如下：<br>CREATE INDEX &lt;索引的名字&gt; ON tablename (字段名1，字段名2…);<br>ALTER TABLE tablename ADD INDEX [索引的名字] (字段名1，字段名2…);<br>CREATE TABLE tablename ( […], INDEX [索引的名字] (字段名1，字段名2…) );<br>复合索引使用注意事项：<br>何时使用复合索引，要根据where条件建索引，注意不要过多使用索引，过多使用会对更新操作效<br>率有很大影响。<br>如果表已经建立了(col1，col2)，就没有必要再单独建立（col1）；如果现在有(col1)索引，如果查<br>询需要col1和col2条件，可以建立(col1,col2)复合索引，对于查询有一定提高。<br>1.5 全文索引<br>查询操作在数据量比较少时，可以使用like模糊查询，但是对于大量的文本数据检索，效率很低。如果<br>使用全文索引，查询速度会比like快很多倍。在MySQL 5.6 以前的版本，只有MyISAM存储引擎支持全<br>文索引，从MySQL 5.6开始MyISAM和InnoDB存储引擎均支持。<br>创建全文索引的方法如下：<br>CREATE FULLTEXT INDEX &lt;索引的名字&gt; ON tablename (字段名);<br>ALTER TABLE tablename ADD FULLTEXT [索引的名字] (字段名);<br>CREATE TABLE tablename ( […], FULLTEXT KEY [索引的名字] (字段名) ;<br>和常用的like模糊查询不同，全文索引有自己的语法格式，使用 match 和 against 关键字，比如<br>全文索引使用注意事项：<br>全文索引必须在字符串、文本字段上建立。<br>全文索引字段值必须在最小字符和最大字符之间的才会有效。（innodb：3-84；myisam：4-<br>84）<br>全文索引字段值要进行切词处理，按syntax字符进行切割，例如b+aaa，切分成b和aaa<br>全文索引匹配查询，默认使用的是等值匹配，例如a匹配a，不会匹配ab,ac。如果想匹配可以在布<br>尔模式下搜索a*<br>第2节 索引原理<br>MySQL官方对索引定义：是存储引擎用于快速查找记录的一种数据结构。需要额外开辟空间和数据维护<br>工作。<br>索引是物理数据页存储，在数据文件中（InnoDB，ibd文件），利用数据页(page)存储。<br>索引可以加快检索速度，但是同时也会降低增删改操作速度，索引维护需要代价。<br>索引涉及的理论知识：二分查找法、Hash和B+Tree。<br>2.1 二分查找法<br>二分查找法也叫作折半查找法，它是在有序数组中查找指定数据的搜索算法。它的优点是等值查询、范<br>围查询性能优秀，缺点是更新数据、新增数据、删除数据维护成本高。<br>首先定位left和right两个指针<br>select * from user where match(name) against(‘aaa’); select * from user where match(name) against(‘a*’ in boolean mode);<br>计算(left+right)/2<br>判断除2后索引位置值与目标值的大小比对<br>索引位置值大于目标值就-1，right移动；如果小于目标值就+1，left移动<br>举个例子，下面的有序数组有17 个值，查找的目标值是7，过程如下：<br>第一次查找<br>第二次查找<br>第三次查找<br>第四次查找<br>2.2 Hash结构<br>Hash底层实现是由Hash表来实现的，是根据键值 &lt;key,value&gt; 存储数据的结构。非常适合根据key查找<br>value值，也就是单个key查询，或者说等值查询。其结构如下所示：<br>从上面结构可以看出，Hash索引可以方便的提供等值查询，但是对于范围查询就需要全表扫描了。<br>Hash索引在MySQL 中Hash结构主要应用在Memory原生的Hash索引 、InnoDB 自适应哈希索引。<br>InnoDB提供的自适应哈希索引功能强大，接下来重点描述下InnoDB 自适应哈希索引。<br>InnoDB自适应哈希索引是为了提升查询效率，InnoDB存储引擎会监控表上各个索引页的查询，当<br>InnoDB注意到某些索引值访问非常频繁时，会在内存中基于B+Tree索引再创建一个哈希索引，使得内<br>存中的 B+Tree 索引具备哈希索引的功能，即能够快速定值访问频繁访问的索引页。<br>InnoDB自适应哈希索引：在使用Hash索引访问时，一次性查找就能定位数据，等值查询效率要优于<br>B+Tree。<br>自适应哈希索引的建立使得InnoDB存储引擎能自动根据索引页访问的频率和模式自动地为某些热点页<br>建立哈希索引来加速访问。另外InnoDB自适应哈希索引的功能，用户只能选择开启或关闭功能，无法<br>进行人工干涉。<br>show engine innodb status \G; show variables like ‘%innodb_adaptive%’;<br>2.3 B+Tree结构<br>MySQL数据库索引采用的是B+Tree结构，在B-Tree结构上做了优化改造。<br>B-Tree结构<br>索引值和data数据分布在整棵树结构中<br>每个节点可以存放多个索引值及对应的data数据<br>树节点中的多个索引值从左到右升序排列<br>B树的搜索：从根节点开始，对节点内的索引值序列采用二分法查找，如果命中就结束查找。没有<br>命中会进入子节点重复查找过程，直到所对应的的节点指针为空，或已经是叶子节点了才结束。<br>B+Tree结构<br>非叶子节点不存储data数据，只存储索引值，这样便于存储更多的索引值<br>叶子节点包含了所有的索引值和data数据<br>叶子节点用指针连接，提高区间的访问性能<br>相比B树，B+树进行范围查找时，只需要查找定位两个节点的索引值，然后利用叶子节点的指针进<br>行遍历即可。而B树需要遍历范围内所有的节点和数据，显然B+Tree效率高。<br>2.4 聚簇索引和辅助索引<br>聚簇索引和非聚簇索引：B+Tree的叶子节点存放主键索引值和行记录就属于聚簇索引；如果索引值和行<br>记录分开存放就属于非聚簇索引。<br>主键索引和辅助索引：B+Tree的叶子节点存放的是主键字段值就属于主键索引；如果存放的是非主键值<br>就属于辅助索引（二级索引）。<br>在InnoDB引擎中，主键索引采用的就是聚簇索引结构存储。<br>聚簇索引（聚集索引）<br>聚簇索引是一种数据存储方式，InnoDB的聚簇索引就是按照主键顺序构建 B+Tree结构。B+Tree<br>的叶子节点就是行记录，行记录和主键值紧凑地存储在一起。 这也意味着 InnoDB 的主键索引就<br>是数据表本身，它按主键顺序存放了整张表的数据，占用的空间就是整个表数据量的大小。通常说<br>的主键索引就是聚集索引。<br>InnoDB的表要求必须要有聚簇索引：<br>如果表定义了主键，则主键索引就是聚簇索引<br>如果表没有定义主键，则第一个非空unique列作为聚簇索引<br>否则InnoDB会从建一个隐藏的row-id作为聚簇索引<br>辅助索引<br>InnoDB辅助索引，也叫作二级索引，是根据索引列构建 B+Tree结构。但在 B+Tree 的叶子节点中<br>只存了索引列和主键的信息。二级索引占用的空间会比聚簇索引小很多， 通常创建辅助索引就是<br>为了提升查询效率。一个表InnoDB只能创建一个聚簇索引，但可以创建多个辅助索引。<br>非聚簇索引<br>与InnoDB表存储不同，MyISAM数据表的索引文件和数据文件是分开的，被称为非聚簇索引结<br>构。</p>
<p>查询优化<br>MySQL 提供了一个 EXPLAIN 命令，它可以对 SELECT 语句进行分析，并输出 SELECT 执行的详细信<br>息，供开发人员有针对性的优化。例如：<br>EXPLAIN 命令的输出内容大致如下：<br>select_type<br>表示查询的类型。常用的值如下：<br>SIMPLE ： 表示查询语句不包含子查询或union<br>PRIMARY：表示此查询是最外层的查询<br>UNION：表示此查询是UNION的第二个或后续的查询<br>EXPLAIN SELECT * from user WHERE id &lt; 3;<br>DEPENDENT UNION：UNION中的第二个或后续的查询语句，使用了外面查询结果<br>UNION RESULT：UNION的结果<br>SUBQUERY：SELECT子查询语句<br>DEPENDENT SUBQUERY：SELECT子查询语句依赖外层查询的结果。<br>最常见的查询类型是SIMPLE，表示我们的查询没有子查询也没用到UNION查询。<br>type<br>表示存储引擎查询数据时采用的方式。比较重要的一个属性，通过它可以判断出查询是全表扫描还<br>是基于索引的部分扫描。常用属性值如下，从上至下效率依次增强。<br>ALL：表示全表扫描，性能最差。<br>index：表示基于索引的全表扫描，先扫描索引再扫描全表数据。<br>range：表示使用索引范围查询。使用&gt;、&gt;=、&lt;、&lt;=、in等等。<br>ref：表示使用非唯一索引进行单值查询。<br>eq_ref：一般情况下出现在多表join查询，表示前面表的每一个记录，都只能匹配后面表的一<br>行结果。<br>const：表示使用主键或唯一索引做等值查询，常量查询。<br>NULL：表示不用访问表，速度最快。<br>possible_keys<br>表示查询时能够使用到的索引。注意并不一定会真正使用，显示的是索引名称。<br>key<br>表示查询时真正使用到的索引，显示的是索引名称。<br>rows<br>MySQL查询优化器会根据统计信息，估算SQL要查询到结果需要扫描多少行记录。原则上rows是<br>越少效率越高，可以直观的了解到SQL效率高低。<br>key_len<br>表示查询使用了索引的字节数量。可以判断是否全部使用了组合索引。<br>key_len的计算规则如下：<br>字符串类型<br>字符串长度跟字符集有关：latin1=1、gbk=2、utf8=3、utf8mb4=4<br>char(n)：n*字符集长度<br>varchar(n)：n * 字符集长度 + 2字节<br>数值类型<br>TINYINT：1个字节<br>SMALLINT：2个字节<br>MEDIUMINT：3个字节<br>INT、FLOAT：4个字节<br>BIGINT、DOUBLE：8个字节<br>时间类型<br>DATE：3个字节<br>TIMESTAMP：4个字节<br>DATETIME：8个字节<br>字段属性<br>NULL属性占用1个字节，如果一个字段设置了NOT NULL，则没有此项。<br>Extra<br>Extra表示很多额外的信息，各种操作会在Extra提示相关信息，常见几种如下：<br>Using where<br>表示查询需要通过索引回表查询数据。<br>Using index<br>表示查询需要通过索引，索引就可以满足所需数据。<br>Using filesort<br>表示查询出来的结果需要额外排序，数据量小在内存，大的话在磁盘，因此有Using filesort<br>建议优化。<br>Using temprorary<br>查询使用到了临时表，一般出现于去重、分组等操作。<br>3.2 回表查询<br>在之前介绍过，InnoDB索引有聚簇索引和辅助索引。聚簇索引的叶子节点存储行记录，InnoDB必须要<br>有，且只有一个。辅助索引的叶子节点存储的是主键值和索引字段值，通过辅助索引无法直接定位行记<br>录，通常情况下，需要扫码两遍索引树。先通过辅助索引定位主键值，然后再通过聚簇索引定位行记<br>录，这就叫做回表查询，它的性能比扫一遍索引树低。<br>总结：通过索引查询主键值，然后再去聚簇索引查询记录信息<br>3.3 覆盖索引<br>在SQL-Server官网的介绍如下：<br>在MySQL官网，类似的说法出现在explain查询计划优化章节，即explain的输出结果Extra字段为Using<br>index时，能够触发索引覆盖。<br>不管是SQL-Server官网，还是MySQL官网，都表达了：只需要在一棵索引树上就能获取SQL所需的所<br>有列数据，无需回表，速度更快，这就叫做索引覆盖。<br>实现索引覆盖最常见的方法就是：将被查询的字段，建立到组合索引。<br>3.4 最左前缀原则<br>复合索引使用时遵循最左前缀原则，最左前缀顾名思义，就是最左优先，即查询中使用到最左边的列，<br>那么查询就会使用到索引，如果从索引的第二列开始查找，索引将失效。<br>3.5 LIKE查询<br>面试题：MySQL在使用like模糊查询时，索引能不能起作用？<br>回答：MySQL在使用Like模糊查询时，索引是可以被使用的，只有把%字符写在后面才会使用到索引。<br>select * from user where name like ‘%o%’; //不起作用<br>select * from user where name like ‘o%’; //起作用<br>select * from user where name like ‘%o’; //不起作用<br>3.6 NULL查询<br>面试题：如果MySQL表的某一列含有NULL值，那么包含该列的索引是否有效？<br>对MySQL来说，NULL是一个特殊的值，从概念上讲，NULL意味着“一个未知值”，它的处理方式与其他<br>值有些不同。比如：不能使用=，&lt;，&gt;这样的运算符，对NULL做算术运算的结果都是NULL，count时<br>不会包括NULL行等，NULL比空字符串需要更多的存储空间等。<br>NULL列需要增加额外空间来记录其值是否为NULL。对于MyISAM表，每一个空列额外占用一位，四舍<br>五入到最接近的字节。<br>虽然MySQL可以在含有NULL的列上使用索引，但NULL和其他数据还是有区别的，不建议列上允许为<br>NULL。最好设置NOT NULL，并给一个默认值，比如0和 ‘’ 空字符串等，如果是datetime类型，也可以<br>设置系统当前时间或某个固定的特殊值，例如’1970-01-01 00:00:00’。 “NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”<br>3.7 索引与排序<br>MySQL查询支持filesort和index两种方式的排序，filesort是先把结果查出，然后在缓存或磁盘进行排序<br>操作，效率较低。使用index是指利用索引自动实现排序，不需另做排序操作，效率会比较高。<br>filesort有两种排序算法：双路排序和单路排序。<br>双路排序：需要两次磁盘扫描读取，最终得到用户数据。第一次将排序字段读取出来，然后排序；第二<br>次去读取其他字段数据。<br>单路排序：从磁盘查询所需的所有列数据，然后在内存排序将结果返回。如果查询数据超出缓存<br>sort_buffer，会导致多次磁盘读取操作，并创建临时表，最后产生了多次IO，反而会增加负担。解决方<br>案：少使用select *；增加sort_buffer_size容量和max_length_for_sort_data容量。<br>如果我们Explain分析SQL，结果中Extra属性显示Using filesort，表示使用了filesort排序方式，需要优<br>化。如果Extra属性显示Using index时，表示覆盖索引，也表示所有操作在索引上完成，也可以使用<br>index排序方式，建议大家尽可能采用覆盖索引。<br>以下几种情况，会使用index方式的排序。<br>ORDER BY 子句索引列组合满足索引最左前列<br>WHERE子句+ORDER BY子句索引列组合满足索引最左前列<br>以下几种情况，会使用filesort方式的排序。<br>对索引列同时使用了ASC和DESC<br>WHERE子句和ORDER BY子句满足最左前缀，但where子句使用了范围查询（例如&gt;、&lt;、in<br>等）<br>ORDER BY或者WHERE+ORDER BY索引列没有满足索引最左前列<br>使用了不同的索引，MySQL每次只采用一个索引，ORDER BY涉及了两个索引<br>WHERE子句与ORDER BY子句，使用了不同的索引<br>explain select id from user order by id; //对应(id)、(id,name)索引有效 explain select id from user where age=18 order by name; //对应 (age,name)索引 explain select id from user order by age asc,name desc; //对应 (age,name)索引 explain select id from user where age&gt;10 order by name; //对应 (age,name)索引 explain select id from user order by name; //对应(age,name)索引 explain select id from user order by name,age; //对应(name)、(age)两个索 引explain select id from user where name=’tom’ order by age; //对应 (name)、(age)索引<br>WHERE子句或者ORDER BY子句中索引列使用了表达式，包括函数表达式<br>第4节 查询优化<br>4.1 慢查询定位<br>开启慢查询日志<br>查看 MySQL 数据库是否开启了慢查询日志和慢查询日志文件的存储位置的命令如下：<br>通过如下命令开启慢查询日志：<br>long_query_time：指定慢查询的阀值，单位秒。如果SQL执行时间超过阀值，就属于慢查询<br>记录到日志文件中。<br>log_queries_not_using_indexes：表示会记录没有使用索引的查询SQL。前提是slow_query_log<br>的值为ON，否则不会奏效。<br>查看慢查询日志<br>文本方式查看<br>直接使用文本编辑器打开slow.log日志即可。<br>time：日志记录的时间<br>User@Host：执行的用户及主机<br>Query_time：执行的时间<br>Lock_time：锁表时间<br>Rows_sent：发送给请求方的记录数，结果数量<br>Rows_examined：语句扫描的记录条数<br>SET timestamp：语句执行的时间点<br>select….：执行的具体的SQL语句<br>使用mysqldumpslow查看<br>MySQL 提供了一个慢查询日志分析工具mysqldumpslow，可以通过该工具分析慢查询日志<br>内容。<br>在 MySQL bin目录下执行下面命令可以查看该使用格式。<br>运行如下命令查看慢查询日志信息：<br>explain select id from user order by abs(age); //对应(age)索引 SHOW VARIABLES LIKE ‘slow_query_log%’ SET global slow_query_log = ON; SET global slow_query_log_file = ‘OAK-slow.log’; SET global log_queries_not_using_indexes = ON; SET long_query_time = 10; perl mysqldumpslow.pl –help<br>除了使用mysqldumpslow工具，也可以使用第三方分析工具，比如pt-query-digest、<br>mysqlsla等。<br>4.2 慢查询优化<br>索引和慢查询<br>如何判断是否为慢查询？<br>MySQL判断一条语句是否为慢查询语句，主要依据SQL语句的执行时间，它把当前语句的执<br>行时间跟 long_query_time 参数做比较，如果语句的执行时间 &gt; long_query_time，就会把<br>这条执行语句记录到慢查询日志里面。long_query_time 参数的默认值是 10s，该参数值可<br>以根据自己的业务需要进行调整。<br>如何判断是否应用了索引？<br>SQL语句是否使用了索引，可根据SQL语句执行过程中有没有用到表的索引，可通过 explain<br>命令分析查看，检查结果中的 key 值，是否为NULL。<br>应用了索引是否一定快？<br>下面我们来看看下面语句的 explain 的结果，你觉得这条语句有用上索引吗？比如<br>虽然使用了索引，但是还是从主键索引的最左边的叶节点开始向右扫描整个索引树，进行了<br>全表扫描，此时索引就失去了意义。<br>而像 select * from user where id = 2; 这样的语句，才是我们平时说的使用了索引。它表示<br>的意思是，我们使用了索引的快速搜索功能，并且有效地减少了扫描行数。<br>查询是否使用索引，只是表示一个SQL语句的执行过程；而是否为慢查询，是由它执行的时间决定<br>的，也就是说是否使用了索引和是否是慢查询两者之间没有必然的联系。<br>我们在使用索引时，不要只关注是否起作用，应该关心索引是否减少了查询扫描的数据行数，如果<br>扫描行数减少了，效率才会得到提升。对于一个大表，不止要创建索引，还要考虑索引过滤性，过<br>滤性好，执行速度才会快。<br>提高索引过滤性<br>假如有一个5000万记录的用户表，通过sex=’男’索引过滤后，还需要定位3000万，SQL执行速度也<br>不会很快。其实这个问题涉及到索引的过滤性，比如1万条记录利用索引过滤后定位10条、100<br>条、1000条，那他们过滤性是不同的。索引过滤性与索引字段、表的数据量、表设计结构都有关<br>系。<br>下面我们看一个案例：<br>优化1 perl mysqldumpslow.pl -t 5 -s at C:\ProgramData\MySQL\Data\OAK-slow.log select * from user where id&gt;0; 表：student 字段：id,name,sex,age 造数据：insert into student (name,sex,age) select name,sex,age from student; SQL案例：select * from student where age=18 and name like ‘张%’;（全表扫 描）alter table student add index(name); //追加name索引<br>优化3<br>慢查询原因总结<br>全表扫描：explain分析type属性all<br>全索引扫描：explain分析type属性index<br>索引过滤性不好：靠索引字段选型、数据量和状态、表设计<br>频繁的回表查询开销：尽量少用select *，使用覆盖索引<br>4.3 分页查询优化<br>一般性分页<br>般的分页查询使用简单的 limit 子句就可以实现。limit格式如下：<br>第一个参数指定第一个返回记录行的偏移量，注意从0开始；<br>第二个参数指定返回记录行的最大数目；<br>如果只给定一个参数，它表示返回最大的记录行数目；<br>思考1：如果偏移量固定，返回记录量对执行时间有什么影响？<br>结果：在查询记录时，返回记录量低于100条，查询时间基本没有变化，差距不大。随着查询记录<br>量越大，所花费的时间也会越来越多。<br>思考2：如果查询偏移量变化，返回记录数固定对执行时间有什么影响？</p>
<p>优化2 alter table student add index(age,name); //追加age,name索引 可以看到，index condition pushdown 优化的效果还是很不错的。再进一步优化，我们可以把名 字的第一个字和年龄做一个联合索引，这里可以使用 MySQL 5.7 引入的虚拟列来实现。 //为user表添加first_name虚拟列，以及联合索引(first_name,age) alter table student add first_name varchar(2) generated always as (left(name, 1)), add index(first_name, age); explain select * from student where first_name=’张’ and age=18; SELECT * FROM 表名 LIMIT [offset,] rows select * from user limit 10000,1; select * from user limit 10000,10; select * from user limit 10000,100; select * from user limit 10000,1000; select * from user limit 10000,10000;<br>结果：在查询记录时，如果查询记录量相同，偏移量超过100后就开始随着偏移量增大，查询时间<br>急剧的增加。（这种分页查询机制，每次都会从数据库第一条记录开始扫描，越往后查询越慢，而<br>且查询的数据越多，也会拖慢总查询速度。）<br>分页优化方案<br>第一步：利用覆盖索引优化<br>第二步：利用子查询优化<br>原因：使用了id做主键比较(id&gt;=)，并且子查询使用了覆盖索引进行优化。<br>MySQL事务和锁<br>第1节 ACID 特性<br>在关系型数据库管理系统中，一个逻辑工作单元要成为事务，必须满足这 4 个特性，即所谓的 ACID：<br>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p>
<p>1.1 原子性<br>原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。<br>修改—》Buffer Pool修改—》刷盘。可能会有下面两种情况：<br>事务提交了，如果此时Buffer Pool的脏页没有刷盘，如何保证修改的数据生效？ Redo<br>如果事务没提交，但是Buffer Pool的脏页刷盘了，如何保证不该存在的数据撤销？Undo<br>每一个写事务，都会修改BufferPool，从而产生相应的Redo/Undo日志，在Buffer Pool 中的页被刷到<br>磁盘之前，这些日志信息都会先写入到日志文件中，如果 Buffer Pool 中的脏页没有刷成功，此时数据<br>库挂了，那在数据库再次启动之后，可以通过 Redo 日志将其恢复出来，以保证脏页写的数据不会丢<br>失。如果脏页刷新成功，此时数据库挂了，就需要通过Undo来实现了。<br>1.2 持久性<br>持久性：指的是一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，后续的操作或故障不<br>应该对其有任何影响，不会丢失。<br>如下图所示，一个“提交”动作触发的操作有：binlog落地、发送binlog、存储引擎提交、flush_logs，<br>check_point、事务提交标记等。这些都是数据库保证其数据完整性、持久性的手段。<br>select * from user limit 1,100; select * from user limit 10,100; select * from user limit 100,100; select * from user limit 1000,100; select * from user limit 10000,100; select * from user limit 10000,100; select id from user limit 10000,100; select * from user limit 10000,100; select * from user where id&gt;= (select id from user limit 10000,1) limit 100;<br>MySQL的持久性也与WAL技术相关，redo log在系统Crash重启之类的情况时，可以修复数据，从而保<br>障事务的持久性。通过原子性可以保证逻辑上的持久性，通过存储引擎的数据刷盘可以保证物理上的持<br>久性。<br>1.3 隔离性<br>隔离性：指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并<br>发事务是隔离的。<br>InnoDB 支持的隔离性有 4 种，隔离性从低到高分别为：读未提交、读提交、可重复读、可串行化。锁<br>和多版本控制（MVCC）技术就是用于保障隔离性的（后面课程详解）。<br>1.4 一致性<br>一致性：指的是事务开始之前和事务结束之后，数据库的完整性限制未被破坏。一致性包括两方面的内<br>容，分别是约束一致性和数据一致性。<br>约束一致性：创建表结构时所指定的外键、Check、唯一索引等约束，可惜在 MySQL 中不支持<br>Check 。<br>数据一致性：是一个综合性的规定，因为它是由原子性、持久性、隔离性共同保证的结果，而不是<br>单单依赖于某一种技术。<br>一致性也可以理解为数据的完整性。数据的完整性是通过原子性、隔离性、持久性来保证的，而这3个<br>特性又是通过 Redo/Undo 来保证的。逻辑上的一致性，包括唯一索引、外键约束、check 约束，这属<br>于业务逻辑范畴。<br>ACID 及它们之间的关系如下图所示，4个特性中有3个与 WAL 有关系，都需要通过 Redo、Undo 日志<br>来保证等。<br>WAL的全称为Write-Ahead Logging，先写日志，再写磁盘。<br>第2节 事务控制的演进<br>2.1 并发事务<br>事务并发处理可能会带来一些问题，比如：更新丢失、脏读、不可重复读、幻读等。<br>更新丢失<br>当两个或多个事务更新同一行记录，会产生更新丢失现象。可以分为回滚覆盖和提交覆盖。<br>回滚覆盖：一个事务回滚操作，把其他事务已提交的数据给覆盖了。<br>提交覆盖：一个事务提交操作，把其他事务已提交的数据给覆盖了。<br>脏读<br>一个事务读取到了另一个事务修改但未提交的数据。<br>不可重复读<br>一个事务中多次读取同一行记录不一致，后面读取的跟前面读取的不一致。<br>幻读<br>一个事务中多次按相同条件查询，结果不一致。后续查询的结果和面前查询结果不同，多了或少了<br>几行记录。<br>2.3 排队<br>最简单的方法，就是完全顺序执行所有事务的数据库操作，不需要加锁，简单的说就是全局排队。序列<br>化执行所有的事务单元，数据库某个时刻只处理一个事务操作，特点是强一致性，处理性能低。<br>2.2 排他锁<br>引入锁之后就可以支持并发处理事务，如果事务之间涉及到相同的数据项时，会使用排他锁，或叫互斥<br>锁，先进入的事务独占数据项以后，其他事务被阻塞，等待前面的事务释放锁。<br>注意，在整个事务1结束之前，锁是不会被释放的，所以，事务2必须等到事务1结束之后开始。<br>2.3 读写锁<br>读和写操作：读读、写写、读写、写读。<br>读写锁就是进一步细化锁的颗粒度，区分读操作和写操作，让读和读之间不加锁，这样下面的两个事务<br>就可以同时被执行了。<br>读写锁，可以让读和读并行，而读和写、写和读、写和写这几种之间还是要加排他锁。<br>2.4 MVCC<br>多版本控制MVCC，也就是Copy on Write的思想。MVCC除了支持读和读并行，还支持读和写、写和读<br>的并行，但为了保证一致性，写和写是无法并行的。<br>在事务1开始写操作的时候会copy一个记录的副本，其他事务读操作会读取这个记录副本，因此不会影<br>响其他事务对此记录的读取，实现写和读并行。<br>一、MVCC概念<br>MVCC（Multi Version Concurrency Control）被称为多版本控制，是指在数据库中为了实现高并发的<br>数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。<br>多版本控制很巧妙地将稀缺资源的独占互斥转换为并发，大大提高了数据库的吞吐量及读写性能。<br>如何生成的多版本？每次事务修改操作之前，都会在Undo日志中记录修改之前的数据状态和事务号，<br>该备份记录可以用于其他事务的读取，也可以进行必要时的数据回滚。<br>二、MVCC实现原理<br>MVCC最大的好处是读不加锁，读写不冲突。在读多写少的系统应用中，读写不冲突是非常重要的，极<br>大的提升系统的并发性能，这也是为什么现阶段几乎所有的关系型数据库都支持 MVCC 的原因，不过目<br>前MVCC只在 Read Commited 和 Repeatable Read 两种隔离级别下工作。<br>在 MVCC 并发控制中，读操作可以分为两类: 快照读（Snapshot Read）与当前读 （Current Read）。<br>快照读：读取的是记录的快照版本（有可能是历史版本），不用加锁。（select）<br>当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发<br>修改这条记录。（select… for update 或lock in share mode，insert/delete/update）<br>为了让大家更直观地理解 MVCC 的实现原理，举一个记录更新的案例来讲解 MVCC 中多版本的实现。<br>假设 F1～F6 是表中字段的名字，1～6 是其对应的数据。后面三个隐含字段分别对应该行的隐含ID、事<br>务号和回滚指针，如下图所示。<br>具体的更新过程如下：<br>假如一条数据是刚 INSERT 的，DB_ROW_ID 为 1，其他两个字段为空。当事务 1 更改该行的数据值<br>时，会进行如下操作，如下图所示。<br>用排他锁锁定该行；记录 Redo log；<br>把该行修改前的值复制到 Undo log，即图中下面的行；<br>修改当前行的值，填写事务编号，使回滚指针指向 Undo log 中修改前的行。<br>接下来事务2操作，过程与事务 1 相同，此时 Undo log 中会有两行记录，并且通过回滚指针连在一<br>起，通过当前记录的回滚指针回溯到该行创建时的初始内容，如下图所示。<br>MVCC已经实现了读读、读写、写读并发处理，如果想进一步解决写写冲突，可以采用下面两种方案：<br>乐观锁<br>悲观锁<br>第3节 事务隔离级别<br>3.1 隔离级别类型<br>前面提到的“更新丢失”、”脏读”、“不可重复读”和“幻读”等并发事务问题，其实都是数据库一致性问题，<br>为了解决这些问题，MySQL数据库是通过事务隔离级别来解决的，数据库系统提供了以下 4 种事务隔<br>离级别供用户选择。<br>读未提交<br>Read Uncommitted 读未提交：解决了回滚覆盖类型的更新丢失，但可能发生脏读现象，也就是<br>可能读取到其他会话中未提交事务修改的数据。<br>已提交读<br>Read Committed 读已提交：只能读取到其他会话中已经提交的数据，解决了脏读。但可能发生<br>不可重复读现象，也就是可能在一个事务中两次查询结果不一致。<br>可重复度<br>Repeatable Read 可重复读：解决了不可重复读，它确保同一事务的多个实例在并发读取数据<br>时，会看到同样的数据行。不过理论上会出现幻读，简单的说幻读指的的当用户读取某一范围的数<br>据行时，另一个事务又在该范围插入了新行，当用户在读取该范围的数据时会发现有新的幻影行。<br>可串行化<br>Serializable 串行化：所有的增删改查串行执行。它通过强制事务排序，解决相互冲突，从而解决<br>幻度的问题。这个级别可能导致大量的超时现象的和锁竞争，效率低下。<br>数据库的事务隔离级别越高，并发问题就越小，但是并发处理能力越差（代价）。读未提交隔离级别最<br>低，并发问题多，但是并发处理能力好。以后使用时，可以根据系统特点来选择一个合适的隔离级别，<br>比如对不可重复读和幻读并不敏感，更多关心数据库并发处理能力，此时可以使用Read Commited隔<br>离级别。<br>事务隔离级别，针对Innodb引擎，支持事务的功能。像MyISAM引擎没有关系。<br>事务隔离级别和锁的关系<br>1）事务隔离级别是SQL92定制的标准，相当于事务并发控制的整体解决方案，本质上是对锁和MVCC使<br>用的封装，隐藏了底层细节。<br>2）锁是数据库实现并发控制的基础，事务隔离性是采用锁来实现，对相应操作加不同的锁，就可以防<br>止其他事务同时对数据进行读写操作。<br>3）对用户来讲，首先选择使用隔离级别，当选用的隔离级别不能解决并发问题或需求时，才有必要在<br>开发中手动的设置锁。<br>MySQL默认隔离级别：可重复读<br>Oracle、SQLServer默认隔离级别：读已提交<br>一般使用时，建议采用默认隔离级别，然后存在的一些并发问题，可以通过悲观锁、乐观锁等实现处<br>理。<br>3.2 MySQL隔离级别控制<br>MySQL默认的事务隔离级别是Repeatable Read，查看MySQL当前数据库的事务隔离级别命令如下：<br>或show variables like ‘tx_isolation’;<br>设置事务隔离级别可以如下命令：<br>第4节 锁机制和实战<br>4.1 锁分类<br>在 MySQL中锁有很多不同的分类。<br>从操作的粒度可分为表级锁、行级锁和页级锁。<br>表级锁：每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在<br>MyISAM、InnoDB、BDB 等存储引擎中。<br>行级锁：每次操作锁住一行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应<br>用在InnoDB 存储引擎中。<br>页级锁：每次锁定相邻的一组记录，锁定粒度界于表锁和行锁之间，开销和加锁时间界于表<br>锁和行锁之间，并发度一般。应用在BDB 存储引擎中。<br>从操作的类型可分为读锁和写锁。<br>读锁（S锁）：共享锁，针对同一份数据，多个读操作可以同时进行而不会互相影响。<br>写锁（X锁）：排他锁，当前写操作没有完成前，它会阻断其他写锁和读锁。<br>IS锁、IX锁：意向读锁、意向写锁，属于表级锁，S和X主要针对行级锁。在对表记录添加S或X锁之<br>前，会先对表添加IS或IX锁。<br>S锁：事务A对记录添加了S锁，可以对记录进行读操作，不能做修改，其他事务可以对该记录追加<br>S锁，但是不能追加X锁，需要追加X锁，需要等记录的S锁全部释放。<br>X锁：事务A对记录添加了X锁，可以对记录进行读和修改操作，其他事务不能对记录做读和修改操<br>作。<br>从操作的性能可分为乐观锁和悲观锁。<br>乐观锁：一般的实现方式是对记录数据版本进行比对，在数据更新提交的时候才会进行冲突<br>检测，如果发现冲突了，则提示错误信息。<br>悲观锁：在对一条数据修改的时候，为了避免同时被其他人修改，在修改数据之前先锁定，<br>再修改的控制方式。共享锁和排他锁是悲观锁的不同实现，但都属于悲观锁范畴。<br>4.2 行锁原理<br>在InnoDB引擎中，我们可以使用行锁和表锁，其中行锁又分为共享锁和排他锁。InnoDB行锁是通过对<br>索引数据页上的记录加锁实现的，主要实现算法有 3 种：Record Lock、Gap Lock 和 Next-key Lock。 select @@tx_isolation; set tx_isolation=’READ-UNCOMMITTED’; set tx_isolation=’READ-COMMITTED’; set tx_isolation=’REPEATABLE-READ’; set tx_isolation=’SERIALIZABLE’;<br>RecordLock锁：锁定单个行记录的锁。（记录锁，RC、RR隔离级别都支持）<br>GapLock锁：间隙锁，锁定索引记录间隙，确保索引记录的间隙不变。（范围锁，RR隔离级别支<br>持）<br>Next-key Lock 锁：记录锁和间隙锁组合，同时锁住数据，并且锁住数据前后范围。（记录锁+范<br>围锁，RR隔离级别支持）<br>在RR隔离级别，InnoDB对于记录加锁行为都是先采用Next-Key Lock，但是当SQL操作含有唯一索引<br>时，Innodb会对Next-Key Lock进行优化，降级为RecordLock，仅锁住索引本身而非范围。<br>1）select … from 语句：InnoDB引擎采用MVCC机制实现非阻塞读，所以对于普通的select语句，<br>InnoDB不加锁<br>2）select … from lock in share mode语句：追加了共享锁，InnoDB会使用Next-Key Lock锁进行处<br>理，如果扫描发现唯一索引，可以降级为RecordLock锁。<br>3）select … from for update语句：追加了排他锁，InnoDB会使用Next-Key Lock锁进行处理，如果扫<br>描发现唯一索引，可以降级为RecordLock锁。<br>4）update … where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以<br>降级为RecordLock锁。<br>5）delete … where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降<br>级为RecordLock锁。<br>6）insert语句：InnoDB会在将要插入的那一行设置一个排他的RecordLock锁。<br>下面以“update t1 set name=‘XX’ where id=10”操作为例，举例子分析下 InnoDB 对不同索引的加锁行<br>为，以RR隔离级别为例。<br>主键加锁<br>加锁行为：仅在id=10的主键索引记录上加X锁。<br>唯一键加锁<br>加锁行为：现在唯一索引id上加X锁，然后在id=10的主键索引记录上加X锁。<br>非唯一键加锁<br>加锁行为：对满足id=10条件的记录和主键分别加X锁，然后在(6,c)-(10,b)、(10,b)-(10,d)、(10,d)-<br>(11,f)范围分别加Gap Lock。<br>无索引加锁<br>加锁行为：表里所有行和间隙都会加X锁。（当没有索引时，会导致全表锁定，因为InnoDB引擎<br>锁机制是基于索引实现的记录锁定）。<br>4.3 悲观锁<br>悲观锁（Pessimistic Locking），是指在数据处理过程，将数据处于锁定状态，一般使用数据库的锁机<br>制实现。从广义上来讲，前面提到的行锁、表锁、读锁、写锁、共享锁、排他锁等，这些都属于悲观锁<br>范畴。<br>表级锁<br>表级锁每次操作都锁住整张表，并发度最低。常用命令如下：<br>手动增加表锁<br>查看表上加过的锁<br>删除表锁<br>表级读锁：当前表追加read锁，当前连接和其他的连接都可以读操作；但是当前连接增删改操作<br>会报错，其他连接增删改会被阻塞。<br>lock table 表名称 read|write,表名称2 read|write; show open tables; unlock tables;<br>表级写锁：当前表追加write锁，当前连接可以对表做增删改查操作，其他连接对该表所有操作都<br>被阻塞（包括查询）。<br>总结：表级读锁会阻塞写操作，但是不会阻塞读操作。而写锁则会把读和写操作都阻塞。<br>共享锁（行级锁-读锁）<br>共享锁又称为读锁，简称S锁。共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数<br>据，但是只能读不能修改。使用共享锁的方法是在select … lock in share mode，只适用查询语<br>句。<br>总结：事务使用了共享锁（读锁），只能读取，不能修改，修改操作被阻塞。<br>排他锁（行级锁-写锁）<br>排他锁又称为写锁，简称X锁。排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排<br>他锁，其他事务就不能对该行记录做其他操作，也不能获取该行的锁。<br>使用排他锁的方法是在SQL末尾加上for update，innodb引擎默认会在update，delete语句加上<br>for update。行级锁的实现其实是依靠其对应的索引，所以如果操作没用到索引的查询，那么会锁<br>住全表记录。<br>总结：事务使用了排他锁（写锁），当前事务可以读取和修改，其他事务不能修改，也不能获取记录<br>锁（select… for update）。如果查询没有使用到索引，将会锁住整个表记录。<br>4.4 乐观锁<br>乐观锁是相对于悲观锁而言的，它不是数据库提供的功能，需要开发者自己去实现。在数据库操作时，<br>想法很乐观，认为这次的操作不会导致冲突，因此在数据库操作时并不做任何的特殊处理，即不加锁，<br>而是在进行事务提交时再去判断是否有冲突了。<br>乐观锁实现的关键点：冲突的检测。<br>悲观锁和乐观锁都可以解决事务写写并发，在应用中可以根据并发处理能力选择区分，比如对并发率要<br>求高的选择乐观锁；对于并发率要求低的可以选择悲观锁。<br>乐观锁实现原理<br>使用版本字段（version）<br>先给数据表增加一个版本(version) 字段，每操作一次，将那条记录的版本号加 1。version<br>是用来查看被读的记录有无变化，作用是防止记录在业务处理期间被其他事务修改。<br>使用时间戳（Timestamp）<br>与使用version版本字段相似，同样需要给在数据表增加一个字段，字段类型使用timestamp<br>时间戳。也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳<br>进行对比，如果一致则提交更新，否则就是版本冲突，取消操作。<br>乐观锁案例<br>下面我们使用下单过程作为案例，描述下乐观锁的使用。<br>第一步：查询商品信息<br>第二部：根据商品信息生成订单<br>第三部：修改商品库存<br>除了自己手动实现乐观锁之外，许多数据库访问框架也封装了乐观锁的实现，比如<br>hibernate框架。MyBatis框架大家可以使用OptimisticLocker插件来扩展。<br>4.5 死锁与解决方案<br>下面介绍几种常见的死锁现象和解决方案：<br>一、表锁死锁<br>产生原因：<br>select (quantity,version) from products where id=1; insert into orders … insert into items … update products set quantity=quantity-1,version=version+1 where id=1 and version=#{version};<br>用户A访问表A（锁住了表A），然后又访问表B；另一个用户B访问表B（锁住了表B），然后企图<br>访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要<br>等用户A释放表A才能继续，这就死锁就产生了。<br>用户A–》A表（表锁）–》B表（表锁）<br>用户B–》B表（表锁）–》A表（表锁）<br>解决方案：<br>这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分<br>析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个<br>资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任<br>何时刻都应该按照相同的顺序来锁定资源。<br>二、行级锁死锁<br>产生原因1：<br>如果在事务中执行了一条没有索引条件的查询，引发全表扫描，把行级锁上升为全表记录锁定（等<br>价于表级锁），多个这样的事务执行后，就很容易产生死锁和阻塞，最终应用系统会越来越慢，发<br>生阻塞或死锁。<br>解决方案1：<br>SQL语句中不要使用太复杂的关联多表的查询；使用explain“执行计划”对SQL语句进行分析，对于<br>有全表扫描和全表锁定的SQL语句，建立相应的索引进行优化。<br>产生原因2：<br>两个事务分别想拿到对方持有的锁，互相等待，于是产生死锁。<br>解决方案2：<br>在同一个事务中，尽可能做到一次锁定所需要的所有资源<br>按照id对资源排序，然后按顺序进行处理<br>三、共享锁转换为排他锁<br>产生原因：<br>事务A 查询一条纪录，然后更新该条纪录；此时事务B 也更新该条纪录，这时事务B 的排他锁由于<br>事务A 有共享锁，必须等A 释放共享锁后才可以获取，只能排队等待。事务A 再执行更新操作时，<br>此处发生死锁，因为事务A 需要排他锁来做更新操作。但是，无法授予该锁请求，因为事务B 已经<br>有一个排他锁请求，并且正在等待事务A 释放其共享锁。<br>事务A: select * from dept where deptno=1 lock in share mode; //共享锁,1<br>update dept set dname=’java’ where deptno=1;//排他锁,3<br>事务B: update dept set dname=’Java’ where deptno=1;//由于1有共享锁，没法获取排他锁，需<br>等待，2<br>解决方案：<br>对于按钮等控件，点击立刻失效，不让用户重复点击，避免引发同时对同一条记录多次操<br>作；<br>使用乐观锁进行控制。乐观锁机制避免了长事务中的数据库加锁开销，大大提升了大并发量<br>下的系统性能。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用<br>户更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中；<br>四、死锁排查<br>MySQL提供了几个与锁有关的参数和命令，可以辅助我们优化锁操作，减少死锁发生。<br>查看死锁日志<br>通过show engine innodb status\G命令查看近期死锁日志信息。<br>使用方法：1、查看近期死锁日志信息；2、使用explain查看下SQL执行计划<br>查看锁状态变量<br>通过show status like’innodb_row_lock%‘命令检查状态变量，分析系统中的行锁的争夺<br>情况<br>Innodb_row_lock_current_waits：当前正在等待锁的数量<br>Innodb_row_lock_time：从系统启动到现在锁定总时间长度<br>Innodb_row_lock_time_avg： 每次等待锁的平均时间<br>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次锁的时间<br>Innodb_row_lock_waits：系统启动后到现在总共等待的次数<br>如果等待次数高，而且每次等待时间长，需要分析系统中为什么会有如此多的等待，然后着<br>手定制优化</p>
<p>除了自己手动实现乐观锁之外，许多数据库访问框架也封装了乐观锁的实现，比如<br>hibernate框架。MyBatis框架大家可以使用OptimisticLocker插件来扩展。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://zkkget.github.io/posts/20220725cldvbpc00000fvsujavip6vkb.html" title="Mysql海量数据存储与优化" target="_blank" rel="external">https://zkkget.github.io/posts/20220725cldvbpc00000fvsujavip6vkb.html</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://kkget.github.io/" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://kkget.github.io/" target="_blank"><span class="text-dark">赵kk</span><small class="ml-1x">java Developer &amp; pm</small></a></h3>
        <div>纠结体本体,同步记录日常笔记，Write the code, Change the world！</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/20220726cldvbpbzt000bvsuj72e1h860.html" title="List遍历删除"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/20220725cldvbpc21001ivsuj34oh6fst.html" title="主站博客迁移之线上对事务的处理"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220826100219.jpg" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220112102818.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



            {% if post.top %}
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          {% endif %}
</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://kkget.github.io/" target="_blank" title="主站博客" data-toggle=tooltip data-placement=top><i class="icon icon-主站博客"></i></a></li>
        
        <li><a href="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.png" target="_blank" title="公众号" data-toggle=tooltip data-placement=top><i class="icon icon-公众号"></i></a></li>
        
        <li><a href="https://cloud.tencent.com/developer/inventory/14725" target="_blank" title="云+社区" data-toggle=tooltip data-placement=top><i class="icon icon-云+社区"></i></a></li>
        
        <li><a href="/1462018576" target="_blank" title="QQ" data-toggle=tooltip data-placement=top><i class="icon icon-QQ"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>

  <div>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span >本站总访问量: <span id="busuanzi_value_site_pv"></span>次</span>
  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1840459406&auto=1&height=66"></iframe>
  </div>


</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '5qofQKP6PLlRGj9AKdN2wFy8-gzGzoHsz',
    appKey: 'MUjdIW5XaUutRWAdIFu4IdxP',
    placeholder: '来都来了，说点啥吧~',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     



  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/01/assets/haru01.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
<!--<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script> -->
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
<!--崩溃欺骗-->
<script type="text/javascript" src="/js/src/crash_cheat.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</html>