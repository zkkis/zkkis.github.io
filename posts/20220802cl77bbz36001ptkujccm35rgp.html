<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>面向面试编程 | 个人博客</title>
  <meta name="description" content="@Service 和@Component 注解的差别？@Component spring基础的注解，被spring管理的组件或bean，用于将对象实例化到Spring容器中而@Service源码中是包含@Component注解的，也就是说service实现component的功能，但service用于服务层，处理业务逻辑 各种 Restful 请求格式以及各种 http 请求返回码。123API，">
<meta property="og:type" content="article">
<meta property="og:title" content="面向面试编程">
<meta property="og:url" content="https://zkkget.github.io/posts/20220802cl77bbz36001ptkujccm35rgp.html">
<meta property="og:site_name" content="赵KK个人博客第三站">
<meta property="og:description" content="@Service 和@Component 注解的差别？@Component spring基础的注解，被spring管理的组件或bean，用于将对象实例化到Spring容器中而@Service源码中是包含@Component注解的，也就是说service实现component的功能，但service用于服务层，处理业务逻辑 各种 Restful 请求格式以及各种 http 请求返回码。123API，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/374544735d0dd4104601ef98749c7f89.jpg">
<meta property="og:image" content="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/05-305138350.jpg">
<meta property="article:published_time" content="2022-08-02T03:35:12.000Z">
<meta property="article:modified_time" content="2022-08-17T08:51:17.967Z">
<meta property="article:author" content="赵KK">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/374544735d0dd4104601ef98749c7f89.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://zkkget.github.io/posts/20220802cl77bbz36001ptkujccm35rgp.html">
  
    <link rel="alternate" href="/atom.xml" title="赵KK个人博客第三站" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://kkget.github.io/" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">赵kk</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">java Developer &amp; pm</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 北京, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://kkget.github.io/" target="_blank" title="主站博客" data-toggle=tooltip data-placement=top><i class="icon icon-主站博客"></i></a></li>
        
        <li><a href="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.png" target="_blank" title="公众号" data-toggle=tooltip data-placement=top><i class="icon icon-公众号"></i></a></li>
        
        <li><a href="https://cloud.tencent.com/developer/inventory/14725" target="_blank" title="云+社区" data-toggle=tooltip data-placement=top><i class="icon icon-云+社区"></i></a></li>
        
        <li><a href="/1462018576" target="_blank" title="QQ" data-toggle=tooltip data-placement=top><i class="icon icon-QQ"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>有问题可搜索</br>个人公众号<赵KK日常技术记录></br>或联系作者进行沟通!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MQ/">MQ</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CompletableFuture/" rel="tag">CompletableFuture</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ContainsAll/" rel="tag">ContainsAll</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSON/" rel="tag">JSON</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JunitTest/" rel="tag">JunitTest</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode%E7%AE%97%E6%B3%95%E9%A2%98/" rel="tag">Leetcode算法题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/List%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4/" rel="tag">List遍历删除</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/" rel="tag">MQ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloudAlibaba/" rel="tag">SpringCloudAlibaba</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Springboot/" rel="tag">Springboot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thymleaf/" rel="tag">Thymleaf</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yapi/" rel="tag">Yapi</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/opencv/" rel="tag">opencv</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/valine/" rel="tag">valine</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%A1%E5%9E%92%E6%9C%BA/" rel="tag">堡垒机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E6%88%98/" rel="tag">实战</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/" rel="tag">面试,字节跳动</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/CompletableFuture/" style="font-size: 13px;">CompletableFuture</a> <a href="/tags/ContainsAll/" style="font-size: 13px;">ContainsAll</a> <a href="/tags/JSON/" style="font-size: 13px;">JSON</a> <a href="/tags/JunitTest/" style="font-size: 13px;">JunitTest</a> <a href="/tags/Leetcode%E7%AE%97%E6%B3%95%E9%A2%98/" style="font-size: 13px;">Leetcode算法题</a> <a href="/tags/List%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4/" style="font-size: 13px;">List遍历删除</a> <a href="/tags/MQ/" style="font-size: 13px;">MQ</a> <a href="/tags/MySQL/" style="font-size: 13px;">MySQL</a> <a href="/tags/Mysql/" style="font-size: 13px;">Mysql</a> <a href="/tags/Nginx/" style="font-size: 13px;">Nginx</a> <a href="/tags/SpringCloudAlibaba/" style="font-size: 13px;">SpringCloudAlibaba</a> <a href="/tags/Springboot/" style="font-size: 13px;">Springboot</a> <a href="/tags/Thymleaf/" style="font-size: 13px;">Thymleaf</a> <a href="/tags/Yapi/" style="font-size: 13px;">Yapi</a> <a href="/tags/opencv/" style="font-size: 13px;">opencv</a> <a href="/tags/valine/" style="font-size: 13px;">valine</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 13px;">事务</a> <a href="/tags/%E5%A0%A1%E5%9E%92%E6%9C%BA/" style="font-size: 13px;">堡垒机</a> <a href="/tags/%E5%AE%9E%E6%88%98/" style="font-size: 13px;">实战</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 14px;">面试</a> <a href="/tags/%E9%9D%A2%E8%AF%95-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/" style="font-size: 13px;">面试,字节跳动</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/posts/20220812cl77bbyyh0001tkuj99kbb8ve.html" class="title">1000万数据对比ContainsAll实测</a>
              </p>
              <p class="item-date">
                <time datetime="2022-08-12T08:24:06.000Z" itemprop="datePublished">2022-08-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/posts/20220802cl77bbz36001ptkujccm35rgp.html" class="title">面向面试编程</a>
              </p>
              <p class="item-date">
                <time datetime="2022-08-02T03:35:12.000Z" itemprop="datePublished">2022-08-02</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/posts/20220728cl77bbyyy0003tkuj0nyu0kzp.html" class="title">CompletableFuture</a>
              </p>
              <p class="item-date">
                <time datetime="2022-07-28T02:44:05.000Z" itemprop="datePublished">2022-07-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/posts/20220726cl77bbz2p001ftkujerhq231v.html" class="title">优雅永不过时</a>
              </p>
              <p class="item-date">
                <time datetime="2022-07-26T02:26:41.000Z" itemprop="datePublished">2022-07-26</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/posts/20220726cl77bbyzf0008tkuj38fa1evk.html" class="title">Leetcode算法题</a>
              </p>
              <p class="item-date">
                <time datetime="2022-07-26T02:22:55.000Z" itemprop="datePublished">2022-07-26</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-面向面试编程" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      面向面试编程
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/20220802cl77bbz36001ptkujccm35rgp.html" class="article-date">
	  <time datetime="2022-08-02T03:35:12.000Z" itemprop="datePublished">2022-08-02</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/20220802cl77bbz36001ptkujccm35rgp.html#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 14.5k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 54(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="Service-和-Component-注解的差别？"><a href="#Service-和-Component-注解的差别？" class="headerlink" title="@Service 和@Component 注解的差别？"></a>@Service 和@Component 注解的差别？</h2><p>@Component spring基础的注解，被spring管理的组件或bean，用于将对象实例化到Spring容器中<br>而@Service源码中是包含@Component注解的，也就是说service实现component的功能，但service用于服务层，处理业务逻辑</p>
<h2 id="各种-Restful-请求格式以及各种-http-请求返回码。"><a href="#各种-Restful-请求格式以及各种-http-请求返回码。" class="headerlink" title="各种 Restful 请求格式以及各种 http 请求返回码。"></a>各种 Restful 请求格式以及各种 http 请求返回码。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">API，英文全称Application Programming Interface，翻译为“应用程序编程接口”。就是将一些功能（逻辑）封装成组件，目的是提供一个应用程序接口给其它程序与开发人员访问，而这些访问人员不需要访问源码以及理解内部工作原理就可以直接使用</span><br><span class="line">RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用 XML 格式定义或 JSON 格式定义。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取，所以，使用JSON格式的REST风格的API具有简单、易读、易用的特点。</span><br><span class="line">而http返回状态码常见200.400.500等</span><br></pre></td></tr></table></figure>
<h2 id="Transactional-事务里的事务隔离级别和事务传播机制概念。"><a href="#Transactional-事务里的事务隔离级别和事务传播机制概念。" class="headerlink" title="@Transactional 事务里的事务隔离级别和事务传播机制概念。"></a>@Transactional 事务里的事务隔离级别和事务传播机制概念。</h2><p>定义一个事务受其他并发事务影响程度。事务并发引发的问题。</p>
<p>脏读：一个事务读取到另一个事务修改但还未提交的数据<br>不可重复读：一个事务读取数据之后，该数据被其他事务修改，此时第一个事务读取到的事务就是错误的（强调修改）<br>幻读：一个事务读取了某些数据，没提交再读取时数据多了或者少了，类似幻觉（强调增删）<br>丢失修改：两个事务都读取了数据，其中一个事务修改之后，另一个事务也做了修改，前者的修改丢失</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以放在 类上 或者 方法上。 </span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 区别于 transactionManager属性</span></span><br><span class="line"><span class="comment">	 * 查看 transactionManager</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 选定特定的 事务管理器 SpringBoot中默认不用配置 可以是beanName或者特定的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">	<span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置传播级别</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置事务隔离级别</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 事务超时</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 事务只读 默认是可以修改的 如果设置为true只能执行查询相关</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 指定错误回滚 当未抛出该类型的错误或者其子类的错误时 不会回滚 默认是任何错误（异常）都会回滚</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 略 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 如果配置这个 如果抛出此异常将不会回滚</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 略 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Isolation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用默认的隔离级别</span></span><br><span class="line"><span class="comment">	 * 所有其他级别对应于JDBC隔离级别</span></span><br><span class="line"><span class="comment">	 * 具体隔离级别 查看 java.sql.Connection</span></span><br><span class="line"><span class="comment">	 * Mysql 默认 RR(REPEATABLE_READ)</span></span><br><span class="line"><span class="comment">	 * Oracle 默认 RC(READ_COMMITTED)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 未提交读 什么问题都不解决</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_READ_UNCOMMITTED</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交读 解决脏读</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_READ_COMMITTED</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重复读 解决脏读和不可重复读 不解决幻读</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 串行读 解决所有的事务隔离问题</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Isolation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传播行为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Support a current transaction, create a new one if none exists.</span></span><br><span class="line"><span class="comment">	 * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This is the default setting of a transaction annotation.</span></span><br><span class="line"><span class="comment">	 * 外围有事务则加入形成同一个事务，外围无事务则新开启，内部事务之间相互独立</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Support a current transaction, execute non-transactionally if none exists.</span></span><br><span class="line"><span class="comment">	 * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note: For transaction managers with transaction synchronization,</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> SUPPORTS&#125; is slightly different from no transaction at all,</span></span><br><span class="line"><span class="comment">	 * as it defines a transaction scope that synchronization will apply for.</span></span><br><span class="line"><span class="comment">	 * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc)</span></span><br><span class="line"><span class="comment">	 * will be shared for the entire specified scope. Note that this depends on</span></span><br><span class="line"><span class="comment">	 * the actual synchronization configuration of the transaction manager.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization</span></span><br><span class="line"><span class="comment">	 * 若外围没有事务则非事务执行，有事务则同 REQUIRED</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Support a current transaction, throw an exception if none exists.</span></span><br><span class="line"><span class="comment">	 * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">	 * 使用外围事务，若外围无事务则抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new transaction, and suspend the current transaction if one exists.</span></span><br><span class="line"><span class="comment">	 * Analogous to the EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span></span><br><span class="line"><span class="comment">	 * on all transaction managers. This in particular applies to</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span></span><br><span class="line"><span class="comment">	 * which requires the &#123;<span class="doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span></span><br><span class="line"><span class="comment">	 * made available to it (which is server-specific in standard Java EE).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span></span><br><span class="line"><span class="comment">	 * 外围有无事务都开启新事务，相互独立，且与外围事务相互独立开 如果当前有事务，就把当前的事务挂起</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Execute non-transactionally, suspend the current transaction if one exists.</span></span><br><span class="line"><span class="comment">	 * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span></span><br><span class="line"><span class="comment">	 * on all transaction managers. This in particular applies to</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span></span><br><span class="line"><span class="comment">	 * which requires the &#123;<span class="doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span></span><br><span class="line"><span class="comment">	 * made available to it (which is server-specific in standard Java EE).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span></span><br><span class="line"><span class="comment">	 * 非事务执行，若外围存在事务则挂起该事务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Execute non-transactionally, throw an exception if a transaction exists.</span></span><br><span class="line"><span class="comment">	 * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">	 * 非事务执行，当外围有事务则抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Execute within a nested transaction if a current transaction exists,</span></span><br><span class="line"><span class="comment">	 * behave like &#123;<span class="doctag">@code</span> REQUIRED&#125; otherwise. There is no analogous feature in EJB.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific</span></span><br><span class="line"><span class="comment">	 * transaction managers. Out of the box, this only applies to the JDBC</span></span><br><span class="line"><span class="comment">	 * DataSourceTransactionManager. Some JTA providers might support nested</span></span><br><span class="line"><span class="comment">	 * transactions as well.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.jdbc.datasource.DataSourceTransactionManager</span></span><br><span class="line"><span class="comment">	 * 外围无事务，则同 REQUIRED 内部开启新事务相互独立。外围有事务，则内部事务是其子事务，主事务回滚则子事务全部回滚，子事务回滚不影响其他子事务和主事务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Propagation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Spring-依赖注入概念和-Autowired-的用法。"><a href="#Spring-依赖注入概念和-Autowired-的用法。" class="headerlink" title="Spring 依赖注入概念和@Autowired 的用法。"></a>Spring 依赖注入概念和@Autowired 的用法。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">概念：实例不再由程序员实例化，而是通过spring容器帮我们<span class="keyword">new</span>指定实例并且将实例注入到需要该对象的类。</span><br><span class="line">依赖注入能够让相互协作的软件组件保持松散耦合</span><br><span class="line"><span class="meta">@Autowired</span> 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 <span class="meta">@Autowired</span>的使用来消除 set ，get方法。也可作用与集合上</span><br><span class="line">这里授权服务配置类是继承了AuthorizationServerConfigurerAdapter，而AuthorizationServerConfigurerAdapter又实现了AuthorizationServerConfigurer接口！</span><br><span class="line">源码AuthorizationServerConfigurer</span><br><span class="line"><span class="meta">@Autowired</span>对List自动注入</span><br><span class="line"><span class="comment">//@Autowired注解用在接口的集合上面，所有实现该接口的实现类都会在该集合中</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;IAsynTask&gt; tasks = Collections.emptyList();</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Bean-的生命周期。"><a href="#Spring-Bean-的生命周期。" class="headerlink" title="Spring Bean 的生命周期。"></a>Spring Bean 的生命周期。</h2><p>Bean 的生命周期概括起来就是 4 个阶段：</p>
<p>实例化（Instantiation）<br>属性赋值（Populate）<br>初始化（Initialization）<br>销毁（Destruction）<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/374544735d0dd4104601ef98749c7f89.jpg" alt="流程"><br>##Spring Boot 启动流程以及底层源码、<br><img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/05-305138350.jpg" alt="流程"><br>索引的数据结构（比如 B+树）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">B+Tree</span><br><span class="line">B+Tree相对于B-Tree有几点不同：</span><br><span class="line">非叶子节点只存储键值信息。</span><br><span class="line">所有叶子节点之间都有一个链指针。</span><br><span class="line">数据记录都存放在叶子节点中。</span><br><span class="line">查询速度快，但是占用空间</span><br><span class="line">索引结构：B-Tree B+Tree B：balance</span><br><span class="line">B-Tree：平衡二叉树</span><br><span class="line">特点：</span><br><span class="line"><span class="number">1.</span>具有数据节点</span><br><span class="line"><span class="number">2.</span>指向下层指针</span><br><span class="line"><span class="number">3.</span>指向数据指针</span><br><span class="line">缺页查询,产生IO</span><br><span class="line">B+Tree：</span><br><span class="line">特点:</span><br><span class="line"><span class="number">1.</span>具有数据节点</span><br><span class="line"><span class="number">2.</span>指向下层指针</span><br><span class="line">命中数据<span class="number">3</span>层查找后查询数据指针</span><br><span class="line">加载更快，产生更少IO</span><br><span class="line">效率：BTree更高，但从IO角度，Mysql选择B+Tree</span><br><span class="line"></span><br><span class="line">Hash 索引的特点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hash 索引只能够用于使用 = 或者 &lt;=&gt; 运算符的相等比较(但是速度更快)。Hash 索引不能够用于诸如 &lt; 等用于查找一个范围值的比较运算符。依赖于这种单值查找的系统被称为 “键-值存储”；对于这种系统，尽可能地使用 hash 索引。</span><br><span class="line">优化器不能够使用 hash 索引来加速 ORDER BY 操作。这种类型的索引不能够用于按照顺序查找下一个条目。</span><br><span class="line">MySql 无法使用 hash 索引估计两个值之间有多少行(这种情况由范围优化器来决定使用哪个索引)。如果你将一张 MyISAM 或 InnoDB 表转换成一个 hash 索引的内存表时，一些查询可能会受此影响。</span><br><span class="line">查找某行记录必须进行全键匹配。而 B-tree 索引，任何该键的左前缀都可用以查找记录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>建索引的语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_xxx <span class="keyword">USING</span> BTREE <span class="keyword">ON</span> tablename (字段,字段,字段);</span><br></pre></td></tr></table></figure>
<p>索引的种类尤其是复合索引以及对应的回表和最左匹配原则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">普通索引：最基本的索引，没有任何约束限制。</span><br><span class="line">唯一索引：和普通索引类似，但是具有唯一性约束，可以有 <span class="keyword">null</span></span><br><span class="line">主键索引：特殊的唯一索引，不允许有 <span class="keyword">null</span>，一张表最多一个主键索引</span><br><span class="line">组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并</span><br><span class="line">全文索引：对文本的内容进行分词、搜索</span><br><span class="line">覆盖索引：查询列要被所建的索引覆盖，不必读取数据行</span><br><span class="line"><span class="number">1</span>、复合索引绑定的第一个列,没有出现在查询条件中;</span><br><span class="line">举例说明：为emp表插入索引idx_age_deptid_name(age,deptid,name),但是在查询条件中未使用age,导致复合索引全部失效。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、复合索引绑定的多个列是有顺序的,某一个列没有出现在查询条件中,存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里没有deptid列，会导致复合索引中的deptid及其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>查询条件中出现某个列是范围查询的，存储引擎不能使用复合索引中该列其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里deptid列使用到了范围查询，会导致复合索引中的deptid其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>查询条件中某列使用否定条件的（!= &lt;&gt; IS NOT NULL），存储引擎不能使用索引中该列其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里deptid列使用到了否定条件，会导致复合索引中的deptid其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>查询条件中某列使用LIKE条件后的字段是以%开头的（如：’%ABC’），存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里name列使用到了like ‘%a’，会导致复合索引中的name及其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>查询条件中某列使用函数的，存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件里name列使用到了like ‘%a’，会导致复合索引中的name及其后的索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>查询条件中某列使用类型转换的（包括显示的和隐示的），存储引擎不能使用索引中该列及其后的所有列。</span><br><span class="line">如：字符串类型的列NAME=<span class="number">3</span>,就是隐示的类型转换，将INT型转换为字符串类型。如果写为NAME=’<span class="number">3</span>’,就不是类型转换。</span><br><span class="line">举例：为emp表插入索引idx_age_deptid_name(age,deptid,name),查询时查询条件name=<span class="number">3</span>，会导致复合索引中的name及其后的索引失效。条件写成name=‘<span class="number">3</span>’，索引就不会失效。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>如果索引的列在 select 所需获得的列中（因为在 mysql 中索引是根据索引列的值进行排序的，所以索引节点中存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表，如果 select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表。<br>使用聚集索引（主键或第一个唯一索引）就不会回表，普通索引就会回表</p>
<h2 id="索引下推优化，"><a href="#索引下推优化，" class="headerlink" title="索引下推优化，"></a>索引下推优化，</h2><p>可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表字数。<br>最左匹配原则<br>带头大哥不能死,中间兄弟不能断</p>
<h2 id="Spring-AOP-底层原理"><a href="#Spring-AOP-底层原理" class="headerlink" title="Spring AOP 底层原理"></a>Spring AOP 底层原理</h2><p>aop 底层是采用动态代理机制实现的：接口+实现类</p>
<h2 id="如果要代理的对象，实现了某个接口，那么-Spring-AOP-会使用-JDK-Proxy，去创建代"><a href="#如果要代理的对象，实现了某个接口，那么-Spring-AOP-会使用-JDK-Proxy，去创建代" class="headerlink" title="如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代"></a>如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代</h2><p>理对象。</p>
<h2 id="没有实现接口的对象，就无法使用-JDK-Proxy-去进行代理了，这时候-Spring-AOP-会使用"><a href="#没有实现接口的对象，就无法使用-JDK-Proxy-去进行代理了，这时候-Spring-AOP-会使用" class="headerlink" title="没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用"></a>没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用</h2><p>Cglib 生成一个被代理对象的子类来作为代理。<br>就是由代理创建出一个和 impl 实现类平级的一个对象，但是这个对象不是一个真正的对象，<br>只是一个代理对象，但它可以实现和 impl 相同的功能，这个就是 aop 的横向机制原理，这<br>样就不需要修改源代码。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>HashMap在java1.7之前底层数据结构是数组+链表，1.8之后是数组+链表+红黑树，<br>在1.7以前的put方法采用的是头插法，当hash碰撞次数到达8，且桶内元素到达64个的时候形成链表，但是在极端情况下会造成链表过长，效率变低，并且在rehash的时候，头插法会造成回环链首尾相连，形成死锁，在java1.8以后采用红黑树，除了添加效率都高，是线程不安全的，不安全示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class HashMapTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMapThread thread0 = new HashMapThread();</span><br><span class="line">        HashMapThread thread1 = new HashMapThread();</span><br><span class="line">        HashMapThread thread2 = new HashMapThread();</span><br><span class="line">        HashMapThread thread3 = new HashMapThread();</span><br><span class="line">        HashMapThread thread4 = new HashMapThread();</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HashMapThread extends Thread &#123;</span><br><span class="line">    private static AtomicInteger ai = new AtomicInteger();</span><br><span class="line">    private static Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (ai.get() &lt; 1000000) &#123;</span><br><span class="line">            map.put(ai.get(), ai.get());</span><br><span class="line">            ai.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK1.8 之前</p>
<h2 id="JDK1-8-之前-HashMap-底层是-数组和链表-结合在一起使用也就是-链表散列。-HashMap-通过-key-的-hashCode-经过扰动函数处理过后得到-hash-值，然后通过-n"><a href="#JDK1-8-之前-HashMap-底层是-数组和链表-结合在一起使用也就是-链表散列。-HashMap-通过-key-的-hashCode-经过扰动函数处理过后得到-hash-值，然后通过-n" class="headerlink" title="JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。 ## HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n -"></a>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。 ## HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n -</h2><ol>
<li>&amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在<br>元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，<br>直接覆盖，不相同就通过拉链法解决冲突。<h2 id="所谓扰动函数指的就是-HashMap-的-hash-方法。使用-hash-方法也就是扰动函数是为了"><a href="#所谓扰动函数指的就是-HashMap-的-hash-方法。使用-hash-方法也就是扰动函数是为了" class="headerlink" title="所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了"></a>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了</h2>防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。<br>JDK1.8 之后<br>当链表长度大于阈值（默认为 8）时，会首先调用 treeifyBin()方法。这个方法会根据<br>HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会<br>执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize() 方法对数组扩容。</li>
</ol>
<p>1.通常代替HashMap的安全由HashTable代替，但是多线程下他的put.get方法都是synchronized，效率太低，<br>2.Collections.synchronizedMap(),底层仍是synchronized<br>3.java9实现Collections.of()<br>ConcurrentHashMap 与 ConcurrentSkipListMap<br>ConcurrentHashMap 加锁<br>ConcurrentSkipListMap 不需要加锁，浪费空间，<br>4.ConcurrentHashMap<br>ConcurrentHashMap如何保证线程安全，在1.7以前由划分segment分段锁机制，共计16个并发级别，隔离级别太大，有很多空间就浪费了，太小就段内的元素过多<br>1.8以后是cas算法C语言写得，无锁算法，put添加的时候，链表+红黑树<br>put方法（无锁添加）<br>3、HashMap 的扩容机制是怎样的？<br>一般情况下，当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的 2 倍。<br>HashMap 的容量是有上限的，必须小于 1&lt;&lt;30，即 1073741824。如果容量超出了这个<br>数，则不再增长，且阈值会被设置为 Integer.MAX_VALUE。<br>JDK7 中的扩容机制</p>
<h2 id="空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是空数"><a href="#空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是空数" class="headerlink" title="空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是空数"></a>空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是空数</h2><p>组。</p>
<h2 id="有参构造函数：根据参数确定容量、负载因子、阈值等。"><a href="#有参构造函数：根据参数确定容量、负载因子、阈值等。" class="headerlink" title="有参构造函数：根据参数确定容量、负载因子、阈值等。"></a>有参构造函数：根据参数确定容量、负载因子、阈值等。</h2><h2 id="第一次-put-时会初始化数组，其容量变为不小于指定容量的-2-的幂数，然后根据负载因子"><a href="#第一次-put-时会初始化数组，其容量变为不小于指定容量的-2-的幂数，然后根据负载因子" class="headerlink" title="第一次 put 时会初始化数组，其容量变为不小于指定容量的 2 的幂数，然后根据负载因子"></a>第一次 put 时会初始化数组，其容量变为不小于指定容量的 2 的幂数，然后根据负载因子</h2><p>确定阈值。</p>
<h2 id="如果不是第一次扩容，则-新容量-旧容量-x-2-，新阈值-新容量-x-负载因子-。"><a href="#如果不是第一次扩容，则-新容量-旧容量-x-2-，新阈值-新容量-x-负载因子-。" class="headerlink" title="如果不是第一次扩容，则 新容量=旧容量 x 2 ，新阈值=新容量 x 负载因子 。"></a>如果不是第一次扩容，则 新容量=旧容量 x 2 ，新阈值=新容量 x 负载因子 。</h2><p>JDK8 的扩容机制</p>
<h2 id="空参数的构造函数：实例化的-HashMap-默认内部数组是-null，即没有实例化。第一次调"><a href="#空参数的构造函数：实例化的-HashMap-默认内部数组是-null，即没有实例化。第一次调" class="headerlink" title="空参数的构造函数：实例化的 HashMap 默认内部数组是 null，即没有实例化。第一次调"></a>空参数的构造函数：实例化的 HashMap 默认内部数组是 null，即没有实例化。第一次调</h2><p>用 put 方法时，则会开始第一次初始化扩容，长度为 16。 ## 有参构造函数：用于指定容量。会根据指定的正整数找到不小于指定容量的 2 的幂数，将<br>这个数设置赋值给阈值（threshold）。第一次调用 put 方法时，会将阈值赋值给容量，<br>然后让 阈值 = 容量 x 负载因子。 ## 如果不是第一次扩容，则容量变为原来的 2 倍，阈值也变为原来的 2 倍。（容量和阈值都<br>变为原来的 2 倍时，负载因子还是不变）。<br>此外还有几个细节需要注意：</p>
<h2 id="首次-put-时，先会触发扩容（算是初始化），然后存入数据，然后判断是否需要扩容；"><a href="#首次-put-时，先会触发扩容（算是初始化），然后存入数据，然后判断是否需要扩容；" class="headerlink" title="首次 put 时，先会触发扩容（算是初始化），然后存入数据，然后判断是否需要扩容；"></a>首次 put 时，先会触发扩容（算是初始化），然后存入数据，然后判断是否需要扩容；</h2><h2 id="不是首次-put，则不再初始化，直接存入数据，然后判断是否需要扩容；"><a href="#不是首次-put，则不再初始化，直接存入数据，然后判断是否需要扩容；" class="headerlink" title="不是首次 put，则不再初始化，直接存入数据，然后判断是否需要扩容；"></a>不是首次 put，则不再初始化，直接存入数据，然后判断是否需要扩容；</h2><p>4、ConcurrentHashMap 的存储结构是怎样的？</p>
<h2 id="Java7-中-ConcurrnetHashMap-使用的分段锁，也就是每一个-Segment-上同时只有一个"><a href="#Java7-中-ConcurrnetHashMap-使用的分段锁，也就是每一个-Segment-上同时只有一个" class="headerlink" title="Java7 中 ConcurrnetHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个"></a>Java7 中 ConcurrnetHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个</h2><p>线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它<br>的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变，默认 Segment 的<br>个数是 16 个。</p>
<h2 id="Java8-中的-ConcurrnetHashMap-使用的-Synchronized-锁加-CAS-的机制。结构也由"><a href="#Java8-中的-ConcurrnetHashMap-使用的-Synchronized-锁加-CAS-的机制。结构也由" class="headerlink" title="Java8 中的 ConcurrnetHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由"></a>Java8 中的 ConcurrnetHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由</h2><p>Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红<br>黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红<br>黑树，在冲突小于一定数量时又退回链表。<br>5、线程池大小如何设置？</p>
<h2 id="CPU-密集型任务-N-1-：-这种任务消耗的主要是-CPU-资源，可以将线程数设置为-N-（CPU-核心数）-1，比-CPU-核心数多出来的一个线程是为了防止线程偶发的缺页中断，"><a href="#CPU-密集型任务-N-1-：-这种任务消耗的主要是-CPU-资源，可以将线程数设置为-N-（CPU-核心数）-1，比-CPU-核心数多出来的一个线程是为了防止线程偶发的缺页中断，" class="headerlink" title="CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N （CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，"></a>CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N （CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，</h2><p>或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而<br>在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p>
<h2 id="I-O-密集型任务-2N-：-这种任务应用起来，系统会用大部分的时间来处理-I-O-交互，而"><a href="#I-O-密集型任务-2N-：-这种任务应用起来，系统会用大部分的时间来处理-I-O-交互，而" class="headerlink" title="I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而"></a>I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而</h2><p>线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程<br>使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是<br>2N。<br>如何判断是 CPU 密集任务还是 IO 密集任务？<br>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单<br>凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相<br>比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。<br>6、IO 密集=Ncpu*2 是怎么计算出来？</p>
<h2 id="I-O-密集型任务任务应用起来，系统会用大部分的时间来处理-I-O-交互，而线程在处理"><a href="#I-O-密集型任务任务应用起来，系统会用大部分的时间来处理-I-O-交互，而线程在处理" class="headerlink" title="I/O 密集型任务任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理"></a>I/O 密集型任务任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理</h2><p>I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在<br>I/O 密集型任务的应用中，我们可以多配置一些线程。例如：数据库交互，文件上传下<br>载，网络传输等。IO 密集型，即该任务需要大量的 IO，即大量的阻塞，故需要多配置线<br>程数。</p>
<h2 id="7、G1-收集器有哪些特点？"><a href="#7、G1-收集器有哪些特点？" class="headerlink" title="7、G1 收集器有哪些特点？"></a>7、G1 收集器有哪些特点？</h2><p>G1 的全称是 Garbage-First，意为垃圾优先，哪一块的垃圾最多就优先清理它。<br>G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布，变成可预期且可配置的。<br>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：<br>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者<br>CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程<br>执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</p>
<h2 id="分代收集：虽然-G1-可以不需要其他收集器配合就能独立管理整个-GC-堆，但是还是保留"><a href="#分代收集：虽然-G1-可以不需要其他收集器配合就能独立管理整个-GC-堆，但是还是保留" class="headerlink" title="分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留"></a>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留</h2><p>了分代的概念。<br>空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法<br>实现的收集器；从局部上来看是基于“标记-复制”算法实现的。<br>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共<br>同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明<br>确指定在一个长度为 M 毫秒的时间片段内。<br>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的<br>Region（这也就是它的名字 Garbage-First 的由来）</p>
<h2 id="8、你有哪些手段来排查-OOM-的问题？"><a href="#8、你有哪些手段来排查-OOM-的问题？" class="headerlink" title="8、你有哪些手段来排查 OOM 的问题？"></a>8、你有哪些手段来排查 OOM 的问题？</h2><p>增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -<br>XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信<br>息到指定目录。<br>同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域。<br>使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未<br>清理，时间长了就会内存溢出，可以把改为弱引用。</p>
<h2 id="9、请你谈谈-MySQL-事务隔离级别，MySQL-的默认隔离级别是什么？"><a href="#9、请你谈谈-MySQL-事务隔离级别，MySQL-的默认隔离级别是什么？" class="headerlink" title="9、请你谈谈 MySQL 事务隔离级别，MySQL 的默认隔离级别是什么？"></a>9、请你谈谈 MySQL 事务隔离级别，MySQL 的默认隔离级别是什么？</h2><p>为了达到事务的四大特性，数据库定义了 4 种不同的事务隔离级别：<br> READ-UNCOMMITTED（读取未提交）：最低的隔离级别，允许脏读，也就是可能读取<br>到其他会话中未提交事务修改的数据，可能会导致脏读、幻读或不可重复读。<br> READ-COMMITTED（读取已提交）： 只能读取到已经提交的数据。Oracle 等多数数据<br>库默认都是该级别 （不重复读），可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br>REPEATABLE-READ（可重复读）：对同一字段的多次读取结果都是一致的，除非数据是<br>被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br>SERIALIZABLE（可串行化）：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事<br>务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏<br>读、不可重复读以及幻读。<br> MySQL 默认采用的 REPEATABLE_READ 隔离级别。</p>
<h2 id="可重复读解决了哪些问题？"><a href="#可重复读解决了哪些问题？" class="headerlink" title="可重复读解决了哪些问题？"></a>可重复读解决了哪些问题？</h2><p> 可重复读的核心就是一致性读(consistent read);保证多次读取同一个数据时，其值都和事<br>务开始时候的内容是一致，禁止读取到别的事务未提交的数据，会造成幻读。<br> 而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就<br>需要进入锁等待。<br>32<br> 查询只承认在事务启动前就已经提交完成的数据。<br> 可重复读解决的是重复读的问题，可重复读在快照读的情况下是不会有幻读，但当前读的<br>时候会有幻读。</p>
<h2 id="11、对-SQL-慢查询会考虑哪些优化-？"><a href="#11、对-SQL-慢查询会考虑哪些优化-？" class="headerlink" title="11、对 SQL 慢查询会考虑哪些优化 ？"></a>11、对 SQL 慢查询会考虑哪些优化 ？</h2><p> 分析语句，是否加载了不必要的字段/数据。<br> 分析 SQL 执行计划（explain extended），思考可能的优化点，是否命中索引等。<br> 查看 SQL 涉及的表结构和索引信息。<br> 如果 SQL 很复杂，优化 SQL 结构。<br> 按照可能的优化点执行表结构变更、增加索引、SQL 改写等操作。<br> 查看优化后的执行时间和执行计划。<br> 如果表数据量太大，考虑分表。<br> 利用缓存，减少查询次数</p>
<h2 id="12、谈一谈缓存穿透、缓存击穿和缓存雪崩，以及解决办法？"><a href="#12、谈一谈缓存穿透、缓存击穿和缓存雪崩，以及解决办法？" class="headerlink" title="12、谈一谈缓存穿透、缓存击穿和缓存雪崩，以及解决办法？"></a>12、谈一谈缓存穿透、缓存击穿和缓存雪崩，以及解决办法？</h2><p>缓存穿透<br> 问题：大量并发查询不存在的 KEY，在缓存和数据库中都不存在，同时给缓存和数据库带<br>来压力。<br> 原因：一般而言，缓存穿透有 2 种可能性：业务数据被误删，导致缓存和数据库中都没有<br>数据。恶意进行 ddos 攻击。<br> 分析：为什么会多次透传呢？不存在 一直为空，需要注意让缓存能够区分 KEY 不存在和<br>查询到一个空值。<br> 解决办法：缓存空值的 KEY，这样第一次不存在也会被加载会记录，下次拿到有这个<br>KEY。Bloom 过滤或 RoaingBitmap 判断 KEY 是否存在，如果布隆过滤器中没有查到这<br>个数据，就不去数据库中查。在处理请求前增加恶意请求检查，如果检测到是恶意攻击，<br>则拒绝进行服务。完全以缓存为准，使用延迟异步加载的策略（异步线程负责维护缓存的<br>数据，定期或根据条件触发更新），这样就不会触发更新。<br>缓存击穿<br> 问题：某个 KEY 失效的时候，正好有大量并发请求访问这个 KEY。  分析：跟穿透其实很像，属于比较偶然的。<br> 解决办法：KEY 的更新操作添加全局互斥锁。完全以缓存为准，使用延迟异步加载的策略<br>（异步线程负责维护缓存的数据，定期或根据条件触发更新），这样就不会触发更新。<br>缓存雪崩<br> 问题：当某一时刻发生大规模的缓存失效的情况，导致大量的请求无法获取数据，从而将<br>流量压力传导到数据库上，导致数据库压力过大甚至宕机。<br> 原因：一般而言，缓存雪崩有 2 种可能性：大量的数据同一个时间失效：比如业务关系强<br>相关的数据要求同时失效 Redis 宕机<br> 分析：一般来说，由于更新策略、或者数据热点、缓存服务宕机等原因，可能会导致缓存<br>数据同一个时间点大规模不可用，或者都更新。所以，需要我们的更新策略要在时间上合<br>适，数据要均匀分享，缓存服务器要多台高可用。<br> 解决办法：更新策略在时间上做到比较平均。如果数据需要同一时间失效，可以给这批数<br>据加上一些随机值，使得这批数据不要在同一个时间过期，降低数据库的压力。使用的热<br>数据尽量分散到不同的机器上。多台机器做主从复制或者多副本，实现高可用。做好主从<br>的部署，当主节点挂掉后，能快速的使用从结点顶上。实现熔断限流机制，对系统进行负<br>载能力控制。对于非核心功能的业务，拒绝其请求，只允许核心功能业务访问数据库获取<br>数据。服务降价：提供默认返回值，或简单的提示信息。</p>
<h2 id="13、LRU-是什么？如何实现？"><a href="#13、LRU-是什么？如何实现？" class="headerlink" title="13、LRU 是什么？如何实现？"></a>13、LRU 是什么？如何实现？</h2><p>最近最少使用策略 LRU（Least Recently Used）是一种缓存淘汰算法，是一种缓存淘汰机<br>制。<br> 使用双向链表实现的队列，队列的最大容量为缓存的大小。在使用过程中，把最近使用的<br>页面移动到队列头，最近没有使用的页面将被放在队列尾的位置<br> 使用一个哈希表，把页号作为键，把缓存在队列中的节点的地址作为值，只需要把这个页<br>对应的节点移动到队列的前面，如果需要的页面在内存中，此时需要把这个页面加载到内<br>存中，简单的说，就是将一个新节点添加到队列前面，并在哈希表中跟新相应的节点地<br>址，如果队列是满的，那么就从队尾移除一个节点，并将新节点添加到队列的前面。</p>
<h2 id="14、什么是堆内存？参数如何设置？"><a href="#14、什么是堆内存？参数如何设置？" class="headerlink" title="14、什么是堆内存？参数如何设置？"></a>14、什么是堆内存？参数如何设置？</h2><p>堆内存是指由程序代码自由分配的内存，与栈内存作区分。<br>在 Java 中，堆内存主要用于分配对象的存储空间，只要拿到对象引用，所有线程都可<br>以访问堆内存。<br> -Xmx, 指定最大堆内存。 如 -Xmx4g. 这只是限制了 Heap 部分的最大值为 4g。这个内<br>存不包括栈内存，也不包括堆外使用的内存。<br> -Xms, 指定堆内存空间的初始大小。 如 -Xms4g。 而且指定的内存大小，并不是操作系<br>统实际分配的初始值，而是 GC 先规划好，用到才分配。 专用服务器上需要保持 –Xms<br>和 –Xmx 一致，否则应用刚启动可能就有好几个 FullGC。当两者配置不一致时，堆内存<br>扩容可能会导致性能抖动。<br>34<br> -Xmn, 等价于 -XX:NewSize，使用 G1 垃圾收集器 不应该 设置该选项，在其他的某些业<br>务场景下可以设置。官方建议设置为 -Xmx 的 1/2 ~ 1/4.<br> -XX：MaxPermSize=size, 这是 JDK1.7 之前使用的。Java8 默认允许的 Meta 空间无限<br>大，此参数无效。<br> -XX：MaxMetaspaceSize=size, Java8 默认不限制 Meta 空间, 一般不允许设置该选<br>项。<br> -XX：MaxDirectMemorySize=size，系统可以使用的最大堆外内存，这个参数跟 -<br>Dsun.nio.MaxDirectMemorySize 效果相同。<br> -Xss, 设置每个线程栈的字节数。 例如 -Xss1m 指定线程栈为 1MB，与-<br>XX:ThreadStackSize=1m 等价</p>
<h2 id="15、栈和队列，举个使用场景例子？"><a href="#15、栈和队列，举个使用场景例子？" class="headerlink" title="15、栈和队列，举个使用场景例子？"></a>15、栈和队列，举个使用场景例子？</h2><p> 栈（后进先出）可以用于字符匹配，数据反转等场景<br> 队列（先进先出）可以用于任务队列，共享打印机等场景</p>
<h2 id="16、MySQL-为什么-InnoDB-是默认引擎？"><a href="#16、MySQL-为什么-InnoDB-是默认引擎？" class="headerlink" title="16、MySQL 为什么 InnoDB 是默认引擎？"></a>16、MySQL 为什么 InnoDB 是默认引擎？</h2><p>MyISAM与InnoDB 的区别（9个不同点）<br>区别：</p>
<ol>
<li><p>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </p>
</li>
<li><p>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； </p>
</li>
<li><p>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p>
<pre><code>MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。
</code></pre>
</li>
<li><p>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；</p>
</li>
</ol>
<p>那么为什么InnoDB没有了这个变量呢？</p>
<pre><code>因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。
如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS
</code></pre>
<ol start="5">
<li><p>Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了</p>
</li>
<li><p>MyISAM表格可以被压缩后进行查询操作</p>
</li>
<li><p>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</p>
<pre><code>InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。
</code></pre>
</li>
</ol>
<p>例如：</p>
<pre><code>t_user(uid, uname, age, sex) innodb;

uid PK
无其他索引
update t_user set age=10 where uid=1;             命中索引，行锁。

update t_user set age=10 where uid != 1;           未命中索引，表锁。

update t_user set age=10 where name=&#39;chackca&#39;;    无索引，表锁。
</code></pre>
<p>8、InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有</p>
<p>9、Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI</p>
<pre><code>    Innodb：frm是表定义文件，ibd是数据文件

    Myisam：frm是表定义文件，myd是数据文件，myi是索引文件
</code></pre>
<p>如何选择：<br>    1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</p>
<pre><code>2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。

3. 系统奔溃后，MyISAM恢复起来更困难，能否接受；

4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。
</code></pre>
<p>InnoDB为什么推荐使用自增ID作为主键？</p>
<pre><code>答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。
</code></pre>
<p>innodb引擎的4大特性</p>
<pre><code>   插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)
</code></pre>
<h2 id="19、MVCC-是什么？它的底层原理是什么？"><a href="#19、MVCC-是什么？它的底层原理是什么？" class="headerlink" title="19、MVCC 是什么？它的底层原理是什么？"></a>19、MVCC 是什么？它的底层原理是什么？</h2><p>MVCC，多版本并发控制,它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并<br>发性能的一种机制。<br> 事务版本号<br> 表的隐藏列<br> undo log<br> read view</p>
<h2 id="20、undo-log-具体怎么回滚事务-？"><a href="#20、undo-log-具体怎么回滚事务-？" class="headerlink" title="20、undo log 具体怎么回滚事务 ？"></a>20、undo log 具体怎么回滚事务 ？</h2><p>举个例子：<br> 对于 insert 类型的 sql，会在 undo log 中记录下方才你 insert 进来的数据的 ID，当你想<br>roll back 时，根据 ID 完成精准的删除。<br> 对于 delete 类型的 sql，会在 undo log 中记录方才你删除的数据，当你回滚时会将删除<br>前的数据 insert 进去。<br> 对于 update 类型的 sql，会在 undo log 中记录下修改前的数据，回滚时只需要反向<br>update 即可。<br> 对于 select 类型的 sql，别费心了，select 不需要回滚。</p>
<h2 id="22、索引失效的情况有哪些？"><a href="#22、索引失效的情况有哪些？" class="headerlink" title="22、索引失效的情况有哪些？"></a>22、索引失效的情况有哪些？</h2><p> like 以%开头索引无效，当 like 以&amp;结尾，索引有效。<br> or 语句前后没有同事使用索引，当且仅当 or 语句查询条件的前后列均为索引时，索引生<br>效。<br> 组合索引，使用的不是第一列索引时候，索引失效，即最左匹配规则。<br> 数据类型出现隐式转换，如 varchar 不加单引号的时候可能会自动转换为 int 类型，这个<br>时候索引失效。<br> 在索引列上使用 IS NULL 或者 IS NOT NULL 时候，索引失效，因为索引是不索引空值<br>得。<br> 在索引字段上使用，NOT、 &lt;&gt;、！= 、时候是不会使用索引的，对于这样的处理只会进<br>行全表扫描。<br> 对索引字段进行计算操作，函数操作时不会使用索引。<br> 当全表扫描速度比索引速度快的时候不会使用索引。<br>索引失效场景一：带头大哥不能死，中间兄弟不能断</p>
<p>索引失效场景二：在索引列上做操作</p>
<p>索引失效场景三：范围条件右边全失效</p>
<p>索引低效场景四：select * 会降低索引的效率</p>
<p>索引失效场景五：使用!=或&lt;&gt;会导致索引失效</p>
<p>索引失效场景六、isnull和is not null字段无法使用索引</p>
<p>索引失效场景七、%like%查询时的索引失效问题</p>
<p>索引失效场景八、字符串不加单引号索引失效</p>
<p>索引失效场景九、少用or，用or连接索引会失效</p>
<h2 id="Spring-Bean-容器的生命周期是什么样的？"><a href="#Spring-Bean-容器的生命周期是什么样的？" class="headerlink" title="Spring Bean 容器的生命周期是什么样的？"></a>Spring Bean 容器的生命周期是什么样的？</h2><p> Bean 容器找到配置文件中 Spring Bean 的定义。<br> Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。<br> 如果涉及到一些属性值 利用 set()方法设置一些属性值。<br> 如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名<br>字。<br> 如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传<br>入 ClassLoader 对象的实例。<br> 如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入<br>BeanFactory 对象的实例。<br> 与上面的类似，如果实现了其他 <code>*</code>.Aware 接口，就调用相应的方法。<br> 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行<br>postProcessBeforeInitialization() 方法<br>39<br> 如果 Bean 实现了 InitializingBean 接口，执行 afterPropertiesSet()方法。<br> 如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。<br> 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行<br>postProcessAfterInitialization() 方法<br> 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方<br>法。<br> 当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执<br>行指定的方法。</p>
<h2 id="Redis-数据结构-压缩列表和跳跃表的区别"><a href="#Redis-数据结构-压缩列表和跳跃表的区别" class="headerlink" title="Redis 数据结构 压缩列表和跳跃表的区别"></a>Redis 数据结构 压缩列表和跳跃表的区别</h2><p>压缩列表（ziplist）本质上就是一个字节数组，是 Redis 为了节约内存而设计的一种线性<br>数据结构，可以包含多个元素，每个元素可以是一个字节数组或一个整数。<br> 跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指<br>针，从而达到快速访问节点的目的。跳跃表支持平均 O（logN）、最坏 O（N）复杂度的<br>节点查找，还可以通过顺序性操作来批量处理节点</p>
<h2 id="1-redis的hash怎么实现的？-实现原理-rehash过程"><a href="#1-redis的hash怎么实现的？-实现原理-rehash过程" class="headerlink" title="1.redis的hash怎么实现的？(实现原理)rehash过程"></a>1.redis的hash怎么实现的？(实现原理)rehash过程</h2><p>redis初始创建hash表,有序集合，链表时, 存储结构采用一种ziplist的存储结构, 这种结构内存排列更紧密, 能提高访存性能.<br>hash_max_ziplist_entries和hash_max_ziplist_value值作为阀值，hash_max_ziplist_entries表示一旦ziplist中元素数量超过该值，则需要转换为dict结构；hash_max_ziplist_value表示一旦ziplist中数据长度大于该值，则需要转换为dict结构。<br>哈希等价于Java语言的HashMap或者是Python语言的字典（Dict）<br>redis hash 的内部结构.第一维是数组,第二维是链表.组成一个 hashtable.<br>在 Java 中 HashMap 扩容是个很耗时的操作,需要去申请新的数组,为了追求高性能,Redis 采用了渐进式 rehash 策略.这也是 hash 中最重要的部分.<br>在扩容的时候 rehash 策略会保留新旧两个 hashtable 结构,查询时也会同时查询两个 hashtable.Redis会将旧 hashtable 中的内容一点一点的迁移到新的 hashtable 中,当迁移完成时,就会用新的 hashtable 取代之前的.当 hashtable 移除了最后一个元素之后,这个数据结构将会被删除.<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5cfe6383e51d45599e019d8f">https://juejin.im/post/5cfe6383e51d45599e019d8f</a><br>与java的hashmap的rehash区别<br>个人理解：hashmap的rehash是一次性拷贝的，不同的是，Redis的字典只能是字符串，另外他们rehash的方式不一样，因为Java的HashMap的字典很大时，rehash是个耗时的操作，需要一次全部rehash。Redis为了追求高性能，不能堵塞服务，所以采用了渐进式rehash策略。<br>rehash的详细步骤<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/meituantech/p/9376472.html">https://www.cnblogs.com/meituantech/p/9376472.html</a><br>与ConcurrentHashMap扩容的策略比较？<br>ConcurrentHashMap采用的扩容策略为： “多线程协同式rehash“。<br>1.扩容所花费的时间对比： 一个单线程渐进扩容，一个多线程协同扩容。在平均的情况下，是ConcurrentHashMap 快。这也意味着，扩容时所需要 花费的空间能够更快的进行释放。<br>2.读操作，两者性能相差不多。<br>3.写操作，Redis的字典返回更快些，因为它不像ConcurrentHashMap那样去帮着扩容(当要写的桶位已经搬到了newTable时)，等扩容完才能进行操作。<br>4.删除操作，与写一样。<br><a target="_blank" rel="noopener" href="http://xytschool.com/resource/236.html">http://xytschool.com/resource/236.html</a></p>
<h2 id="redis如何保证高可用"><a href="#redis如何保证高可用" class="headerlink" title="redis如何保证高可用"></a>redis如何保证高可用</h2><p>保证redis高可用机制需要redis主从复制、redis持久化机制、哨兵机制、keepalived等的支持。<br>主从复制的作用：数据备份、读写分离、分布式集群、实现高可用、宕机容错机制等。</p>
<h2 id="redis主从复制原理"><a href="#redis主从复制原理" class="headerlink" title="redis主从复制原理"></a>redis主从复制原理</h2><p>首先主从复制需要分为两个角色：master(主) 和 slave(从) ，注意：redis里面只支持一个主，不像Mysql、Nginx主从复制可以多主多从。</p>
<p>(1)redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</p>
<p>(2)通过redis的复制功能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/itcats_cn/article/details/82428716">https://blog.csdn.net/itcats_cn/article/details/82428716</a></p>
<h1 id="说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？"><a href="#说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？" class="headerlink" title="说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？"></a>说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？</h1><p>个人理解：强一致性的数据是不适合放在缓存中的。另外MySQL对事务的支持也是redis本身不能达到的，需要单独实现<br>一般不是说redis or  MySQL,而是redis+MySQL<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011784767/article/details/76824822">https://blog.csdn.net/u011784767/article/details/76824822</a><br>为什么Redis进行RDB持久化数据时，新起一个进程而不是在原进程中起一个线程来持久化数据<br>(1)Redis RDB持久化机制会阻塞主进程，这样主进程就无法响应客户端请求。<br>(2)我们知道Redis对客户端响应请求的工作模型是单进程和单线程的，如果在主进程内启动一个线程，这样会造成对数据的竞争条件，为了避免使用锁降低性能。基于以上两点这就是为什么Redis通过启动一个进程来执行RDB了<br>—单线程的redis为什么这么快<br>(1)纯内存操作<br>(2)单线程操作，避免了频繁的上下文切换<br>(3)采用了非阻塞I/O多路复用机制</p>
<p>1</p>
<h2 id="Redis的数据类型以及使用场景"><a href="#Redis的数据类型以及使用场景" class="headerlink" title="Redis的数据类型以及使用场景"></a>Redis的数据类型以及使用场景</h2><p>(1)String<br>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。<br>一般做一些复杂的计数功能的缓存。</p>
<p>(2)hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，<br>就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p>
<p>(3)list<br>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，<br>做基于redis的分页功能，性能极佳，用户体验好。</p>
<p>(4)set<br>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？<br>因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再启一个公共服务，太麻烦了。</p>
<p>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p>
<p>(5)sorted set<br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。sorted set可以用来做延时任务。最后一个应用就是可以做范围查找</p>
<h1 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h1><p>redis采用的是定期删除+惰性删除+内存淘汰策略。<br>[2020年6月29日17:25:36在平时的项目中测试，不定期会产生无用token的key数据，平时可以进行模糊删除]</p>
<p>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>
<p>解决方案:<br>(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试<br>(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，<br>异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。<br>(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。<br>迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p>
<p>缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p>
<p>解决方案:<br>(一)给缓存的失效时间，加上一个随机值，避免集体失效。<br>(二)使用互斥锁，但是该方案吞吐量明显下降了。<br>(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。<br>自己做缓存预热操作。然后细分以下几个小点<br>1 从缓存A读数据库，有则直接返回<br>2 A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。<br>3 更新线程同时更新缓存A和缓存B。</p>
<h2 id="如何解决redis的并发竞争key问题"><a href="#如何解决redis的并发竞争key问题" class="headerlink" title="如何解决redis的并发竞争key问题"></a>如何解决redis的并发竞争key问题</h2><p>分析:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。<br>需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。<br>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，<br>这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。</p>
<p>回答:如下所示<br>(1)如果对这个key操作，不要求顺序<br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>(2)如果对这个key操作，要求顺序<br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，<br>需要保存一个时间戳。假设时间戳如下<br>系统A key 1 {valueA  3:00}<br>系统B key 1 {valueB  3:05}<br>系统C key 1 {valueC  3:10}<br>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。<br>redis分页<br>HSCAN testHash “0” count 10</p>
<p>注：测试field数量在22条时（没有测试Redis中Hash使分页生效时的field数量的下限），分页未生效。<br>#mysql 执行一个 sql 的过程<br>执行完毕之后有一个缓存的过程<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoying/p/12073812.html">https://www.cnblogs.com/luoying/p/12073812.html</a></p>
<h2 id="MySQL分页limit速度太慢的优化方法"><a href="#MySQL分页limit速度太慢的优化方法" class="headerlink" title="MySQL分页limit速度太慢的优化方法"></a>MySQL分页limit速度太慢的优化方法</h2><p>1.子查询优化法<br>先找出第一条数据，然后大于等于这条数据的id就是要获取的数据<br>缺点：数据必须是连续的，可以说不能有where条件，where条件会筛选数据，导致数据失去连续性<br>2.limit限制优化法<br>把limit偏移量限制低于某个数<br>3.where条件先过滤后分页</p>
<h2 id="wait-notify-为什么要搭配使用？"><a href="#wait-notify-为什么要搭配使用？" class="headerlink" title="wait notify 为什么要搭配使用？"></a>wait notify 为什么要搭配使用？</h2><p>单独调用会报异常<br>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。因为程序验证通常是在对象的同步方法或同步代码块中调用它们的。如果尝试在未获取对象锁时调用这三个方法，<br>“java.lang.IllegalMonitorStateException:current thread not owner”。<br>底层把对象作为一个监视器</p>
<h2 id="栈会溢出吗？什么时候溢出？方法区会溢出吗？"><a href="#栈会溢出吗？什么时候溢出？方法区会溢出吗？" class="headerlink" title="栈会溢出吗？什么时候溢出？方法区会溢出吗？"></a>栈会溢出吗？什么时候溢出？方法区会溢出吗？</h2><p>栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来<br>存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，<br>对象引用类型。如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出<br>StackOverflowError 异常，方法递归调用产生这种结果。如果 Java 虚拟机栈可以动态扩展，<br>并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时<br>候没有足够的内存去创建对应的虚拟机栈，那么 Java 虚拟机将抛出一个 OutOfMemory 异<br>常。(线程启动过多)。<br>方法区会发生溢出。<br>HotSpot jdk1.7 之前字符串常量池是方法区的一部分，方法区叫做“永久代”，在 1.7 之前<br>无限的创建对象就会造成内存溢出，提示信息：PermGen space 而是用 jdk1.7 之后，开始逐<br>步去永久代，就不会产生内存溢出。<br>方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等，<br>如果动态生成大量的 Class 文件，也会产生内存溢出。常见的场景还有：大量 JSP 或动态产生<br>JSP 文件的应用（JSP 第一次运行时需要编译为 java 类）、基于 OSGi 的应用（即使是同一个<br>类文件，被不同的类加载器加载也会视为不同的类）</p>
<h2 id="redis排行榜代码"><a href="#redis排行榜代码" class="headerlink" title="redis排行榜代码"></a>redis排行榜代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">countPoint</span><span class="params">(Long pointId,String ponitList, Long userId)</span> </span>&#123;</span><br><span class="line">        String key = RedisConstants.get(pointId.toString());</span><br><span class="line">        String userIdStr = userId.toString();</span><br><span class="line">        <span class="keyword">boolean</span> flag = redisService.isMember(key, userIdStr);</span><br><span class="line">        DetailVo vo = DetailVo.builder()</span><br><span class="line">                .pointId(pointId)</span><br><span class="line">                .likeCreateTime(<span class="keyword">new</span> Date())</span><br><span class="line">                .likeUserId(userId)</span><br><span class="line">                .likedUserId(likedUserId)</span><br><span class="line">                .build();</span><br><span class="line">        Map resultMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            redisService.srem(key, userIdStr);</span><br><span class="line">            vo.setType(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//减分</span></span><br><span class="line">            redisService.incrScoreZset(ponitList,likedUserId.toString(),-<span class="number">1</span>);</span><br><span class="line">            resultMap.put(<span class="string">&quot;no&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisService.sadd(key, userIdStr);</span><br><span class="line">            <span class="comment">//加分</span></span><br><span class="line">            redisService.incrScoreZset(ponitList,likedUserId.toString(),<span class="number">1</span>);</span><br><span class="line">            vo.setType(<span class="number">1</span>);</span><br><span class="line">            resultMap.put(<span class="string">&quot;yes&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        mQProducer.sendUpdateUp(vo);</span><br><span class="line">        resultMap.put(<span class="string">&quot;Number&quot;</span>, redisService.scard(key));</span><br><span class="line">        <span class="keyword">return</span> resultMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；</span><br><span class="line">接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的</span><br><span class="line">参数，就是传递给 sql 的参数。</span><br><span class="line">Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符</span><br><span class="line">串作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个</span><br><span class="line">&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个</span><br><span class="line">MapperStatement 对象。</span><br><span class="line">举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯</span><br><span class="line">一找到 namespace 为 com.mybatis3.mappers.StudentDao 下面 id 为</span><br><span class="line">findStudentById 的 MapperStatement。</span><br><span class="line">Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻</span><br><span class="line">找策略。Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK</span><br><span class="line">动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而</span><br><span class="line">执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回。</span><br></pre></td></tr></table></figure>
<h2 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内<br>存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分<br>页功能，也可以使用分页插件来完成物理分页。<br>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件<br>的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物<br>理分页语句和物理分页参数。</p>
<h2 id="Mybatis-的一级、二级缓存"><a href="#Mybatis-的一级、二级缓存" class="headerlink" title="Mybatis 的一级、二级缓存"></a>Mybatis 的一级、二级缓存</h2><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为<br>Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就<br>将清空，默认打开一级缓存。<br>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap<br>存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，<br>如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要<br>实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置<br><cache/> ； 第 46 页 共 485 页<br>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存<br>Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将<br>被 clear。</p>
<h1 id="Redis面试专题"><a href="#Redis面试专题" class="headerlink" title="Redis面试专题"></a>Redis面试专题</h1><h2 id="redis-和-memcached-什么区别？为什么高并发下有时单线程的-redis-比多线程的"><a href="#redis-和-memcached-什么区别？为什么高并发下有时单线程的-redis-比多线程的" class="headerlink" title="redis 和 memcached 什么区别？为什么高并发下有时单线程的 redis 比多线程的"></a>redis 和 memcached 什么区别？为什么高并发下有时单线程的 redis 比多线程的</h2><p>memcached 效率要高？<br>区别：<br>1.mc 可缓存图片和视频。rd 支持除 k/v 更多的数据结构;<br>2.rd 可以使用虚拟内存，rd 可持久化和 aof 灾难恢复，rd 通过主从支持数据备份;<br>3.rd 可以做消息队列。<br>原因：mc 多线程模型引入了缓存一致性和锁，加锁带来了性能损耗。</p>
<h2 id="假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>使用 keys 指令可以扫出指定模式的 key 列表。<br>对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问<br>题？<br>这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一<br>段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指<br>令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客<br>户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://zkkget.github.io/posts/20220802cl77bbz36001ptkujccm35rgp.html" title="面向面试编程" target="_blank" rel="external">https://zkkget.github.io/posts/20220802cl77bbz36001ptkujccm35rgp.html</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://kkget.github.io/" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://kkget.github.io/" target="_blank"><span class="text-dark">赵kk</span><small class="ml-1x">java Developer &amp; pm</small></a></h3>
        <div>纠结体本体,同步记录日常笔记，Write the code, Change the world！</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/20220812cl77bbyyh0001tkuj99kbb8ve.html" title="1000万数据对比ContainsAll实测"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/20220728cl77bbyyy0003tkuj0nyu0kzp.html" title="CompletableFuture"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220112102818.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220112102818.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



            {% if post.top %}
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          {% endif %}
</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://kkget.github.io/" target="_blank" title="主站博客" data-toggle=tooltip data-placement=top><i class="icon icon-主站博客"></i></a></li>
        
        <li><a href="https://zkk-1300025204.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.png" target="_blank" title="公众号" data-toggle=tooltip data-placement=top><i class="icon icon-公众号"></i></a></li>
        
        <li><a href="https://cloud.tencent.com/developer/inventory/14725" target="_blank" title="云+社区" data-toggle=tooltip data-placement=top><i class="icon icon-云+社区"></i></a></li>
        
        <li><a href="/1462018576" target="_blank" title="QQ" data-toggle=tooltip data-placement=top><i class="icon icon-QQ"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>

  <div>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span >本站总访问量: <span id="busuanzi_value_site_pv"></span>次</span>
  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1840459406&auto=1&height=66"></iframe>
  </div>


</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '5qofQKP6PLlRGj9AKdN2wFy8-gzGzoHsz',
    appKey: 'MUjdIW5XaUutRWAdIFu4IdxP',
    placeholder: '来都来了，说点啥吧~',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/01/assets/haru01.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
<!--<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script> -->
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
<!--崩溃欺骗-->
<script type="text/javascript" src="/js/src/crash_cheat.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</html>